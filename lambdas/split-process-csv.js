"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});

// node_modules/tslib/tslib.es6.mjs
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __addDisposableResource: () => __addDisposableResource,
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldIn: () => __classPrivateFieldIn,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __disposeResources: () => __disposeResources,
  __esDecorate: () => __esDecorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __propKey: () => __propKey,
  __read: () => __read,
  __rest: () => __rest,
  __rewriteRelativeImportExtension: () => __rewriteRelativeImportExtension,
  __runInitializers: () => __runInitializers,
  __setFunctionName: () => __setFunctionName,
  __spread: () => __spread,
  __spreadArray: () => __spreadArray,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values,
  default: () => tslib_es6_default
});
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f) i[n] = f(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
  }
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}
function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  var r, s = 0;
  function next() {
    while (r = env.stack.pop()) {
      try {
        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
            fail(e);
            return next();
          });
        } else s |= 1;
      } catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}
function __rewriteRelativeImportExtension(path, preserveJsx) {
  if (typeof path === "string" && /^\.\.?\//.test(path)) {
    return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
      return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
    });
  }
  return path;
}
var extendStatics, __assign, __createBinding, __setModuleDefault, ownKeys, _SuppressedError, tslib_es6_default;
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.mjs"() {
    extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    __createBinding = Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    __setModuleDefault = Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    };
    ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    tslib_es6_default = {
      __extends,
      __assign,
      __rest,
      __decorate,
      __param,
      __esDecorate,
      __runInitializers,
      __propKey,
      __setFunctionName,
      __metadata,
      __awaiter,
      __generator,
      __createBinding,
      __exportStar,
      __values,
      __read,
      __spread,
      __spreadArrays,
      __spreadArray,
      __await,
      __asyncGenerator,
      __asyncDelegator,
      __asyncValues,
      __makeTemplateObject,
      __importStar,
      __importDefault,
      __classPrivateFieldGet,
      __classPrivateFieldSet,
      __classPrivateFieldIn,
      __addDisposableResource,
      __disposeResources,
      __rewriteRelativeImportExtension
    };
  }
});

// node_modules/reflect-metadata/Reflect.js
var require_Reflect = __commonJS({
  "node_modules/reflect-metadata/Reflect.js"() {
    var Reflect2;
    (function(Reflect3) {
      (function(factory) {
        var root = typeof globalThis === "object" ? globalThis : typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : sloppyModeThis();
        var exporter = makeExporter(Reflect3);
        if (typeof root.Reflect !== "undefined") {
          exporter = makeExporter(root.Reflect, exporter);
        }
        factory(exporter, root);
        if (typeof root.Reflect === "undefined") {
          root.Reflect = Reflect3;
        }
        function makeExporter(target, previous) {
          return function(key, value) {
            Object.defineProperty(target, key, { configurable: true, writable: true, value });
            if (previous)
              previous(key, value);
          };
        }
        function functionThis() {
          try {
            return Function("return this;")();
          } catch (_) {
          }
        }
        function indirectEvalThis() {
          try {
            return (void 0, eval)("(function() { return this; })()");
          } catch (_) {
          }
        }
        function sloppyModeThis() {
          return functionThis() || indirectEvalThis();
        }
      })(function(exporter, root) {
        var hasOwn = Object.prototype.hasOwnProperty;
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function";
        var supportsProto = { __proto__: [] } instanceof Array;
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
          // create an object in dictionary mode (a.k.a. "slow" mode in v8)
          create: supportsCreate ? function() {
            return MakeDictionary(/* @__PURE__ */ Object.create(null));
          } : supportsProto ? function() {
            return MakeDictionary({ __proto__: null });
          } : function() {
            return MakeDictionary({});
          },
          has: downLevel ? function(map, key) {
            return hasOwn.call(map, key);
          } : function(map, key) {
            return key in map;
          },
          get: downLevel ? function(map, key) {
            return hasOwn.call(map, key) ? map[key] : void 0;
          } : function(map, key) {
            return map[key];
          }
        };
        var functionPrototype = Object.getPrototypeOf(Function);
        var _Map = typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        var registrySymbol = supportsSymbol ? Symbol.for("@reflect-metadata:registry") : void 0;
        var metadataRegistry = GetOrCreateMetadataRegistry();
        var metadataProvider = CreateMetadataProvider(metadataRegistry);
        function decorate(decorators, target, propertyKey, attributes) {
          if (!IsUndefined(propertyKey)) {
            if (!IsArray(decorators))
              throw new TypeError();
            if (!IsObject(target))
              throw new TypeError();
            if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull2(attributes))
              throw new TypeError();
            if (IsNull2(attributes))
              attributes = void 0;
            propertyKey = ToPropertyKey(propertyKey);
            return DecorateProperty(decorators, target, propertyKey, attributes);
          } else {
            if (!IsArray(decorators))
              throw new TypeError();
            if (!IsConstructor(target))
              throw new TypeError();
            return DecorateConstructor(decorators, target);
          }
        }
        exporter("decorate", decorate);
        function metadata(metadataKey, metadataValue) {
          function decorator(target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
              throw new TypeError();
            OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
          }
          return decorator;
        }
        exporter("metadata", metadata);
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        function hasMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        function hasOwnMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        function getMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        function getOwnMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        function getMetadataKeys(target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        function getOwnMetadataKeys(target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        function deleteMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          var provider = GetMetadataProvider(
            target,
            propertyKey,
            /*Create*/
            false
          );
          if (IsUndefined(provider))
            return false;
          return provider.OrdinaryDeleteMetadata(metadataKey, target, propertyKey);
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
          for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            var decorated = decorator(target);
            if (!IsUndefined(decorated) && !IsNull2(decorated)) {
              if (!IsConstructor(decorated))
                throw new TypeError();
              target = decorated;
            }
          }
          return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
          for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            var decorated = decorator(target, propertyKey, descriptor);
            if (!IsUndefined(decorated) && !IsNull2(decorated)) {
              if (!IsObject(decorated))
                throw new TypeError();
              descriptor = decorated;
            }
          }
          return descriptor;
        }
        function OrdinaryHasMetadata(MetadataKey, O, P) {
          var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
          if (hasOwn2)
            return true;
          var parent = OrdinaryGetPrototypeOf(O);
          if (!IsNull2(parent))
            return OrdinaryHasMetadata(MetadataKey, parent, P);
          return false;
        }
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
          var provider = GetMetadataProvider(
            O,
            P,
            /*Create*/
            false
          );
          if (IsUndefined(provider))
            return false;
          return ToBoolean(provider.OrdinaryHasOwnMetadata(MetadataKey, O, P));
        }
        function OrdinaryGetMetadata(MetadataKey, O, P) {
          var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
          if (hasOwn2)
            return OrdinaryGetOwnMetadata(MetadataKey, O, P);
          var parent = OrdinaryGetPrototypeOf(O);
          if (!IsNull2(parent))
            return OrdinaryGetMetadata(MetadataKey, parent, P);
          return void 0;
        }
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
          var provider = GetMetadataProvider(
            O,
            P,
            /*Create*/
            false
          );
          if (IsUndefined(provider))
            return;
          return provider.OrdinaryGetOwnMetadata(MetadataKey, O, P);
        }
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
          var provider = GetMetadataProvider(
            O,
            P,
            /*Create*/
            true
          );
          provider.OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P);
        }
        function OrdinaryMetadataKeys(O, P) {
          var ownKeys2 = OrdinaryOwnMetadataKeys(O, P);
          var parent = OrdinaryGetPrototypeOf(O);
          if (parent === null)
            return ownKeys2;
          var parentKeys = OrdinaryMetadataKeys(parent, P);
          if (parentKeys.length <= 0)
            return ownKeys2;
          if (ownKeys2.length <= 0)
            return parentKeys;
          var set = new _Set();
          var keys = [];
          for (var _i = 0, ownKeys_1 = ownKeys2; _i < ownKeys_1.length; _i++) {
            var key = ownKeys_1[_i];
            var hasKey = set.has(key);
            if (!hasKey) {
              set.add(key);
              keys.push(key);
            }
          }
          for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
            var key = parentKeys_1[_a];
            var hasKey = set.has(key);
            if (!hasKey) {
              set.add(key);
              keys.push(key);
            }
          }
          return keys;
        }
        function OrdinaryOwnMetadataKeys(O, P) {
          var provider = GetMetadataProvider(
            O,
            P,
            /*create*/
            false
          );
          if (!provider) {
            return [];
          }
          return provider.OrdinaryOwnMetadataKeys(O, P);
        }
        function Type(x) {
          if (x === null)
            return 1;
          switch (typeof x) {
            case "undefined":
              return 0;
            case "boolean":
              return 2;
            case "string":
              return 3;
            case "symbol":
              return 4;
            case "number":
              return 5;
            case "object":
              return x === null ? 1 : 6;
            default:
              return 6;
          }
        }
        function IsUndefined(x) {
          return x === void 0;
        }
        function IsNull2(x) {
          return x === null;
        }
        function IsSymbol(x) {
          return typeof x === "symbol";
        }
        function IsObject(x) {
          return typeof x === "object" ? x !== null : typeof x === "function";
        }
        function ToPrimitive(input, PreferredType) {
          switch (Type(input)) {
            case 0:
              return input;
            case 1:
              return input;
            case 2:
              return input;
            case 3:
              return input;
            case 4:
              return input;
            case 5:
              return input;
          }
          var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
          var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
          if (exoticToPrim !== void 0) {
            var result = exoticToPrim.call(input, hint);
            if (IsObject(result))
              throw new TypeError();
            return result;
          }
          return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        function OrdinaryToPrimitive(O, hint) {
          if (hint === "string") {
            var toString_1 = O.toString;
            if (IsCallable(toString_1)) {
              var result = toString_1.call(O);
              if (!IsObject(result))
                return result;
            }
            var valueOf = O.valueOf;
            if (IsCallable(valueOf)) {
              var result = valueOf.call(O);
              if (!IsObject(result))
                return result;
            }
          } else {
            var valueOf = O.valueOf;
            if (IsCallable(valueOf)) {
              var result = valueOf.call(O);
              if (!IsObject(result))
                return result;
            }
            var toString_2 = O.toString;
            if (IsCallable(toString_2)) {
              var result = toString_2.call(O);
              if (!IsObject(result))
                return result;
            }
          }
          throw new TypeError();
        }
        function ToBoolean(argument) {
          return !!argument;
        }
        function ToString(argument) {
          return "" + argument;
        }
        function ToPropertyKey(argument) {
          var key = ToPrimitive(
            argument,
            3
            /* String */
          );
          if (IsSymbol(key))
            return key;
          return ToString(key);
        }
        function IsArray(argument) {
          return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
        }
        function IsCallable(argument) {
          return typeof argument === "function";
        }
        function IsConstructor(argument) {
          return typeof argument === "function";
        }
        function IsPropertyKey(argument) {
          switch (Type(argument)) {
            case 3:
              return true;
            case 4:
              return true;
            default:
              return false;
          }
        }
        function SameValueZero(x, y) {
          return x === y || x !== x && y !== y;
        }
        function GetMethod(V, P) {
          var func = V[P];
          if (func === void 0 || func === null)
            return void 0;
          if (!IsCallable(func))
            throw new TypeError();
          return func;
        }
        function GetIterator(obj) {
          var method = GetMethod(obj, iteratorSymbol);
          if (!IsCallable(method))
            throw new TypeError();
          var iterator = method.call(obj);
          if (!IsObject(iterator))
            throw new TypeError();
          return iterator;
        }
        function IteratorValue(iterResult) {
          return iterResult.value;
        }
        function IteratorStep(iterator) {
          var result = iterator.next();
          return result.done ? false : result;
        }
        function IteratorClose(iterator) {
          var f = iterator["return"];
          if (f)
            f.call(iterator);
        }
        function OrdinaryGetPrototypeOf(O) {
          var proto = Object.getPrototypeOf(O);
          if (typeof O !== "function" || O === functionPrototype)
            return proto;
          if (proto !== functionPrototype)
            return proto;
          var prototype = O.prototype;
          var prototypeProto = prototype && Object.getPrototypeOf(prototype);
          if (prototypeProto == null || prototypeProto === Object.prototype)
            return proto;
          var constructor = prototypeProto.constructor;
          if (typeof constructor !== "function")
            return proto;
          if (constructor === O)
            return proto;
          return constructor;
        }
        function CreateMetadataRegistry() {
          var fallback;
          if (!IsUndefined(registrySymbol) && typeof root.Reflect !== "undefined" && !(registrySymbol in root.Reflect) && typeof root.Reflect.defineMetadata === "function") {
            fallback = CreateFallbackProvider(root.Reflect);
          }
          var first;
          var second;
          var rest;
          var targetProviderMap = new _WeakMap();
          var registry = {
            registerProvider,
            getProvider,
            setProvider
          };
          return registry;
          function registerProvider(provider) {
            if (!Object.isExtensible(registry)) {
              throw new Error("Cannot add provider to a frozen registry.");
            }
            switch (true) {
              case fallback === provider:
                break;
              case IsUndefined(first):
                first = provider;
                break;
              case first === provider:
                break;
              case IsUndefined(second):
                second = provider;
                break;
              case second === provider:
                break;
              default:
                if (rest === void 0)
                  rest = new _Set();
                rest.add(provider);
                break;
            }
          }
          function getProviderNoCache(O, P) {
            if (!IsUndefined(first)) {
              if (first.isProviderFor(O, P))
                return first;
              if (!IsUndefined(second)) {
                if (second.isProviderFor(O, P))
                  return first;
                if (!IsUndefined(rest)) {
                  var iterator = GetIterator(rest);
                  while (true) {
                    var next = IteratorStep(iterator);
                    if (!next) {
                      return void 0;
                    }
                    var provider = IteratorValue(next);
                    if (provider.isProviderFor(O, P)) {
                      IteratorClose(iterator);
                      return provider;
                    }
                  }
                }
              }
            }
            if (!IsUndefined(fallback) && fallback.isProviderFor(O, P)) {
              return fallback;
            }
            return void 0;
          }
          function getProvider(O, P) {
            var providerMap = targetProviderMap.get(O);
            var provider;
            if (!IsUndefined(providerMap)) {
              provider = providerMap.get(P);
            }
            if (!IsUndefined(provider)) {
              return provider;
            }
            provider = getProviderNoCache(O, P);
            if (!IsUndefined(provider)) {
              if (IsUndefined(providerMap)) {
                providerMap = new _Map();
                targetProviderMap.set(O, providerMap);
              }
              providerMap.set(P, provider);
            }
            return provider;
          }
          function hasProvider(provider) {
            if (IsUndefined(provider))
              throw new TypeError();
            return first === provider || second === provider || !IsUndefined(rest) && rest.has(provider);
          }
          function setProvider(O, P, provider) {
            if (!hasProvider(provider)) {
              throw new Error("Metadata provider not registered.");
            }
            var existingProvider = getProvider(O, P);
            if (existingProvider !== provider) {
              if (!IsUndefined(existingProvider)) {
                return false;
              }
              var providerMap = targetProviderMap.get(O);
              if (IsUndefined(providerMap)) {
                providerMap = new _Map();
                targetProviderMap.set(O, providerMap);
              }
              providerMap.set(P, provider);
            }
            return true;
          }
        }
        function GetOrCreateMetadataRegistry() {
          var metadataRegistry2;
          if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
            metadataRegistry2 = root.Reflect[registrySymbol];
          }
          if (IsUndefined(metadataRegistry2)) {
            metadataRegistry2 = CreateMetadataRegistry();
          }
          if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
            Object.defineProperty(root.Reflect, registrySymbol, {
              enumerable: false,
              configurable: false,
              writable: false,
              value: metadataRegistry2
            });
          }
          return metadataRegistry2;
        }
        function CreateMetadataProvider(registry) {
          var metadata2 = new _WeakMap();
          var provider = {
            isProviderFor: function(O, P) {
              var targetMetadata = metadata2.get(O);
              if (IsUndefined(targetMetadata))
                return false;
              return targetMetadata.has(P);
            },
            OrdinaryDefineOwnMetadata: OrdinaryDefineOwnMetadata2,
            OrdinaryHasOwnMetadata: OrdinaryHasOwnMetadata2,
            OrdinaryGetOwnMetadata: OrdinaryGetOwnMetadata2,
            OrdinaryOwnMetadataKeys: OrdinaryOwnMetadataKeys2,
            OrdinaryDeleteMetadata
          };
          metadataRegistry.registerProvider(provider);
          return provider;
          function GetOrCreateMetadataMap(O, P, Create) {
            var targetMetadata = metadata2.get(O);
            var createdTargetMetadata = false;
            if (IsUndefined(targetMetadata)) {
              if (!Create)
                return void 0;
              targetMetadata = new _Map();
              metadata2.set(O, targetMetadata);
              createdTargetMetadata = true;
            }
            var metadataMap = targetMetadata.get(P);
            if (IsUndefined(metadataMap)) {
              if (!Create)
                return void 0;
              metadataMap = new _Map();
              targetMetadata.set(P, metadataMap);
              if (!registry.setProvider(O, P, provider)) {
                targetMetadata.delete(P);
                if (createdTargetMetadata) {
                  metadata2.delete(O);
                }
                throw new Error("Wrong provider for target.");
              }
            }
            return metadataMap;
          }
          function OrdinaryHasOwnMetadata2(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(
              O,
              P,
              /*Create*/
              false
            );
            if (IsUndefined(metadataMap))
              return false;
            return ToBoolean(metadataMap.has(MetadataKey));
          }
          function OrdinaryGetOwnMetadata2(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(
              O,
              P,
              /*Create*/
              false
            );
            if (IsUndefined(metadataMap))
              return void 0;
            return metadataMap.get(MetadataKey);
          }
          function OrdinaryDefineOwnMetadata2(MetadataKey, MetadataValue, O, P) {
            var metadataMap = GetOrCreateMetadataMap(
              O,
              P,
              /*Create*/
              true
            );
            metadataMap.set(MetadataKey, MetadataValue);
          }
          function OrdinaryOwnMetadataKeys2(O, P) {
            var keys = [];
            var metadataMap = GetOrCreateMetadataMap(
              O,
              P,
              /*Create*/
              false
            );
            if (IsUndefined(metadataMap))
              return keys;
            var keysObj = metadataMap.keys();
            var iterator = GetIterator(keysObj);
            var k = 0;
            while (true) {
              var next = IteratorStep(iterator);
              if (!next) {
                keys.length = k;
                return keys;
              }
              var nextValue = IteratorValue(next);
              try {
                keys[k] = nextValue;
              } catch (e) {
                try {
                  IteratorClose(iterator);
                } finally {
                  throw e;
                }
              }
              k++;
            }
          }
          function OrdinaryDeleteMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(
              O,
              P,
              /*Create*/
              false
            );
            if (IsUndefined(metadataMap))
              return false;
            if (!metadataMap.delete(MetadataKey))
              return false;
            if (metadataMap.size === 0) {
              var targetMetadata = metadata2.get(O);
              if (!IsUndefined(targetMetadata)) {
                targetMetadata.delete(P);
                if (targetMetadata.size === 0) {
                  metadata2.delete(targetMetadata);
                }
              }
            }
            return true;
          }
        }
        function CreateFallbackProvider(reflect) {
          var defineMetadata2 = reflect.defineMetadata, hasOwnMetadata2 = reflect.hasOwnMetadata, getOwnMetadata2 = reflect.getOwnMetadata, getOwnMetadataKeys2 = reflect.getOwnMetadataKeys, deleteMetadata2 = reflect.deleteMetadata;
          var metadataOwner = new _WeakMap();
          var provider = {
            isProviderFor: function(O, P) {
              var metadataPropertySet = metadataOwner.get(O);
              if (!IsUndefined(metadataPropertySet) && metadataPropertySet.has(P)) {
                return true;
              }
              if (getOwnMetadataKeys2(O, P).length) {
                if (IsUndefined(metadataPropertySet)) {
                  metadataPropertySet = new _Set();
                  metadataOwner.set(O, metadataPropertySet);
                }
                metadataPropertySet.add(P);
                return true;
              }
              return false;
            },
            OrdinaryDefineOwnMetadata: defineMetadata2,
            OrdinaryHasOwnMetadata: hasOwnMetadata2,
            OrdinaryGetOwnMetadata: getOwnMetadata2,
            OrdinaryOwnMetadataKeys: getOwnMetadataKeys2,
            OrdinaryDeleteMetadata: deleteMetadata2
          };
          return provider;
        }
        function GetMetadataProvider(O, P, Create) {
          var registeredProvider = metadataRegistry.getProvider(O, P);
          if (!IsUndefined(registeredProvider)) {
            return registeredProvider;
          }
          if (Create) {
            if (metadataRegistry.setProvider(O, P, metadataProvider)) {
              return metadataProvider;
            }
            throw new Error("Illegal state.");
          }
          return void 0;
        }
        function CreateMapPolyfill() {
          var cacheSentinel = {};
          var arraySentinel = [];
          var MapIterator = (
            /** @class */
            (function() {
              function MapIterator2(keys, values, selector) {
                this._index = 0;
                this._keys = keys;
                this._values = values;
                this._selector = selector;
              }
              MapIterator2.prototype["@@iterator"] = function() {
                return this;
              };
              MapIterator2.prototype[iteratorSymbol] = function() {
                return this;
              };
              MapIterator2.prototype.next = function() {
                var index = this._index;
                if (index >= 0 && index < this._keys.length) {
                  var result = this._selector(this._keys[index], this._values[index]);
                  if (index + 1 >= this._keys.length) {
                    this._index = -1;
                    this._keys = arraySentinel;
                    this._values = arraySentinel;
                  } else {
                    this._index++;
                  }
                  return { value: result, done: false };
                }
                return { value: void 0, done: true };
              };
              MapIterator2.prototype.throw = function(error) {
                if (this._index >= 0) {
                  this._index = -1;
                  this._keys = arraySentinel;
                  this._values = arraySentinel;
                }
                throw error;
              };
              MapIterator2.prototype.return = function(value) {
                if (this._index >= 0) {
                  this._index = -1;
                  this._keys = arraySentinel;
                  this._values = arraySentinel;
                }
                return { value, done: true };
              };
              return MapIterator2;
            })()
          );
          var Map2 = (
            /** @class */
            (function() {
              function Map3() {
                this._keys = [];
                this._values = [];
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              }
              Object.defineProperty(Map3.prototype, "size", {
                get: function() {
                  return this._keys.length;
                },
                enumerable: true,
                configurable: true
              });
              Map3.prototype.has = function(key) {
                return this._find(
                  key,
                  /*insert*/
                  false
                ) >= 0;
              };
              Map3.prototype.get = function(key) {
                var index = this._find(
                  key,
                  /*insert*/
                  false
                );
                return index >= 0 ? this._values[index] : void 0;
              };
              Map3.prototype.set = function(key, value) {
                var index = this._find(
                  key,
                  /*insert*/
                  true
                );
                this._values[index] = value;
                return this;
              };
              Map3.prototype.delete = function(key) {
                var index = this._find(
                  key,
                  /*insert*/
                  false
                );
                if (index >= 0) {
                  var size = this._keys.length;
                  for (var i = index + 1; i < size; i++) {
                    this._keys[i - 1] = this._keys[i];
                    this._values[i - 1] = this._values[i];
                  }
                  this._keys.length--;
                  this._values.length--;
                  if (SameValueZero(key, this._cacheKey)) {
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                  }
                  return true;
                }
                return false;
              };
              Map3.prototype.clear = function() {
                this._keys.length = 0;
                this._values.length = 0;
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              };
              Map3.prototype.keys = function() {
                return new MapIterator(this._keys, this._values, getKey);
              };
              Map3.prototype.values = function() {
                return new MapIterator(this._keys, this._values, getValue);
              };
              Map3.prototype.entries = function() {
                return new MapIterator(this._keys, this._values, getEntry);
              };
              Map3.prototype["@@iterator"] = function() {
                return this.entries();
              };
              Map3.prototype[iteratorSymbol] = function() {
                return this.entries();
              };
              Map3.prototype._find = function(key, insert) {
                if (!SameValueZero(this._cacheKey, key)) {
                  this._cacheIndex = -1;
                  for (var i = 0; i < this._keys.length; i++) {
                    if (SameValueZero(this._keys[i], key)) {
                      this._cacheIndex = i;
                      break;
                    }
                  }
                }
                if (this._cacheIndex < 0 && insert) {
                  this._cacheIndex = this._keys.length;
                  this._keys.push(key);
                  this._values.push(void 0);
                }
                return this._cacheIndex;
              };
              return Map3;
            })()
          );
          return Map2;
          function getKey(key, _) {
            return key;
          }
          function getValue(_, value) {
            return value;
          }
          function getEntry(key, value) {
            return [key, value];
          }
        }
        function CreateSetPolyfill() {
          var Set2 = (
            /** @class */
            (function() {
              function Set3() {
                this._map = new _Map();
              }
              Object.defineProperty(Set3.prototype, "size", {
                get: function() {
                  return this._map.size;
                },
                enumerable: true,
                configurable: true
              });
              Set3.prototype.has = function(value) {
                return this._map.has(value);
              };
              Set3.prototype.add = function(value) {
                return this._map.set(value, value), this;
              };
              Set3.prototype.delete = function(value) {
                return this._map.delete(value);
              };
              Set3.prototype.clear = function() {
                this._map.clear();
              };
              Set3.prototype.keys = function() {
                return this._map.keys();
              };
              Set3.prototype.values = function() {
                return this._map.keys();
              };
              Set3.prototype.entries = function() {
                return this._map.entries();
              };
              Set3.prototype["@@iterator"] = function() {
                return this.keys();
              };
              Set3.prototype[iteratorSymbol] = function() {
                return this.keys();
              };
              return Set3;
            })()
          );
          return Set2;
        }
        function CreateWeakMapPolyfill() {
          var UUID_SIZE = 16;
          var keys = HashMap.create();
          var rootKey = CreateUniqueKey();
          return (
            /** @class */
            (function() {
              function WeakMap2() {
                this._key = CreateUniqueKey();
              }
              WeakMap2.prototype.has = function(target) {
                var table = GetOrCreateWeakMapTable(
                  target,
                  /*create*/
                  false
                );
                return table !== void 0 ? HashMap.has(table, this._key) : false;
              };
              WeakMap2.prototype.get = function(target) {
                var table = GetOrCreateWeakMapTable(
                  target,
                  /*create*/
                  false
                );
                return table !== void 0 ? HashMap.get(table, this._key) : void 0;
              };
              WeakMap2.prototype.set = function(target, value) {
                var table = GetOrCreateWeakMapTable(
                  target,
                  /*create*/
                  true
                );
                table[this._key] = value;
                return this;
              };
              WeakMap2.prototype.delete = function(target) {
                var table = GetOrCreateWeakMapTable(
                  target,
                  /*create*/
                  false
                );
                return table !== void 0 ? delete table[this._key] : false;
              };
              WeakMap2.prototype.clear = function() {
                this._key = CreateUniqueKey();
              };
              return WeakMap2;
            })()
          );
          function CreateUniqueKey() {
            var key;
            do
              key = "@@WeakMap@@" + CreateUUID();
            while (HashMap.has(keys, key));
            keys[key] = true;
            return key;
          }
          function GetOrCreateWeakMapTable(target, create) {
            if (!hasOwn.call(target, rootKey)) {
              if (!create)
                return void 0;
              Object.defineProperty(target, rootKey, { value: HashMap.create() });
            }
            return target[rootKey];
          }
          function FillRandomBytes(buffer, size) {
            for (var i = 0; i < size; ++i)
              buffer[i] = Math.random() * 255 | 0;
            return buffer;
          }
          function GenRandomBytes(size) {
            if (typeof Uint8Array === "function") {
              var array = new Uint8Array(size);
              if (typeof crypto !== "undefined") {
                crypto.getRandomValues(array);
              } else if (typeof msCrypto !== "undefined") {
                msCrypto.getRandomValues(array);
              } else {
                FillRandomBytes(array, size);
              }
              return array;
            }
            return FillRandomBytes(new Array(size), size);
          }
          function CreateUUID() {
            var data = GenRandomBytes(UUID_SIZE);
            data[6] = data[6] & 79 | 64;
            data[8] = data[8] & 191 | 128;
            var result = "";
            for (var offset = 0; offset < UUID_SIZE; ++offset) {
              var byte = data[offset];
              if (offset === 4 || offset === 6 || offset === 8)
                result += "-";
              if (byte < 16)
                result += "0";
              result += byte.toString(16).toLowerCase();
            }
            return result;
          }
        }
        function MakeDictionary(obj) {
          obj.__ = void 0;
          delete obj.__;
          return obj;
        }
      });
    })(Reflect2 || (Reflect2 = {}));
  }
});

// node_modules/typeorm/metadata-builder/MetadataUtils.js
var require_MetadataUtils = __commonJS({
  "node_modules/typeorm/metadata-builder/MetadataUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MetadataUtils = void 0;
    var MetadataUtils = class {
      /**
       * Gets given's entity all inherited classes.
       * Gives in order from parents to children.
       * For example Post extends ContentModel which extends Unit it will give
       * [Unit, ContentModel, Post]
       */
      static getInheritanceTree(entity) {
        const tree = [entity];
        const getPrototypeOf = (object) => {
          const proto = Object.getPrototypeOf(object);
          if (proto && proto.name) {
            tree.push(proto);
            getPrototypeOf(proto);
          }
        };
        getPrototypeOf(entity);
        return tree;
      }
      /**
       * Checks if this table is inherited from another table.
       */
      static isInherited(target1, target2) {
        return target1.prototype instanceof target2;
      }
      /**
       * Filters given array of targets by a given classes.
       * If classes are not given, then it returns array itself.
       */
      static filterByTarget(array, classes) {
        if (!classes)
          return array;
        return array.filter((item) => item.target && classes.indexOf(item.target) !== -1);
      }
    };
    exports2.MetadataUtils = MetadataUtils;
  }
});

// node_modules/typeorm/metadata-args/MetadataArgsStorage.js
var require_MetadataArgsStorage = __commonJS({
  "node_modules/typeorm/metadata-args/MetadataArgsStorage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MetadataArgsStorage = void 0;
    var MetadataUtils_1 = require_MetadataUtils();
    var MetadataArgsStorage = class {
      constructor() {
        this.tables = [];
        this.trees = [];
        this.entityRepositories = [];
        this.transactionEntityManagers = [];
        this.transactionRepositories = [];
        this.namingStrategies = [];
        this.entitySubscribers = [];
        this.indices = [];
        this.foreignKeys = [];
        this.uniques = [];
        this.checks = [];
        this.exclusions = [];
        this.columns = [];
        this.generations = [];
        this.relations = [];
        this.joinColumns = [];
        this.joinTables = [];
        this.entityListeners = [];
        this.relationCounts = [];
        this.relationIds = [];
        this.embeddeds = [];
        this.inheritances = [];
        this.discriminatorValues = [];
      }
      filterTables(target) {
        return this.filterByTarget(this.tables, target);
      }
      filterColumns(target) {
        return this.filterByTargetAndWithoutDuplicateProperties(this.columns, target);
      }
      findGenerated(target, propertyName) {
        return this.generations.find((generated) => {
          return (Array.isArray(target) ? target.indexOf(generated.target) !== -1 : generated.target === target) && generated.propertyName === propertyName;
        });
      }
      findTree(target) {
        return this.trees.find((tree) => {
          return Array.isArray(target) ? target.indexOf(tree.target) !== -1 : tree.target === target;
        });
      }
      filterRelations(target) {
        return this.filterByTargetAndWithoutDuplicateRelationProperties(this.relations, target);
      }
      filterRelationIds(target) {
        return this.filterByTargetAndWithoutDuplicateProperties(this.relationIds, target);
      }
      filterRelationCounts(target) {
        return this.filterByTargetAndWithoutDuplicateProperties(this.relationCounts, target);
      }
      filterIndices(target) {
        return this.indices.filter((index) => {
          return Array.isArray(target) ? target.indexOf(index.target) !== -1 : index.target === target;
        });
      }
      filterForeignKeys(target) {
        return this.foreignKeys.filter((foreignKey) => {
          return Array.isArray(target) ? target.indexOf(foreignKey.target) !== -1 : foreignKey.target === target;
        });
      }
      filterUniques(target) {
        return this.uniques.filter((unique) => {
          return Array.isArray(target) ? target.indexOf(unique.target) !== -1 : unique.target === target;
        });
      }
      filterChecks(target) {
        return this.checks.filter((check) => {
          return Array.isArray(target) ? target.indexOf(check.target) !== -1 : check.target === target;
        });
      }
      filterExclusions(target) {
        return this.exclusions.filter((exclusion) => {
          return Array.isArray(target) ? target.indexOf(exclusion.target) !== -1 : exclusion.target === target;
        });
      }
      filterListeners(target) {
        return this.filterByTarget(this.entityListeners, target);
      }
      filterEmbeddeds(target) {
        return this.filterByTargetAndWithoutDuplicateEmbeddedProperties(this.embeddeds, target);
      }
      findJoinTable(target, propertyName) {
        return this.joinTables.find((joinTable) => {
          return joinTable.target === target && joinTable.propertyName === propertyName;
        });
      }
      filterJoinColumns(target, propertyName) {
        return this.joinColumns.filter((joinColumn) => {
          return joinColumn.target === target && joinColumn.propertyName === propertyName;
        });
      }
      filterSubscribers(target) {
        return this.filterByTarget(this.entitySubscribers, target);
      }
      filterNamingStrategies(target) {
        return this.filterByTarget(this.namingStrategies, target);
      }
      filterTransactionEntityManagers(target, propertyName) {
        return this.transactionEntityManagers.filter((transactionEm) => {
          return (Array.isArray(target) ? target.indexOf(transactionEm.target) !== -1 : transactionEm.target === target) && transactionEm.methodName === propertyName;
        });
      }
      filterTransactionRepository(target, propertyName) {
        return this.transactionRepositories.filter((transactionEm) => {
          return (Array.isArray(target) ? target.indexOf(transactionEm.target) !== -1 : transactionEm.target === target) && transactionEm.methodName === propertyName;
        });
      }
      filterSingleTableChildren(target) {
        return this.tables.filter((table) => {
          return typeof table.target === "function" && typeof target === "function" && MetadataUtils_1.MetadataUtils.isInherited(table.target, target) && table.type === "entity-child";
        });
      }
      findInheritanceType(target) {
        return this.inheritances.find((inheritance) => inheritance.target === target);
      }
      findDiscriminatorValue(target) {
        return this.discriminatorValues.find((discriminatorValue) => discriminatorValue.target === target);
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Filters given array by a given target or targets.
       */
      filterByTarget(array, target) {
        return array.filter((table) => {
          return Array.isArray(target) ? target.indexOf(table.target) !== -1 : table.target === target;
        });
      }
      /**
       * Filters given array by a given target or targets and prevents duplicate property names.
       */
      filterByTargetAndWithoutDuplicateProperties(array, target) {
        const newArray = [];
        array.forEach((item) => {
          const sameTarget = Array.isArray(target) ? target.indexOf(item.target) !== -1 : item.target === target;
          if (sameTarget) {
            if (!newArray.find((newItem) => newItem.propertyName === item.propertyName))
              newArray.push(item);
          }
        });
        return newArray;
      }
      /**
       * Filters given array by a given target or targets and prevents duplicate relation property names.
       */
      filterByTargetAndWithoutDuplicateRelationProperties(array, target) {
        const newArray = [];
        array.forEach((item) => {
          const sameTarget = Array.isArray(target) ? target.indexOf(item.target) !== -1 : item.target === target;
          if (sameTarget) {
            const existingIndex = newArray.findIndex((newItem) => newItem.propertyName === item.propertyName);
            if (Array.isArray(target) && existingIndex !== -1 && target.indexOf(item.target) < target.indexOf(newArray[existingIndex].target)) {
              const clone = Object.create(newArray[existingIndex]);
              clone.type = item.type;
              newArray[existingIndex] = clone;
            } else if (existingIndex === -1) {
              newArray.push(item);
            }
          }
        });
        return newArray;
      }
      /**
       * Filters given array by a given target or targets and prevents duplicate embedded property names.
       */
      filterByTargetAndWithoutDuplicateEmbeddedProperties(array, target) {
        const newArray = [];
        array.forEach((item) => {
          const sameTarget = Array.isArray(target) ? target.indexOf(item.target) !== -1 : item.target === target;
          if (sameTarget) {
            const isDuplicateEmbeddedProperty = newArray.find((newItem) => newItem.prefix === item.prefix && newItem.propertyName === item.propertyName);
            if (!isDuplicateEmbeddedProperty)
              newArray.push(item);
          }
        });
        return newArray;
      }
    };
    exports2.MetadataArgsStorage = MetadataArgsStorage;
  }
});

// node_modules/ansis/index.js
var require_ansis = __commonJS({
  "node_modules/ansis/index.js"(exports2, module2) {
    var { defineProperty: e, setPrototypeOf: t, create: r, keys: n } = Object;
    var l = "";
    var { round: s, max: i } = Math;
    var o = (e2) => {
      let [, t2] = /([a-f\d]{3,6})/i.exec(e2) || [], r2 = t2 ? t2.length : 0;
      if (3 === r2) t2 = t2[0] + t2[0] + t2[1] + t2[1] + t2[2] + t2[2];
      else if (6 ^ r2) return [0, 0, 0];
      let n2 = parseInt(t2, 16);
      return [n2 >> 16 & 255, n2 >> 8 & 255, 255 & n2];
    };
    var a = (e2, t2, r2) => e2 === t2 && t2 === r2 ? e2 < 8 ? 16 : e2 > 248 ? 231 : s((e2 - 8) / 247 * 24) + 232 : 16 + 36 * s(e2 / 51) + 6 * s(t2 / 51) + s(r2 / 51);
    var c = (e2) => {
      let t2, r2, n2, l2, o2;
      return e2 < 8 ? 30 + e2 : e2 < 16 ? e2 - 8 + 90 : (e2 >= 232 ? t2 = r2 = n2 = (10 * (e2 - 232) + 8) / 255 : (o2 = (e2 -= 16) % 36, t2 = (e2 / 36 | 0) / 5, r2 = (o2 / 6 | 0) / 5, n2 = o2 % 6 / 5), l2 = 2 * i(t2, r2, n2), l2 ? 30 + (s(n2) << 2 | s(r2) << 1 | s(t2)) + (2 ^ l2 ? 0 : 60) : 30);
    };
    var u = (() => {
      let e2 = (e3) => i2.some(((t3) => e3.test(t3))), t2 = globalThis, r2 = t2.Deno, l2 = !!r2, s2 = t2.process || r2 || {}, i2 = s2.argv || s2.args || [], o2 = s2.env || {}, a2 = -1;
      if (l2) try {
        o2 = o2.toObject();
      } catch (e3) {
        a2 = 0;
      }
      let c2 = !!o2.PM2_HOME && !!o2.pm_id || o2.NEXT_RUNTIME?.includes("edge") || (l2 ? r2.isatty(1) : !!s2.stdout?.isTTY), u2 = "FORCE_COLOR", p2 = o2[u2], g2 = parseInt(p2), d2 = isNaN(g2) ? "false" === p2 ? 0 : -1 : g2, f2 = u2 in o2 && d2 || e2(/^-{1,2}color=?(true|always)?$/);
      return f2 && (a2 = d2), a2 < 0 && (a2 = ((e3, t3, r3) => {
        let l3 = e3.TERM, s3 = "," + n(e3).join(",");
        return { "24bit": 3, truecolor: 3, ansi256: 2, ansi: 1 }[e3.COLORTERM] || (e3.TF_BUILD ? 1 : /,TEAMCI/.test(s3) ? 2 : e3.CI ? /,GIT(HUB|EA)/.test(s3) ? 3 : 1 : !t3 || /-mono|dumb/i.test(l3) ? 0 : r3 || /term-(kit|dir)/.test(l3) ? 3 : /-256/.test(l3) ? 2 : /scr|xterm|tty|ansi|color|[nm]ux|vt|cyg/.test(l3) ? 1 : 3);
      })(o2, c2, "win32" === (l2 ? r2.build.os : s2.platform))), !d2 || o2.NO_COLOR || e2(/^-{1,2}(no-color|color=(false|never))$/) ? 0 : f2 && !a2 || t2.window?.chrome ? 3 : a2;
    })();
    var p = u > 0;
    var g = { open: l, close: l };
    var d = p ? (e2, t2) => ({ open: `\x1B[${e2}m`, close: `\x1B[${t2}m` }) : () => g;
    var f = 39;
    var b = 49;
    var _ = (e2, t2) => (r2, n2, l2) => d(((e3, t3, r3) => c(a(e3, t3, r3)))(r2, n2, l2) + e2, t2);
    var m = (e2) => (t2, r2, n2) => e2(a(t2, r2, n2));
    var y = (e2) => (t2) => e2(...o(t2));
    var h = (e2, t2, r2) => d(`38;2;${e2};${t2};${r2}`, f);
    var O = (e2, t2, r2) => d(`48;2;${e2};${t2};${r2}`, b);
    var $ = (e2) => d(`38;5;${e2}`, f);
    var x = (e2) => d(`48;5;${e2}`, b);
    2 === u ? (h = m($), O = m(x)) : 1 === u && (h = _(0, f), O = _(10, b), $ = (e2) => d(c(e2), f), x = (e2) => d(c(e2) + 10, b));
    var T;
    var w = { ansi256: $, bgAnsi256: x, fg: $, bg: x, rgb: h, bgRgb: O, hex: y(h), bgHex: y(O), visible: g, reset: d(0, 0), bold: d(1, 22), dim: d(2, 22), italic: d(3, 23), underline: d(4, 24), inverse: d(7, 27), hidden: d(8, 28) };
    var R = "Bright";
    var E = 30;
    "black,red,green,yellow,blue,magenta,cyan,white".split(",").map(((e2) => {
      T = "bg" + e2[0].toUpperCase() + e2.slice(1), w[e2] = d(E, f), w[e2 + R] = d(60 + E, f), w[T] = d(E + 10, b), w[T + R] = d(70 + E++, b);
    })), w.grey = w.gray = d(90, f), w.bgGrey = w.bgGray = d(100, b), w.strikethrough = w.strike = d(9, 29);
    var v;
    var C = {};
    var I = ({ _p: e2 }, { open: r2, close: n2 }) => {
      let s2 = (e3, ...t2) => {
        if (!e3) {
          if (r2 && r2 === n2) return r2;
          if (null == e3 || l === e3) return l;
        }
        let i3 = e3.raw ? String.raw(e3, ...t2).replace(/\\n/g, "\n") : l + e3, o3 = s2._p, { _a: a2, _b: c2 } = o3;
        if (i3.includes("\x1B")) for (; o3; ) {
          let e4, t3 = o3.close, r3 = o3.open, n3 = t3.length, s3 = l, a3 = 0;
          if (n3) {
            for (; ~(e4 = i3.indexOf(t3, a3)); a3 = e4 + n3) s3 += i3.slice(a3, e4) + r3;
            i3 = s3 + i3.slice(a3);
          }
          o3 = o3._p;
        }
        return i3.includes("\n") && (i3 = i3.replace(/(\r?\n)/g, c2 + "$1" + a2)), a2 + i3 + c2;
      }, i2 = r2, o2 = n2;
      return e2 && (i2 = e2._a + r2, o2 = n2 + e2._b), t(s2, v), s2._p = { open: r2, close: n2, _a: i2, _b: o2, _p: e2 }, s2.open = i2, s2.close = o2, s2;
    };
    var M = function() {
      let n2 = { Ansis: M, isSupported: () => p, strip: (e2) => e2.replace(/[][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g, l), extend(l2) {
        for (let t2 in l2) {
          let r2 = l2[t2], n3 = (typeof r2)[0], s2 = "s" === n3 ? h(...o(r2)) : r2;
          C[t2] = "f" === n3 ? { get() {
            return (...e2) => I(this, r2(...e2));
          } } : { get() {
            let r3 = I(this, s2);
            return e(this, t2, { value: r3 }), r3;
          } };
        }
        return v = r({}, C), t(n2, v), n2;
      } };
      return n2.extend(w);
    };
    var k = new M();
    module2.exports = k, k.default = k;
  }
});

// node_modules/dotenv/package.json
var require_package = __commonJS({
  "node_modules/dotenv/package.json"(exports2, module2) {
    module2.exports = {
      name: "dotenv",
      version: "16.6.1",
      description: "Loads environment variables from .env file",
      main: "lib/main.js",
      types: "lib/main.d.ts",
      exports: {
        ".": {
          types: "./lib/main.d.ts",
          require: "./lib/main.js",
          default: "./lib/main.js"
        },
        "./config": "./config.js",
        "./config.js": "./config.js",
        "./lib/env-options": "./lib/env-options.js",
        "./lib/env-options.js": "./lib/env-options.js",
        "./lib/cli-options": "./lib/cli-options.js",
        "./lib/cli-options.js": "./lib/cli-options.js",
        "./package.json": "./package.json"
      },
      scripts: {
        "dts-check": "tsc --project tests/types/tsconfig.json",
        lint: "standard",
        pretest: "npm run lint && npm run dts-check",
        test: "tap run --allow-empty-coverage --disable-coverage --timeout=60000",
        "test:coverage": "tap run --show-full-coverage --timeout=60000 --coverage-report=text --coverage-report=lcov",
        prerelease: "npm test",
        release: "standard-version"
      },
      repository: {
        type: "git",
        url: "git://github.com/motdotla/dotenv.git"
      },
      homepage: "https://github.com/motdotla/dotenv#readme",
      funding: "https://dotenvx.com",
      keywords: [
        "dotenv",
        "env",
        ".env",
        "environment",
        "variables",
        "config",
        "settings"
      ],
      readmeFilename: "README.md",
      license: "BSD-2-Clause",
      devDependencies: {
        "@types/node": "^18.11.3",
        decache: "^4.6.2",
        sinon: "^14.0.1",
        standard: "^17.0.0",
        "standard-version": "^9.5.0",
        tap: "^19.2.0",
        typescript: "^4.8.4"
      },
      engines: {
        node: ">=12"
      },
      browser: {
        fs: false
      }
    };
  }
});

// node_modules/dotenv/lib/main.js
var require_main = __commonJS({
  "node_modules/dotenv/lib/main.js"(exports2, module2) {
    var fs = require("fs");
    var path = require("path");
    var os = require("os");
    var crypto2 = require("crypto");
    var packageJson = require_package();
    var version = packageJson.version;
    var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    function parse(src) {
      const obj = {};
      let lines = src.toString();
      lines = lines.replace(/\r\n?/mg, "\n");
      let match;
      while ((match = LINE.exec(lines)) != null) {
        const key = match[1];
        let value = match[2] || "";
        value = value.trim();
        const maybeQuote = value[0];
        value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
        if (maybeQuote === '"') {
          value = value.replace(/\\n/g, "\n");
          value = value.replace(/\\r/g, "\r");
        }
        obj[key] = value;
      }
      return obj;
    }
    function _parseVault(options) {
      options = options || {};
      const vaultPath = _vaultPath(options);
      options.path = vaultPath;
      const result = DotenvModule.configDotenv(options);
      if (!result.parsed) {
        const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
        err.code = "MISSING_DATA";
        throw err;
      }
      const keys = _dotenvKey(options).split(",");
      const length = keys.length;
      let decrypted;
      for (let i = 0; i < length; i++) {
        try {
          const key = keys[i].trim();
          const attrs = _instructions(result, key);
          decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
          break;
        } catch (error) {
          if (i + 1 >= length) {
            throw error;
          }
        }
      }
      return DotenvModule.parse(decrypted);
    }
    function _warn(message) {
      console.log(`[dotenv@${version}][WARN] ${message}`);
    }
    function _debug(message) {
      console.log(`[dotenv@${version}][DEBUG] ${message}`);
    }
    function _log(message) {
      console.log(`[dotenv@${version}] ${message}`);
    }
    function _dotenvKey(options) {
      if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
        return options.DOTENV_KEY;
      }
      if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
        return process.env.DOTENV_KEY;
      }
      return "";
    }
    function _instructions(result, dotenvKey) {
      let uri;
      try {
        uri = new URL(dotenvKey);
      } catch (error) {
        if (error.code === "ERR_INVALID_URL") {
          const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        }
        throw error;
      }
      const key = uri.password;
      if (!key) {
        const err = new Error("INVALID_DOTENV_KEY: Missing key part");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      const environment = uri.searchParams.get("environment");
      if (!environment) {
        const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
      const ciphertext = result.parsed[environmentKey];
      if (!ciphertext) {
        const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
        err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
        throw err;
      }
      return { ciphertext, key };
    }
    function _vaultPath(options) {
      let possibleVaultPath = null;
      if (options && options.path && options.path.length > 0) {
        if (Array.isArray(options.path)) {
          for (const filepath of options.path) {
            if (fs.existsSync(filepath)) {
              possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
            }
          }
        } else {
          possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
        }
      } else {
        possibleVaultPath = path.resolve(process.cwd(), ".env.vault");
      }
      if (fs.existsSync(possibleVaultPath)) {
        return possibleVaultPath;
      }
      return null;
    }
    function _resolveHome(envPath) {
      return envPath[0] === "~" ? path.join(os.homedir(), envPath.slice(1)) : envPath;
    }
    function _configVault(options) {
      const debug = Boolean(options && options.debug);
      const quiet = options && "quiet" in options ? options.quiet : true;
      if (debug || !quiet) {
        _log("Loading env from encrypted .env.vault");
      }
      const parsed = DotenvModule._parseVault(options);
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsed, options);
      return { parsed };
    }
    function configDotenv(options) {
      const dotenvPath = path.resolve(process.cwd(), ".env");
      let encoding = "utf8";
      const debug = Boolean(options && options.debug);
      const quiet = options && "quiet" in options ? options.quiet : true;
      if (options && options.encoding) {
        encoding = options.encoding;
      } else {
        if (debug) {
          _debug("No encoding is specified. UTF-8 is used by default");
        }
      }
      let optionPaths = [dotenvPath];
      if (options && options.path) {
        if (!Array.isArray(options.path)) {
          optionPaths = [_resolveHome(options.path)];
        } else {
          optionPaths = [];
          for (const filepath of options.path) {
            optionPaths.push(_resolveHome(filepath));
          }
        }
      }
      let lastError;
      const parsedAll = {};
      for (const path2 of optionPaths) {
        try {
          const parsed = DotenvModule.parse(fs.readFileSync(path2, { encoding }));
          DotenvModule.populate(parsedAll, parsed, options);
        } catch (e) {
          if (debug) {
            _debug(`Failed to load ${path2} ${e.message}`);
          }
          lastError = e;
        }
      }
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsedAll, options);
      if (debug || !quiet) {
        const keysCount = Object.keys(parsedAll).length;
        const shortPaths = [];
        for (const filePath of optionPaths) {
          try {
            const relative = path.relative(process.cwd(), filePath);
            shortPaths.push(relative);
          } catch (e) {
            if (debug) {
              _debug(`Failed to load ${filePath} ${e.message}`);
            }
            lastError = e;
          }
        }
        _log(`injecting env (${keysCount}) from ${shortPaths.join(",")}`);
      }
      if (lastError) {
        return { parsed: parsedAll, error: lastError };
      } else {
        return { parsed: parsedAll };
      }
    }
    function config(options) {
      if (_dotenvKey(options).length === 0) {
        return DotenvModule.configDotenv(options);
      }
      const vaultPath = _vaultPath(options);
      if (!vaultPath) {
        _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
        return DotenvModule.configDotenv(options);
      }
      return DotenvModule._configVault(options);
    }
    function decrypt(encrypted, keyStr) {
      const key = Buffer.from(keyStr.slice(-64), "hex");
      let ciphertext = Buffer.from(encrypted, "base64");
      const nonce = ciphertext.subarray(0, 12);
      const authTag = ciphertext.subarray(-16);
      ciphertext = ciphertext.subarray(12, -16);
      try {
        const aesgcm = crypto2.createDecipheriv("aes-256-gcm", key, nonce);
        aesgcm.setAuthTag(authTag);
        return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
      } catch (error) {
        const isRange = error instanceof RangeError;
        const invalidKeyLength = error.message === "Invalid key length";
        const decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
        if (isRange || invalidKeyLength) {
          const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        } else if (decryptionFailed) {
          const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
          err.code = "DECRYPTION_FAILED";
          throw err;
        } else {
          throw error;
        }
      }
    }
    function populate(processEnv, parsed, options = {}) {
      const debug = Boolean(options && options.debug);
      const override = Boolean(options && options.override);
      if (typeof parsed !== "object") {
        const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
        err.code = "OBJECT_REQUIRED";
        throw err;
      }
      for (const key of Object.keys(parsed)) {
        if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
          if (override === true) {
            processEnv[key] = parsed[key];
          }
          if (debug) {
            if (override === true) {
              _debug(`"${key}" is already defined and WAS overwritten`);
            } else {
              _debug(`"${key}" is already defined and was NOT overwritten`);
            }
          }
        } else {
          processEnv[key] = parsed[key];
        }
      }
    }
    var DotenvModule = {
      configDotenv,
      _configVault,
      _parseVault,
      config,
      decrypt,
      parse,
      populate
    };
    module2.exports.configDotenv = DotenvModule.configDotenv;
    module2.exports._configVault = DotenvModule._configVault;
    module2.exports._parseVault = DotenvModule._parseVault;
    module2.exports.config = DotenvModule.config;
    module2.exports.decrypt = DotenvModule.decrypt;
    module2.exports.parse = DotenvModule.parse;
    module2.exports.populate = DotenvModule.populate;
    module2.exports = DotenvModule;
  }
});

// node_modules/sql-highlight/lib/keywords.js
var require_keywords = __commonJS({
  "node_modules/sql-highlight/lib/keywords.js"(exports2, module2) {
    module2.exports = [
      "ADD CONSTRAINT",
      "ADD",
      "ALL",
      "ALTER COLUMN",
      "ALTER TABLE",
      "ALTER",
      "AND",
      "ANY",
      "AS",
      "ASC",
      "AUTO_INCREMENT",
      "BACKUP DATABASE",
      "BEGIN",
      "BETWEEN",
      "BINARY",
      "BLOB",
      "BY",
      "CASCADE",
      "CASE",
      "CHAR",
      "CHECK",
      "COLUMN",
      "COMMIT",
      "CONSTRAINT",
      "CREATE DATABASE",
      "CREATE INDEX",
      "CREATE OR REPLACE VIEW",
      "CREATE PROCEDURE",
      "CREATE TABLE",
      "CREATE UNIQUE INDEX",
      "CREATE VIEW",
      "CREATE",
      "CURRENT_DATE",
      "CURRENT_TIME",
      "DATABASE",
      "DATETIME",
      "DECIMAL",
      "DECLARE",
      "DEFAULT",
      "DELETE",
      "DESC",
      "DISTINCT",
      "DROP COLUMN",
      "DROP CONSTRAINT",
      "DROP DATABASE",
      "DROP DEFAULT",
      "DROP INDEX",
      "DROP TABLE",
      "DROP VIEW",
      "DROP",
      "EACH",
      "ELSE",
      "ELSEIF",
      "END",
      "ENGINE",
      "EXEC",
      "EXISTS",
      "FALSE",
      "FOR",
      "FOREIGN KEY",
      "FROM",
      "FULL OUTER JOIN",
      "GROUP BY",
      "GROUP",
      "HAVING",
      "IF",
      "IFNULL",
      "ILIKE",
      "IN",
      "INDEX_LIST",
      "INDEX",
      "INNER JOIN",
      "INSERT INTO SELECT",
      "INSERT INTO",
      "INSERT",
      "INTEGER",
      "INTERVAL",
      "INTO",
      "IS NOT NULL",
      "IS NULL",
      "IS",
      "JOIN",
      "KEY",
      "KEYS",
      "LEADING",
      "LEFT JOIN",
      "LEFT",
      "LIKE",
      "LIMIT",
      "LONGTEXT",
      "MATCH",
      "NOT NULL",
      "NOT",
      "NULL",
      "ON",
      "OPTION",
      "OR",
      "ORDER BY",
      "ORDER",
      "OUT",
      "OUTER JOIN",
      "OUTER",
      "OVERLAPS",
      "PRAGMA",
      "PRIMARY KEY",
      "PRIMARY",
      "PRINT",
      "PROCEDURE",
      "REFERENCES",
      "REPLACE",
      "RETURNING",
      "RIGHT JOIN",
      "RIGHT",
      "ROWNUM",
      "SELECT DISTINCT",
      "SELECT INTO",
      "SELECT TOP",
      "SELECT",
      "SET",
      "SHOW",
      "TABLE",
      "TEXT",
      "THEN",
      "TIMESTAMP",
      "TINYBLOB",
      "TINYINT",
      "TINYTEXT",
      "TO",
      "TOP",
      "TRAILING",
      "TRUE",
      "TRUNCATE TABLE",
      "UNION ALL",
      "UNION",
      "UNIQUE",
      "UNSIGNED",
      "UPDATE",
      "VALUES",
      "VARBINARY",
      "VARCHAR",
      "VIEW",
      "WHEN",
      "WHERE",
      "WITH"
    ];
  }
});

// node_modules/sql-highlight/lib/escapeHtml.js
var require_escapeHtml = __commonJS({
  "node_modules/sql-highlight/lib/escapeHtml.js"(exports2, module2) {
    var charCodeMap = {
      34: "&quot;",
      // "
      38: "&amp;",
      // &
      39: "&#39;",
      // '
      60: "&lt;",
      // <
      62: "&gt;"
      // >
    };
    function escapeHtml(str) {
      let html = "";
      let lastIndex = 0;
      for (let i = 0; i < str.length; i++) {
        const replacement = charCodeMap[str.charCodeAt(i)];
        if (!replacement) continue;
        if (lastIndex !== i) {
          html += str.substring(lastIndex, i);
        }
        lastIndex = i + 1;
        html += replacement;
      }
      return html + str.substring(lastIndex);
    }
    module2.exports = escapeHtml;
  }
});

// node_modules/sql-highlight/lib/index.js
var require_lib = __commonJS({
  "node_modules/sql-highlight/lib/index.js"(exports2, module2) {
    var keywords = require_keywords();
    var escapeHtml = require_escapeHtml();
    var DEFAULT_OPTIONS = {
      html: false,
      htmlEscaper: escapeHtml,
      classPrefix: "sql-hl-",
      colors: {
        keyword: "\x1B[35m",
        function: "\x1B[31m",
        number: "\x1B[32m",
        string: "\x1B[32m",
        identifier: "\x1B[0m",
        special: "\x1B[33m",
        bracket: "\x1B[33m",
        comment: "\x1B[2m\x1B[90m",
        clear: "\x1B[0m"
      }
    };
    var highlighters = [
      /(?<number>[+-]?(?:\d+\.\d+|\d+|\.\d+)(?:E[+-]?\d+)?)/,
      // Note: Repeating string escapes like 'sql''server' will also work as they are just repeating strings
      /(?<string>'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*")/,
      /(?<comment>--[^\n\r]*|#[^\n\r]*|\/\*(?:[^*]|\*(?!\/))*\*\/)/,
      // Future improvement: Comments should be allowed between the function name and the opening parenthesis
      /\b(?<function>\w+)(?=\s*\()/,
      /(?<bracket>[()])/,
      /(?<identifier>\b\w+\b|`(?:[^`\\]|\\.)*`)/,
      /(?<whitespace>\s+)/,
      // Multi-character arithmetic, bitwise, comparison, and compound operators as listed in
      // https://www.w3schools.com/sql/sql_operators.asp, https://www.tutorialspoint.com/sql/sql-operators.htm,
      // https://data-flair.training/blogs/sql-operators/, plus any single character (in particular ,:;.) not matched by
      // the above regexps.
      /(?<special>\^-=|\|\*=|\+=|-=|\*=|\/=|%=|&=|>=|<=|<>|!=|!<|!>|>>|<<|.)/
    ];
    var tokenizer = new RegExp(
      [
        `\\b(?<keyword>${keywords.join("|")})\\b`,
        ...highlighters.map((regex) => regex.source)
      ].join("|"),
      "gis"
    );
    function getSegments(sqlString) {
      const segments = Array.from(sqlString.matchAll(tokenizer), (match) => ({
        name: Object.keys(match.groups).find((key) => match.groups[key]),
        content: match[0]
      }));
      return segments;
    }
    function highlight(sqlString, options) {
      const fullOptions = Object.assign({}, DEFAULT_OPTIONS, options);
      return getSegments(sqlString).map(({ name, content }) => {
        if (fullOptions.html) {
          const escapedContent = fullOptions.htmlEscaper(content);
          return name === "whitespace" ? escapedContent : `<span class="${fullOptions.classPrefix}${name}">${escapedContent}</span>`;
        }
        if (fullOptions.colors[name]) {
          return fullOptions.colors[name] + content + fullOptions.colors.clear;
        }
        return content;
      }).join("");
    }
    module2.exports = {
      getSegments,
      highlight,
      DEFAULT_OPTIONS
    };
  }
});

// node_modules/@sqltools/formatter/lib/core/escapeRegExp.js
var require_escapeRegExp = __commonJS({
  "node_modules/@sqltools/formatter/lib/core/escapeRegExp.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reHasRegExpChar = RegExp(reRegExpChar.source);
    function escapeRegExp(str) {
      return str && reHasRegExpChar.test(str) ? str.replace(reRegExpChar, "\\$&") : str || "";
    }
    exports2["default"] = escapeRegExp;
  }
});

// node_modules/@sqltools/formatter/lib/core/types.js
var require_types = __commonJS({
  "node_modules/@sqltools/formatter/lib/core/types.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2.TokenTypes = void 0;
    var TokenTypes;
    (function(TokenTypes2) {
      TokenTypes2["WHITESPACE"] = "whitespace";
      TokenTypes2["WORD"] = "word";
      TokenTypes2["STRING"] = "string";
      TokenTypes2["RESERVED"] = "reserved";
      TokenTypes2["RESERVED_TOP_LEVEL"] = "reserved-top-level";
      TokenTypes2["RESERVED_TOP_LEVEL_NO_INDENT"] = "reserved-top-level-no-indent";
      TokenTypes2["RESERVED_NEWLINE"] = "reserved-newline";
      TokenTypes2["OPERATOR"] = "operator";
      TokenTypes2["NO_SPACE_OPERATOR"] = "no-space-operator";
      TokenTypes2["OPEN_PAREN"] = "open-paren";
      TokenTypes2["CLOSE_PAREN"] = "close-paren";
      TokenTypes2["LINE_COMMENT"] = "line-comment";
      TokenTypes2["BLOCK_COMMENT"] = "block-comment";
      TokenTypes2["NUMBER"] = "number";
      TokenTypes2["PLACEHOLDER"] = "placeholder";
      TokenTypes2["SERVERVARIABLE"] = "servervariable";
    })(TokenTypes = exports2.TokenTypes || (exports2.TokenTypes = {}));
  }
});

// node_modules/@sqltools/formatter/lib/core/Tokenizer.js
var require_Tokenizer = __commonJS({
  "node_modules/@sqltools/formatter/lib/core/Tokenizer.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports2.__esModule = true;
    var escapeRegExp_1 = __importDefault2(require_escapeRegExp());
    var types_1 = require_types();
    var Tokenizer = (function() {
      function Tokenizer2(cfg) {
        this.WHITESPACE_REGEX = /^(\s+)/u;
        this.NUMBER_REGEX = /^((-\s*)?[0-9]+(\.[0-9]+)?|0x[0-9a-fA-F]+|0b[01]+|([a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}))\b/u;
        this.AMBIGUOS_OPERATOR_REGEX = /^(\?\||\?&)/u;
        this.OPERATOR_REGEX = /^(!=|<>|>>|<<|==|<=|>=|!<|!>|\|\|\/|\|\/|\|\||~~\*|~~|!~~\*|!~~|~\*|!~\*|!~|:=|=>|&&|@>|<@|#-|@@|@|.)/u;
        this.NO_SPACE_OPERATOR_REGEX = /^(::|->>|->|#>>|#>)/u;
        this.BLOCK_COMMENT_REGEX = /^(\/\*[^]*?(?:\*\/|$))/u;
        this.LINE_COMMENT_REGEX = this.createLineCommentRegex(cfg.lineCommentTypes);
        this.RESERVED_TOP_LEVEL_REGEX = this.createReservedWordRegex(cfg.reservedTopLevelWords);
        this.RESERVED_TOP_LEVEL_NO_INDENT_REGEX = this.createReservedWordRegex(cfg.reservedTopLevelWordsNoIndent);
        this.RESERVED_NEWLINE_REGEX = this.createReservedWordRegex(cfg.reservedNewlineWords);
        this.RESERVED_PLAIN_REGEX = this.createReservedWordRegex(cfg.reservedWords);
        this.WORD_REGEX = this.createWordRegex(cfg.specialWordChars);
        this.STRING_REGEX = this.createStringRegex(cfg.stringTypes);
        this.OPEN_PAREN_REGEX = this.createParenRegex(cfg.openParens);
        this.CLOSE_PAREN_REGEX = this.createParenRegex(cfg.closeParens);
        this.INDEXED_PLACEHOLDER_REGEX = this.createPlaceholderRegex(cfg.indexedPlaceholderTypes, "[0-9]*");
        this.IDENT_NAMED_PLACEHOLDER_REGEX = this.createPlaceholderRegex(cfg.namedPlaceholderTypes, "[a-zA-Z0-9._$]+");
        this.STRING_NAMED_PLACEHOLDER_REGEX = this.createPlaceholderRegex(cfg.namedPlaceholderTypes, this.createStringPattern(cfg.stringTypes));
      }
      Tokenizer2.prototype.createLineCommentRegex = function(lineCommentTypes) {
        var unMatchJSONOperators = "((?<!#)>|(?:[^>]))";
        return new RegExp("^((?:".concat(lineCommentTypes.map(function(c) {
          return (0, escapeRegExp_1["default"])(c);
        }).join("|"), ")").concat(unMatchJSONOperators, ".*?(?:\r\n|\r|\n|$))"), "u");
      };
      Tokenizer2.prototype.createReservedWordRegex = function(reservedWords) {
        var reservedWordsPattern = reservedWords.join("|").replace(/ /gu, "\\s+");
        return new RegExp("^(".concat(reservedWordsPattern, ")\\b"), "iu");
      };
      Tokenizer2.prototype.createWordRegex = function(specialChars) {
        return new RegExp("^([\\p{Alphabetic}\\p{Mark}\\p{Decimal_Number}\\p{Connector_Punctuation}\\p{Join_Control}".concat(specialChars.join(""), "]+)"), "u");
      };
      Tokenizer2.prototype.createStringRegex = function(stringTypes) {
        return new RegExp("^(" + this.createStringPattern(stringTypes) + ")", "u");
      };
      Tokenizer2.prototype.createStringPattern = function(stringTypes) {
        var patterns = {
          "``": "((`[^`]*($|`))+)",
          "[]": "((\\[[^\\]]*($|\\]))(\\][^\\]]*($|\\]))*)",
          '""': '(("[^"\\\\]*(?:\\\\.[^"\\\\]*)*("|$))+)',
          "''": "(('[^'\\\\]*(?:\\\\.[^'\\\\]*)*('|$))+)",
          "N''": "((N'[^N'\\\\]*(?:\\\\.[^N'\\\\]*)*('|$))+)",
          "E''": "(((E|e)'[^'\\\\]*(?:\\\\.[^'\\\\]*)*('|$))+)"
        };
        return stringTypes.map(function(t) {
          return patterns[t];
        }).join("|");
      };
      Tokenizer2.prototype.createParenRegex = function(parens) {
        var _this = this;
        return new RegExp("^(" + parens.map(function(p) {
          return _this.escapeParen(p);
        }).join("|") + ")", "iu");
      };
      Tokenizer2.prototype.escapeParen = function(paren) {
        if (paren.length === 1) {
          return (0, escapeRegExp_1["default"])(paren);
        } else {
          return "\\b" + paren + "\\b";
        }
      };
      Tokenizer2.prototype.createPlaceholderRegex = function(types, pattern) {
        if (!types || types.length === 0) {
          return null;
        }
        var typesRegex = types.map(escapeRegExp_1["default"]).join("|");
        return new RegExp("^((?:".concat(typesRegex, ")(?:").concat(pattern, "))"), "u");
      };
      Tokenizer2.prototype.tokenize = function(input) {
        if (!input)
          return [];
        var tokens = [];
        var token;
        while (input.length) {
          token = this.getNextToken(input, token);
          input = input.substring(token.value.length);
          tokens.push(token);
        }
        return tokens;
      };
      Tokenizer2.prototype.getNextToken = function(input, previousToken) {
        return this.getWhitespaceToken(input) || this.getCommentToken(input) || this.getStringToken(input) || this.getOpenParenToken(input) || this.getCloseParenToken(input) || this.getAmbiguosOperatorToken(input) || this.getNoSpaceOperatorToken(input) || this.getServerVariableToken(input) || this.getPlaceholderToken(input) || this.getNumberToken(input) || this.getReservedWordToken(input, previousToken) || this.getWordToken(input) || this.getOperatorToken(input);
      };
      Tokenizer2.prototype.getWhitespaceToken = function(input) {
        return this.getTokenOnFirstMatch({
          input,
          type: types_1.TokenTypes.WHITESPACE,
          regex: this.WHITESPACE_REGEX
        });
      };
      Tokenizer2.prototype.getCommentToken = function(input) {
        return this.getLineCommentToken(input) || this.getBlockCommentToken(input);
      };
      Tokenizer2.prototype.getLineCommentToken = function(input) {
        return this.getTokenOnFirstMatch({
          input,
          type: types_1.TokenTypes.LINE_COMMENT,
          regex: this.LINE_COMMENT_REGEX
        });
      };
      Tokenizer2.prototype.getBlockCommentToken = function(input) {
        return this.getTokenOnFirstMatch({
          input,
          type: types_1.TokenTypes.BLOCK_COMMENT,
          regex: this.BLOCK_COMMENT_REGEX
        });
      };
      Tokenizer2.prototype.getStringToken = function(input) {
        return this.getTokenOnFirstMatch({
          input,
          type: types_1.TokenTypes.STRING,
          regex: this.STRING_REGEX
        });
      };
      Tokenizer2.prototype.getOpenParenToken = function(input) {
        return this.getTokenOnFirstMatch({
          input,
          type: types_1.TokenTypes.OPEN_PAREN,
          regex: this.OPEN_PAREN_REGEX
        });
      };
      Tokenizer2.prototype.getCloseParenToken = function(input) {
        return this.getTokenOnFirstMatch({
          input,
          type: types_1.TokenTypes.CLOSE_PAREN,
          regex: this.CLOSE_PAREN_REGEX
        });
      };
      Tokenizer2.prototype.getPlaceholderToken = function(input) {
        return this.getIdentNamedPlaceholderToken(input) || this.getStringNamedPlaceholderToken(input) || this.getIndexedPlaceholderToken(input);
      };
      Tokenizer2.prototype.getServerVariableToken = function(input) {
        return this.getTokenOnFirstMatch({
          input,
          type: types_1.TokenTypes.SERVERVARIABLE,
          regex: /(^@@\w+)/iu
        });
      };
      Tokenizer2.prototype.getIdentNamedPlaceholderToken = function(input) {
        return this.getPlaceholderTokenWithKey({
          input,
          regex: this.IDENT_NAMED_PLACEHOLDER_REGEX,
          parseKey: function(v) {
            return v.slice(1);
          }
        });
      };
      Tokenizer2.prototype.getStringNamedPlaceholderToken = function(input) {
        var _this = this;
        return this.getPlaceholderTokenWithKey({
          input,
          regex: this.STRING_NAMED_PLACEHOLDER_REGEX,
          parseKey: function(v) {
            return _this.getEscapedPlaceholderKey({ key: v.slice(2, -1), quoteChar: v.slice(-1) });
          }
        });
      };
      Tokenizer2.prototype.getIndexedPlaceholderToken = function(input) {
        return this.getPlaceholderTokenWithKey({
          input,
          regex: this.INDEXED_PLACEHOLDER_REGEX,
          parseKey: function(v) {
            return v.slice(1);
          }
        });
      };
      Tokenizer2.prototype.getPlaceholderTokenWithKey = function(_a) {
        var input = _a.input, regex = _a.regex, parseKey = _a.parseKey;
        var token = this.getTokenOnFirstMatch({ input, regex, type: types_1.TokenTypes.PLACEHOLDER });
        if (token) {
          token.key = parseKey(token.value);
        }
        return token;
      };
      Tokenizer2.prototype.getEscapedPlaceholderKey = function(_a) {
        var key = _a.key, quoteChar = _a.quoteChar;
        return key.replace(new RegExp((0, escapeRegExp_1["default"])("\\" + quoteChar), "gu"), quoteChar);
      };
      Tokenizer2.prototype.getNumberToken = function(input) {
        return this.getTokenOnFirstMatch({
          input,
          type: types_1.TokenTypes.NUMBER,
          regex: this.NUMBER_REGEX
        });
      };
      Tokenizer2.prototype.getOperatorToken = function(input) {
        return this.getTokenOnFirstMatch({
          input,
          type: types_1.TokenTypes.OPERATOR,
          regex: this.OPERATOR_REGEX
        });
      };
      Tokenizer2.prototype.getAmbiguosOperatorToken = function(input) {
        return this.getTokenOnFirstMatch({
          input,
          type: types_1.TokenTypes.OPERATOR,
          regex: this.AMBIGUOS_OPERATOR_REGEX
        });
      };
      Tokenizer2.prototype.getNoSpaceOperatorToken = function(input) {
        return this.getTokenOnFirstMatch({
          input,
          type: types_1.TokenTypes.NO_SPACE_OPERATOR,
          regex: this.NO_SPACE_OPERATOR_REGEX
        });
      };
      Tokenizer2.prototype.getReservedWordToken = function(input, previousToken) {
        if (previousToken && previousToken.value && previousToken.value === ".") {
          return;
        }
        return this.getToplevelReservedToken(input) || this.getNewlineReservedToken(input) || this.getTopLevelReservedTokenNoIndent(input) || this.getPlainReservedToken(input);
      };
      Tokenizer2.prototype.getToplevelReservedToken = function(input) {
        return this.getTokenOnFirstMatch({
          input,
          type: types_1.TokenTypes.RESERVED_TOP_LEVEL,
          regex: this.RESERVED_TOP_LEVEL_REGEX
        });
      };
      Tokenizer2.prototype.getNewlineReservedToken = function(input) {
        return this.getTokenOnFirstMatch({
          input,
          type: types_1.TokenTypes.RESERVED_NEWLINE,
          regex: this.RESERVED_NEWLINE_REGEX
        });
      };
      Tokenizer2.prototype.getPlainReservedToken = function(input) {
        return this.getTokenOnFirstMatch({
          input,
          type: types_1.TokenTypes.RESERVED,
          regex: this.RESERVED_PLAIN_REGEX
        });
      };
      Tokenizer2.prototype.getTopLevelReservedTokenNoIndent = function(input) {
        return this.getTokenOnFirstMatch({
          input,
          type: types_1.TokenTypes.RESERVED_TOP_LEVEL_NO_INDENT,
          regex: this.RESERVED_TOP_LEVEL_NO_INDENT_REGEX
        });
      };
      Tokenizer2.prototype.getWordToken = function(input) {
        return this.getTokenOnFirstMatch({
          input,
          type: types_1.TokenTypes.WORD,
          regex: this.WORD_REGEX
        });
      };
      Tokenizer2.prototype.getTokenOnFirstMatch = function(_a) {
        var input = _a.input, type = _a.type, regex = _a.regex;
        var matches = input.match(regex);
        if (matches) {
          return { type, value: matches[1] };
        }
      };
      return Tokenizer2;
    })();
    exports2["default"] = Tokenizer;
  }
});

// node_modules/@sqltools/formatter/lib/core/last.js
var require_last = __commonJS({
  "node_modules/@sqltools/formatter/lib/core/last.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    var last = function(arr) {
      if (arr === void 0) {
        arr = [];
      }
      return arr[arr.length - 1];
    };
    exports2["default"] = last;
  }
});

// node_modules/@sqltools/formatter/lib/core/Indentation.js
var require_Indentation = __commonJS({
  "node_modules/@sqltools/formatter/lib/core/Indentation.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports2.__esModule = true;
    var last_1 = __importDefault2(require_last());
    var INDENT_TYPE_TOP_LEVEL = "top-level";
    var INDENT_TYPE_BLOCK_LEVEL = "block-level";
    var Indentation = (function() {
      function Indentation2(indent) {
        this.indent = indent;
        this.indentTypes = [];
        this.indent = indent || "  ";
      }
      Indentation2.prototype.getIndent = function() {
        return new Array(this.indentTypes.length).fill(this.indent).join("");
      };
      Indentation2.prototype.increaseTopLevel = function() {
        this.indentTypes.push(INDENT_TYPE_TOP_LEVEL);
      };
      Indentation2.prototype.increaseBlockLevel = function() {
        this.indentTypes.push(INDENT_TYPE_BLOCK_LEVEL);
      };
      Indentation2.prototype.decreaseTopLevel = function() {
        if ((0, last_1["default"])(this.indentTypes) === INDENT_TYPE_TOP_LEVEL) {
          this.indentTypes.pop();
        }
      };
      Indentation2.prototype.decreaseBlockLevel = function() {
        while (this.indentTypes.length > 0) {
          var type = this.indentTypes.pop();
          if (type !== INDENT_TYPE_TOP_LEVEL) {
            break;
          }
        }
      };
      Indentation2.prototype.resetIndentation = function() {
        this.indentTypes = [];
      };
      return Indentation2;
    })();
    exports2["default"] = Indentation;
  }
});

// node_modules/@sqltools/formatter/lib/core/InlineBlock.js
var require_InlineBlock = __commonJS({
  "node_modules/@sqltools/formatter/lib/core/InlineBlock.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    var types_1 = require_types();
    var INLINE_MAX_LENGTH = 50;
    var InlineBlock = (function() {
      function InlineBlock2() {
        this.level = 0;
      }
      InlineBlock2.prototype.beginIfPossible = function(tokens, index) {
        if (this.level === 0 && this.isInlineBlock(tokens, index)) {
          this.level = 1;
        } else if (this.level > 0) {
          this.level++;
        } else {
          this.level = 0;
        }
      };
      InlineBlock2.prototype.end = function() {
        this.level--;
      };
      InlineBlock2.prototype.isActive = function() {
        return this.level > 0;
      };
      InlineBlock2.prototype.isInlineBlock = function(tokens, index) {
        var length = 0;
        var level = 0;
        for (var i = index; i < tokens.length; i++) {
          var token = tokens[i];
          length += token.value.length;
          if (length > INLINE_MAX_LENGTH) {
            return false;
          }
          if (token.type === types_1.TokenTypes.OPEN_PAREN) {
            level++;
          } else if (token.type === types_1.TokenTypes.CLOSE_PAREN) {
            level--;
            if (level === 0) {
              return true;
            }
          }
          if (this.isForbiddenToken(token)) {
            return false;
          }
        }
        return false;
      };
      InlineBlock2.prototype.isForbiddenToken = function(_a) {
        var type = _a.type, value = _a.value;
        return type === types_1.TokenTypes.RESERVED_TOP_LEVEL || type === types_1.TokenTypes.RESERVED_NEWLINE || type === types_1.TokenTypes.LINE_COMMENT || type === types_1.TokenTypes.BLOCK_COMMENT || value === ";";
      };
      return InlineBlock2;
    })();
    exports2["default"] = InlineBlock;
  }
});

// node_modules/@sqltools/formatter/lib/core/Params.js
var require_Params = __commonJS({
  "node_modules/@sqltools/formatter/lib/core/Params.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    var Params = (function() {
      function Params2(params) {
        this.params = params;
        this.index = 0;
        this.params = params;
      }
      Params2.prototype.get = function(_a) {
        var key = _a.key, value = _a.value;
        if (!this.params) {
          return value;
        }
        if (key) {
          return this.params[key];
        }
        return this.params[this.index++];
      };
      return Params2;
    })();
    exports2["default"] = Params;
  }
});

// node_modules/@sqltools/formatter/lib/core/Formatter.js
var require_Formatter = __commonJS({
  "node_modules/@sqltools/formatter/lib/core/Formatter.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports2.__esModule = true;
    var types_1 = require_types();
    var Indentation_1 = __importDefault2(require_Indentation());
    var InlineBlock_1 = __importDefault2(require_InlineBlock());
    var Params_1 = __importDefault2(require_Params());
    var spaceChars = [" ", "	"];
    var trimSpacesEnd = function(str) {
      var end = str.length - 1;
      while (end >= 0 && spaceChars.includes(str[end])) {
        end--;
      }
      return str.substring(0, end + 1);
    };
    var Formatter = (function() {
      function Formatter2(cfg, tokenizer, tokenOverride) {
        this.cfg = cfg;
        this.tokenizer = tokenizer;
        this.tokenOverride = tokenOverride;
        this.tokens = [];
        this.previousReservedWord = { type: null, value: null };
        this.previousNonWhiteSpace = { type: null, value: null };
        this.index = 0;
        this.indentation = new Indentation_1["default"](this.cfg.indent);
        this.inlineBlock = new InlineBlock_1["default"]();
        this.params = new Params_1["default"](this.cfg.params);
      }
      Formatter2.prototype.format = function(query) {
        this.tokens = this.tokenizer.tokenize(query);
        var formattedQuery = this.getFormattedQueryFromTokens();
        return formattedQuery.trim();
      };
      Formatter2.prototype.getFormattedQueryFromTokens = function() {
        var _this = this;
        var formattedQuery = "";
        this.tokens.forEach(function(token, index) {
          _this.index = index;
          if (_this.tokenOverride)
            token = _this.tokenOverride(token, _this.previousReservedWord) || token;
          if (token.type === types_1.TokenTypes.WHITESPACE) {
            formattedQuery = _this.formatWhitespace(token, formattedQuery);
          } else if (token.type === types_1.TokenTypes.LINE_COMMENT) {
            formattedQuery = _this.formatLineComment(token, formattedQuery);
          } else if (token.type === types_1.TokenTypes.BLOCK_COMMENT) {
            formattedQuery = _this.formatBlockComment(token, formattedQuery);
          } else if (token.type === types_1.TokenTypes.RESERVED_TOP_LEVEL || token.type === types_1.TokenTypes.RESERVED_TOP_LEVEL_NO_INDENT || token.type === types_1.TokenTypes.RESERVED_NEWLINE || token.type === types_1.TokenTypes.RESERVED) {
            formattedQuery = _this.formatReserved(token, formattedQuery);
          } else if (token.type === types_1.TokenTypes.OPEN_PAREN) {
            formattedQuery = _this.formatOpeningParentheses(token, formattedQuery);
          } else if (token.type === types_1.TokenTypes.CLOSE_PAREN) {
            formattedQuery = _this.formatClosingParentheses(token, formattedQuery);
          } else if (token.type === types_1.TokenTypes.NO_SPACE_OPERATOR) {
            formattedQuery = _this.formatWithoutSpaces(token, formattedQuery);
          } else if (token.type === types_1.TokenTypes.PLACEHOLDER || token.type === types_1.TokenTypes.SERVERVARIABLE) {
            formattedQuery = _this.formatPlaceholder(token, formattedQuery);
          } else if (token.value === ",") {
            formattedQuery = _this.formatComma(token, formattedQuery);
          } else if (token.value === ":") {
            formattedQuery = _this.formatWithSpaceAfter(token, formattedQuery);
          } else if (token.value === ".") {
            formattedQuery = _this.formatWithoutSpaces(token, formattedQuery);
          } else if (token.value === ";") {
            formattedQuery = _this.formatQuerySeparator(token, formattedQuery);
          } else {
            formattedQuery = _this.formatWithSpaces(token, formattedQuery);
          }
          if (token.type !== types_1.TokenTypes.WHITESPACE) {
            _this.previousNonWhiteSpace = token;
          }
        });
        return formattedQuery;
      };
      Formatter2.prototype.formatWhitespace = function(token, query) {
        if (this.cfg.linesBetweenQueries === "preserve" && /((\r\n|\n)(\r\n|\n)+)/u.test(token.value) && this.previousToken().value === ";") {
          return query.replace(/(\n|\r\n)$/u, "") + token.value;
        }
        return query;
      };
      Formatter2.prototype.formatReserved = function(token, query) {
        if (token.type === types_1.TokenTypes.RESERVED_NEWLINE && this.previousReservedWord && this.previousReservedWord.value && token.value.toUpperCase() === "AND" && this.previousReservedWord.value.toUpperCase() === "BETWEEN") {
          token.type = types_1.TokenTypes.RESERVED;
        }
        if (token.type === types_1.TokenTypes.RESERVED_TOP_LEVEL) {
          query = this.formatTopLevelReservedWord(token, query);
        } else if (token.type === types_1.TokenTypes.RESERVED_TOP_LEVEL_NO_INDENT) {
          query = this.formatTopLevelReservedWordNoIndent(token, query);
        } else if (token.type === types_1.TokenTypes.RESERVED_NEWLINE) {
          query = this.formatNewlineReservedWord(token, query);
        } else {
          query = this.formatWithSpaces(token, query);
        }
        this.previousReservedWord = token;
        return query;
      };
      Formatter2.prototype.formatLineComment = function(token, query) {
        return this.addNewline(query + token.value);
      };
      Formatter2.prototype.formatBlockComment = function(token, query) {
        return this.addNewline(this.addNewline(query) + this.indentComment(token.value));
      };
      Formatter2.prototype.indentComment = function(comment) {
        return comment.replace(/\n[ \t]*/gu, "\n" + this.indentation.getIndent() + " ");
      };
      Formatter2.prototype.formatTopLevelReservedWordNoIndent = function(token, query) {
        this.indentation.decreaseTopLevel();
        query = this.addNewline(query) + this.equalizeWhitespace(this.formatReservedWord(token.value));
        return this.addNewline(query);
      };
      Formatter2.prototype.formatTopLevelReservedWord = function(token, query) {
        var shouldChangeTopLevel = this.previousNonWhiteSpace.value !== "," && !["GRANT"].includes("".concat(this.previousNonWhiteSpace.value).toUpperCase());
        if (shouldChangeTopLevel) {
          this.indentation.decreaseTopLevel();
          query = this.addNewline(query);
        }
        query = query + this.equalizeWhitespace(this.formatReservedWord(token.value)) + " ";
        if (shouldChangeTopLevel)
          this.indentation.increaseTopLevel();
        return query;
      };
      Formatter2.prototype.formatNewlineReservedWord = function(token, query) {
        return this.addNewline(query) + this.equalizeWhitespace(this.formatReservedWord(token.value)) + " ";
      };
      Formatter2.prototype.equalizeWhitespace = function(value) {
        return value.replace(/\s+/gu, " ");
      };
      Formatter2.prototype.formatOpeningParentheses = function(token, query) {
        token.value = this.formatCase(token.value);
        var previousTokenType = this.previousToken().type;
        if (previousTokenType !== types_1.TokenTypes.WHITESPACE && previousTokenType !== types_1.TokenTypes.OPEN_PAREN && previousTokenType !== types_1.TokenTypes.LINE_COMMENT) {
          query = trimSpacesEnd(query);
        }
        query += token.value;
        this.inlineBlock.beginIfPossible(this.tokens, this.index);
        if (!this.inlineBlock.isActive()) {
          this.indentation.increaseBlockLevel();
          query = this.addNewline(query);
        }
        return query;
      };
      Formatter2.prototype.formatClosingParentheses = function(token, query) {
        token.value = this.formatCase(token.value);
        if (this.inlineBlock.isActive()) {
          this.inlineBlock.end();
          return this.formatWithSpaceAfter(token, query);
        } else {
          this.indentation.decreaseBlockLevel();
          return this.formatWithSpaces(token, this.addNewline(query));
        }
      };
      Formatter2.prototype.formatPlaceholder = function(token, query) {
        return query + this.params.get(token) + " ";
      };
      Formatter2.prototype.formatComma = function(token, query) {
        query = trimSpacesEnd(query) + token.value + " ";
        if (this.inlineBlock.isActive()) {
          return query;
        } else if (/^LIMIT$/iu.test(this.previousReservedWord.value)) {
          return query;
        } else {
          return this.addNewline(query);
        }
      };
      Formatter2.prototype.formatWithSpaceAfter = function(token, query) {
        return trimSpacesEnd(query) + token.value + " ";
      };
      Formatter2.prototype.formatWithoutSpaces = function(token, query) {
        return trimSpacesEnd(query) + token.value;
      };
      Formatter2.prototype.formatWithSpaces = function(token, query) {
        var value = token.type === types_1.TokenTypes.RESERVED ? this.formatReservedWord(token.value) : token.value;
        return query + value + " ";
      };
      Formatter2.prototype.formatReservedWord = function(value) {
        return this.formatCase(value);
      };
      Formatter2.prototype.formatQuerySeparator = function(token, query) {
        this.indentation.resetIndentation();
        var lines = "\n";
        if (this.cfg.linesBetweenQueries !== "preserve") {
          lines = "\n".repeat(this.cfg.linesBetweenQueries || 1);
        }
        return trimSpacesEnd(query) + token.value + lines;
      };
      Formatter2.prototype.addNewline = function(query) {
        query = trimSpacesEnd(query);
        if (!query.endsWith("\n"))
          query += "\n";
        return query + this.indentation.getIndent();
      };
      Formatter2.prototype.previousToken = function() {
        return this.tokens[this.index - 1] || { type: null, value: null };
      };
      Formatter2.prototype.formatCase = function(value) {
        if (this.cfg.reservedWordCase === "upper")
          return value.toUpperCase();
        if (this.cfg.reservedWordCase === "lower")
          return value.toLowerCase();
        return value;
      };
      return Formatter2;
    })();
    exports2["default"] = Formatter;
  }
});

// node_modules/@sqltools/formatter/lib/languages/utils/abstract.js
var require_abstract = __commonJS({
  "node_modules/@sqltools/formatter/lib/languages/utils/abstract.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports2.__esModule = true;
    var Tokenizer_1 = __importDefault2(require_Tokenizer());
    var Formatter_1 = __importDefault2(require_Formatter());
    var AbstractFormatter = (function() {
      function AbstractFormatter2(cfg) {
        this.cfg = cfg;
      }
      AbstractFormatter2.prototype.format = function(query) {
        return new Formatter_1["default"](this.cfg, this.tokenizer(), this.tokenOverride).format(query);
      };
      AbstractFormatter2.prototype.tokenize = function(query) {
        return this.tokenizer().tokenize(query);
      };
      AbstractFormatter2.prototype.tokenizer = function() {
        return new Tokenizer_1["default"](this.getTokenizerConfig());
      };
      return AbstractFormatter2;
    })();
    exports2["default"] = AbstractFormatter;
  }
});

// node_modules/@sqltools/formatter/lib/languages/Db2Formatter.js
var require_Db2Formatter = __commonJS({
  "node_modules/@sqltools/formatter/lib/languages/Db2Formatter.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports2.__esModule = true;
    var abstract_1 = __importDefault2(require_abstract());
    var Db2Formatter = (function(_super) {
      __extends2(Db2Formatter2, _super);
      function Db2Formatter2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Db2Formatter2.prototype.getTokenizerConfig = function() {
        return {
          reservedWords,
          reservedTopLevelWords,
          reservedNewlineWords,
          reservedTopLevelWordsNoIndent,
          stringTypes: ['""', "''", "``", "[]"],
          openParens: ["("],
          closeParens: [")"],
          indexedPlaceholderTypes: ["?"],
          namedPlaceholderTypes: [":"],
          lineCommentTypes: ["--"],
          specialWordChars: ["#", "@"]
        };
      };
      return Db2Formatter2;
    })(abstract_1["default"]);
    exports2["default"] = Db2Formatter;
    var reservedWords = [
      "ABS",
      "ACTIVATE",
      "ALIAS",
      "ALL",
      "ALLOCATE",
      "ALLOW",
      "ALTER",
      "ANY",
      "ARE",
      "ARRAY",
      "AS",
      "ASC",
      "ASENSITIVE",
      "ASSOCIATE",
      "ASUTIME",
      "ASYMMETRIC",
      "AT",
      "ATOMIC",
      "ATTRIBUTES",
      "AUDIT",
      "AUTHORIZATION",
      "AUX",
      "AUXILIARY",
      "AVG",
      "BEFORE",
      "BEGIN",
      "BETWEEN",
      "BIGINT",
      "BINARY",
      "BLOB",
      "BOOLEAN",
      "BOTH",
      "BUFFERPOOL",
      "BY",
      "CACHE",
      "CALL",
      "CALLED",
      "CAPTURE",
      "CARDINALITY",
      "CASCADED",
      "CASE",
      "CAST",
      "CCSID",
      "CEIL",
      "CEILING",
      "CHAR",
      "CHARACTER",
      "CHARACTER_LENGTH",
      "CHAR_LENGTH",
      "CHECK",
      "CLOB",
      "CLONE",
      "CLOSE",
      "CLUSTER",
      "COALESCE",
      "COLLATE",
      "COLLECT",
      "COLLECTION",
      "COLLID",
      "COLUMN",
      "COMMENT",
      "COMMIT",
      "CONCAT",
      "CONDITION",
      "CONNECT",
      "CONNECTION",
      "CONSTRAINT",
      "CONTAINS",
      "CONTINUE",
      "CONVERT",
      "CORR",
      "CORRESPONDING",
      "COUNT",
      "COUNT_BIG",
      "COVAR_POP",
      "COVAR_SAMP",
      "CREATE",
      "CROSS",
      "CUBE",
      "CUME_DIST",
      "CURRENT",
      "CURRENT_DATE",
      "CURRENT_DEFAULT_TRANSFORM_GROUP",
      "CURRENT_LC_CTYPE",
      "CURRENT_PATH",
      "CURRENT_ROLE",
      "CURRENT_SCHEMA",
      "CURRENT_SERVER",
      "CURRENT_TIME",
      "CURRENT_TIMESTAMP",
      "CURRENT_TIMEZONE",
      "CURRENT_TRANSFORM_GROUP_FOR_TYPE",
      "CURRENT_USER",
      "CURSOR",
      "CYCLE",
      "DATA",
      "DATABASE",
      "DATAPARTITIONNAME",
      "DATAPARTITIONNUM",
      "DATE",
      "DAY",
      "DAYS",
      "DB2GENERAL",
      "DB2GENRL",
      "DB2SQL",
      "DBINFO",
      "DBPARTITIONNAME",
      "DBPARTITIONNUM",
      "DEALLOCATE",
      "DEC",
      "DECIMAL",
      "DECLARE",
      "DEFAULT",
      "DEFAULTS",
      "DEFINITION",
      "DELETE",
      "DENSERANK",
      "DENSE_RANK",
      "DEREF",
      "DESCRIBE",
      "DESCRIPTOR",
      "DETERMINISTIC",
      "DIAGNOSTICS",
      "DISABLE",
      "DISALLOW",
      "DISCONNECT",
      "DISTINCT",
      "DO",
      "DOCUMENT",
      "DOUBLE",
      "DROP",
      "DSSIZE",
      "DYNAMIC",
      "EACH",
      "EDITPROC",
      "ELEMENT",
      "ELSE",
      "ELSEIF",
      "ENABLE",
      "ENCODING",
      "ENCRYPTION",
      "END",
      "END-EXEC",
      "ENDING",
      "ERASE",
      "ESCAPE",
      "EVERY",
      "EXCEPTION",
      "EXCLUDING",
      "EXCLUSIVE",
      "EXEC",
      "EXECUTE",
      "EXISTS",
      "EXIT",
      "EXP",
      "EXPLAIN",
      "EXTENDED",
      "EXTERNAL",
      "EXTRACT",
      "FALSE",
      "FENCED",
      "FETCH",
      "FIELDPROC",
      "FILE",
      "FILTER",
      "FINAL",
      "FIRST",
      "FLOAT",
      "FLOOR",
      "FOR",
      "FOREIGN",
      "FREE",
      "FULL",
      "FUNCTION",
      "FUSION",
      "GENERAL",
      "GENERATED",
      "GET",
      "GLOBAL",
      "GOTO",
      "GRANT",
      "GRAPHIC",
      "GROUP",
      "GROUPING",
      "HANDLER",
      "HASH",
      "HASHED_VALUE",
      "HINT",
      "HOLD",
      "HOUR",
      "HOURS",
      "IDENTITY",
      "IF",
      "IMMEDIATE",
      "IN",
      "INCLUDING",
      "INCLUSIVE",
      "INCREMENT",
      "INDEX",
      "INDICATOR",
      "INDICATORS",
      "INF",
      "INFINITY",
      "INHERIT",
      "INNER",
      "INOUT",
      "INSENSITIVE",
      "INSERT",
      "INT",
      "INTEGER",
      "INTEGRITY",
      "INTERSECTION",
      "INTERVAL",
      "INTO",
      "IS",
      "ISOBID",
      "ISOLATION",
      "ITERATE",
      "JAR",
      "JAVA",
      "KEEP",
      "KEY",
      "LABEL",
      "LANGUAGE",
      "LARGE",
      "LATERAL",
      "LC_CTYPE",
      "LEADING",
      "LEAVE",
      "LEFT",
      "LIKE",
      "LINKTYPE",
      "LN",
      "LOCAL",
      "LOCALDATE",
      "LOCALE",
      "LOCALTIME",
      "LOCALTIMESTAMP",
      "LOCATOR",
      "LOCATORS",
      "LOCK",
      "LOCKMAX",
      "LOCKSIZE",
      "LONG",
      "LOOP",
      "LOWER",
      "MAINTAINED",
      "MATCH",
      "MATERIALIZED",
      "MAX",
      "MAXVALUE",
      "MEMBER",
      "MERGE",
      "METHOD",
      "MICROSECOND",
      "MICROSECONDS",
      "MIN",
      "MINUTE",
      "MINUTES",
      "MINVALUE",
      "MOD",
      "MODE",
      "MODIFIES",
      "MODULE",
      "MONTH",
      "MONTHS",
      "MULTISET",
      "NAN",
      "NATIONAL",
      "NATURAL",
      "NCHAR",
      "NCLOB",
      "NEW",
      "NEW_TABLE",
      "NEXTVAL",
      "NO",
      "NOCACHE",
      "NOCYCLE",
      "NODENAME",
      "NODENUMBER",
      "NOMAXVALUE",
      "NOMINVALUE",
      "NONE",
      "NOORDER",
      "NORMALIZE",
      "NORMALIZED",
      "NOT",
      "NULL",
      "NULLIF",
      "NULLS",
      "NUMERIC",
      "NUMPARTS",
      "OBID",
      "OCTET_LENGTH",
      "OF",
      "OFFSET",
      "OLD",
      "OLD_TABLE",
      "ON",
      "ONLY",
      "OPEN",
      "OPTIMIZATION",
      "OPTIMIZE",
      "OPTION",
      "ORDER",
      "OUT",
      "OUTER",
      "OVER",
      "OVERLAPS",
      "OVERLAY",
      "OVERRIDING",
      "PACKAGE",
      "PADDED",
      "PAGESIZE",
      "PARAMETER",
      "PART",
      "PARTITION",
      "PARTITIONED",
      "PARTITIONING",
      "PARTITIONS",
      "PASSWORD",
      "PATH",
      "PERCENTILE_CONT",
      "PERCENTILE_DISC",
      "PERCENT_RANK",
      "PIECESIZE",
      "PLAN",
      "POSITION",
      "POWER",
      "PRECISION",
      "PREPARE",
      "PREVVAL",
      "PRIMARY",
      "PRIQTY",
      "PRIVILEGES",
      "PROCEDURE",
      "PROGRAM",
      "PSID",
      "PUBLIC",
      "QUERY",
      "QUERYNO",
      "RANGE",
      "RANK",
      "READ",
      "READS",
      "REAL",
      "RECOVERY",
      "RECURSIVE",
      "REF",
      "REFERENCES",
      "REFERENCING",
      "REFRESH",
      "REGR_AVGX",
      "REGR_AVGY",
      "REGR_COUNT",
      "REGR_INTERCEPT",
      "REGR_R2",
      "REGR_SLOPE",
      "REGR_SXX",
      "REGR_SXY",
      "REGR_SYY",
      "RELEASE",
      "RENAME",
      "REPEAT",
      "RESET",
      "RESIGNAL",
      "RESTART",
      "RESTRICT",
      "RESULT",
      "RESULT_SET_LOCATOR",
      "RETURN",
      "RETURNS",
      "REVOKE",
      "RIGHT",
      "ROLE",
      "ROLLBACK",
      "ROLLUP",
      "ROUND_CEILING",
      "ROUND_DOWN",
      "ROUND_FLOOR",
      "ROUND_HALF_DOWN",
      "ROUND_HALF_EVEN",
      "ROUND_HALF_UP",
      "ROUND_UP",
      "ROUTINE",
      "ROW",
      "ROWNUMBER",
      "ROWS",
      "ROWSET",
      "ROW_NUMBER",
      "RRN",
      "RUN",
      "SAVEPOINT",
      "SCHEMA",
      "SCOPE",
      "SCRATCHPAD",
      "SCROLL",
      "SEARCH",
      "SECOND",
      "SECONDS",
      "SECQTY",
      "SECURITY",
      "SENSITIVE",
      "SEQUENCE",
      "SESSION",
      "SESSION_USER",
      "SIGNAL",
      "SIMILAR",
      "SIMPLE",
      "SMALLINT",
      "SNAN",
      "SOME",
      "SOURCE",
      "SPECIFIC",
      "SPECIFICTYPE",
      "SQL",
      "SQLEXCEPTION",
      "SQLID",
      "SQLSTATE",
      "SQLWARNING",
      "SQRT",
      "STACKED",
      "STANDARD",
      "START",
      "STARTING",
      "STATEMENT",
      "STATIC",
      "STATMENT",
      "STAY",
      "STDDEV_POP",
      "STDDEV_SAMP",
      "STOGROUP",
      "STORES",
      "STYLE",
      "SUBMULTISET",
      "SUBSTRING",
      "SUM",
      "SUMMARY",
      "SYMMETRIC",
      "SYNONYM",
      "SYSFUN",
      "SYSIBM",
      "SYSPROC",
      "SYSTEM",
      "SYSTEM_USER",
      "TABLE",
      "TABLESAMPLE",
      "TABLESPACE",
      "THEN",
      "TIME",
      "TIMESTAMP",
      "TIMEZONE_HOUR",
      "TIMEZONE_MINUTE",
      "TO",
      "TRAILING",
      "TRANSACTION",
      "TRANSLATE",
      "TRANSLATION",
      "TREAT",
      "TRIGGER",
      "TRIM",
      "TRUE",
      "TRUNCATE",
      "TYPE",
      "UESCAPE",
      "UNDO",
      "UNIQUE",
      "UNKNOWN",
      "UNNEST",
      "UNTIL",
      "UPPER",
      "USAGE",
      "USER",
      "USING",
      "VALIDPROC",
      "VALUE",
      "VARCHAR",
      "VARIABLE",
      "VARIANT",
      "VARYING",
      "VAR_POP",
      "VAR_SAMP",
      "VCAT",
      "VERSION",
      "VIEW",
      "VOLATILE",
      "VOLUMES",
      "WHEN",
      "WHENEVER",
      "WHILE",
      "WIDTH_BUCKET",
      "WINDOW",
      "WITH",
      "WITHIN",
      "WITHOUT",
      "WLM",
      "WRITE",
      "XMLELEMENT",
      "XMLEXISTS",
      "XMLNAMESPACES",
      "YEAR",
      "YEARS"
    ];
    var reservedTopLevelWords = [
      "ADD",
      "AFTER",
      "ALTER COLUMN",
      "ALTER TABLE",
      "DELETE FROM",
      "EXCEPT",
      "FETCH FIRST",
      "FROM",
      "GROUP BY",
      "GO",
      "HAVING",
      "INSERT INTO",
      "INTERSECT",
      "LIMIT",
      "ORDER BY",
      "SELECT",
      "SET CURRENT SCHEMA",
      "SET SCHEMA",
      "SET",
      "UPDATE",
      "VALUES",
      "WHERE"
    ];
    var reservedTopLevelWordsNoIndent = ["INTERSECT", "INTERSECT ALL", "MINUS", "UNION", "UNION ALL"];
    var reservedNewlineWords = [
      "AND",
      "CROSS JOIN",
      "INNER JOIN",
      "JOIN",
      "LEFT JOIN",
      "LEFT OUTER JOIN",
      "OR",
      "OUTER JOIN",
      "RIGHT JOIN",
      "RIGHT OUTER JOIN"
    ];
  }
});

// node_modules/@sqltools/formatter/lib/languages/N1qlFormatter.js
var require_N1qlFormatter = __commonJS({
  "node_modules/@sqltools/formatter/lib/languages/N1qlFormatter.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports2.__esModule = true;
    var abstract_1 = __importDefault2(require_abstract());
    var N1qlFormatter = (function(_super) {
      __extends2(N1qlFormatter2, _super);
      function N1qlFormatter2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      N1qlFormatter2.prototype.getTokenizerConfig = function() {
        return {
          reservedWords,
          reservedTopLevelWords,
          reservedNewlineWords,
          reservedTopLevelWordsNoIndent,
          stringTypes: ['""', "''", "``"],
          openParens: ["(", "[", "{"],
          closeParens: [")", "]", "}"],
          namedPlaceholderTypes: ["$"],
          lineCommentTypes: ["#", "--"],
          specialWordChars: []
        };
      };
      return N1qlFormatter2;
    })(abstract_1["default"]);
    exports2["default"] = N1qlFormatter;
    var reservedWords = [
      "ALL",
      "ALTER",
      "ANALYZE",
      "AND",
      "ANY",
      "ARRAY",
      "AS",
      "ASC",
      "BEGIN",
      "BETWEEN",
      "BINARY",
      "BOOLEAN",
      "BREAK",
      "BUCKET",
      "BUILD",
      "BY",
      "CALL",
      "CASE",
      "CAST",
      "CLUSTER",
      "COLLATE",
      "COLLECTION",
      "COMMIT",
      "CONNECT",
      "CONTINUE",
      "CORRELATE",
      "COVER",
      "CREATE",
      "DATABASE",
      "DATASET",
      "DATASTORE",
      "DECLARE",
      "DECREMENT",
      "DELETE",
      "DERIVED",
      "DESC",
      "DESCRIBE",
      "DISTINCT",
      "DO",
      "DROP",
      "EACH",
      "ELEMENT",
      "ELSE",
      "END",
      "EVERY",
      "EXCEPT",
      "EXCLUDE",
      "EXECUTE",
      "EXISTS",
      "EXPLAIN",
      "FALSE",
      "FETCH",
      "FIRST",
      "FLATTEN",
      "FOR",
      "FORCE",
      "FROM",
      "FUNCTION",
      "GRANT",
      "GROUP",
      "GSI",
      "HAVING",
      "IF",
      "IGNORE",
      "ILIKE",
      "IN",
      "INCLUDE",
      "INCREMENT",
      "INDEX",
      "INFER",
      "INLINE",
      "INNER",
      "INSERT",
      "INTERSECT",
      "INTO",
      "IS",
      "JOIN",
      "KEY",
      "KEYS",
      "KEYSPACE",
      "KNOWN",
      "LAST",
      "LEFT",
      "LET",
      "LETTING",
      "LIKE",
      "LIMIT",
      "LSM",
      "MAP",
      "MAPPING",
      "MATCHED",
      "MATERIALIZED",
      "MERGE",
      "MISSING",
      "NAMESPACE",
      "NEST",
      "NOT",
      "NULL",
      "NUMBER",
      "OBJECT",
      "OFFSET",
      "ON",
      "OPTION",
      "OR",
      "ORDER",
      "OUTER",
      "OVER",
      "PARSE",
      "PARTITION",
      "PASSWORD",
      "PATH",
      "POOL",
      "PREPARE",
      "PRIMARY",
      "PRIVATE",
      "PRIVILEGE",
      "PROCEDURE",
      "PUBLIC",
      "RAW",
      "REALM",
      "REDUCE",
      "RENAME",
      "RETURN",
      "RETURNING",
      "REVOKE",
      "RIGHT",
      "ROLE",
      "ROLLBACK",
      "SATISFIES",
      "SCHEMA",
      "SELECT",
      "SELF",
      "SEMI",
      "SET",
      "SHOW",
      "SOME",
      "START",
      "STATISTICS",
      "STRING",
      "SYSTEM",
      "THEN",
      "TO",
      "TRANSACTION",
      "TRIGGER",
      "TRUE",
      "TRUNCATE",
      "UNDER",
      "UNION",
      "UNIQUE",
      "UNKNOWN",
      "UNNEST",
      "UNSET",
      "UPDATE",
      "UPSERT",
      "USE",
      "USER",
      "USING",
      "VALIDATE",
      "VALUE",
      "VALUED",
      "VALUES",
      "VIA",
      "VIEW",
      "WHEN",
      "WHERE",
      "WHILE",
      "WITH",
      "WITHIN",
      "WORK",
      "XOR"
    ];
    var reservedTopLevelWords = [
      "DELETE FROM",
      "EXCEPT ALL",
      "EXCEPT",
      "EXPLAIN DELETE FROM",
      "EXPLAIN UPDATE",
      "EXPLAIN UPSERT",
      "FROM",
      "GROUP BY",
      "HAVING",
      "INFER",
      "INSERT INTO",
      "LET",
      "LIMIT",
      "MERGE",
      "NEST",
      "ORDER BY",
      "PREPARE",
      "SELECT",
      "SET CURRENT SCHEMA",
      "SET SCHEMA",
      "SET",
      "UNNEST",
      "UPDATE",
      "UPSERT",
      "USE KEYS",
      "VALUES",
      "WHERE"
    ];
    var reservedTopLevelWordsNoIndent = ["INTERSECT", "INTERSECT ALL", "MINUS", "UNION", "UNION ALL"];
    var reservedNewlineWords = [
      "AND",
      "INNER JOIN",
      "JOIN",
      "LEFT JOIN",
      "LEFT OUTER JOIN",
      "OR",
      "OUTER JOIN",
      "RIGHT JOIN",
      "RIGHT OUTER JOIN",
      "XOR"
    ];
  }
});

// node_modules/@sqltools/formatter/lib/languages/PlSqlFormatter.js
var require_PlSqlFormatter = __commonJS({
  "node_modules/@sqltools/formatter/lib/languages/PlSqlFormatter.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports2.__esModule = true;
    var abstract_1 = __importDefault2(require_abstract());
    var types_1 = require_types();
    var PlSqlFormatter = (function(_super) {
      __extends2(PlSqlFormatter2, _super);
      function PlSqlFormatter2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.tokenOverride = function(token, previousReservedToken) {
          if (token.type === types_1.TokenTypes.RESERVED_TOP_LEVEL && previousReservedToken.value && token.value.toUpperCase() === "SET" && previousReservedToken.value.toUpperCase() === "BY") {
            token.type = types_1.TokenTypes.RESERVED;
            return token;
          }
        };
        return _this;
      }
      PlSqlFormatter2.prototype.getTokenizerConfig = function() {
        return {
          reservedWords,
          reservedTopLevelWords,
          reservedNewlineWords,
          reservedTopLevelWordsNoIndent,
          stringTypes: ['""', "N''", "''", "``"],
          openParens: ["(", "CASE"],
          closeParens: [")", "END"],
          indexedPlaceholderTypes: ["?"],
          namedPlaceholderTypes: [":"],
          lineCommentTypes: ["--"],
          specialWordChars: ["_", "$", "#", ".", "@"]
        };
      };
      return PlSqlFormatter2;
    })(abstract_1["default"]);
    exports2["default"] = PlSqlFormatter;
    var reservedWords = [
      "A",
      "ACCESSIBLE",
      "AGENT",
      "AGGREGATE",
      "ALL",
      "ALTER",
      "ANY",
      "ARRAY",
      "AS",
      "ASC",
      "AT",
      "ATTRIBUTE",
      "AUTHID",
      "AVG",
      "BETWEEN",
      "BFILE_BASE",
      "BINARY_INTEGER",
      "BINARY",
      "BLOB_BASE",
      "BLOCK",
      "BODY",
      "BOOLEAN",
      "BOTH",
      "BOUND",
      "BREADTH",
      "BULK",
      "BY",
      "BYTE",
      "C",
      "CALL",
      "CALLING",
      "CASCADE",
      "CASE",
      "CHAR_BASE",
      "CHAR",
      "CHARACTER",
      "CHARSET",
      "CHARSETFORM",
      "CHARSETID",
      "CHECK",
      "CLOB_BASE",
      "CLONE",
      "CLOSE",
      "CLUSTER",
      "CLUSTERS",
      "COALESCE",
      "COLAUTH",
      "COLLECT",
      "COLUMNS",
      "COMMENT",
      "COMMIT",
      "COMMITTED",
      "COMPILED",
      "COMPRESS",
      "CONNECT",
      "CONSTANT",
      "CONSTRUCTOR",
      "CONTEXT",
      "CONTINUE",
      "CONVERT",
      "COUNT",
      "CRASH",
      "CREATE",
      "CREDENTIAL",
      "CURRENT",
      "CURRVAL",
      "CURSOR",
      "CUSTOMDATUM",
      "DANGLING",
      "DATA",
      "DATE_BASE",
      "DATE",
      "DAY",
      "DECIMAL",
      "DEFAULT",
      "DEFINE",
      "DELETE",
      "DEPTH",
      "DESC",
      "DETERMINISTIC",
      "DIRECTORY",
      "DISTINCT",
      "DO",
      "DOUBLE",
      "DROP",
      "DURATION",
      "ELEMENT",
      "ELSIF",
      "EMPTY",
      "END",
      "ESCAPE",
      "EXCEPTIONS",
      "EXCLUSIVE",
      "EXECUTE",
      "EXISTS",
      "EXIT",
      "EXTENDS",
      "EXTERNAL",
      "EXTRACT",
      "FALSE",
      "FETCH",
      "FINAL",
      "FIRST",
      "FIXED",
      "FLOAT",
      "FOR",
      "FORALL",
      "FORCE",
      "FROM",
      "FUNCTION",
      "GENERAL",
      "GOTO",
      "GRANT",
      "GROUP",
      "HASH",
      "HEAP",
      "HIDDEN",
      "HOUR",
      "IDENTIFIED",
      "IF",
      "IMMEDIATE",
      "IN",
      "INCLUDING",
      "INDEX",
      "INDEXES",
      "INDICATOR",
      "INDICES",
      "INFINITE",
      "INSTANTIABLE",
      "INT",
      "INTEGER",
      "INTERFACE",
      "INTERVAL",
      "INTO",
      "INVALIDATE",
      "IS",
      "ISOLATION",
      "JAVA",
      "LANGUAGE",
      "LARGE",
      "LEADING",
      "LENGTH",
      "LEVEL",
      "LIBRARY",
      "LIKE",
      "LIKE2",
      "LIKE4",
      "LIKEC",
      "LIMITED",
      "LOCAL",
      "LOCK",
      "LONG",
      "MAP",
      "MAX",
      "MAXLEN",
      "MEMBER",
      "MERGE",
      "MIN",
      "MINUTE",
      "MLSLABEL",
      "MOD",
      "MODE",
      "MONTH",
      "MULTISET",
      "NAME",
      "NAN",
      "NATIONAL",
      "NATIVE",
      "NATURAL",
      "NATURALN",
      "NCHAR",
      "NEW",
      "NEXTVAL",
      "NOCOMPRESS",
      "NOCOPY",
      "NOT",
      "NOWAIT",
      "NULL",
      "NULLIF",
      "NUMBER_BASE",
      "NUMBER",
      "OBJECT",
      "OCICOLL",
      "OCIDATE",
      "OCIDATETIME",
      "OCIDURATION",
      "OCIINTERVAL",
      "OCILOBLOCATOR",
      "OCINUMBER",
      "OCIRAW",
      "OCIREF",
      "OCIREFCURSOR",
      "OCIROWID",
      "OCISTRING",
      "OCITYPE",
      "OF",
      "OLD",
      "ON",
      "ONLY",
      "OPAQUE",
      "OPEN",
      "OPERATOR",
      "OPTION",
      "ORACLE",
      "ORADATA",
      "ORDER",
      "ORGANIZATION",
      "ORLANY",
      "ORLVARY",
      "OTHERS",
      "OUT",
      "OVERLAPS",
      "OVERRIDING",
      "PACKAGE",
      "PARALLEL_ENABLE",
      "PARAMETER",
      "PARAMETERS",
      "PARENT",
      "PARTITION",
      "PASCAL",
      "PCTFREE",
      "PIPE",
      "PIPELINED",
      "PLS_INTEGER",
      "PLUGGABLE",
      "POSITIVE",
      "POSITIVEN",
      "PRAGMA",
      "PRECISION",
      "PRIOR",
      "PRIVATE",
      "PROCEDURE",
      "PUBLIC",
      "RAISE",
      "RANGE",
      "RAW",
      "READ",
      "REAL",
      "RECORD",
      "REF",
      "REFERENCE",
      "RELEASE",
      "RELIES_ON",
      "REM",
      "REMAINDER",
      "RENAME",
      "RESOURCE",
      "RESULT_CACHE",
      "RESULT",
      "RETURN",
      "RETURNING",
      "REVERSE",
      "REVOKE",
      "ROLLBACK",
      "ROW",
      "ROWID",
      "ROWNUM",
      "ROWTYPE",
      "SAMPLE",
      "SAVE",
      "SAVEPOINT",
      "SB1",
      "SB2",
      "SB4",
      "SEARCH",
      "SECOND",
      "SEGMENT",
      "SELF",
      "SEPARATE",
      "SEQUENCE",
      "SERIALIZABLE",
      "SHARE",
      "SHORT",
      "SIZE_T",
      "SIZE",
      "SMALLINT",
      "SOME",
      "SPACE",
      "SPARSE",
      "SQL",
      "SQLCODE",
      "SQLDATA",
      "SQLERRM",
      "SQLNAME",
      "SQLSTATE",
      "STANDARD",
      "START",
      "STATIC",
      "STDDEV",
      "STORED",
      "STRING",
      "STRUCT",
      "STYLE",
      "SUBMULTISET",
      "SUBPARTITION",
      "SUBSTITUTABLE",
      "SUBTYPE",
      "SUCCESSFUL",
      "SUM",
      "SYNONYM",
      "SYSDATE",
      "TABAUTH",
      "TABLE",
      "TDO",
      "THE",
      "THEN",
      "TIME",
      "TIMESTAMP",
      "TIMEZONE_ABBR",
      "TIMEZONE_HOUR",
      "TIMEZONE_MINUTE",
      "TIMEZONE_REGION",
      "TO",
      "TRAILING",
      "TRANSACTION",
      "TRANSACTIONAL",
      "TRIGGER",
      "TRUE",
      "TRUSTED",
      "TYPE",
      "UB1",
      "UB2",
      "UB4",
      "UID",
      "UNDER",
      "UNIQUE",
      "UNPLUG",
      "UNSIGNED",
      "UNTRUSTED",
      "USE",
      "USER",
      "USING",
      "VALIDATE",
      "VALIST",
      "VALUE",
      "VARCHAR",
      "VARCHAR2",
      "VARIABLE",
      "VARIANCE",
      "VARRAY",
      "VARYING",
      "VIEW",
      "VIEWS",
      "VOID",
      "WHENEVER",
      "WHILE",
      "WITH",
      "WORK",
      "WRAPPED",
      "WRITE",
      "YEAR",
      "ZONE"
    ];
    var reservedTopLevelWords = [
      "ADD",
      "ALTER COLUMN",
      "ALTER TABLE",
      "BEGIN",
      "CONNECT BY",
      "DECLARE",
      "DELETE FROM",
      "DELETE",
      "END",
      "EXCEPT",
      "EXCEPTION",
      "FETCH FIRST",
      "FROM",
      "GROUP BY",
      "HAVING",
      "INSERT INTO",
      "INSERT",
      "LIMIT",
      "LOOP",
      "MODIFY",
      "ORDER BY",
      "SELECT",
      "SET CURRENT SCHEMA",
      "SET SCHEMA",
      "SET",
      "START WITH",
      "UPDATE",
      "VALUES",
      "WHERE"
    ];
    var reservedTopLevelWordsNoIndent = ["INTERSECT", "INTERSECT ALL", "MINUS", "UNION", "UNION ALL"];
    var reservedNewlineWords = [
      "AND",
      "CROSS APPLY",
      "CROSS JOIN",
      "ELSE",
      "END",
      "INNER JOIN",
      "JOIN",
      "LEFT JOIN",
      "LEFT OUTER JOIN",
      "OR",
      "OUTER APPLY",
      "OUTER JOIN",
      "RIGHT JOIN",
      "RIGHT OUTER JOIN",
      "WHEN",
      "XOR"
    ];
  }
});

// node_modules/@sqltools/formatter/lib/languages/StandardSqlFormatter.js
var require_StandardSqlFormatter = __commonJS({
  "node_modules/@sqltools/formatter/lib/languages/StandardSqlFormatter.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports2.__esModule = true;
    var abstract_1 = __importDefault2(require_abstract());
    var StandardSqlFormatter = (function(_super) {
      __extends2(StandardSqlFormatter2, _super);
      function StandardSqlFormatter2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      StandardSqlFormatter2.prototype.getTokenizerConfig = function() {
        return {
          reservedWords,
          reservedTopLevelWords,
          reservedNewlineWords,
          reservedTopLevelWordsNoIndent,
          stringTypes: ['""', "N''", "''", "``", "[]", "E''"],
          openParens: ["(", "CASE"],
          closeParens: [")", "END"],
          indexedPlaceholderTypes: ["?"],
          namedPlaceholderTypes: ["@", ":", "%", "$"],
          lineCommentTypes: ["#", "--"],
          specialWordChars: []
        };
      };
      return StandardSqlFormatter2;
    })(abstract_1["default"]);
    exports2["default"] = StandardSqlFormatter;
    var reservedWords = [
      "ACCESSIBLE",
      "ACTION",
      "AGAINST",
      "AGGREGATE",
      "ALGORITHM",
      "ALL",
      "ALTER",
      "ANALYSE",
      "ANALYZE",
      "AS",
      "ASC",
      "AUTOCOMMIT",
      "AUTO_INCREMENT",
      "BACKUP",
      "BEGIN",
      "BETWEEN",
      "BINLOG",
      "BOTH",
      "CASCADE",
      "CASE",
      "CHANGE",
      "CHANGED",
      "CHARACTER SET",
      "CHARSET",
      "CHECK",
      "CHECKSUM",
      "COLLATE",
      "COLLATION",
      "COLUMN",
      "COLUMNS",
      "COMMENT",
      "COMMIT",
      "COMMITTED",
      "COMPRESSED",
      "CONCURRENT",
      "CONSTRAINT",
      "CONTAINS",
      "CONVERT",
      "COUNT",
      "CREATE",
      "CROSS",
      "CURRENT_TIMESTAMP",
      "DATABASE",
      "DATABASES",
      "DAY_HOUR",
      "DAY_MINUTE",
      "DAY_SECOND",
      "DAY",
      "DEFAULT",
      "DEFINER",
      "DELAYED",
      "DELETE",
      "DESC",
      "DESCRIBE",
      "DETERMINISTIC",
      "DISTINCT",
      "DISTINCTROW",
      "DIV",
      "DO",
      "DROP",
      "DUMPFILE",
      "DUPLICATE",
      "DYNAMIC",
      "ELSE",
      "ENCLOSED",
      "END",
      "ENGINE",
      "ENGINES",
      "ENGINE_TYPE",
      "ESCAPE",
      "ESCAPED",
      "EVENTS",
      "EXEC",
      "EXECUTE",
      "EXISTS",
      "EXPLAIN",
      "EXTENDED",
      "FAST",
      "FETCH",
      "FIELDS",
      "FILE",
      "FIRST",
      "FIXED",
      "FLUSH",
      "FOR",
      "FORCE",
      "FOREIGN",
      "FULL",
      "FULLTEXT",
      "FUNCTION",
      "GLOBAL",
      "GRANTS",
      "GROUP_CONCAT",
      "HEAP",
      "HIGH_PRIORITY",
      "HOSTS",
      "HOUR",
      "HOUR_MINUTE",
      "HOUR_SECOND",
      "IDENTIFIED",
      "IF",
      "IFNULL",
      "IGNORE",
      "IN",
      "INDEX",
      "INDEXES",
      "INFILE",
      "INSERT",
      "INSERT_ID",
      "INSERT_METHOD",
      "INTERVAL",
      "INTO",
      "INVOKER",
      "IS",
      "ISOLATION",
      "KEY",
      "KEYS",
      "KILL",
      "LAST_INSERT_ID",
      "LEADING",
      "LEVEL",
      "LIKE",
      "LINEAR",
      "LINES",
      "LOAD",
      "LOCAL",
      "LOCK",
      "LOCKS",
      "LOGS",
      "LOW_PRIORITY",
      "MARIA",
      "MASTER",
      "MASTER_CONNECT_RETRY",
      "MASTER_HOST",
      "MASTER_LOG_FILE",
      "MATCH",
      "MAX_CONNECTIONS_PER_HOUR",
      "MAX_QUERIES_PER_HOUR",
      "MAX_ROWS",
      "MAX_UPDATES_PER_HOUR",
      "MAX_USER_CONNECTIONS",
      "MEDIUM",
      "MERGE",
      "MINUTE",
      "MINUTE_SECOND",
      "MIN_ROWS",
      "MODE",
      "MONTH",
      "MRG_MYISAM",
      "MYISAM",
      "NAMES",
      "NATURAL",
      "NOT",
      "NOW()",
      "NULL",
      "OFFSET",
      "ON DELETE",
      "ON UPDATE",
      "ON",
      "ONLY",
      "OPEN",
      "OPTIMIZE",
      "OPTION",
      "OPTIONALLY",
      "OUTFILE",
      "PACK_KEYS",
      "PAGE",
      "PARTIAL",
      "PARTITION",
      "PARTITIONS",
      "PASSWORD",
      "PRIMARY",
      "PRIVILEGES",
      "PROCEDURE",
      "PROCESS",
      "PROCESSLIST",
      "PURGE",
      "QUICK",
      "RAID0",
      "RAID_CHUNKS",
      "RAID_CHUNKSIZE",
      "RAID_TYPE",
      "RANGE",
      "READ",
      "READ_ONLY",
      "READ_WRITE",
      "REFERENCES",
      "REGEXP",
      "RELOAD",
      "RENAME",
      "REPAIR",
      "REPEATABLE",
      "REPLACE",
      "REPLICATION",
      "RESET",
      "RESTORE",
      "RESTRICT",
      "RETURN",
      "RETURNS",
      "REVOKE",
      "RLIKE",
      "ROLLBACK",
      "ROW",
      "ROWS",
      "ROW_FORMAT",
      "SECOND",
      "SECURITY",
      "SEPARATOR",
      "SERIALIZABLE",
      "SESSION",
      "SHARE",
      "SHOW",
      "SHUTDOWN",
      "SLAVE",
      "SONAME",
      "SOUNDS",
      "SQL",
      "SQL_AUTO_IS_NULL",
      "SQL_BIG_RESULT",
      "SQL_BIG_SELECTS",
      "SQL_BIG_TABLES",
      "SQL_BUFFER_RESULT",
      "SQL_CACHE",
      "SQL_CALC_FOUND_ROWS",
      "SQL_LOG_BIN",
      "SQL_LOG_OFF",
      "SQL_LOG_UPDATE",
      "SQL_LOW_PRIORITY_UPDATES",
      "SQL_MAX_JOIN_SIZE",
      "SQL_NO_CACHE",
      "SQL_QUOTE_SHOW_CREATE",
      "SQL_SAFE_UPDATES",
      "SQL_SELECT_LIMIT",
      "SQL_SLAVE_SKIP_COUNTER",
      "SQL_SMALL_RESULT",
      "SQL_WARNINGS",
      "START",
      "STARTING",
      "STATUS",
      "STOP",
      "STORAGE",
      "STRAIGHT_JOIN",
      "STRING",
      "STRIPED",
      "SUPER",
      "TABLE",
      "TABLES",
      "TEMPORARY",
      "TERMINATED",
      "THEN",
      "TO",
      "TRAILING",
      "TRANSACTIONAL",
      "TRIGGER",
      "TRUE",
      "TRUNCATE",
      "TYPE",
      "TYPES",
      "UNCOMMITTED",
      "UNIQUE",
      "UNLOCK",
      "UNSIGNED",
      "USAGE",
      "USE",
      "USING",
      "VARIABLES",
      "VIEW",
      "WHEN",
      "WITH",
      "WORK",
      "WRITE",
      "YEAR_MONTH"
    ];
    var reservedTopLevelWords = [
      "ADD",
      "AFTER",
      "ALTER COLUMN",
      "ALTER TABLE",
      "CREATE OR REPLACE",
      "DECLARE",
      "DELETE FROM",
      "EXCEPT",
      "FETCH FIRST",
      "FROM",
      "GO",
      "GRANT",
      "GROUP BY",
      "HAVING",
      "INSERT INTO",
      "INSERT",
      "LIMIT",
      "MODIFY",
      "ORDER BY",
      "RETURNING",
      "SELECT",
      "SET CURRENT SCHEMA",
      "SET SCHEMA",
      "SET",
      "UPDATE",
      "VALUES",
      "WHERE"
    ];
    var reservedTopLevelWordsNoIndent = ["INTERSECT ALL", "INTERSECT", "MINUS", "UNION ALL", "UNION"];
    var reservedNewlineWords = [
      "AND",
      "CROSS APPLY",
      "CROSS JOIN",
      "ELSE",
      "INNER JOIN",
      "FULL JOIN",
      "FULL OUTER JOIN",
      "LEFT JOIN",
      "LEFT OUTER JOIN",
      "NATURAL JOIN",
      "OR",
      "OUTER APPLY",
      "OUTER JOIN",
      "RENAME",
      "RIGHT JOIN",
      "RIGHT OUTER JOIN",
      "JOIN",
      "WHEN",
      "XOR"
    ];
  }
});

// node_modules/@sqltools/formatter/lib/sqlFormatter.js
var require_sqlFormatter = __commonJS({
  "node_modules/@sqltools/formatter/lib/sqlFormatter.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports2.__esModule = true;
    exports2.tokenize = exports2.format = void 0;
    var Db2Formatter_1 = __importDefault2(require_Db2Formatter());
    var N1qlFormatter_1 = __importDefault2(require_N1qlFormatter());
    var PlSqlFormatter_1 = __importDefault2(require_PlSqlFormatter());
    var StandardSqlFormatter_1 = __importDefault2(require_StandardSqlFormatter());
    var format = function(query, cfg) {
      if (cfg === void 0) {
        cfg = {};
      }
      switch (cfg.language) {
        case "db2":
          return new Db2Formatter_1["default"](cfg).format(query);
        case "n1ql":
          return new N1qlFormatter_1["default"](cfg).format(query);
        case "pl/sql":
          return new PlSqlFormatter_1["default"](cfg).format(query);
        case "sql":
        default:
          return new StandardSqlFormatter_1["default"](cfg).format(query);
      }
    };
    exports2.format = format;
    var tokenize = function(query, cfg) {
      if (cfg === void 0) {
        cfg = {};
      }
      return new StandardSqlFormatter_1["default"](cfg).tokenize(query);
    };
    exports2.tokenize = tokenize;
    exports2["default"] = {
      format: exports2.format,
      tokenize: exports2.tokenize
    };
  }
});

// node_modules/postgres-array/index.js
var require_postgres_array = __commonJS({
  "node_modules/postgres-array/index.js"(exports2) {
    "use strict";
    exports2.parse = function(source, transform) {
      return new ArrayParser(source, transform).parse();
    };
    var ArrayParser = class _ArrayParser {
      constructor(source, transform) {
        this.source = source;
        this.transform = transform || identity;
        this.position = 0;
        this.entries = [];
        this.recorded = [];
        this.dimension = 0;
      }
      isEof() {
        return this.position >= this.source.length;
      }
      nextCharacter() {
        var character = this.source[this.position++];
        if (character === "\\") {
          return {
            value: this.source[this.position++],
            escaped: true
          };
        }
        return {
          value: character,
          escaped: false
        };
      }
      record(character) {
        this.recorded.push(character);
      }
      newEntry(includeEmpty) {
        var entry;
        if (this.recorded.length > 0 || includeEmpty) {
          entry = this.recorded.join("");
          if (entry === "NULL" && !includeEmpty) {
            entry = null;
          }
          if (entry !== null) entry = this.transform(entry);
          this.entries.push(entry);
          this.recorded = [];
        }
      }
      consumeDimensions() {
        if (this.source[0] === "[") {
          while (!this.isEof()) {
            var char = this.nextCharacter();
            if (char.value === "=") break;
          }
        }
      }
      parse(nested) {
        var character, parser, quote;
        this.consumeDimensions();
        while (!this.isEof()) {
          character = this.nextCharacter();
          if (character.value === "{" && !quote) {
            this.dimension++;
            if (this.dimension > 1) {
              parser = new _ArrayParser(this.source.substr(this.position - 1), this.transform);
              this.entries.push(parser.parse(true));
              this.position += parser.position - 2;
            }
          } else if (character.value === "}" && !quote) {
            this.dimension--;
            if (!this.dimension) {
              this.newEntry();
              if (nested) return this.entries;
            }
          } else if (character.value === '"' && !character.escaped) {
            if (quote) this.newEntry(true);
            quote = !quote;
          } else if (character.value === "," && !quote) {
            this.newEntry();
          } else {
            this.record(character.value);
          }
        }
        if (this.dimension !== 0) {
          throw new Error("array dimension not balanced");
        }
        return this.entries;
      }
    };
    function identity(value) {
      return value;
    }
  }
});

// node_modules/pg-types/lib/arrayParser.js
var require_arrayParser = __commonJS({
  "node_modules/pg-types/lib/arrayParser.js"(exports2, module2) {
    var array = require_postgres_array();
    module2.exports = {
      create: function(source, transform) {
        return {
          parse: function() {
            return array.parse(source, transform);
          }
        };
      }
    };
  }
});

// node_modules/postgres-date/index.js
var require_postgres_date = __commonJS({
  "node_modules/postgres-date/index.js"(exports2, module2) {
    "use strict";
    var DATE_TIME = /(\d{1,})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})(\.\d{1,})?.*?( BC)?$/;
    var DATE = /^(\d{1,})-(\d{2})-(\d{2})( BC)?$/;
    var TIME_ZONE = /([Z+-])(\d{2})?:?(\d{2})?:?(\d{2})?/;
    var INFINITY = /^-?infinity$/;
    module2.exports = function parseDate(isoDate) {
      if (INFINITY.test(isoDate)) {
        return Number(isoDate.replace("i", "I"));
      }
      var matches = DATE_TIME.exec(isoDate);
      if (!matches) {
        return getDate(isoDate) || null;
      }
      var isBC = !!matches[8];
      var year = parseInt(matches[1], 10);
      if (isBC) {
        year = bcYearToNegativeYear(year);
      }
      var month = parseInt(matches[2], 10) - 1;
      var day = matches[3];
      var hour = parseInt(matches[4], 10);
      var minute = parseInt(matches[5], 10);
      var second = parseInt(matches[6], 10);
      var ms = matches[7];
      ms = ms ? 1e3 * parseFloat(ms) : 0;
      var date;
      var offset = timeZoneOffset(isoDate);
      if (offset != null) {
        date = new Date(Date.UTC(year, month, day, hour, minute, second, ms));
        if (is0To99(year)) {
          date.setUTCFullYear(year);
        }
        if (offset !== 0) {
          date.setTime(date.getTime() - offset);
        }
      } else {
        date = new Date(year, month, day, hour, minute, second, ms);
        if (is0To99(year)) {
          date.setFullYear(year);
        }
      }
      return date;
    };
    function getDate(isoDate) {
      var matches = DATE.exec(isoDate);
      if (!matches) {
        return;
      }
      var year = parseInt(matches[1], 10);
      var isBC = !!matches[4];
      if (isBC) {
        year = bcYearToNegativeYear(year);
      }
      var month = parseInt(matches[2], 10) - 1;
      var day = matches[3];
      var date = new Date(year, month, day);
      if (is0To99(year)) {
        date.setFullYear(year);
      }
      return date;
    }
    function timeZoneOffset(isoDate) {
      if (isoDate.endsWith("+00")) {
        return 0;
      }
      var zone = TIME_ZONE.exec(isoDate.split(" ")[1]);
      if (!zone) return;
      var type = zone[1];
      if (type === "Z") {
        return 0;
      }
      var sign = type === "-" ? -1 : 1;
      var offset = parseInt(zone[2], 10) * 3600 + parseInt(zone[3] || 0, 10) * 60 + parseInt(zone[4] || 0, 10);
      return offset * sign * 1e3;
    }
    function bcYearToNegativeYear(year) {
      return -(year - 1);
    }
    function is0To99(num) {
      return num >= 0 && num < 100;
    }
  }
});

// node_modules/xtend/mutable.js
var require_mutable = __commonJS({
  "node_modules/xtend/mutable.js"(exports2, module2) {
    module2.exports = extend;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function extend(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }
  }
});

// node_modules/postgres-interval/index.js
var require_postgres_interval = __commonJS({
  "node_modules/postgres-interval/index.js"(exports2, module2) {
    "use strict";
    var extend = require_mutable();
    module2.exports = PostgresInterval;
    function PostgresInterval(raw) {
      if (!(this instanceof PostgresInterval)) {
        return new PostgresInterval(raw);
      }
      extend(this, parse(raw));
    }
    var properties = ["seconds", "minutes", "hours", "days", "months", "years"];
    PostgresInterval.prototype.toPostgres = function() {
      var filtered = properties.filter(this.hasOwnProperty, this);
      if (this.milliseconds && filtered.indexOf("seconds") < 0) {
        filtered.push("seconds");
      }
      if (filtered.length === 0) return "0";
      return filtered.map(function(property) {
        var value = this[property] || 0;
        if (property === "seconds" && this.milliseconds) {
          value = (value + this.milliseconds / 1e3).toFixed(6).replace(/\.?0+$/, "");
        }
        return value + " " + property;
      }, this).join(" ");
    };
    var propertiesISOEquivalent = {
      years: "Y",
      months: "M",
      days: "D",
      hours: "H",
      minutes: "M",
      seconds: "S"
    };
    var dateProperties = ["years", "months", "days"];
    var timeProperties = ["hours", "minutes", "seconds"];
    PostgresInterval.prototype.toISOString = PostgresInterval.prototype.toISO = function() {
      var datePart = dateProperties.map(buildProperty, this).join("");
      var timePart = timeProperties.map(buildProperty, this).join("");
      return "P" + datePart + "T" + timePart;
      function buildProperty(property) {
        var value = this[property] || 0;
        if (property === "seconds" && this.milliseconds) {
          value = (value + this.milliseconds / 1e3).toFixed(6).replace(/0+$/, "");
        }
        return value + propertiesISOEquivalent[property];
      }
    };
    var NUMBER = "([+-]?\\d+)";
    var YEAR = NUMBER + "\\s+years?";
    var MONTH = NUMBER + "\\s+mons?";
    var DAY = NUMBER + "\\s+days?";
    var TIME = "([+-])?([\\d]*):(\\d\\d):(\\d\\d)\\.?(\\d{1,6})?";
    var INTERVAL = new RegExp([YEAR, MONTH, DAY, TIME].map(function(regexString) {
      return "(" + regexString + ")?";
    }).join("\\s*"));
    var positions = {
      years: 2,
      months: 4,
      days: 6,
      hours: 9,
      minutes: 10,
      seconds: 11,
      milliseconds: 12
    };
    var negatives = ["hours", "minutes", "seconds", "milliseconds"];
    function parseMilliseconds(fraction) {
      var microseconds = fraction + "000000".slice(fraction.length);
      return parseInt(microseconds, 10) / 1e3;
    }
    function parse(interval) {
      if (!interval) return {};
      var matches = INTERVAL.exec(interval);
      var isNegative = matches[8] === "-";
      return Object.keys(positions).reduce(function(parsed, property) {
        var position = positions[property];
        var value = matches[position];
        if (!value) return parsed;
        value = property === "milliseconds" ? parseMilliseconds(value) : parseInt(value, 10);
        if (!value) return parsed;
        if (isNegative && ~negatives.indexOf(property)) {
          value *= -1;
        }
        parsed[property] = value;
        return parsed;
      }, {});
    }
  }
});

// node_modules/postgres-bytea/index.js
var require_postgres_bytea = __commonJS({
  "node_modules/postgres-bytea/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function parseBytea(input) {
      if (/^\\x/.test(input)) {
        return new Buffer(input.substr(2), "hex");
      }
      var output = "";
      var i = 0;
      while (i < input.length) {
        if (input[i] !== "\\") {
          output += input[i];
          ++i;
        } else {
          if (/[0-7]{3}/.test(input.substr(i + 1, 3))) {
            output += String.fromCharCode(parseInt(input.substr(i + 1, 3), 8));
            i += 4;
          } else {
            var backslashes = 1;
            while (i + backslashes < input.length && input[i + backslashes] === "\\") {
              backslashes++;
            }
            for (var k = 0; k < Math.floor(backslashes / 2); ++k) {
              output += "\\";
            }
            i += Math.floor(backslashes / 2) * 2;
          }
        }
      }
      return new Buffer(output, "binary");
    };
  }
});

// node_modules/pg-types/lib/textParsers.js
var require_textParsers = __commonJS({
  "node_modules/pg-types/lib/textParsers.js"(exports2, module2) {
    var array = require_postgres_array();
    var arrayParser = require_arrayParser();
    var parseDate = require_postgres_date();
    var parseInterval = require_postgres_interval();
    var parseByteA = require_postgres_bytea();
    function allowNull(fn) {
      return function nullAllowed(value) {
        if (value === null) return value;
        return fn(value);
      };
    }
    function parseBool(value) {
      if (value === null) return value;
      return value === "TRUE" || value === "t" || value === "true" || value === "y" || value === "yes" || value === "on" || value === "1";
    }
    function parseBoolArray(value) {
      if (!value) return null;
      return array.parse(value, parseBool);
    }
    function parseBaseTenInt(string) {
      return parseInt(string, 10);
    }
    function parseIntegerArray(value) {
      if (!value) return null;
      return array.parse(value, allowNull(parseBaseTenInt));
    }
    function parseBigIntegerArray(value) {
      if (!value) return null;
      return array.parse(value, allowNull(function(entry) {
        return parseBigInteger(entry).trim();
      }));
    }
    var parsePointArray = function(value) {
      if (!value) {
        return null;
      }
      var p = arrayParser.create(value, function(entry) {
        if (entry !== null) {
          entry = parsePoint(entry);
        }
        return entry;
      });
      return p.parse();
    };
    var parseFloatArray = function(value) {
      if (!value) {
        return null;
      }
      var p = arrayParser.create(value, function(entry) {
        if (entry !== null) {
          entry = parseFloat(entry);
        }
        return entry;
      });
      return p.parse();
    };
    var parseStringArray = function(value) {
      if (!value) {
        return null;
      }
      var p = arrayParser.create(value);
      return p.parse();
    };
    var parseDateArray = function(value) {
      if (!value) {
        return null;
      }
      var p = arrayParser.create(value, function(entry) {
        if (entry !== null) {
          entry = parseDate(entry);
        }
        return entry;
      });
      return p.parse();
    };
    var parseIntervalArray = function(value) {
      if (!value) {
        return null;
      }
      var p = arrayParser.create(value, function(entry) {
        if (entry !== null) {
          entry = parseInterval(entry);
        }
        return entry;
      });
      return p.parse();
    };
    var parseByteAArray = function(value) {
      if (!value) {
        return null;
      }
      return array.parse(value, allowNull(parseByteA));
    };
    var parseInteger = function(value) {
      return parseInt(value, 10);
    };
    var parseBigInteger = function(value) {
      var valStr = String(value);
      if (/^\d+$/.test(valStr)) {
        return valStr;
      }
      return value;
    };
    var parseJsonArray = function(value) {
      if (!value) {
        return null;
      }
      return array.parse(value, allowNull(JSON.parse));
    };
    var parsePoint = function(value) {
      if (value[0] !== "(") {
        return null;
      }
      value = value.substring(1, value.length - 1).split(",");
      return {
        x: parseFloat(value[0]),
        y: parseFloat(value[1])
      };
    };
    var parseCircle = function(value) {
      if (value[0] !== "<" && value[1] !== "(") {
        return null;
      }
      var point = "(";
      var radius = "";
      var pointParsed = false;
      for (var i = 2; i < value.length - 1; i++) {
        if (!pointParsed) {
          point += value[i];
        }
        if (value[i] === ")") {
          pointParsed = true;
          continue;
        } else if (!pointParsed) {
          continue;
        }
        if (value[i] === ",") {
          continue;
        }
        radius += value[i];
      }
      var result = parsePoint(point);
      result.radius = parseFloat(radius);
      return result;
    };
    var init = function(register) {
      register(20, parseBigInteger);
      register(21, parseInteger);
      register(23, parseInteger);
      register(26, parseInteger);
      register(700, parseFloat);
      register(701, parseFloat);
      register(16, parseBool);
      register(1082, parseDate);
      register(1114, parseDate);
      register(1184, parseDate);
      register(600, parsePoint);
      register(651, parseStringArray);
      register(718, parseCircle);
      register(1e3, parseBoolArray);
      register(1001, parseByteAArray);
      register(1005, parseIntegerArray);
      register(1007, parseIntegerArray);
      register(1028, parseIntegerArray);
      register(1016, parseBigIntegerArray);
      register(1017, parsePointArray);
      register(1021, parseFloatArray);
      register(1022, parseFloatArray);
      register(1231, parseFloatArray);
      register(1014, parseStringArray);
      register(1015, parseStringArray);
      register(1008, parseStringArray);
      register(1009, parseStringArray);
      register(1040, parseStringArray);
      register(1041, parseStringArray);
      register(1115, parseDateArray);
      register(1182, parseDateArray);
      register(1185, parseDateArray);
      register(1186, parseInterval);
      register(1187, parseIntervalArray);
      register(17, parseByteA);
      register(114, JSON.parse.bind(JSON));
      register(3802, JSON.parse.bind(JSON));
      register(199, parseJsonArray);
      register(3807, parseJsonArray);
      register(3907, parseStringArray);
      register(2951, parseStringArray);
      register(791, parseStringArray);
      register(1183, parseStringArray);
      register(1270, parseStringArray);
    };
    module2.exports = {
      init
    };
  }
});

// node_modules/pg-int8/index.js
var require_pg_int8 = __commonJS({
  "node_modules/pg-int8/index.js"(exports2, module2) {
    "use strict";
    var BASE = 1e6;
    function readInt8(buffer) {
      var high = buffer.readInt32BE(0);
      var low = buffer.readUInt32BE(4);
      var sign = "";
      if (high < 0) {
        high = ~high + (low === 0);
        low = ~low + 1 >>> 0;
        sign = "-";
      }
      var result = "";
      var carry;
      var t;
      var digits;
      var pad;
      var l;
      var i;
      {
        carry = high % BASE;
        high = high / BASE >>> 0;
        t = 4294967296 * carry + low;
        low = t / BASE >>> 0;
        digits = "" + (t - BASE * low);
        if (low === 0 && high === 0) {
          return sign + digits + result;
        }
        pad = "";
        l = 6 - digits.length;
        for (i = 0; i < l; i++) {
          pad += "0";
        }
        result = pad + digits + result;
      }
      {
        carry = high % BASE;
        high = high / BASE >>> 0;
        t = 4294967296 * carry + low;
        low = t / BASE >>> 0;
        digits = "" + (t - BASE * low);
        if (low === 0 && high === 0) {
          return sign + digits + result;
        }
        pad = "";
        l = 6 - digits.length;
        for (i = 0; i < l; i++) {
          pad += "0";
        }
        result = pad + digits + result;
      }
      {
        carry = high % BASE;
        high = high / BASE >>> 0;
        t = 4294967296 * carry + low;
        low = t / BASE >>> 0;
        digits = "" + (t - BASE * low);
        if (low === 0 && high === 0) {
          return sign + digits + result;
        }
        pad = "";
        l = 6 - digits.length;
        for (i = 0; i < l; i++) {
          pad += "0";
        }
        result = pad + digits + result;
      }
      {
        carry = high % BASE;
        t = 4294967296 * carry + low;
        digits = "" + t % BASE;
        return sign + digits + result;
      }
    }
    module2.exports = readInt8;
  }
});

// node_modules/pg-types/lib/binaryParsers.js
var require_binaryParsers = __commonJS({
  "node_modules/pg-types/lib/binaryParsers.js"(exports2, module2) {
    var parseInt64 = require_pg_int8();
    var parseBits = function(data, bits, offset, invert, callback) {
      offset = offset || 0;
      invert = invert || false;
      callback = callback || function(lastValue, newValue, bits2) {
        return lastValue * Math.pow(2, bits2) + newValue;
      };
      var offsetBytes = offset >> 3;
      var inv = function(value) {
        if (invert) {
          return ~value & 255;
        }
        return value;
      };
      var mask = 255;
      var firstBits = 8 - offset % 8;
      if (bits < firstBits) {
        mask = 255 << 8 - bits & 255;
        firstBits = bits;
      }
      if (offset) {
        mask = mask >> offset % 8;
      }
      var result = 0;
      if (offset % 8 + bits >= 8) {
        result = callback(0, inv(data[offsetBytes]) & mask, firstBits);
      }
      var bytes = bits + offset >> 3;
      for (var i = offsetBytes + 1; i < bytes; i++) {
        result = callback(result, inv(data[i]), 8);
      }
      var lastBits = (bits + offset) % 8;
      if (lastBits > 0) {
        result = callback(result, inv(data[bytes]) >> 8 - lastBits, lastBits);
      }
      return result;
    };
    var parseFloatFromBits = function(data, precisionBits, exponentBits) {
      var bias = Math.pow(2, exponentBits - 1) - 1;
      var sign = parseBits(data, 1);
      var exponent = parseBits(data, exponentBits, 1);
      if (exponent === 0) {
        return 0;
      }
      var precisionBitsCounter = 1;
      var parsePrecisionBits = function(lastValue, newValue, bits) {
        if (lastValue === 0) {
          lastValue = 1;
        }
        for (var i = 1; i <= bits; i++) {
          precisionBitsCounter /= 2;
          if ((newValue & 1 << bits - i) > 0) {
            lastValue += precisionBitsCounter;
          }
        }
        return lastValue;
      };
      var mantissa = parseBits(data, precisionBits, exponentBits + 1, false, parsePrecisionBits);
      if (exponent == Math.pow(2, exponentBits + 1) - 1) {
        if (mantissa === 0) {
          return sign === 0 ? Infinity : -Infinity;
        }
        return NaN;
      }
      return (sign === 0 ? 1 : -1) * Math.pow(2, exponent - bias) * mantissa;
    };
    var parseInt16 = function(value) {
      if (parseBits(value, 1) == 1) {
        return -1 * (parseBits(value, 15, 1, true) + 1);
      }
      return parseBits(value, 15, 1);
    };
    var parseInt32 = function(value) {
      if (parseBits(value, 1) == 1) {
        return -1 * (parseBits(value, 31, 1, true) + 1);
      }
      return parseBits(value, 31, 1);
    };
    var parseFloat32 = function(value) {
      return parseFloatFromBits(value, 23, 8);
    };
    var parseFloat64 = function(value) {
      return parseFloatFromBits(value, 52, 11);
    };
    var parseNumeric = function(value) {
      var sign = parseBits(value, 16, 32);
      if (sign == 49152) {
        return NaN;
      }
      var weight = Math.pow(1e4, parseBits(value, 16, 16));
      var result = 0;
      var digits = [];
      var ndigits = parseBits(value, 16);
      for (var i = 0; i < ndigits; i++) {
        result += parseBits(value, 16, 64 + 16 * i) * weight;
        weight /= 1e4;
      }
      var scale = Math.pow(10, parseBits(value, 16, 48));
      return (sign === 0 ? 1 : -1) * Math.round(result * scale) / scale;
    };
    var parseDate = function(isUTC, value) {
      var sign = parseBits(value, 1);
      var rawValue = parseBits(value, 63, 1);
      var result = new Date((sign === 0 ? 1 : -1) * rawValue / 1e3 + 9466848e5);
      if (!isUTC) {
        result.setTime(result.getTime() + result.getTimezoneOffset() * 6e4);
      }
      result.usec = rawValue % 1e3;
      result.getMicroSeconds = function() {
        return this.usec;
      };
      result.setMicroSeconds = function(value2) {
        this.usec = value2;
      };
      result.getUTCMicroSeconds = function() {
        return this.usec;
      };
      return result;
    };
    var parseArray = function(value) {
      var dim = parseBits(value, 32);
      var flags = parseBits(value, 32, 32);
      var elementType = parseBits(value, 32, 64);
      var offset = 96;
      var dims = [];
      for (var i = 0; i < dim; i++) {
        dims[i] = parseBits(value, 32, offset);
        offset += 32;
        offset += 32;
      }
      var parseElement = function(elementType2) {
        var length = parseBits(value, 32, offset);
        offset += 32;
        if (length == 4294967295) {
          return null;
        }
        var result;
        if (elementType2 == 23 || elementType2 == 20) {
          result = parseBits(value, length * 8, offset);
          offset += length * 8;
          return result;
        } else if (elementType2 == 25) {
          result = value.toString(this.encoding, offset >> 3, (offset += length << 3) >> 3);
          return result;
        } else {
          console.log("ERROR: ElementType not implemented: " + elementType2);
        }
      };
      var parse = function(dimension, elementType2) {
        var array = [];
        var i2;
        if (dimension.length > 1) {
          var count = dimension.shift();
          for (i2 = 0; i2 < count; i2++) {
            array[i2] = parse(dimension, elementType2);
          }
          dimension.unshift(count);
        } else {
          for (i2 = 0; i2 < dimension[0]; i2++) {
            array[i2] = parseElement(elementType2);
          }
        }
        return array;
      };
      return parse(dims, elementType);
    };
    var parseText = function(value) {
      return value.toString("utf8");
    };
    var parseBool = function(value) {
      if (value === null) return null;
      return parseBits(value, 8) > 0;
    };
    var init = function(register) {
      register(20, parseInt64);
      register(21, parseInt16);
      register(23, parseInt32);
      register(26, parseInt32);
      register(1700, parseNumeric);
      register(700, parseFloat32);
      register(701, parseFloat64);
      register(16, parseBool);
      register(1114, parseDate.bind(null, false));
      register(1184, parseDate.bind(null, true));
      register(1e3, parseArray);
      register(1007, parseArray);
      register(1016, parseArray);
      register(1008, parseArray);
      register(1009, parseArray);
      register(25, parseText);
    };
    module2.exports = {
      init
    };
  }
});

// node_modules/pg-types/lib/builtins.js
var require_builtins = __commonJS({
  "node_modules/pg-types/lib/builtins.js"(exports2, module2) {
    module2.exports = {
      BOOL: 16,
      BYTEA: 17,
      CHAR: 18,
      INT8: 20,
      INT2: 21,
      INT4: 23,
      REGPROC: 24,
      TEXT: 25,
      OID: 26,
      TID: 27,
      XID: 28,
      CID: 29,
      JSON: 114,
      XML: 142,
      PG_NODE_TREE: 194,
      SMGR: 210,
      PATH: 602,
      POLYGON: 604,
      CIDR: 650,
      FLOAT4: 700,
      FLOAT8: 701,
      ABSTIME: 702,
      RELTIME: 703,
      TINTERVAL: 704,
      CIRCLE: 718,
      MACADDR8: 774,
      MONEY: 790,
      MACADDR: 829,
      INET: 869,
      ACLITEM: 1033,
      BPCHAR: 1042,
      VARCHAR: 1043,
      DATE: 1082,
      TIME: 1083,
      TIMESTAMP: 1114,
      TIMESTAMPTZ: 1184,
      INTERVAL: 1186,
      TIMETZ: 1266,
      BIT: 1560,
      VARBIT: 1562,
      NUMERIC: 1700,
      REFCURSOR: 1790,
      REGPROCEDURE: 2202,
      REGOPER: 2203,
      REGOPERATOR: 2204,
      REGCLASS: 2205,
      REGTYPE: 2206,
      UUID: 2950,
      TXID_SNAPSHOT: 2970,
      PG_LSN: 3220,
      PG_NDISTINCT: 3361,
      PG_DEPENDENCIES: 3402,
      TSVECTOR: 3614,
      TSQUERY: 3615,
      GTSVECTOR: 3642,
      REGCONFIG: 3734,
      REGDICTIONARY: 3769,
      JSONB: 3802,
      REGNAMESPACE: 4089,
      REGROLE: 4096
    };
  }
});

// node_modules/pg-types/index.js
var require_pg_types = __commonJS({
  "node_modules/pg-types/index.js"(exports2) {
    var textParsers = require_textParsers();
    var binaryParsers = require_binaryParsers();
    var arrayParser = require_arrayParser();
    var builtinTypes = require_builtins();
    exports2.getTypeParser = getTypeParser;
    exports2.setTypeParser = setTypeParser;
    exports2.arrayParser = arrayParser;
    exports2.builtins = builtinTypes;
    var typeParsers = {
      text: {},
      binary: {}
    };
    function noParse(val) {
      return String(val);
    }
    function getTypeParser(oid, format) {
      format = format || "text";
      if (!typeParsers[format]) {
        return noParse;
      }
      return typeParsers[format][oid] || noParse;
    }
    function setTypeParser(oid, format, parseFn) {
      if (typeof format == "function") {
        parseFn = format;
        format = "text";
      }
      typeParsers[format][oid] = parseFn;
    }
    textParsers.init(function(oid, converter) {
      typeParsers.text[oid] = converter;
    });
    binaryParsers.init(function(oid, converter) {
      typeParsers.binary[oid] = converter;
    });
  }
});

// node_modules/pg/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/pg/lib/defaults.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      // database host. defaults to localhost
      host: "localhost",
      // database user's name
      user: process.platform === "win32" ? process.env.USERNAME : process.env.USER,
      // name of database to connect
      database: void 0,
      // database user's password
      password: null,
      // a Postgres connection string to be used instead of setting individual connection items
      // NOTE:  Setting this value will cause it to override any other value (such as database or user) defined
      // in the defaults object.
      connectionString: void 0,
      // database port
      port: 5432,
      // number of rows to return at a time from a prepared statement's
      // portal. 0 will return all rows at once
      rows: 0,
      // binary result mode
      binary: false,
      // Connection pool options - see https://github.com/brianc/node-pg-pool
      // number of connections to use in connection pool
      // 0 will disable connection pooling
      max: 10,
      // max milliseconds a client can go unused before it is removed
      // from the pool and destroyed
      idleTimeoutMillis: 3e4,
      client_encoding: "",
      ssl: false,
      application_name: void 0,
      fallback_application_name: void 0,
      options: void 0,
      parseInputDatesAsUTC: false,
      // max milliseconds any query using this connection will execute for before timing out in error.
      // false=unlimited
      statement_timeout: false,
      // Abort any statement that waits longer than the specified duration in milliseconds while attempting to acquire a lock.
      // false=unlimited
      lock_timeout: false,
      // Terminate any session with an open transaction that has been idle for longer than the specified duration in milliseconds
      // false=unlimited
      idle_in_transaction_session_timeout: false,
      // max milliseconds to wait for query to complete (client side)
      query_timeout: false,
      connect_timeout: 0,
      keepalives: 1,
      keepalives_idle: 0
    };
    var pgTypes = require_pg_types();
    var parseBigInteger = pgTypes.getTypeParser(20, "text");
    var parseBigIntegerArray = pgTypes.getTypeParser(1016, "text");
    module2.exports.__defineSetter__("parseInt8", function(val) {
      pgTypes.setTypeParser(20, "text", val ? pgTypes.getTypeParser(23, "text") : parseBigInteger);
      pgTypes.setTypeParser(1016, "text", val ? pgTypes.getTypeParser(1007, "text") : parseBigIntegerArray);
    });
  }
});

// node_modules/pg/lib/utils.js
var require_utils = __commonJS({
  "node_modules/pg/lib/utils.js"(exports2, module2) {
    "use strict";
    var defaults = require_defaults();
    var util = require("util");
    var { isDate } = util.types || util;
    function escapeElement(elementRepresentation) {
      const escaped = elementRepresentation.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
      return '"' + escaped + '"';
    }
    function arrayString(val) {
      let result = "{";
      for (let i = 0; i < val.length; i++) {
        if (i > 0) {
          result = result + ",";
        }
        if (val[i] === null || typeof val[i] === "undefined") {
          result = result + "NULL";
        } else if (Array.isArray(val[i])) {
          result = result + arrayString(val[i]);
        } else if (ArrayBuffer.isView(val[i])) {
          let item = val[i];
          if (!(item instanceof Buffer)) {
            const buf = Buffer.from(item.buffer, item.byteOffset, item.byteLength);
            if (buf.length === item.byteLength) {
              item = buf;
            } else {
              item = buf.slice(item.byteOffset, item.byteOffset + item.byteLength);
            }
          }
          result += "\\\\x" + item.toString("hex");
        } else {
          result += escapeElement(prepareValue(val[i]));
        }
      }
      result = result + "}";
      return result;
    }
    var prepareValue = function(val, seen) {
      if (val == null) {
        return null;
      }
      if (typeof val === "object") {
        if (val instanceof Buffer) {
          return val;
        }
        if (ArrayBuffer.isView(val)) {
          const buf = Buffer.from(val.buffer, val.byteOffset, val.byteLength);
          if (buf.length === val.byteLength) {
            return buf;
          }
          return buf.slice(val.byteOffset, val.byteOffset + val.byteLength);
        }
        if (isDate(val)) {
          if (defaults.parseInputDatesAsUTC) {
            return dateToStringUTC(val);
          } else {
            return dateToString(val);
          }
        }
        if (Array.isArray(val)) {
          return arrayString(val);
        }
        return prepareObject(val, seen);
      }
      return val.toString();
    };
    function prepareObject(val, seen) {
      if (val && typeof val.toPostgres === "function") {
        seen = seen || [];
        if (seen.indexOf(val) !== -1) {
          throw new Error('circular reference detected while preparing "' + val + '" for query');
        }
        seen.push(val);
        return prepareValue(val.toPostgres(prepareValue), seen);
      }
      return JSON.stringify(val);
    }
    function dateToString(date) {
      let offset = -date.getTimezoneOffset();
      let year = date.getFullYear();
      const isBCYear = year < 1;
      if (isBCYear) year = Math.abs(year) + 1;
      let ret = String(year).padStart(4, "0") + "-" + String(date.getMonth() + 1).padStart(2, "0") + "-" + String(date.getDate()).padStart(2, "0") + "T" + String(date.getHours()).padStart(2, "0") + ":" + String(date.getMinutes()).padStart(2, "0") + ":" + String(date.getSeconds()).padStart(2, "0") + "." + String(date.getMilliseconds()).padStart(3, "0");
      if (offset < 0) {
        ret += "-";
        offset *= -1;
      } else {
        ret += "+";
      }
      ret += String(Math.floor(offset / 60)).padStart(2, "0") + ":" + String(offset % 60).padStart(2, "0");
      if (isBCYear) ret += " BC";
      return ret;
    }
    function dateToStringUTC(date) {
      let year = date.getUTCFullYear();
      const isBCYear = year < 1;
      if (isBCYear) year = Math.abs(year) + 1;
      let ret = String(year).padStart(4, "0") + "-" + String(date.getUTCMonth() + 1).padStart(2, "0") + "-" + String(date.getUTCDate()).padStart(2, "0") + "T" + String(date.getUTCHours()).padStart(2, "0") + ":" + String(date.getUTCMinutes()).padStart(2, "0") + ":" + String(date.getUTCSeconds()).padStart(2, "0") + "." + String(date.getUTCMilliseconds()).padStart(3, "0");
      ret += "+00:00";
      if (isBCYear) ret += " BC";
      return ret;
    }
    function normalizeQueryConfig(config, values, callback) {
      config = typeof config === "string" ? { text: config } : config;
      if (values) {
        if (typeof values === "function") {
          config.callback = values;
        } else {
          config.values = values;
        }
      }
      if (callback) {
        config.callback = callback;
      }
      return config;
    }
    var escapeIdentifier = function(str) {
      return '"' + str.replace(/"/g, '""') + '"';
    };
    var escapeLiteral = function(str) {
      let hasBackslash = false;
      let escaped = "'";
      if (str == null) {
        return "''";
      }
      if (typeof str !== "string") {
        return "''";
      }
      for (let i = 0; i < str.length; i++) {
        const c = str[i];
        if (c === "'") {
          escaped += c + c;
        } else if (c === "\\") {
          escaped += c + c;
          hasBackslash = true;
        } else {
          escaped += c;
        }
      }
      escaped += "'";
      if (hasBackslash === true) {
        escaped = " E" + escaped;
      }
      return escaped;
    };
    module2.exports = {
      prepareValue: function prepareValueWrapper(value) {
        return prepareValue(value);
      },
      normalizeQueryConfig,
      escapeIdentifier,
      escapeLiteral
    };
  }
});

// node_modules/pg/lib/crypto/utils-legacy.js
var require_utils_legacy = __commonJS({
  "node_modules/pg/lib/crypto/utils-legacy.js"(exports2, module2) {
    "use strict";
    var nodeCrypto = require("crypto");
    function md5(string) {
      return nodeCrypto.createHash("md5").update(string, "utf-8").digest("hex");
    }
    function postgresMd5PasswordHash(user, password, salt) {
      const inner = md5(password + user);
      const outer = md5(Buffer.concat([Buffer.from(inner), salt]));
      return "md5" + outer;
    }
    function sha256(text) {
      return nodeCrypto.createHash("sha256").update(text).digest();
    }
    function hashByName(hashName, text) {
      hashName = hashName.replace(/(\D)-/, "$1");
      return nodeCrypto.createHash(hashName).update(text).digest();
    }
    function hmacSha256(key, msg) {
      return nodeCrypto.createHmac("sha256", key).update(msg).digest();
    }
    async function deriveKey(password, salt, iterations) {
      return nodeCrypto.pbkdf2Sync(password, salt, iterations, 32, "sha256");
    }
    module2.exports = {
      postgresMd5PasswordHash,
      randomBytes: nodeCrypto.randomBytes,
      deriveKey,
      sha256,
      hashByName,
      hmacSha256,
      md5
    };
  }
});

// node_modules/pg/lib/crypto/utils-webcrypto.js
var require_utils_webcrypto = __commonJS({
  "node_modules/pg/lib/crypto/utils-webcrypto.js"(exports2, module2) {
    var nodeCrypto = require("crypto");
    module2.exports = {
      postgresMd5PasswordHash,
      randomBytes,
      deriveKey,
      sha256,
      hashByName,
      hmacSha256,
      md5
    };
    var webCrypto = nodeCrypto.webcrypto || globalThis.crypto;
    var subtleCrypto = webCrypto.subtle;
    var textEncoder = new TextEncoder();
    function randomBytes(length) {
      return webCrypto.getRandomValues(Buffer.alloc(length));
    }
    async function md5(string) {
      try {
        return nodeCrypto.createHash("md5").update(string, "utf-8").digest("hex");
      } catch (e) {
        const data = typeof string === "string" ? textEncoder.encode(string) : string;
        const hash = await subtleCrypto.digest("MD5", data);
        return Array.from(new Uint8Array(hash)).map((b) => b.toString(16).padStart(2, "0")).join("");
      }
    }
    async function postgresMd5PasswordHash(user, password, salt) {
      const inner = await md5(password + user);
      const outer = await md5(Buffer.concat([Buffer.from(inner), salt]));
      return "md5" + outer;
    }
    async function sha256(text) {
      return await subtleCrypto.digest("SHA-256", text);
    }
    async function hashByName(hashName, text) {
      return await subtleCrypto.digest(hashName, text);
    }
    async function hmacSha256(keyBuffer, msg) {
      const key = await subtleCrypto.importKey("raw", keyBuffer, { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
      return await subtleCrypto.sign("HMAC", key, textEncoder.encode(msg));
    }
    async function deriveKey(password, salt, iterations) {
      const key = await subtleCrypto.importKey("raw", textEncoder.encode(password), "PBKDF2", false, ["deriveBits"]);
      const params = { name: "PBKDF2", hash: "SHA-256", salt, iterations };
      return await subtleCrypto.deriveBits(params, key, 32 * 8, ["deriveBits"]);
    }
  }
});

// node_modules/pg/lib/crypto/utils.js
var require_utils2 = __commonJS({
  "node_modules/pg/lib/crypto/utils.js"(exports2, module2) {
    "use strict";
    var useLegacyCrypto = parseInt(process.versions && process.versions.node && process.versions.node.split(".")[0]) < 15;
    if (useLegacyCrypto) {
      module2.exports = require_utils_legacy();
    } else {
      module2.exports = require_utils_webcrypto();
    }
  }
});

// node_modules/pg/lib/crypto/cert-signatures.js
var require_cert_signatures = __commonJS({
  "node_modules/pg/lib/crypto/cert-signatures.js"(exports2, module2) {
    function x509Error(msg, cert) {
      return new Error("SASL channel binding: " + msg + " when parsing public certificate " + cert.toString("base64"));
    }
    function readASN1Length(data, index) {
      let length = data[index++];
      if (length < 128) return { length, index };
      const lengthBytes = length & 127;
      if (lengthBytes > 4) throw x509Error("bad length", data);
      length = 0;
      for (let i = 0; i < lengthBytes; i++) {
        length = length << 8 | data[index++];
      }
      return { length, index };
    }
    function readASN1OID(data, index) {
      if (data[index++] !== 6) throw x509Error("non-OID data", data);
      const { length: OIDLength, index: indexAfterOIDLength } = readASN1Length(data, index);
      index = indexAfterOIDLength;
      const lastIndex = index + OIDLength;
      const byte1 = data[index++];
      let oid = (byte1 / 40 >> 0) + "." + byte1 % 40;
      while (index < lastIndex) {
        let value = 0;
        while (index < lastIndex) {
          const nextByte = data[index++];
          value = value << 7 | nextByte & 127;
          if (nextByte < 128) break;
        }
        oid += "." + value;
      }
      return { oid, index };
    }
    function expectASN1Seq(data, index) {
      if (data[index++] !== 48) throw x509Error("non-sequence data", data);
      return readASN1Length(data, index);
    }
    function signatureAlgorithmHashFromCertificate(data, index) {
      if (index === void 0) index = 0;
      index = expectASN1Seq(data, index).index;
      const { length: certInfoLength, index: indexAfterCertInfoLength } = expectASN1Seq(data, index);
      index = indexAfterCertInfoLength + certInfoLength;
      index = expectASN1Seq(data, index).index;
      const { oid, index: indexAfterOID } = readASN1OID(data, index);
      switch (oid) {
        // RSA
        case "1.2.840.113549.1.1.4":
          return "MD5";
        case "1.2.840.113549.1.1.5":
          return "SHA-1";
        case "1.2.840.113549.1.1.11":
          return "SHA-256";
        case "1.2.840.113549.1.1.12":
          return "SHA-384";
        case "1.2.840.113549.1.1.13":
          return "SHA-512";
        case "1.2.840.113549.1.1.14":
          return "SHA-224";
        case "1.2.840.113549.1.1.15":
          return "SHA512-224";
        case "1.2.840.113549.1.1.16":
          return "SHA512-256";
        // ECDSA
        case "1.2.840.10045.4.1":
          return "SHA-1";
        case "1.2.840.10045.4.3.1":
          return "SHA-224";
        case "1.2.840.10045.4.3.2":
          return "SHA-256";
        case "1.2.840.10045.4.3.3":
          return "SHA-384";
        case "1.2.840.10045.4.3.4":
          return "SHA-512";
        // RSASSA-PSS: hash is indicated separately
        case "1.2.840.113549.1.1.10": {
          index = indexAfterOID;
          index = expectASN1Seq(data, index).index;
          if (data[index++] !== 160) throw x509Error("non-tag data", data);
          index = readASN1Length(data, index).index;
          index = expectASN1Seq(data, index).index;
          const { oid: hashOID } = readASN1OID(data, index);
          switch (hashOID) {
            // standalone hash OIDs
            case "1.2.840.113549.2.5":
              return "MD5";
            case "1.3.14.3.2.26":
              return "SHA-1";
            case "2.16.840.1.101.3.4.2.1":
              return "SHA-256";
            case "2.16.840.1.101.3.4.2.2":
              return "SHA-384";
            case "2.16.840.1.101.3.4.2.3":
              return "SHA-512";
          }
          throw x509Error("unknown hash OID " + hashOID, data);
        }
        // Ed25519 -- see https: return//github.com/openssl/openssl/issues/15477
        case "1.3.101.110":
        case "1.3.101.112":
          return "SHA-512";
        // Ed448 -- still not in pg 17.2 (if supported, digest would be SHAKE256 x 64 bytes)
        case "1.3.101.111":
        case "1.3.101.113":
          throw x509Error("Ed448 certificate channel binding is not currently supported by Postgres");
      }
      throw x509Error("unknown OID " + oid, data);
    }
    module2.exports = { signatureAlgorithmHashFromCertificate };
  }
});

// node_modules/pg/lib/crypto/sasl.js
var require_sasl = __commonJS({
  "node_modules/pg/lib/crypto/sasl.js"(exports2, module2) {
    "use strict";
    var crypto2 = require_utils2();
    var { signatureAlgorithmHashFromCertificate } = require_cert_signatures();
    function startSession(mechanisms, stream) {
      const candidates = ["SCRAM-SHA-256"];
      if (stream) candidates.unshift("SCRAM-SHA-256-PLUS");
      const mechanism = candidates.find((candidate) => mechanisms.includes(candidate));
      if (!mechanism) {
        throw new Error("SASL: Only mechanism(s) " + candidates.join(" and ") + " are supported");
      }
      if (mechanism === "SCRAM-SHA-256-PLUS" && typeof stream.getPeerCertificate !== "function") {
        throw new Error("SASL: Mechanism SCRAM-SHA-256-PLUS requires a certificate");
      }
      const clientNonce = crypto2.randomBytes(18).toString("base64");
      const gs2Header = mechanism === "SCRAM-SHA-256-PLUS" ? "p=tls-server-end-point" : stream ? "y" : "n";
      return {
        mechanism,
        clientNonce,
        response: gs2Header + ",,n=*,r=" + clientNonce,
        message: "SASLInitialResponse"
      };
    }
    async function continueSession(session, password, serverData, stream) {
      if (session.message !== "SASLInitialResponse") {
        throw new Error("SASL: Last message was not SASLInitialResponse");
      }
      if (typeof password !== "string") {
        throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a string");
      }
      if (password === "") {
        throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a non-empty string");
      }
      if (typeof serverData !== "string") {
        throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: serverData must be a string");
      }
      const sv = parseServerFirstMessage(serverData);
      if (!sv.nonce.startsWith(session.clientNonce)) {
        throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce");
      } else if (sv.nonce.length === session.clientNonce.length) {
        throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short");
      }
      const clientFirstMessageBare = "n=*,r=" + session.clientNonce;
      const serverFirstMessage = "r=" + sv.nonce + ",s=" + sv.salt + ",i=" + sv.iteration;
      let channelBinding = stream ? "eSws" : "biws";
      if (session.mechanism === "SCRAM-SHA-256-PLUS") {
        const peerCert = stream.getPeerCertificate().raw;
        let hashName = signatureAlgorithmHashFromCertificate(peerCert);
        if (hashName === "MD5" || hashName === "SHA-1") hashName = "SHA-256";
        const certHash = await crypto2.hashByName(hashName, peerCert);
        const bindingData = Buffer.concat([Buffer.from("p=tls-server-end-point,,"), Buffer.from(certHash)]);
        channelBinding = bindingData.toString("base64");
      }
      const clientFinalMessageWithoutProof = "c=" + channelBinding + ",r=" + sv.nonce;
      const authMessage = clientFirstMessageBare + "," + serverFirstMessage + "," + clientFinalMessageWithoutProof;
      const saltBytes = Buffer.from(sv.salt, "base64");
      const saltedPassword = await crypto2.deriveKey(password, saltBytes, sv.iteration);
      const clientKey = await crypto2.hmacSha256(saltedPassword, "Client Key");
      const storedKey = await crypto2.sha256(clientKey);
      const clientSignature = await crypto2.hmacSha256(storedKey, authMessage);
      const clientProof = xorBuffers(Buffer.from(clientKey), Buffer.from(clientSignature)).toString("base64");
      const serverKey = await crypto2.hmacSha256(saltedPassword, "Server Key");
      const serverSignatureBytes = await crypto2.hmacSha256(serverKey, authMessage);
      session.message = "SASLResponse";
      session.serverSignature = Buffer.from(serverSignatureBytes).toString("base64");
      session.response = clientFinalMessageWithoutProof + ",p=" + clientProof;
    }
    function finalizeSession(session, serverData) {
      if (session.message !== "SASLResponse") {
        throw new Error("SASL: Last message was not SASLResponse");
      }
      if (typeof serverData !== "string") {
        throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: serverData must be a string");
      }
      const { serverSignature } = parseServerFinalMessage(serverData);
      if (serverSignature !== session.serverSignature) {
        throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match");
      }
    }
    function isPrintableChars(text) {
      if (typeof text !== "string") {
        throw new TypeError("SASL: text must be a string");
      }
      return text.split("").map((_, i) => text.charCodeAt(i)).every((c) => c >= 33 && c <= 43 || c >= 45 && c <= 126);
    }
    function isBase64(text) {
      return /^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(text);
    }
    function parseAttributePairs(text) {
      if (typeof text !== "string") {
        throw new TypeError("SASL: attribute pairs text must be a string");
      }
      return new Map(
        text.split(",").map((attrValue) => {
          if (!/^.=/.test(attrValue)) {
            throw new Error("SASL: Invalid attribute pair entry");
          }
          const name = attrValue[0];
          const value = attrValue.substring(2);
          return [name, value];
        })
      );
    }
    function parseServerFirstMessage(data) {
      const attrPairs = parseAttributePairs(data);
      const nonce = attrPairs.get("r");
      if (!nonce) {
        throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing");
      } else if (!isPrintableChars(nonce)) {
        throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce must only contain printable characters");
      }
      const salt = attrPairs.get("s");
      if (!salt) {
        throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing");
      } else if (!isBase64(salt)) {
        throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt must be base64");
      }
      const iterationText = attrPairs.get("i");
      if (!iterationText) {
        throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing");
      } else if (!/^[1-9][0-9]*$/.test(iterationText)) {
        throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: invalid iteration count");
      }
      const iteration = parseInt(iterationText, 10);
      return {
        nonce,
        salt,
        iteration
      };
    }
    function parseServerFinalMessage(serverData) {
      const attrPairs = parseAttributePairs(serverData);
      const serverSignature = attrPairs.get("v");
      if (!serverSignature) {
        throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature is missing");
      } else if (!isBase64(serverSignature)) {
        throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature must be base64");
      }
      return {
        serverSignature
      };
    }
    function xorBuffers(a, b) {
      if (!Buffer.isBuffer(a)) {
        throw new TypeError("first argument must be a Buffer");
      }
      if (!Buffer.isBuffer(b)) {
        throw new TypeError("second argument must be a Buffer");
      }
      if (a.length !== b.length) {
        throw new Error("Buffer lengths must match");
      }
      if (a.length === 0) {
        throw new Error("Buffers cannot be empty");
      }
      return Buffer.from(a.map((_, i) => a[i] ^ b[i]));
    }
    module2.exports = {
      startSession,
      continueSession,
      finalizeSession
    };
  }
});

// node_modules/pg/lib/type-overrides.js
var require_type_overrides = __commonJS({
  "node_modules/pg/lib/type-overrides.js"(exports2, module2) {
    "use strict";
    var types = require_pg_types();
    function TypeOverrides(userTypes) {
      this._types = userTypes || types;
      this.text = {};
      this.binary = {};
    }
    TypeOverrides.prototype.getOverrides = function(format) {
      switch (format) {
        case "text":
          return this.text;
        case "binary":
          return this.binary;
        default:
          return {};
      }
    };
    TypeOverrides.prototype.setTypeParser = function(oid, format, parseFn) {
      if (typeof format === "function") {
        parseFn = format;
        format = "text";
      }
      this.getOverrides(format)[oid] = parseFn;
    };
    TypeOverrides.prototype.getTypeParser = function(oid, format) {
      format = format || "text";
      return this.getOverrides(format)[oid] || this._types.getTypeParser(oid, format);
    };
    module2.exports = TypeOverrides;
  }
});

// node_modules/pg-connection-string/index.js
var require_pg_connection_string = __commonJS({
  "node_modules/pg-connection-string/index.js"(exports2, module2) {
    "use strict";
    function parse(str, options = {}) {
      if (str.charAt(0) === "/") {
        const config2 = str.split(" ");
        return { host: config2[0], database: config2[1] };
      }
      const config = {};
      let result;
      let dummyHost = false;
      if (/ |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(str)) {
        str = encodeURI(str).replace(/%25(\d\d)/g, "%$1");
      }
      try {
        try {
          result = new URL(str, "postgres://base");
        } catch (e) {
          result = new URL(str.replace("@/", "@___DUMMY___/"), "postgres://base");
          dummyHost = true;
        }
      } catch (err) {
        err.input && (err.input = "*****REDACTED*****");
      }
      for (const entry of result.searchParams.entries()) {
        config[entry[0]] = entry[1];
      }
      config.user = config.user || decodeURIComponent(result.username);
      config.password = config.password || decodeURIComponent(result.password);
      if (result.protocol == "socket:") {
        config.host = decodeURI(result.pathname);
        config.database = result.searchParams.get("db");
        config.client_encoding = result.searchParams.get("encoding");
        return config;
      }
      const hostname = dummyHost ? "" : result.hostname;
      if (!config.host) {
        config.host = decodeURIComponent(hostname);
      } else if (hostname && /^%2f/i.test(hostname)) {
        result.pathname = hostname + result.pathname;
      }
      if (!config.port) {
        config.port = result.port;
      }
      const pathname = result.pathname.slice(1) || null;
      config.database = pathname ? decodeURI(pathname) : null;
      if (config.ssl === "true" || config.ssl === "1") {
        config.ssl = true;
      }
      if (config.ssl === "0") {
        config.ssl = false;
      }
      if (config.sslcert || config.sslkey || config.sslrootcert || config.sslmode) {
        config.ssl = {};
      }
      const fs = config.sslcert || config.sslkey || config.sslrootcert ? require("fs") : null;
      if (config.sslcert) {
        config.ssl.cert = fs.readFileSync(config.sslcert).toString();
      }
      if (config.sslkey) {
        config.ssl.key = fs.readFileSync(config.sslkey).toString();
      }
      if (config.sslrootcert) {
        config.ssl.ca = fs.readFileSync(config.sslrootcert).toString();
      }
      if (options.useLibpqCompat && config.uselibpqcompat) {
        throw new Error("Both useLibpqCompat and uselibpqcompat are set. Please use only one of them.");
      }
      if (config.uselibpqcompat === "true" || options.useLibpqCompat) {
        switch (config.sslmode) {
          case "disable": {
            config.ssl = false;
            break;
          }
          case "prefer": {
            config.ssl.rejectUnauthorized = false;
            break;
          }
          case "require": {
            if (config.sslrootcert) {
              config.ssl.checkServerIdentity = function() {
              };
            } else {
              config.ssl.rejectUnauthorized = false;
            }
            break;
          }
          case "verify-ca": {
            if (!config.ssl.ca) {
              throw new Error(
                "SECURITY WARNING: Using sslmode=verify-ca requires specifying a CA with sslrootcert. If a public CA is used, verify-ca allows connections to a server that somebody else may have registered with the CA, making you vulnerable to Man-in-the-Middle attacks. Either specify a custom CA certificate with sslrootcert parameter or use sslmode=verify-full for proper security."
              );
            }
            config.ssl.checkServerIdentity = function() {
            };
            break;
          }
          case "verify-full": {
            break;
          }
        }
      } else {
        switch (config.sslmode) {
          case "disable": {
            config.ssl = false;
            break;
          }
          case "prefer":
          case "require":
          case "verify-ca":
          case "verify-full": {
            break;
          }
          case "no-verify": {
            config.ssl.rejectUnauthorized = false;
            break;
          }
        }
      }
      return config;
    }
    function toConnectionOptions(sslConfig) {
      const connectionOptions = Object.entries(sslConfig).reduce((c, [key, value]) => {
        if (value !== void 0 && value !== null) {
          c[key] = value;
        }
        return c;
      }, {});
      return connectionOptions;
    }
    function toClientConfig(config) {
      const poolConfig = Object.entries(config).reduce((c, [key, value]) => {
        if (key === "ssl") {
          const sslConfig = value;
          if (typeof sslConfig === "boolean") {
            c[key] = sslConfig;
          }
          if (typeof sslConfig === "object") {
            c[key] = toConnectionOptions(sslConfig);
          }
        } else if (value !== void 0 && value !== null) {
          if (key === "port") {
            if (value !== "") {
              const v = parseInt(value, 10);
              if (isNaN(v)) {
                throw new Error(`Invalid ${key}: ${value}`);
              }
              c[key] = v;
            }
          } else {
            c[key] = value;
          }
        }
        return c;
      }, {});
      return poolConfig;
    }
    function parseIntoClientConfig(str) {
      return toClientConfig(parse(str));
    }
    module2.exports = parse;
    parse.parse = parse;
    parse.toClientConfig = toClientConfig;
    parse.parseIntoClientConfig = parseIntoClientConfig;
  }
});

// node_modules/pg/lib/connection-parameters.js
var require_connection_parameters = __commonJS({
  "node_modules/pg/lib/connection-parameters.js"(exports2, module2) {
    "use strict";
    var dns = require("dns");
    var defaults = require_defaults();
    var parse = require_pg_connection_string().parse;
    var val = function(key, config, envVar) {
      if (envVar === void 0) {
        envVar = process.env["PG" + key.toUpperCase()];
      } else if (envVar === false) {
      } else {
        envVar = process.env[envVar];
      }
      return config[key] || envVar || defaults[key];
    };
    var readSSLConfigFromEnvironment = function() {
      switch (process.env.PGSSLMODE) {
        case "disable":
          return false;
        case "prefer":
        case "require":
        case "verify-ca":
        case "verify-full":
          return true;
        case "no-verify":
          return { rejectUnauthorized: false };
      }
      return defaults.ssl;
    };
    var quoteParamValue = function(value) {
      return "'" + ("" + value).replace(/\\/g, "\\\\").replace(/'/g, "\\'") + "'";
    };
    var add = function(params, config, paramName) {
      const value = config[paramName];
      if (value !== void 0 && value !== null) {
        params.push(paramName + "=" + quoteParamValue(value));
      }
    };
    var ConnectionParameters = class {
      constructor(config) {
        config = typeof config === "string" ? parse(config) : config || {};
        if (config.connectionString) {
          config = Object.assign({}, config, parse(config.connectionString));
        }
        this.user = val("user", config);
        this.database = val("database", config);
        if (this.database === void 0) {
          this.database = this.user;
        }
        this.port = parseInt(val("port", config), 10);
        this.host = val("host", config);
        Object.defineProperty(this, "password", {
          configurable: true,
          enumerable: false,
          writable: true,
          value: val("password", config)
        });
        this.binary = val("binary", config);
        this.options = val("options", config);
        this.ssl = typeof config.ssl === "undefined" ? readSSLConfigFromEnvironment() : config.ssl;
        if (typeof this.ssl === "string") {
          if (this.ssl === "true") {
            this.ssl = true;
          }
        }
        if (this.ssl === "no-verify") {
          this.ssl = { rejectUnauthorized: false };
        }
        if (this.ssl && this.ssl.key) {
          Object.defineProperty(this.ssl, "key", {
            enumerable: false
          });
        }
        this.client_encoding = val("client_encoding", config);
        this.replication = val("replication", config);
        this.isDomainSocket = !(this.host || "").indexOf("/");
        this.application_name = val("application_name", config, "PGAPPNAME");
        this.fallback_application_name = val("fallback_application_name", config, false);
        this.statement_timeout = val("statement_timeout", config, false);
        this.lock_timeout = val("lock_timeout", config, false);
        this.idle_in_transaction_session_timeout = val("idle_in_transaction_session_timeout", config, false);
        this.query_timeout = val("query_timeout", config, false);
        if (config.connectionTimeoutMillis === void 0) {
          this.connect_timeout = process.env.PGCONNECT_TIMEOUT || 0;
        } else {
          this.connect_timeout = Math.floor(config.connectionTimeoutMillis / 1e3);
        }
        if (config.keepAlive === false) {
          this.keepalives = 0;
        } else if (config.keepAlive === true) {
          this.keepalives = 1;
        }
        if (typeof config.keepAliveInitialDelayMillis === "number") {
          this.keepalives_idle = Math.floor(config.keepAliveInitialDelayMillis / 1e3);
        }
      }
      getLibpqConnectionString(cb) {
        const params = [];
        add(params, this, "user");
        add(params, this, "password");
        add(params, this, "port");
        add(params, this, "application_name");
        add(params, this, "fallback_application_name");
        add(params, this, "connect_timeout");
        add(params, this, "options");
        const ssl = typeof this.ssl === "object" ? this.ssl : this.ssl ? { sslmode: this.ssl } : {};
        add(params, ssl, "sslmode");
        add(params, ssl, "sslca");
        add(params, ssl, "sslkey");
        add(params, ssl, "sslcert");
        add(params, ssl, "sslrootcert");
        if (this.database) {
          params.push("dbname=" + quoteParamValue(this.database));
        }
        if (this.replication) {
          params.push("replication=" + quoteParamValue(this.replication));
        }
        if (this.host) {
          params.push("host=" + quoteParamValue(this.host));
        }
        if (this.isDomainSocket) {
          return cb(null, params.join(" "));
        }
        if (this.client_encoding) {
          params.push("client_encoding=" + quoteParamValue(this.client_encoding));
        }
        dns.lookup(this.host, function(err, address) {
          if (err) return cb(err, null);
          params.push("hostaddr=" + quoteParamValue(address));
          return cb(null, params.join(" "));
        });
      }
    };
    module2.exports = ConnectionParameters;
  }
});

// node_modules/pg/lib/result.js
var require_result = __commonJS({
  "node_modules/pg/lib/result.js"(exports2, module2) {
    "use strict";
    var types = require_pg_types();
    var matchRegexp = /^([A-Za-z]+)(?: (\d+))?(?: (\d+))?/;
    var Result = class {
      constructor(rowMode, types2) {
        this.command = null;
        this.rowCount = null;
        this.oid = null;
        this.rows = [];
        this.fields = [];
        this._parsers = void 0;
        this._types = types2;
        this.RowCtor = null;
        this.rowAsArray = rowMode === "array";
        if (this.rowAsArray) {
          this.parseRow = this._parseRowAsArray;
        }
        this._prebuiltEmptyResultObject = null;
      }
      // adds a command complete message
      addCommandComplete(msg) {
        let match;
        if (msg.text) {
          match = matchRegexp.exec(msg.text);
        } else {
          match = matchRegexp.exec(msg.command);
        }
        if (match) {
          this.command = match[1];
          if (match[3]) {
            this.oid = parseInt(match[2], 10);
            this.rowCount = parseInt(match[3], 10);
          } else if (match[2]) {
            this.rowCount = parseInt(match[2], 10);
          }
        }
      }
      _parseRowAsArray(rowData) {
        const row = new Array(rowData.length);
        for (let i = 0, len = rowData.length; i < len; i++) {
          const rawValue = rowData[i];
          if (rawValue !== null) {
            row[i] = this._parsers[i](rawValue);
          } else {
            row[i] = null;
          }
        }
        return row;
      }
      parseRow(rowData) {
        const row = { ...this._prebuiltEmptyResultObject };
        for (let i = 0, len = rowData.length; i < len; i++) {
          const rawValue = rowData[i];
          const field = this.fields[i].name;
          if (rawValue !== null) {
            const v = this.fields[i].format === "binary" ? Buffer.from(rawValue) : rawValue;
            row[field] = this._parsers[i](v);
          } else {
            row[field] = null;
          }
        }
        return row;
      }
      addRow(row) {
        this.rows.push(row);
      }
      addFields(fieldDescriptions) {
        this.fields = fieldDescriptions;
        if (this.fields.length) {
          this._parsers = new Array(fieldDescriptions.length);
        }
        const row = {};
        for (let i = 0; i < fieldDescriptions.length; i++) {
          const desc = fieldDescriptions[i];
          row[desc.name] = null;
          if (this._types) {
            this._parsers[i] = this._types.getTypeParser(desc.dataTypeID, desc.format || "text");
          } else {
            this._parsers[i] = types.getTypeParser(desc.dataTypeID, desc.format || "text");
          }
        }
        this._prebuiltEmptyResultObject = { ...row };
      }
    };
    module2.exports = Result;
  }
});

// node_modules/pg/lib/query.js
var require_query = __commonJS({
  "node_modules/pg/lib/query.js"(exports2, module2) {
    "use strict";
    var { EventEmitter } = require("events");
    var Result = require_result();
    var utils = require_utils();
    var Query = class extends EventEmitter {
      constructor(config, values, callback) {
        super();
        config = utils.normalizeQueryConfig(config, values, callback);
        this.text = config.text;
        this.values = config.values;
        this.rows = config.rows;
        this.types = config.types;
        this.name = config.name;
        this.queryMode = config.queryMode;
        this.binary = config.binary;
        this.portal = config.portal || "";
        this.callback = config.callback;
        this._rowMode = config.rowMode;
        if (process.domain && config.callback) {
          this.callback = process.domain.bind(config.callback);
        }
        this._result = new Result(this._rowMode, this.types);
        this._results = this._result;
        this._canceledDueToError = false;
      }
      requiresPreparation() {
        if (this.queryMode === "extended") {
          return true;
        }
        if (this.name) {
          return true;
        }
        if (this.rows) {
          return true;
        }
        if (!this.text) {
          return false;
        }
        if (!this.values) {
          return false;
        }
        return this.values.length > 0;
      }
      _checkForMultirow() {
        if (this._result.command) {
          if (!Array.isArray(this._results)) {
            this._results = [this._result];
          }
          this._result = new Result(this._rowMode, this._result._types);
          this._results.push(this._result);
        }
      }
      // associates row metadata from the supplied
      // message with this query object
      // metadata used when parsing row results
      handleRowDescription(msg) {
        this._checkForMultirow();
        this._result.addFields(msg.fields);
        this._accumulateRows = this.callback || !this.listeners("row").length;
      }
      handleDataRow(msg) {
        let row;
        if (this._canceledDueToError) {
          return;
        }
        try {
          row = this._result.parseRow(msg.fields);
        } catch (err) {
          this._canceledDueToError = err;
          return;
        }
        this.emit("row", row, this._result);
        if (this._accumulateRows) {
          this._result.addRow(row);
        }
      }
      handleCommandComplete(msg, connection) {
        this._checkForMultirow();
        this._result.addCommandComplete(msg);
        if (this.rows) {
          connection.sync();
        }
      }
      // if a named prepared statement is created with empty query text
      // the backend will send an emptyQuery message but *not* a command complete message
      // since we pipeline sync immediately after execute we don't need to do anything here
      // unless we have rows specified, in which case we did not pipeline the initial sync call
      handleEmptyQuery(connection) {
        if (this.rows) {
          connection.sync();
        }
      }
      handleError(err, connection) {
        if (this._canceledDueToError) {
          err = this._canceledDueToError;
          this._canceledDueToError = false;
        }
        if (this.callback) {
          return this.callback(err);
        }
        this.emit("error", err);
      }
      handleReadyForQuery(con) {
        if (this._canceledDueToError) {
          return this.handleError(this._canceledDueToError, con);
        }
        if (this.callback) {
          try {
            this.callback(null, this._results);
          } catch (err) {
            process.nextTick(() => {
              throw err;
            });
          }
        }
        this.emit("end", this._results);
      }
      submit(connection) {
        if (typeof this.text !== "string" && typeof this.name !== "string") {
          return new Error("A query must have either text or a name. Supplying neither is unsupported.");
        }
        const previous = connection.parsedStatements[this.name];
        if (this.text && previous && this.text !== previous) {
          return new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
        }
        if (this.values && !Array.isArray(this.values)) {
          return new Error("Query values must be an array");
        }
        if (this.requiresPreparation()) {
          connection.stream.cork && connection.stream.cork();
          try {
            this.prepare(connection);
          } finally {
            connection.stream.uncork && connection.stream.uncork();
          }
        } else {
          connection.query(this.text);
        }
        return null;
      }
      hasBeenParsed(connection) {
        return this.name && connection.parsedStatements[this.name];
      }
      handlePortalSuspended(connection) {
        this._getRows(connection, this.rows);
      }
      _getRows(connection, rows) {
        connection.execute({
          portal: this.portal,
          rows
        });
        if (!rows) {
          connection.sync();
        } else {
          connection.flush();
        }
      }
      // http://developer.postgresql.org/pgdocs/postgres/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY
      prepare(connection) {
        if (!this.hasBeenParsed(connection)) {
          connection.parse({
            text: this.text,
            name: this.name,
            types: this.types
          });
        }
        try {
          connection.bind({
            portal: this.portal,
            statement: this.name,
            values: this.values,
            binary: this.binary,
            valueMapper: utils.prepareValue
          });
        } catch (err) {
          this.handleError(err, connection);
          return;
        }
        connection.describe({
          type: "P",
          name: this.portal || ""
        });
        this._getRows(connection, this.rows);
      }
      handleCopyInResponse(connection) {
        connection.sendCopyFail("No source stream defined");
      }
      handleCopyData(msg, connection) {
      }
    };
    module2.exports = Query;
  }
});

// node_modules/pg-protocol/dist/messages.js
var require_messages = __commonJS({
  "node_modules/pg-protocol/dist/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NoticeMessage = exports2.DataRowMessage = exports2.CommandCompleteMessage = exports2.ReadyForQueryMessage = exports2.NotificationResponseMessage = exports2.BackendKeyDataMessage = exports2.AuthenticationMD5Password = exports2.ParameterStatusMessage = exports2.ParameterDescriptionMessage = exports2.RowDescriptionMessage = exports2.Field = exports2.CopyResponse = exports2.CopyDataMessage = exports2.DatabaseError = exports2.copyDone = exports2.emptyQuery = exports2.replicationStart = exports2.portalSuspended = exports2.noData = exports2.closeComplete = exports2.bindComplete = exports2.parseComplete = void 0;
    exports2.parseComplete = {
      name: "parseComplete",
      length: 5
    };
    exports2.bindComplete = {
      name: "bindComplete",
      length: 5
    };
    exports2.closeComplete = {
      name: "closeComplete",
      length: 5
    };
    exports2.noData = {
      name: "noData",
      length: 5
    };
    exports2.portalSuspended = {
      name: "portalSuspended",
      length: 5
    };
    exports2.replicationStart = {
      name: "replicationStart",
      length: 4
    };
    exports2.emptyQuery = {
      name: "emptyQuery",
      length: 4
    };
    exports2.copyDone = {
      name: "copyDone",
      length: 4
    };
    var DatabaseError = class extends Error {
      constructor(message, length, name) {
        super(message);
        this.length = length;
        this.name = name;
      }
    };
    exports2.DatabaseError = DatabaseError;
    var CopyDataMessage = class {
      constructor(length, chunk) {
        this.length = length;
        this.chunk = chunk;
        this.name = "copyData";
      }
    };
    exports2.CopyDataMessage = CopyDataMessage;
    var CopyResponse = class {
      constructor(length, name, binary, columnCount) {
        this.length = length;
        this.name = name;
        this.binary = binary;
        this.columnTypes = new Array(columnCount);
      }
    };
    exports2.CopyResponse = CopyResponse;
    var Field = class {
      constructor(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, format) {
        this.name = name;
        this.tableID = tableID;
        this.columnID = columnID;
        this.dataTypeID = dataTypeID;
        this.dataTypeSize = dataTypeSize;
        this.dataTypeModifier = dataTypeModifier;
        this.format = format;
      }
    };
    exports2.Field = Field;
    var RowDescriptionMessage = class {
      constructor(length, fieldCount) {
        this.length = length;
        this.fieldCount = fieldCount;
        this.name = "rowDescription";
        this.fields = new Array(this.fieldCount);
      }
    };
    exports2.RowDescriptionMessage = RowDescriptionMessage;
    var ParameterDescriptionMessage = class {
      constructor(length, parameterCount) {
        this.length = length;
        this.parameterCount = parameterCount;
        this.name = "parameterDescription";
        this.dataTypeIDs = new Array(this.parameterCount);
      }
    };
    exports2.ParameterDescriptionMessage = ParameterDescriptionMessage;
    var ParameterStatusMessage = class {
      constructor(length, parameterName, parameterValue) {
        this.length = length;
        this.parameterName = parameterName;
        this.parameterValue = parameterValue;
        this.name = "parameterStatus";
      }
    };
    exports2.ParameterStatusMessage = ParameterStatusMessage;
    var AuthenticationMD5Password = class {
      constructor(length, salt) {
        this.length = length;
        this.salt = salt;
        this.name = "authenticationMD5Password";
      }
    };
    exports2.AuthenticationMD5Password = AuthenticationMD5Password;
    var BackendKeyDataMessage = class {
      constructor(length, processID, secretKey) {
        this.length = length;
        this.processID = processID;
        this.secretKey = secretKey;
        this.name = "backendKeyData";
      }
    };
    exports2.BackendKeyDataMessage = BackendKeyDataMessage;
    var NotificationResponseMessage = class {
      constructor(length, processId, channel, payload) {
        this.length = length;
        this.processId = processId;
        this.channel = channel;
        this.payload = payload;
        this.name = "notification";
      }
    };
    exports2.NotificationResponseMessage = NotificationResponseMessage;
    var ReadyForQueryMessage = class {
      constructor(length, status) {
        this.length = length;
        this.status = status;
        this.name = "readyForQuery";
      }
    };
    exports2.ReadyForQueryMessage = ReadyForQueryMessage;
    var CommandCompleteMessage = class {
      constructor(length, text) {
        this.length = length;
        this.text = text;
        this.name = "commandComplete";
      }
    };
    exports2.CommandCompleteMessage = CommandCompleteMessage;
    var DataRowMessage = class {
      constructor(length, fields) {
        this.length = length;
        this.fields = fields;
        this.name = "dataRow";
        this.fieldCount = fields.length;
      }
    };
    exports2.DataRowMessage = DataRowMessage;
    var NoticeMessage = class {
      constructor(length, message) {
        this.length = length;
        this.message = message;
        this.name = "notice";
      }
    };
    exports2.NoticeMessage = NoticeMessage;
  }
});

// node_modules/pg-protocol/dist/buffer-writer.js
var require_buffer_writer = __commonJS({
  "node_modules/pg-protocol/dist/buffer-writer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Writer = void 0;
    var Writer = class {
      constructor(size = 256) {
        this.size = size;
        this.offset = 5;
        this.headerPosition = 0;
        this.buffer = Buffer.allocUnsafe(size);
      }
      ensure(size) {
        const remaining = this.buffer.length - this.offset;
        if (remaining < size) {
          const oldBuffer = this.buffer;
          const newSize = oldBuffer.length + (oldBuffer.length >> 1) + size;
          this.buffer = Buffer.allocUnsafe(newSize);
          oldBuffer.copy(this.buffer);
        }
      }
      addInt32(num) {
        this.ensure(4);
        this.buffer[this.offset++] = num >>> 24 & 255;
        this.buffer[this.offset++] = num >>> 16 & 255;
        this.buffer[this.offset++] = num >>> 8 & 255;
        this.buffer[this.offset++] = num >>> 0 & 255;
        return this;
      }
      addInt16(num) {
        this.ensure(2);
        this.buffer[this.offset++] = num >>> 8 & 255;
        this.buffer[this.offset++] = num >>> 0 & 255;
        return this;
      }
      addCString(string) {
        if (!string) {
          this.ensure(1);
        } else {
          const len = Buffer.byteLength(string);
          this.ensure(len + 1);
          this.buffer.write(string, this.offset, "utf-8");
          this.offset += len;
        }
        this.buffer[this.offset++] = 0;
        return this;
      }
      addString(string = "") {
        const len = Buffer.byteLength(string);
        this.ensure(len);
        this.buffer.write(string, this.offset);
        this.offset += len;
        return this;
      }
      add(otherBuffer) {
        this.ensure(otherBuffer.length);
        otherBuffer.copy(this.buffer, this.offset);
        this.offset += otherBuffer.length;
        return this;
      }
      join(code) {
        if (code) {
          this.buffer[this.headerPosition] = code;
          const length = this.offset - (this.headerPosition + 1);
          this.buffer.writeInt32BE(length, this.headerPosition + 1);
        }
        return this.buffer.slice(code ? 0 : 5, this.offset);
      }
      flush(code) {
        const result = this.join(code);
        this.offset = 5;
        this.headerPosition = 0;
        this.buffer = Buffer.allocUnsafe(this.size);
        return result;
      }
    };
    exports2.Writer = Writer;
  }
});

// node_modules/pg-protocol/dist/serializer.js
var require_serializer = __commonJS({
  "node_modules/pg-protocol/dist/serializer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.serialize = void 0;
    var buffer_writer_1 = require_buffer_writer();
    var writer = new buffer_writer_1.Writer();
    var startup = (opts) => {
      writer.addInt16(3).addInt16(0);
      for (const key of Object.keys(opts)) {
        writer.addCString(key).addCString(opts[key]);
      }
      writer.addCString("client_encoding").addCString("UTF8");
      const bodyBuffer = writer.addCString("").flush();
      const length = bodyBuffer.length + 4;
      return new buffer_writer_1.Writer().addInt32(length).add(bodyBuffer).flush();
    };
    var requestSsl = () => {
      const response = Buffer.allocUnsafe(8);
      response.writeInt32BE(8, 0);
      response.writeInt32BE(80877103, 4);
      return response;
    };
    var password = (password2) => {
      return writer.addCString(password2).flush(
        112
        /* code.startup */
      );
    };
    var sendSASLInitialResponseMessage = function(mechanism, initialResponse) {
      writer.addCString(mechanism).addInt32(Buffer.byteLength(initialResponse)).addString(initialResponse);
      return writer.flush(
        112
        /* code.startup */
      );
    };
    var sendSCRAMClientFinalMessage = function(additionalData) {
      return writer.addString(additionalData).flush(
        112
        /* code.startup */
      );
    };
    var query = (text) => {
      return writer.addCString(text).flush(
        81
        /* code.query */
      );
    };
    var emptyArray = [];
    var parse = (query2) => {
      const name = query2.name || "";
      if (name.length > 63) {
        console.error("Warning! Postgres only supports 63 characters for query names.");
        console.error("You supplied %s (%s)", name, name.length);
        console.error("This can cause conflicts and silent errors executing queries");
      }
      const types = query2.types || emptyArray;
      const len = types.length;
      const buffer = writer.addCString(name).addCString(query2.text).addInt16(len);
      for (let i = 0; i < len; i++) {
        buffer.addInt32(types[i]);
      }
      return writer.flush(
        80
        /* code.parse */
      );
    };
    var paramWriter = new buffer_writer_1.Writer();
    var writeValues = function(values, valueMapper) {
      for (let i = 0; i < values.length; i++) {
        const mappedVal = valueMapper ? valueMapper(values[i], i) : values[i];
        if (mappedVal == null) {
          writer.addInt16(
            0
            /* ParamType.STRING */
          );
          paramWriter.addInt32(-1);
        } else if (mappedVal instanceof Buffer) {
          writer.addInt16(
            1
            /* ParamType.BINARY */
          );
          paramWriter.addInt32(mappedVal.length);
          paramWriter.add(mappedVal);
        } else {
          writer.addInt16(
            0
            /* ParamType.STRING */
          );
          paramWriter.addInt32(Buffer.byteLength(mappedVal));
          paramWriter.addString(mappedVal);
        }
      }
    };
    var bind = (config = {}) => {
      const portal = config.portal || "";
      const statement = config.statement || "";
      const binary = config.binary || false;
      const values = config.values || emptyArray;
      const len = values.length;
      writer.addCString(portal).addCString(statement);
      writer.addInt16(len);
      writeValues(values, config.valueMapper);
      writer.addInt16(len);
      writer.add(paramWriter.flush());
      writer.addInt16(1);
      writer.addInt16(
        binary ? 1 : 0
        /* ParamType.STRING */
      );
      return writer.flush(
        66
        /* code.bind */
      );
    };
    var emptyExecute = Buffer.from([69, 0, 0, 0, 9, 0, 0, 0, 0, 0]);
    var execute = (config) => {
      if (!config || !config.portal && !config.rows) {
        return emptyExecute;
      }
      const portal = config.portal || "";
      const rows = config.rows || 0;
      const portalLength = Buffer.byteLength(portal);
      const len = 4 + portalLength + 1 + 4;
      const buff = Buffer.allocUnsafe(1 + len);
      buff[0] = 69;
      buff.writeInt32BE(len, 1);
      buff.write(portal, 5, "utf-8");
      buff[portalLength + 5] = 0;
      buff.writeUInt32BE(rows, buff.length - 4);
      return buff;
    };
    var cancel = (processID, secretKey) => {
      const buffer = Buffer.allocUnsafe(16);
      buffer.writeInt32BE(16, 0);
      buffer.writeInt16BE(1234, 4);
      buffer.writeInt16BE(5678, 6);
      buffer.writeInt32BE(processID, 8);
      buffer.writeInt32BE(secretKey, 12);
      return buffer;
    };
    var cstringMessage = (code, string) => {
      const stringLen = Buffer.byteLength(string);
      const len = 4 + stringLen + 1;
      const buffer = Buffer.allocUnsafe(1 + len);
      buffer[0] = code;
      buffer.writeInt32BE(len, 1);
      buffer.write(string, 5, "utf-8");
      buffer[len] = 0;
      return buffer;
    };
    var emptyDescribePortal = writer.addCString("P").flush(
      68
      /* code.describe */
    );
    var emptyDescribeStatement = writer.addCString("S").flush(
      68
      /* code.describe */
    );
    var describe = (msg) => {
      return msg.name ? cstringMessage(68, `${msg.type}${msg.name || ""}`) : msg.type === "P" ? emptyDescribePortal : emptyDescribeStatement;
    };
    var close = (msg) => {
      const text = `${msg.type}${msg.name || ""}`;
      return cstringMessage(67, text);
    };
    var copyData = (chunk) => {
      return writer.add(chunk).flush(
        100
        /* code.copyFromChunk */
      );
    };
    var copyFail = (message) => {
      return cstringMessage(102, message);
    };
    var codeOnlyBuffer = (code) => Buffer.from([code, 0, 0, 0, 4]);
    var flushBuffer = codeOnlyBuffer(
      72
      /* code.flush */
    );
    var syncBuffer = codeOnlyBuffer(
      83
      /* code.sync */
    );
    var endBuffer = codeOnlyBuffer(
      88
      /* code.end */
    );
    var copyDoneBuffer = codeOnlyBuffer(
      99
      /* code.copyDone */
    );
    var serialize2 = {
      startup,
      password,
      requestSsl,
      sendSASLInitialResponseMessage,
      sendSCRAMClientFinalMessage,
      query,
      parse,
      bind,
      execute,
      describe,
      close,
      flush: () => flushBuffer,
      sync: () => syncBuffer,
      end: () => endBuffer,
      copyData,
      copyDone: () => copyDoneBuffer,
      copyFail,
      cancel
    };
    exports2.serialize = serialize2;
  }
});

// node_modules/pg-protocol/dist/buffer-reader.js
var require_buffer_reader = __commonJS({
  "node_modules/pg-protocol/dist/buffer-reader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BufferReader = void 0;
    var emptyBuffer = Buffer.allocUnsafe(0);
    var BufferReader = class {
      constructor(offset = 0) {
        this.offset = offset;
        this.buffer = emptyBuffer;
        this.encoding = "utf-8";
      }
      setBuffer(offset, buffer) {
        this.offset = offset;
        this.buffer = buffer;
      }
      int16() {
        const result = this.buffer.readInt16BE(this.offset);
        this.offset += 2;
        return result;
      }
      byte() {
        const result = this.buffer[this.offset];
        this.offset++;
        return result;
      }
      int32() {
        const result = this.buffer.readInt32BE(this.offset);
        this.offset += 4;
        return result;
      }
      uint32() {
        const result = this.buffer.readUInt32BE(this.offset);
        this.offset += 4;
        return result;
      }
      string(length) {
        const result = this.buffer.toString(this.encoding, this.offset, this.offset + length);
        this.offset += length;
        return result;
      }
      cstring() {
        const start = this.offset;
        let end = start;
        while (this.buffer[end++] !== 0) {
        }
        this.offset = end;
        return this.buffer.toString(this.encoding, start, end - 1);
      }
      bytes(length) {
        const result = this.buffer.slice(this.offset, this.offset + length);
        this.offset += length;
        return result;
      }
    };
    exports2.BufferReader = BufferReader;
  }
});

// node_modules/pg-protocol/dist/parser.js
var require_parser = __commonJS({
  "node_modules/pg-protocol/dist/parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Parser = void 0;
    var messages_1 = require_messages();
    var buffer_reader_1 = require_buffer_reader();
    var CODE_LENGTH = 1;
    var LEN_LENGTH = 4;
    var HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH;
    var emptyBuffer = Buffer.allocUnsafe(0);
    var Parser = class {
      constructor(opts) {
        this.buffer = emptyBuffer;
        this.bufferLength = 0;
        this.bufferOffset = 0;
        this.reader = new buffer_reader_1.BufferReader();
        if ((opts === null || opts === void 0 ? void 0 : opts.mode) === "binary") {
          throw new Error("Binary mode not supported yet");
        }
        this.mode = (opts === null || opts === void 0 ? void 0 : opts.mode) || "text";
      }
      parse(buffer, callback) {
        this.mergeBuffer(buffer);
        const bufferFullLength = this.bufferOffset + this.bufferLength;
        let offset = this.bufferOffset;
        while (offset + HEADER_LENGTH <= bufferFullLength) {
          const code = this.buffer[offset];
          const length = this.buffer.readUInt32BE(offset + CODE_LENGTH);
          const fullMessageLength = CODE_LENGTH + length;
          if (fullMessageLength + offset <= bufferFullLength) {
            const message = this.handlePacket(offset + HEADER_LENGTH, code, length, this.buffer);
            callback(message);
            offset += fullMessageLength;
          } else {
            break;
          }
        }
        if (offset === bufferFullLength) {
          this.buffer = emptyBuffer;
          this.bufferLength = 0;
          this.bufferOffset = 0;
        } else {
          this.bufferLength = bufferFullLength - offset;
          this.bufferOffset = offset;
        }
      }
      mergeBuffer(buffer) {
        if (this.bufferLength > 0) {
          const newLength = this.bufferLength + buffer.byteLength;
          const newFullLength = newLength + this.bufferOffset;
          if (newFullLength > this.buffer.byteLength) {
            let newBuffer;
            if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) {
              newBuffer = this.buffer;
            } else {
              let newBufferLength = this.buffer.byteLength * 2;
              while (newLength >= newBufferLength) {
                newBufferLength *= 2;
              }
              newBuffer = Buffer.allocUnsafe(newBufferLength);
            }
            this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength);
            this.buffer = newBuffer;
            this.bufferOffset = 0;
          }
          buffer.copy(this.buffer, this.bufferOffset + this.bufferLength);
          this.bufferLength = newLength;
        } else {
          this.buffer = buffer;
          this.bufferOffset = 0;
          this.bufferLength = buffer.byteLength;
        }
      }
      handlePacket(offset, code, length, bytes) {
        switch (code) {
          case 50:
            return messages_1.bindComplete;
          case 49:
            return messages_1.parseComplete;
          case 51:
            return messages_1.closeComplete;
          case 110:
            return messages_1.noData;
          case 115:
            return messages_1.portalSuspended;
          case 99:
            return messages_1.copyDone;
          case 87:
            return messages_1.replicationStart;
          case 73:
            return messages_1.emptyQuery;
          case 68:
            return this.parseDataRowMessage(offset, length, bytes);
          case 67:
            return this.parseCommandCompleteMessage(offset, length, bytes);
          case 90:
            return this.parseReadyForQueryMessage(offset, length, bytes);
          case 65:
            return this.parseNotificationMessage(offset, length, bytes);
          case 82:
            return this.parseAuthenticationResponse(offset, length, bytes);
          case 83:
            return this.parseParameterStatusMessage(offset, length, bytes);
          case 75:
            return this.parseBackendKeyData(offset, length, bytes);
          case 69:
            return this.parseErrorMessage(offset, length, bytes, "error");
          case 78:
            return this.parseErrorMessage(offset, length, bytes, "notice");
          case 84:
            return this.parseRowDescriptionMessage(offset, length, bytes);
          case 116:
            return this.parseParameterDescriptionMessage(offset, length, bytes);
          case 71:
            return this.parseCopyInMessage(offset, length, bytes);
          case 72:
            return this.parseCopyOutMessage(offset, length, bytes);
          case 100:
            return this.parseCopyData(offset, length, bytes);
          default:
            return new messages_1.DatabaseError("received invalid response: " + code.toString(16), length, "error");
        }
      }
      parseReadyForQueryMessage(offset, length, bytes) {
        this.reader.setBuffer(offset, bytes);
        const status = this.reader.string(1);
        return new messages_1.ReadyForQueryMessage(length, status);
      }
      parseCommandCompleteMessage(offset, length, bytes) {
        this.reader.setBuffer(offset, bytes);
        const text = this.reader.cstring();
        return new messages_1.CommandCompleteMessage(length, text);
      }
      parseCopyData(offset, length, bytes) {
        const chunk = bytes.slice(offset, offset + (length - 4));
        return new messages_1.CopyDataMessage(length, chunk);
      }
      parseCopyInMessage(offset, length, bytes) {
        return this.parseCopyMessage(offset, length, bytes, "copyInResponse");
      }
      parseCopyOutMessage(offset, length, bytes) {
        return this.parseCopyMessage(offset, length, bytes, "copyOutResponse");
      }
      parseCopyMessage(offset, length, bytes, messageName) {
        this.reader.setBuffer(offset, bytes);
        const isBinary = this.reader.byte() !== 0;
        const columnCount = this.reader.int16();
        const message = new messages_1.CopyResponse(length, messageName, isBinary, columnCount);
        for (let i = 0; i < columnCount; i++) {
          message.columnTypes[i] = this.reader.int16();
        }
        return message;
      }
      parseNotificationMessage(offset, length, bytes) {
        this.reader.setBuffer(offset, bytes);
        const processId = this.reader.int32();
        const channel = this.reader.cstring();
        const payload = this.reader.cstring();
        return new messages_1.NotificationResponseMessage(length, processId, channel, payload);
      }
      parseRowDescriptionMessage(offset, length, bytes) {
        this.reader.setBuffer(offset, bytes);
        const fieldCount = this.reader.int16();
        const message = new messages_1.RowDescriptionMessage(length, fieldCount);
        for (let i = 0; i < fieldCount; i++) {
          message.fields[i] = this.parseField();
        }
        return message;
      }
      parseField() {
        const name = this.reader.cstring();
        const tableID = this.reader.uint32();
        const columnID = this.reader.int16();
        const dataTypeID = this.reader.uint32();
        const dataTypeSize = this.reader.int16();
        const dataTypeModifier = this.reader.int32();
        const mode = this.reader.int16() === 0 ? "text" : "binary";
        return new messages_1.Field(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode);
      }
      parseParameterDescriptionMessage(offset, length, bytes) {
        this.reader.setBuffer(offset, bytes);
        const parameterCount = this.reader.int16();
        const message = new messages_1.ParameterDescriptionMessage(length, parameterCount);
        for (let i = 0; i < parameterCount; i++) {
          message.dataTypeIDs[i] = this.reader.int32();
        }
        return message;
      }
      parseDataRowMessage(offset, length, bytes) {
        this.reader.setBuffer(offset, bytes);
        const fieldCount = this.reader.int16();
        const fields = new Array(fieldCount);
        for (let i = 0; i < fieldCount; i++) {
          const len = this.reader.int32();
          fields[i] = len === -1 ? null : this.reader.string(len);
        }
        return new messages_1.DataRowMessage(length, fields);
      }
      parseParameterStatusMessage(offset, length, bytes) {
        this.reader.setBuffer(offset, bytes);
        const name = this.reader.cstring();
        const value = this.reader.cstring();
        return new messages_1.ParameterStatusMessage(length, name, value);
      }
      parseBackendKeyData(offset, length, bytes) {
        this.reader.setBuffer(offset, bytes);
        const processID = this.reader.int32();
        const secretKey = this.reader.int32();
        return new messages_1.BackendKeyDataMessage(length, processID, secretKey);
      }
      parseAuthenticationResponse(offset, length, bytes) {
        this.reader.setBuffer(offset, bytes);
        const code = this.reader.int32();
        const message = {
          name: "authenticationOk",
          length
        };
        switch (code) {
          case 0:
            break;
          case 3:
            if (message.length === 8) {
              message.name = "authenticationCleartextPassword";
            }
            break;
          case 5:
            if (message.length === 12) {
              message.name = "authenticationMD5Password";
              const salt = this.reader.bytes(4);
              return new messages_1.AuthenticationMD5Password(length, salt);
            }
            break;
          case 10:
            {
              message.name = "authenticationSASL";
              message.mechanisms = [];
              let mechanism;
              do {
                mechanism = this.reader.cstring();
                if (mechanism) {
                  message.mechanisms.push(mechanism);
                }
              } while (mechanism);
            }
            break;
          case 11:
            message.name = "authenticationSASLContinue";
            message.data = this.reader.string(length - 8);
            break;
          case 12:
            message.name = "authenticationSASLFinal";
            message.data = this.reader.string(length - 8);
            break;
          default:
            throw new Error("Unknown authenticationOk message type " + code);
        }
        return message;
      }
      parseErrorMessage(offset, length, bytes, name) {
        this.reader.setBuffer(offset, bytes);
        const fields = {};
        let fieldType = this.reader.string(1);
        while (fieldType !== "\0") {
          fields[fieldType] = this.reader.cstring();
          fieldType = this.reader.string(1);
        }
        const messageValue = fields.M;
        const message = name === "notice" ? new messages_1.NoticeMessage(length, messageValue) : new messages_1.DatabaseError(messageValue, length, name);
        message.severity = fields.S;
        message.code = fields.C;
        message.detail = fields.D;
        message.hint = fields.H;
        message.position = fields.P;
        message.internalPosition = fields.p;
        message.internalQuery = fields.q;
        message.where = fields.W;
        message.schema = fields.s;
        message.table = fields.t;
        message.column = fields.c;
        message.dataType = fields.d;
        message.constraint = fields.n;
        message.file = fields.F;
        message.line = fields.L;
        message.routine = fields.R;
        return message;
      }
    };
    exports2.Parser = Parser;
  }
});

// node_modules/pg-protocol/dist/index.js
var require_dist = __commonJS({
  "node_modules/pg-protocol/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DatabaseError = exports2.serialize = exports2.parse = void 0;
    var messages_1 = require_messages();
    Object.defineProperty(exports2, "DatabaseError", { enumerable: true, get: function() {
      return messages_1.DatabaseError;
    } });
    var serializer_1 = require_serializer();
    Object.defineProperty(exports2, "serialize", { enumerable: true, get: function() {
      return serializer_1.serialize;
    } });
    var parser_1 = require_parser();
    function parse(stream, callback) {
      const parser = new parser_1.Parser();
      stream.on("data", (buffer) => parser.parse(buffer, callback));
      return new Promise((resolve) => stream.on("end", () => resolve()));
    }
    exports2.parse = parse;
  }
});

// node_modules/pg-cloudflare/dist/empty.js
var require_empty = __commonJS({
  "node_modules/pg-cloudflare/dist/empty.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = {};
  }
});

// node_modules/pg/lib/stream.js
var require_stream = __commonJS({
  "node_modules/pg/lib/stream.js"(exports2, module2) {
    var { getStream, getSecureStream } = getStreamFuncs();
    module2.exports = {
      /**
       * Get a socket stream compatible with the current runtime environment.
       * @returns {Duplex}
       */
      getStream,
      /**
       * Get a TLS secured socket, compatible with the current environment,
       * using the socket and other settings given in `options`.
       * @returns {Duplex}
       */
      getSecureStream
    };
    function getNodejsStreamFuncs() {
      function getStream2(ssl) {
        const net = require("net");
        return new net.Socket();
      }
      function getSecureStream2(options) {
        const tls = require("tls");
        return tls.connect(options);
      }
      return {
        getStream: getStream2,
        getSecureStream: getSecureStream2
      };
    }
    function getCloudflareStreamFuncs() {
      function getStream2(ssl) {
        const { CloudflareSocket } = require_empty();
        return new CloudflareSocket(ssl);
      }
      function getSecureStream2(options) {
        options.socket.startTls(options);
        return options.socket;
      }
      return {
        getStream: getStream2,
        getSecureStream: getSecureStream2
      };
    }
    function isCloudflareRuntime() {
      if (typeof navigator === "object" && navigator !== null && typeof navigator.userAgent === "string") {
        return navigator.userAgent === "Cloudflare-Workers";
      }
      if (typeof Response === "function") {
        const resp = new Response(null, { cf: { thing: true } });
        if (typeof resp.cf === "object" && resp.cf !== null && resp.cf.thing) {
          return true;
        }
      }
      return false;
    }
    function getStreamFuncs() {
      if (isCloudflareRuntime()) {
        return getCloudflareStreamFuncs();
      }
      return getNodejsStreamFuncs();
    }
  }
});

// node_modules/pg/lib/connection.js
var require_connection = __commonJS({
  "node_modules/pg/lib/connection.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var { parse, serialize: serialize2 } = require_dist();
    var { getStream, getSecureStream } = require_stream();
    var flushBuffer = serialize2.flush();
    var syncBuffer = serialize2.sync();
    var endBuffer = serialize2.end();
    var Connection2 = class extends EventEmitter {
      constructor(config) {
        super();
        config = config || {};
        this.stream = config.stream || getStream(config.ssl);
        if (typeof this.stream === "function") {
          this.stream = this.stream(config);
        }
        this._keepAlive = config.keepAlive;
        this._keepAliveInitialDelayMillis = config.keepAliveInitialDelayMillis;
        this.lastBuffer = false;
        this.parsedStatements = {};
        this.ssl = config.ssl || false;
        this._ending = false;
        this._emitMessage = false;
        const self2 = this;
        this.on("newListener", function(eventName) {
          if (eventName === "message") {
            self2._emitMessage = true;
          }
        });
      }
      connect(port, host) {
        const self2 = this;
        this._connecting = true;
        this.stream.setNoDelay(true);
        this.stream.connect(port, host);
        this.stream.once("connect", function() {
          if (self2._keepAlive) {
            self2.stream.setKeepAlive(true, self2._keepAliveInitialDelayMillis);
          }
          self2.emit("connect");
        });
        const reportStreamError = function(error) {
          if (self2._ending && (error.code === "ECONNRESET" || error.code === "EPIPE")) {
            return;
          }
          self2.emit("error", error);
        };
        this.stream.on("error", reportStreamError);
        this.stream.on("close", function() {
          self2.emit("end");
        });
        if (!this.ssl) {
          return this.attachListeners(this.stream);
        }
        this.stream.once("data", function(buffer) {
          const responseCode = buffer.toString("utf8");
          switch (responseCode) {
            case "S":
              break;
            case "N":
              self2.stream.end();
              return self2.emit("error", new Error("The server does not support SSL connections"));
            default:
              self2.stream.end();
              return self2.emit("error", new Error("There was an error establishing an SSL connection"));
          }
          const options = {
            socket: self2.stream
          };
          if (self2.ssl !== true) {
            Object.assign(options, self2.ssl);
            if ("key" in self2.ssl) {
              options.key = self2.ssl.key;
            }
          }
          const net = require("net");
          if (net.isIP && net.isIP(host) === 0) {
            options.servername = host;
          }
          try {
            self2.stream = getSecureStream(options);
          } catch (err) {
            return self2.emit("error", err);
          }
          self2.attachListeners(self2.stream);
          self2.stream.on("error", reportStreamError);
          self2.emit("sslconnect");
        });
      }
      attachListeners(stream) {
        parse(stream, (msg) => {
          const eventName = msg.name === "error" ? "errorMessage" : msg.name;
          if (this._emitMessage) {
            this.emit("message", msg);
          }
          this.emit(eventName, msg);
        });
      }
      requestSsl() {
        this.stream.write(serialize2.requestSsl());
      }
      startup(config) {
        this.stream.write(serialize2.startup(config));
      }
      cancel(processID, secretKey) {
        this._send(serialize2.cancel(processID, secretKey));
      }
      password(password) {
        this._send(serialize2.password(password));
      }
      sendSASLInitialResponseMessage(mechanism, initialResponse) {
        this._send(serialize2.sendSASLInitialResponseMessage(mechanism, initialResponse));
      }
      sendSCRAMClientFinalMessage(additionalData) {
        this._send(serialize2.sendSCRAMClientFinalMessage(additionalData));
      }
      _send(buffer) {
        if (!this.stream.writable) {
          return false;
        }
        return this.stream.write(buffer);
      }
      query(text) {
        this._send(serialize2.query(text));
      }
      // send parse message
      parse(query) {
        this._send(serialize2.parse(query));
      }
      // send bind message
      bind(config) {
        this._send(serialize2.bind(config));
      }
      // send execute message
      execute(config) {
        this._send(serialize2.execute(config));
      }
      flush() {
        if (this.stream.writable) {
          this.stream.write(flushBuffer);
        }
      }
      sync() {
        this._ending = true;
        this._send(syncBuffer);
      }
      ref() {
        this.stream.ref();
      }
      unref() {
        this.stream.unref();
      }
      end() {
        this._ending = true;
        if (!this._connecting || !this.stream.writable) {
          this.stream.end();
          return;
        }
        return this.stream.write(endBuffer, () => {
          this.stream.end();
        });
      }
      close(msg) {
        this._send(serialize2.close(msg));
      }
      describe(msg) {
        this._send(serialize2.describe(msg));
      }
      sendCopyFromChunk(chunk) {
        this._send(serialize2.copyData(chunk));
      }
      endCopyFrom() {
        this._send(serialize2.copyDone());
      }
      sendCopyFail(msg) {
        this._send(serialize2.copyFail(msg));
      }
    };
    module2.exports = Connection2;
  }
});

// node_modules/split2/index.js
var require_split2 = __commonJS({
  "node_modules/split2/index.js"(exports2, module2) {
    "use strict";
    var { Transform } = require("stream");
    var { StringDecoder } = require("string_decoder");
    var kLast = Symbol("last");
    var kDecoder = Symbol("decoder");
    function transform(chunk, enc, cb) {
      let list;
      if (this.overflow) {
        const buf = this[kDecoder].write(chunk);
        list = buf.split(this.matcher);
        if (list.length === 1) return cb();
        list.shift();
        this.overflow = false;
      } else {
        this[kLast] += this[kDecoder].write(chunk);
        list = this[kLast].split(this.matcher);
      }
      this[kLast] = list.pop();
      for (let i = 0; i < list.length; i++) {
        try {
          push(this, this.mapper(list[i]));
        } catch (error) {
          return cb(error);
        }
      }
      this.overflow = this[kLast].length > this.maxLength;
      if (this.overflow && !this.skipOverflow) {
        cb(new Error("maximum buffer reached"));
        return;
      }
      cb();
    }
    function flush(cb) {
      this[kLast] += this[kDecoder].end();
      if (this[kLast]) {
        try {
          push(this, this.mapper(this[kLast]));
        } catch (error) {
          return cb(error);
        }
      }
      cb();
    }
    function push(self2, val) {
      if (val !== void 0) {
        self2.push(val);
      }
    }
    function noop(incoming) {
      return incoming;
    }
    function split(matcher, mapper, options) {
      matcher = matcher || /\r?\n/;
      mapper = mapper || noop;
      options = options || {};
      switch (arguments.length) {
        case 1:
          if (typeof matcher === "function") {
            mapper = matcher;
            matcher = /\r?\n/;
          } else if (typeof matcher === "object" && !(matcher instanceof RegExp) && !matcher[Symbol.split]) {
            options = matcher;
            matcher = /\r?\n/;
          }
          break;
        case 2:
          if (typeof matcher === "function") {
            options = mapper;
            mapper = matcher;
            matcher = /\r?\n/;
          } else if (typeof mapper === "object") {
            options = mapper;
            mapper = noop;
          }
      }
      options = Object.assign({}, options);
      options.autoDestroy = true;
      options.transform = transform;
      options.flush = flush;
      options.readableObjectMode = true;
      const stream = new Transform(options);
      stream[kLast] = "";
      stream[kDecoder] = new StringDecoder("utf8");
      stream.matcher = matcher;
      stream.mapper = mapper;
      stream.maxLength = options.maxLength;
      stream.skipOverflow = options.skipOverflow || false;
      stream.overflow = false;
      stream._destroy = function(err, cb) {
        this._writableState.errorEmitted = false;
        cb(err);
      };
      return stream;
    }
    module2.exports = split;
  }
});

// node_modules/pgpass/lib/helper.js
var require_helper = __commonJS({
  "node_modules/pgpass/lib/helper.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var Stream = require("stream").Stream;
    var split = require_split2();
    var util = require("util");
    var defaultPort = 5432;
    var isWin = process.platform === "win32";
    var warnStream = process.stderr;
    var S_IRWXG = 56;
    var S_IRWXO = 7;
    var S_IFMT = 61440;
    var S_IFREG = 32768;
    function isRegFile(mode) {
      return (mode & S_IFMT) == S_IFREG;
    }
    var fieldNames = ["host", "port", "database", "user", "password"];
    var nrOfFields = fieldNames.length;
    var passKey = fieldNames[nrOfFields - 1];
    function warn() {
      var isWritable = warnStream instanceof Stream && true === warnStream.writable;
      if (isWritable) {
        var args = Array.prototype.slice.call(arguments).concat("\n");
        warnStream.write(util.format.apply(util, args));
      }
    }
    Object.defineProperty(module2.exports, "isWin", {
      get: function() {
        return isWin;
      },
      set: function(val) {
        isWin = val;
      }
    });
    module2.exports.warnTo = function(stream) {
      var old = warnStream;
      warnStream = stream;
      return old;
    };
    module2.exports.getFileName = function(rawEnv) {
      var env = rawEnv || process.env;
      var file = env.PGPASSFILE || (isWin ? path.join(env.APPDATA || "./", "postgresql", "pgpass.conf") : path.join(env.HOME || "./", ".pgpass"));
      return file;
    };
    module2.exports.usePgPass = function(stats, fname) {
      if (Object.prototype.hasOwnProperty.call(process.env, "PGPASSWORD")) {
        return false;
      }
      if (isWin) {
        return true;
      }
      fname = fname || "<unkn>";
      if (!isRegFile(stats.mode)) {
        warn('WARNING: password file "%s" is not a plain file', fname);
        return false;
      }
      if (stats.mode & (S_IRWXG | S_IRWXO)) {
        warn('WARNING: password file "%s" has group or world access; permissions should be u=rw (0600) or less', fname);
        return false;
      }
      return true;
    };
    var matcher = module2.exports.match = function(connInfo, entry) {
      return fieldNames.slice(0, -1).reduce(function(prev, field, idx) {
        if (idx == 1) {
          if (Number(connInfo[field] || defaultPort) === Number(entry[field])) {
            return prev && true;
          }
        }
        return prev && (entry[field] === "*" || entry[field] === connInfo[field]);
      }, true);
    };
    module2.exports.getPassword = function(connInfo, stream, cb) {
      var pass;
      var lineStream = stream.pipe(split());
      function onLine(line) {
        var entry = parseLine(line);
        if (entry && isValidEntry(entry) && matcher(connInfo, entry)) {
          pass = entry[passKey];
          lineStream.end();
        }
      }
      var onEnd = function() {
        stream.destroy();
        cb(pass);
      };
      var onErr = function(err) {
        stream.destroy();
        warn("WARNING: error on reading file: %s", err);
        cb(void 0);
      };
      stream.on("error", onErr);
      lineStream.on("data", onLine).on("end", onEnd).on("error", onErr);
    };
    var parseLine = module2.exports.parseLine = function(line) {
      if (line.length < 11 || line.match(/^\s+#/)) {
        return null;
      }
      var curChar = "";
      var prevChar = "";
      var fieldIdx = 0;
      var startIdx = 0;
      var endIdx = 0;
      var obj = {};
      var isLastField = false;
      var addToObj = function(idx, i0, i1) {
        var field = line.substring(i0, i1);
        if (!Object.hasOwnProperty.call(process.env, "PGPASS_NO_DEESCAPE")) {
          field = field.replace(/\\([:\\])/g, "$1");
        }
        obj[fieldNames[idx]] = field;
      };
      for (var i = 0; i < line.length - 1; i += 1) {
        curChar = line.charAt(i + 1);
        prevChar = line.charAt(i);
        isLastField = fieldIdx == nrOfFields - 1;
        if (isLastField) {
          addToObj(fieldIdx, startIdx);
          break;
        }
        if (i >= 0 && curChar == ":" && prevChar !== "\\") {
          addToObj(fieldIdx, startIdx, i + 1);
          startIdx = i + 2;
          fieldIdx += 1;
        }
      }
      obj = Object.keys(obj).length === nrOfFields ? obj : null;
      return obj;
    };
    var isValidEntry = module2.exports.isValidEntry = function(entry) {
      var rules = {
        // host
        0: function(x) {
          return x.length > 0;
        },
        // port
        1: function(x) {
          if (x === "*") {
            return true;
          }
          x = Number(x);
          return isFinite(x) && x > 0 && x < 9007199254740992 && Math.floor(x) === x;
        },
        // database
        2: function(x) {
          return x.length > 0;
        },
        // username
        3: function(x) {
          return x.length > 0;
        },
        // password
        4: function(x) {
          return x.length > 0;
        }
      };
      for (var idx = 0; idx < fieldNames.length; idx += 1) {
        var rule = rules[idx];
        var value = entry[fieldNames[idx]] || "";
        var res = rule(value);
        if (!res) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/pgpass/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/pgpass/lib/index.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var fs = require("fs");
    var helper = require_helper();
    module2.exports = function(connInfo, cb) {
      var file = helper.getFileName();
      fs.stat(file, function(err, stat) {
        if (err || !helper.usePgPass(stat, file)) {
          return cb(void 0);
        }
        var st = fs.createReadStream(file);
        helper.getPassword(connInfo, st, cb);
      });
    };
    module2.exports.warnTo = helper.warnTo;
  }
});

// node_modules/pg/lib/client.js
var require_client = __commonJS({
  "node_modules/pg/lib/client.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var utils = require_utils();
    var sasl = require_sasl();
    var TypeOverrides = require_type_overrides();
    var ConnectionParameters = require_connection_parameters();
    var Query = require_query();
    var defaults = require_defaults();
    var Connection2 = require_connection();
    var crypto2 = require_utils2();
    var Client = class extends EventEmitter {
      constructor(config) {
        super();
        this.connectionParameters = new ConnectionParameters(config);
        this.user = this.connectionParameters.user;
        this.database = this.connectionParameters.database;
        this.port = this.connectionParameters.port;
        this.host = this.connectionParameters.host;
        Object.defineProperty(this, "password", {
          configurable: true,
          enumerable: false,
          writable: true,
          value: this.connectionParameters.password
        });
        this.replication = this.connectionParameters.replication;
        const c = config || {};
        this._Promise = c.Promise || global.Promise;
        this._types = new TypeOverrides(c.types);
        this._ending = false;
        this._ended = false;
        this._connecting = false;
        this._connected = false;
        this._connectionError = false;
        this._queryable = true;
        this.enableChannelBinding = Boolean(c.enableChannelBinding);
        this.connection = c.connection || new Connection2({
          stream: c.stream,
          ssl: this.connectionParameters.ssl,
          keepAlive: c.keepAlive || false,
          keepAliveInitialDelayMillis: c.keepAliveInitialDelayMillis || 0,
          encoding: this.connectionParameters.client_encoding || "utf8"
        });
        this.queryQueue = [];
        this.binary = c.binary || defaults.binary;
        this.processID = null;
        this.secretKey = null;
        this.ssl = this.connectionParameters.ssl || false;
        if (this.ssl && this.ssl.key) {
          Object.defineProperty(this.ssl, "key", {
            enumerable: false
          });
        }
        this._connectionTimeoutMillis = c.connectionTimeoutMillis || 0;
      }
      _errorAllQueries(err) {
        const enqueueError = (query) => {
          process.nextTick(() => {
            query.handleError(err, this.connection);
          });
        };
        if (this.activeQuery) {
          enqueueError(this.activeQuery);
          this.activeQuery = null;
        }
        this.queryQueue.forEach(enqueueError);
        this.queryQueue.length = 0;
      }
      _connect(callback) {
        const self2 = this;
        const con = this.connection;
        this._connectionCallback = callback;
        if (this._connecting || this._connected) {
          const err = new Error("Client has already been connected. You cannot reuse a client.");
          process.nextTick(() => {
            callback(err);
          });
          return;
        }
        this._connecting = true;
        if (this._connectionTimeoutMillis > 0) {
          this.connectionTimeoutHandle = setTimeout(() => {
            con._ending = true;
            con.stream.destroy(new Error("timeout expired"));
          }, this._connectionTimeoutMillis);
          if (this.connectionTimeoutHandle.unref) {
            this.connectionTimeoutHandle.unref();
          }
        }
        if (this.host && this.host.indexOf("/") === 0) {
          con.connect(this.host + "/.s.PGSQL." + this.port);
        } else {
          con.connect(this.port, this.host);
        }
        con.on("connect", function() {
          if (self2.ssl) {
            con.requestSsl();
          } else {
            con.startup(self2.getStartupConf());
          }
        });
        con.on("sslconnect", function() {
          con.startup(self2.getStartupConf());
        });
        this._attachListeners(con);
        con.once("end", () => {
          const error = this._ending ? new Error("Connection terminated") : new Error("Connection terminated unexpectedly");
          clearTimeout(this.connectionTimeoutHandle);
          this._errorAllQueries(error);
          this._ended = true;
          if (!this._ending) {
            if (this._connecting && !this._connectionError) {
              if (this._connectionCallback) {
                this._connectionCallback(error);
              } else {
                this._handleErrorEvent(error);
              }
            } else if (!this._connectionError) {
              this._handleErrorEvent(error);
            }
          }
          process.nextTick(() => {
            this.emit("end");
          });
        });
      }
      connect(callback) {
        if (callback) {
          this._connect(callback);
          return;
        }
        return new this._Promise((resolve, reject) => {
          this._connect((error) => {
            if (error) {
              reject(error);
            } else {
              resolve();
            }
          });
        });
      }
      _attachListeners(con) {
        con.on("authenticationCleartextPassword", this._handleAuthCleartextPassword.bind(this));
        con.on("authenticationMD5Password", this._handleAuthMD5Password.bind(this));
        con.on("authenticationSASL", this._handleAuthSASL.bind(this));
        con.on("authenticationSASLContinue", this._handleAuthSASLContinue.bind(this));
        con.on("authenticationSASLFinal", this._handleAuthSASLFinal.bind(this));
        con.on("backendKeyData", this._handleBackendKeyData.bind(this));
        con.on("error", this._handleErrorEvent.bind(this));
        con.on("errorMessage", this._handleErrorMessage.bind(this));
        con.on("readyForQuery", this._handleReadyForQuery.bind(this));
        con.on("notice", this._handleNotice.bind(this));
        con.on("rowDescription", this._handleRowDescription.bind(this));
        con.on("dataRow", this._handleDataRow.bind(this));
        con.on("portalSuspended", this._handlePortalSuspended.bind(this));
        con.on("emptyQuery", this._handleEmptyQuery.bind(this));
        con.on("commandComplete", this._handleCommandComplete.bind(this));
        con.on("parseComplete", this._handleParseComplete.bind(this));
        con.on("copyInResponse", this._handleCopyInResponse.bind(this));
        con.on("copyData", this._handleCopyData.bind(this));
        con.on("notification", this._handleNotification.bind(this));
      }
      // TODO(bmc): deprecate pgpass "built in" integration since this.password can be a function
      // it can be supplied by the user if required - this is a breaking change!
      _checkPgPass(cb) {
        const con = this.connection;
        if (typeof this.password === "function") {
          this._Promise.resolve().then(() => this.password()).then((pass) => {
            if (pass !== void 0) {
              if (typeof pass !== "string") {
                con.emit("error", new TypeError("Password must be a string"));
                return;
              }
              this.connectionParameters.password = this.password = pass;
            } else {
              this.connectionParameters.password = this.password = null;
            }
            cb();
          }).catch((err) => {
            con.emit("error", err);
          });
        } else if (this.password !== null) {
          cb();
        } else {
          try {
            const pgPass = require_lib2();
            pgPass(this.connectionParameters, (pass) => {
              if (void 0 !== pass) {
                this.connectionParameters.password = this.password = pass;
              }
              cb();
            });
          } catch (e) {
            this.emit("error", e);
          }
        }
      }
      _handleAuthCleartextPassword(msg) {
        this._checkPgPass(() => {
          this.connection.password(this.password);
        });
      }
      _handleAuthMD5Password(msg) {
        this._checkPgPass(async () => {
          try {
            const hashedPassword = await crypto2.postgresMd5PasswordHash(this.user, this.password, msg.salt);
            this.connection.password(hashedPassword);
          } catch (e) {
            this.emit("error", e);
          }
        });
      }
      _handleAuthSASL(msg) {
        this._checkPgPass(() => {
          try {
            this.saslSession = sasl.startSession(msg.mechanisms, this.enableChannelBinding && this.connection.stream);
            this.connection.sendSASLInitialResponseMessage(this.saslSession.mechanism, this.saslSession.response);
          } catch (err) {
            this.connection.emit("error", err);
          }
        });
      }
      async _handleAuthSASLContinue(msg) {
        try {
          await sasl.continueSession(
            this.saslSession,
            this.password,
            msg.data,
            this.enableChannelBinding && this.connection.stream
          );
          this.connection.sendSCRAMClientFinalMessage(this.saslSession.response);
        } catch (err) {
          this.connection.emit("error", err);
        }
      }
      _handleAuthSASLFinal(msg) {
        try {
          sasl.finalizeSession(this.saslSession, msg.data);
          this.saslSession = null;
        } catch (err) {
          this.connection.emit("error", err);
        }
      }
      _handleBackendKeyData(msg) {
        this.processID = msg.processID;
        this.secretKey = msg.secretKey;
      }
      _handleReadyForQuery(msg) {
        if (this._connecting) {
          this._connecting = false;
          this._connected = true;
          clearTimeout(this.connectionTimeoutHandle);
          if (this._connectionCallback) {
            this._connectionCallback(null, this);
            this._connectionCallback = null;
          }
          this.emit("connect");
        }
        const { activeQuery } = this;
        this.activeQuery = null;
        this.readyForQuery = true;
        if (activeQuery) {
          activeQuery.handleReadyForQuery(this.connection);
        }
        this._pulseQueryQueue();
      }
      // if we receive an error event or error message
      // during the connection process we handle it here
      _handleErrorWhileConnecting(err) {
        if (this._connectionError) {
          return;
        }
        this._connectionError = true;
        clearTimeout(this.connectionTimeoutHandle);
        if (this._connectionCallback) {
          return this._connectionCallback(err);
        }
        this.emit("error", err);
      }
      // if we're connected and we receive an error event from the connection
      // this means the socket is dead - do a hard abort of all queries and emit
      // the socket error on the client as well
      _handleErrorEvent(err) {
        if (this._connecting) {
          return this._handleErrorWhileConnecting(err);
        }
        this._queryable = false;
        this._errorAllQueries(err);
        this.emit("error", err);
      }
      // handle error messages from the postgres backend
      _handleErrorMessage(msg) {
        if (this._connecting) {
          return this._handleErrorWhileConnecting(msg);
        }
        const activeQuery = this.activeQuery;
        if (!activeQuery) {
          this._handleErrorEvent(msg);
          return;
        }
        this.activeQuery = null;
        activeQuery.handleError(msg, this.connection);
      }
      _handleRowDescription(msg) {
        this.activeQuery.handleRowDescription(msg);
      }
      _handleDataRow(msg) {
        this.activeQuery.handleDataRow(msg);
      }
      _handlePortalSuspended(msg) {
        this.activeQuery.handlePortalSuspended(this.connection);
      }
      _handleEmptyQuery(msg) {
        this.activeQuery.handleEmptyQuery(this.connection);
      }
      _handleCommandComplete(msg) {
        if (this.activeQuery == null) {
          const error = new Error("Received unexpected commandComplete message from backend.");
          this._handleErrorEvent(error);
          return;
        }
        this.activeQuery.handleCommandComplete(msg, this.connection);
      }
      _handleParseComplete() {
        if (this.activeQuery == null) {
          const error = new Error("Received unexpected parseComplete message from backend.");
          this._handleErrorEvent(error);
          return;
        }
        if (this.activeQuery.name) {
          this.connection.parsedStatements[this.activeQuery.name] = this.activeQuery.text;
        }
      }
      _handleCopyInResponse(msg) {
        this.activeQuery.handleCopyInResponse(this.connection);
      }
      _handleCopyData(msg) {
        this.activeQuery.handleCopyData(msg, this.connection);
      }
      _handleNotification(msg) {
        this.emit("notification", msg);
      }
      _handleNotice(msg) {
        this.emit("notice", msg);
      }
      getStartupConf() {
        const params = this.connectionParameters;
        const data = {
          user: params.user,
          database: params.database
        };
        const appName = params.application_name || params.fallback_application_name;
        if (appName) {
          data.application_name = appName;
        }
        if (params.replication) {
          data.replication = "" + params.replication;
        }
        if (params.statement_timeout) {
          data.statement_timeout = String(parseInt(params.statement_timeout, 10));
        }
        if (params.lock_timeout) {
          data.lock_timeout = String(parseInt(params.lock_timeout, 10));
        }
        if (params.idle_in_transaction_session_timeout) {
          data.idle_in_transaction_session_timeout = String(parseInt(params.idle_in_transaction_session_timeout, 10));
        }
        if (params.options) {
          data.options = params.options;
        }
        return data;
      }
      cancel(client, query) {
        if (client.activeQuery === query) {
          const con = this.connection;
          if (this.host && this.host.indexOf("/") === 0) {
            con.connect(this.host + "/.s.PGSQL." + this.port);
          } else {
            con.connect(this.port, this.host);
          }
          con.on("connect", function() {
            con.cancel(client.processID, client.secretKey);
          });
        } else if (client.queryQueue.indexOf(query) !== -1) {
          client.queryQueue.splice(client.queryQueue.indexOf(query), 1);
        }
      }
      setTypeParser(oid, format, parseFn) {
        return this._types.setTypeParser(oid, format, parseFn);
      }
      getTypeParser(oid, format) {
        return this._types.getTypeParser(oid, format);
      }
      // escapeIdentifier and escapeLiteral moved to utility functions & exported
      // on PG
      // re-exported here for backwards compatibility
      escapeIdentifier(str) {
        return utils.escapeIdentifier(str);
      }
      escapeLiteral(str) {
        return utils.escapeLiteral(str);
      }
      _pulseQueryQueue() {
        if (this.readyForQuery === true) {
          this.activeQuery = this.queryQueue.shift();
          if (this.activeQuery) {
            this.readyForQuery = false;
            this.hasExecuted = true;
            const queryError = this.activeQuery.submit(this.connection);
            if (queryError) {
              process.nextTick(() => {
                this.activeQuery.handleError(queryError, this.connection);
                this.readyForQuery = true;
                this._pulseQueryQueue();
              });
            }
          } else if (this.hasExecuted) {
            this.activeQuery = null;
            this.emit("drain");
          }
        }
      }
      query(config, values, callback) {
        let query;
        let result;
        let readTimeout;
        let readTimeoutTimer;
        let queryCallback;
        if (config === null || config === void 0) {
          throw new TypeError("Client was passed a null or undefined query");
        } else if (typeof config.submit === "function") {
          readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
          result = query = config;
          if (typeof values === "function") {
            query.callback = query.callback || values;
          }
        } else {
          readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
          query = new Query(config, values, callback);
          if (!query.callback) {
            result = new this._Promise((resolve, reject) => {
              query.callback = (err, res) => err ? reject(err) : resolve(res);
            }).catch((err) => {
              Error.captureStackTrace(err);
              throw err;
            });
          }
        }
        if (readTimeout) {
          queryCallback = query.callback;
          readTimeoutTimer = setTimeout(() => {
            const error = new Error("Query read timeout");
            process.nextTick(() => {
              query.handleError(error, this.connection);
            });
            queryCallback(error);
            query.callback = () => {
            };
            const index = this.queryQueue.indexOf(query);
            if (index > -1) {
              this.queryQueue.splice(index, 1);
            }
            this._pulseQueryQueue();
          }, readTimeout);
          query.callback = (err, res) => {
            clearTimeout(readTimeoutTimer);
            queryCallback(err, res);
          };
        }
        if (this.binary && !query.binary) {
          query.binary = true;
        }
        if (query._result && !query._result._types) {
          query._result._types = this._types;
        }
        if (!this._queryable) {
          process.nextTick(() => {
            query.handleError(new Error("Client has encountered a connection error and is not queryable"), this.connection);
          });
          return result;
        }
        if (this._ending) {
          process.nextTick(() => {
            query.handleError(new Error("Client was closed and is not queryable"), this.connection);
          });
          return result;
        }
        this.queryQueue.push(query);
        this._pulseQueryQueue();
        return result;
      }
      ref() {
        this.connection.ref();
      }
      unref() {
        this.connection.unref();
      }
      end(cb) {
        this._ending = true;
        if (!this.connection._connecting || this._ended) {
          if (cb) {
            cb();
          } else {
            return this._Promise.resolve();
          }
        }
        if (this.activeQuery || !this._queryable) {
          this.connection.stream.destroy();
        } else {
          this.connection.end();
        }
        if (cb) {
          this.connection.once("end", cb);
        } else {
          return new this._Promise((resolve) => {
            this.connection.once("end", resolve);
          });
        }
      }
    };
    Client.Query = Query;
    module2.exports = Client;
  }
});

// node_modules/pg-pool/index.js
var require_pg_pool = __commonJS({
  "node_modules/pg-pool/index.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var NOOP = function() {
    };
    var removeWhere = (list, predicate) => {
      const i = list.findIndex(predicate);
      return i === -1 ? void 0 : list.splice(i, 1)[0];
    };
    var IdleItem = class {
      constructor(client, idleListener, timeoutId) {
        this.client = client;
        this.idleListener = idleListener;
        this.timeoutId = timeoutId;
      }
    };
    var PendingItem = class {
      constructor(callback) {
        this.callback = callback;
      }
    };
    function throwOnDoubleRelease() {
      throw new Error("Release called on client which has already been released to the pool.");
    }
    function promisify(Promise2, callback) {
      if (callback) {
        return { callback, result: void 0 };
      }
      let rej;
      let res;
      const cb = function(err, client) {
        err ? rej(err) : res(client);
      };
      const result = new Promise2(function(resolve, reject) {
        res = resolve;
        rej = reject;
      }).catch((err) => {
        Error.captureStackTrace(err);
        throw err;
      });
      return { callback: cb, result };
    }
    function makeIdleListener(pool, client) {
      return function idleListener(err) {
        err.client = client;
        client.removeListener("error", idleListener);
        client.on("error", () => {
          pool.log("additional client error after disconnection due to error", err);
        });
        pool._remove(client);
        pool.emit("error", err, client);
      };
    }
    var Pool = class extends EventEmitter {
      constructor(options, Client) {
        super();
        this.options = Object.assign({}, options);
        if (options != null && "password" in options) {
          Object.defineProperty(this.options, "password", {
            configurable: true,
            enumerable: false,
            writable: true,
            value: options.password
          });
        }
        if (options != null && options.ssl && options.ssl.key) {
          Object.defineProperty(this.options.ssl, "key", {
            enumerable: false
          });
        }
        this.options.max = this.options.max || this.options.poolSize || 10;
        this.options.min = this.options.min || 0;
        this.options.maxUses = this.options.maxUses || Infinity;
        this.options.allowExitOnIdle = this.options.allowExitOnIdle || false;
        this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0;
        this.log = this.options.log || function() {
        };
        this.Client = this.options.Client || Client || require_lib3().Client;
        this.Promise = this.options.Promise || global.Promise;
        if (typeof this.options.idleTimeoutMillis === "undefined") {
          this.options.idleTimeoutMillis = 1e4;
        }
        this._clients = [];
        this._idle = [];
        this._expired = /* @__PURE__ */ new WeakSet();
        this._pendingQueue = [];
        this._endCallback = void 0;
        this.ending = false;
        this.ended = false;
      }
      _isFull() {
        return this._clients.length >= this.options.max;
      }
      _isAboveMin() {
        return this._clients.length > this.options.min;
      }
      _pulseQueue() {
        this.log("pulse queue");
        if (this.ended) {
          this.log("pulse queue ended");
          return;
        }
        if (this.ending) {
          this.log("pulse queue on ending");
          if (this._idle.length) {
            this._idle.slice().map((item) => {
              this._remove(item.client);
            });
          }
          if (!this._clients.length) {
            this.ended = true;
            this._endCallback();
          }
          return;
        }
        if (!this._pendingQueue.length) {
          this.log("no queued requests");
          return;
        }
        if (!this._idle.length && this._isFull()) {
          return;
        }
        const pendingItem = this._pendingQueue.shift();
        if (this._idle.length) {
          const idleItem = this._idle.pop();
          clearTimeout(idleItem.timeoutId);
          const client = idleItem.client;
          client.ref && client.ref();
          const idleListener = idleItem.idleListener;
          return this._acquireClient(client, pendingItem, idleListener, false);
        }
        if (!this._isFull()) {
          return this.newClient(pendingItem);
        }
        throw new Error("unexpected condition");
      }
      _remove(client, callback) {
        const removed = removeWhere(this._idle, (item) => item.client === client);
        if (removed !== void 0) {
          clearTimeout(removed.timeoutId);
        }
        this._clients = this._clients.filter((c) => c !== client);
        const context = this;
        client.end(() => {
          context.emit("remove", client);
          if (typeof callback === "function") {
            callback();
          }
        });
      }
      connect(cb) {
        if (this.ending) {
          const err = new Error("Cannot use a pool after calling end on the pool");
          return cb ? cb(err) : this.Promise.reject(err);
        }
        const response = promisify(this.Promise, cb);
        const result = response.result;
        if (this._isFull() || this._idle.length) {
          if (this._idle.length) {
            process.nextTick(() => this._pulseQueue());
          }
          if (!this.options.connectionTimeoutMillis) {
            this._pendingQueue.push(new PendingItem(response.callback));
            return result;
          }
          const queueCallback = (err, res, done) => {
            clearTimeout(tid);
            response.callback(err, res, done);
          };
          const pendingItem = new PendingItem(queueCallback);
          const tid = setTimeout(() => {
            removeWhere(this._pendingQueue, (i) => i.callback === queueCallback);
            pendingItem.timedOut = true;
            response.callback(new Error("timeout exceeded when trying to connect"));
          }, this.options.connectionTimeoutMillis);
          if (tid.unref) {
            tid.unref();
          }
          this._pendingQueue.push(pendingItem);
          return result;
        }
        this.newClient(new PendingItem(response.callback));
        return result;
      }
      newClient(pendingItem) {
        const client = new this.Client(this.options);
        this._clients.push(client);
        const idleListener = makeIdleListener(this, client);
        this.log("checking client timeout");
        let tid;
        let timeoutHit = false;
        if (this.options.connectionTimeoutMillis) {
          tid = setTimeout(() => {
            this.log("ending client due to timeout");
            timeoutHit = true;
            client.connection ? client.connection.stream.destroy() : client.end();
          }, this.options.connectionTimeoutMillis);
        }
        this.log("connecting new client");
        client.connect((err) => {
          if (tid) {
            clearTimeout(tid);
          }
          client.on("error", idleListener);
          if (err) {
            this.log("client failed to connect", err);
            this._clients = this._clients.filter((c) => c !== client);
            if (timeoutHit) {
              err = new Error("Connection terminated due to connection timeout", { cause: err });
            }
            this._pulseQueue();
            if (!pendingItem.timedOut) {
              pendingItem.callback(err, void 0, NOOP);
            }
          } else {
            this.log("new client connected");
            if (this.options.maxLifetimeSeconds !== 0) {
              const maxLifetimeTimeout = setTimeout(() => {
                this.log("ending client due to expired lifetime");
                this._expired.add(client);
                const idleIndex = this._idle.findIndex((idleItem) => idleItem.client === client);
                if (idleIndex !== -1) {
                  this._acquireClient(
                    client,
                    new PendingItem((err2, client2, clientRelease) => clientRelease()),
                    idleListener,
                    false
                  );
                }
              }, this.options.maxLifetimeSeconds * 1e3);
              maxLifetimeTimeout.unref();
              client.once("end", () => clearTimeout(maxLifetimeTimeout));
            }
            return this._acquireClient(client, pendingItem, idleListener, true);
          }
        });
      }
      // acquire a client for a pending work item
      _acquireClient(client, pendingItem, idleListener, isNew) {
        if (isNew) {
          this.emit("connect", client);
        }
        this.emit("acquire", client);
        client.release = this._releaseOnce(client, idleListener);
        client.removeListener("error", idleListener);
        if (!pendingItem.timedOut) {
          if (isNew && this.options.verify) {
            this.options.verify(client, (err) => {
              if (err) {
                client.release(err);
                return pendingItem.callback(err, void 0, NOOP);
              }
              pendingItem.callback(void 0, client, client.release);
            });
          } else {
            pendingItem.callback(void 0, client, client.release);
          }
        } else {
          if (isNew && this.options.verify) {
            this.options.verify(client, client.release);
          } else {
            client.release();
          }
        }
      }
      // returns a function that wraps _release and throws if called more than once
      _releaseOnce(client, idleListener) {
        let released = false;
        return (err) => {
          if (released) {
            throwOnDoubleRelease();
          }
          released = true;
          this._release(client, idleListener, err);
        };
      }
      // release a client back to the poll, include an error
      // to remove it from the pool
      _release(client, idleListener, err) {
        client.on("error", idleListener);
        client._poolUseCount = (client._poolUseCount || 0) + 1;
        this.emit("release", err, client);
        if (err || this.ending || !client._queryable || client._ending || client._poolUseCount >= this.options.maxUses) {
          if (client._poolUseCount >= this.options.maxUses) {
            this.log("remove expended client");
          }
          return this._remove(client, this._pulseQueue.bind(this));
        }
        const isExpired = this._expired.has(client);
        if (isExpired) {
          this.log("remove expired client");
          this._expired.delete(client);
          return this._remove(client, this._pulseQueue.bind(this));
        }
        let tid;
        if (this.options.idleTimeoutMillis && this._isAboveMin()) {
          tid = setTimeout(() => {
            this.log("remove idle client");
            this._remove(client, this._pulseQueue.bind(this));
          }, this.options.idleTimeoutMillis);
          if (this.options.allowExitOnIdle) {
            tid.unref();
          }
        }
        if (this.options.allowExitOnIdle) {
          client.unref();
        }
        this._idle.push(new IdleItem(client, idleListener, tid));
        this._pulseQueue();
      }
      query(text, values, cb) {
        if (typeof text === "function") {
          const response2 = promisify(this.Promise, text);
          setImmediate(function() {
            return response2.callback(new Error("Passing a function as the first parameter to pool.query is not supported"));
          });
          return response2.result;
        }
        if (typeof values === "function") {
          cb = values;
          values = void 0;
        }
        const response = promisify(this.Promise, cb);
        cb = response.callback;
        this.connect((err, client) => {
          if (err) {
            return cb(err);
          }
          let clientReleased = false;
          const onError = (err2) => {
            if (clientReleased) {
              return;
            }
            clientReleased = true;
            client.release(err2);
            cb(err2);
          };
          client.once("error", onError);
          this.log("dispatching query");
          try {
            client.query(text, values, (err2, res) => {
              this.log("query dispatched");
              client.removeListener("error", onError);
              if (clientReleased) {
                return;
              }
              clientReleased = true;
              client.release(err2);
              if (err2) {
                return cb(err2);
              }
              return cb(void 0, res);
            });
          } catch (err2) {
            client.release(err2);
            return cb(err2);
          }
        });
        return response.result;
      }
      end(cb) {
        this.log("ending");
        if (this.ending) {
          const err = new Error("Called end on pool more than once");
          return cb ? cb(err) : this.Promise.reject(err);
        }
        this.ending = true;
        const promised = promisify(this.Promise, cb);
        this._endCallback = promised.callback;
        this._pulseQueue();
        return promised.result;
      }
      get waitingCount() {
        return this._pendingQueue.length;
      }
      get idleCount() {
        return this._idle.length;
      }
      get expiredCount() {
        return this._clients.reduce((acc, client) => acc + (this._expired.has(client) ? 1 : 0), 0);
      }
      get totalCount() {
        return this._clients.length;
      }
    };
    module2.exports = Pool;
  }
});

// node_modules/pg/lib/native/query.js
var require_query2 = __commonJS({
  "node_modules/pg/lib/native/query.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var util = require("util");
    var utils = require_utils();
    var NativeQuery = module2.exports = function(config, values, callback) {
      EventEmitter.call(this);
      config = utils.normalizeQueryConfig(config, values, callback);
      this.text = config.text;
      this.values = config.values;
      this.name = config.name;
      this.queryMode = config.queryMode;
      this.callback = config.callback;
      this.state = "new";
      this._arrayMode = config.rowMode === "array";
      this._emitRowEvents = false;
      this.on(
        "newListener",
        function(event) {
          if (event === "row") this._emitRowEvents = true;
        }.bind(this)
      );
    };
    util.inherits(NativeQuery, EventEmitter);
    var errorFieldMap = {
      sqlState: "code",
      statementPosition: "position",
      messagePrimary: "message",
      context: "where",
      schemaName: "schema",
      tableName: "table",
      columnName: "column",
      dataTypeName: "dataType",
      constraintName: "constraint",
      sourceFile: "file",
      sourceLine: "line",
      sourceFunction: "routine"
    };
    NativeQuery.prototype.handleError = function(err) {
      const fields = this.native.pq.resultErrorFields();
      if (fields) {
        for (const key in fields) {
          const normalizedFieldName = errorFieldMap[key] || key;
          err[normalizedFieldName] = fields[key];
        }
      }
      if (this.callback) {
        this.callback(err);
      } else {
        this.emit("error", err);
      }
      this.state = "error";
    };
    NativeQuery.prototype.then = function(onSuccess, onFailure) {
      return this._getPromise().then(onSuccess, onFailure);
    };
    NativeQuery.prototype.catch = function(callback) {
      return this._getPromise().catch(callback);
    };
    NativeQuery.prototype._getPromise = function() {
      if (this._promise) return this._promise;
      this._promise = new Promise(
        function(resolve, reject) {
          this._once("end", resolve);
          this._once("error", reject);
        }.bind(this)
      );
      return this._promise;
    };
    NativeQuery.prototype.submit = function(client) {
      this.state = "running";
      const self2 = this;
      this.native = client.native;
      client.native.arrayMode = this._arrayMode;
      let after = function(err, rows, results) {
        client.native.arrayMode = false;
        setImmediate(function() {
          self2.emit("_done");
        });
        if (err) {
          return self2.handleError(err);
        }
        if (self2._emitRowEvents) {
          if (results.length > 1) {
            rows.forEach((rowOfRows, i) => {
              rowOfRows.forEach((row) => {
                self2.emit("row", row, results[i]);
              });
            });
          } else {
            rows.forEach(function(row) {
              self2.emit("row", row, results);
            });
          }
        }
        self2.state = "end";
        self2.emit("end", results);
        if (self2.callback) {
          self2.callback(null, results);
        }
      };
      if (process.domain) {
        after = process.domain.bind(after);
      }
      if (this.name) {
        if (this.name.length > 63) {
          console.error("Warning! Postgres only supports 63 characters for query names.");
          console.error("You supplied %s (%s)", this.name, this.name.length);
          console.error("This can cause conflicts and silent errors executing queries");
        }
        const values = (this.values || []).map(utils.prepareValue);
        if (client.namedQueries[this.name]) {
          if (this.text && client.namedQueries[this.name] !== this.text) {
            const err = new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
            return after(err);
          }
          return client.native.execute(this.name, values, after);
        }
        return client.native.prepare(this.name, this.text, values.length, function(err) {
          if (err) return after(err);
          client.namedQueries[self2.name] = self2.text;
          return self2.native.execute(self2.name, values, after);
        });
      } else if (this.values) {
        if (!Array.isArray(this.values)) {
          const err = new Error("Query values must be an array");
          return after(err);
        }
        const vals = this.values.map(utils.prepareValue);
        client.native.query(this.text, vals, after);
      } else if (this.queryMode === "extended") {
        client.native.query(this.text, [], after);
      } else {
        client.native.query(this.text, after);
      }
    };
  }
});

// node_modules/pg/lib/native/client.js
var require_client2 = __commonJS({
  "node_modules/pg/lib/native/client.js"(exports2, module2) {
    "use strict";
    var Native;
    try {
      Native = require("pg-native");
    } catch (e) {
      throw e;
    }
    var TypeOverrides = require_type_overrides();
    var EventEmitter = require("events").EventEmitter;
    var util = require("util");
    var ConnectionParameters = require_connection_parameters();
    var NativeQuery = require_query2();
    var Client = module2.exports = function(config) {
      EventEmitter.call(this);
      config = config || {};
      this._Promise = config.Promise || global.Promise;
      this._types = new TypeOverrides(config.types);
      this.native = new Native({
        types: this._types
      });
      this._queryQueue = [];
      this._ending = false;
      this._connecting = false;
      this._connected = false;
      this._queryable = true;
      const cp = this.connectionParameters = new ConnectionParameters(config);
      if (config.nativeConnectionString) cp.nativeConnectionString = config.nativeConnectionString;
      this.user = cp.user;
      Object.defineProperty(this, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: cp.password
      });
      this.database = cp.database;
      this.host = cp.host;
      this.port = cp.port;
      this.namedQueries = {};
    };
    Client.Query = NativeQuery;
    util.inherits(Client, EventEmitter);
    Client.prototype._errorAllQueries = function(err) {
      const enqueueError = (query) => {
        process.nextTick(() => {
          query.native = this.native;
          query.handleError(err);
        });
      };
      if (this._hasActiveQuery()) {
        enqueueError(this._activeQuery);
        this._activeQuery = null;
      }
      this._queryQueue.forEach(enqueueError);
      this._queryQueue.length = 0;
    };
    Client.prototype._connect = function(cb) {
      const self2 = this;
      if (this._connecting) {
        process.nextTick(() => cb(new Error("Client has already been connected. You cannot reuse a client.")));
        return;
      }
      this._connecting = true;
      this.connectionParameters.getLibpqConnectionString(function(err, conString) {
        if (self2.connectionParameters.nativeConnectionString) conString = self2.connectionParameters.nativeConnectionString;
        if (err) return cb(err);
        self2.native.connect(conString, function(err2) {
          if (err2) {
            self2.native.end();
            return cb(err2);
          }
          self2._connected = true;
          self2.native.on("error", function(err3) {
            self2._queryable = false;
            self2._errorAllQueries(err3);
            self2.emit("error", err3);
          });
          self2.native.on("notification", function(msg) {
            self2.emit("notification", {
              channel: msg.relname,
              payload: msg.extra
            });
          });
          self2.emit("connect");
          self2._pulseQueryQueue(true);
          cb();
        });
      });
    };
    Client.prototype.connect = function(callback) {
      if (callback) {
        this._connect(callback);
        return;
      }
      return new this._Promise((resolve, reject) => {
        this._connect((error) => {
          if (error) {
            reject(error);
          } else {
            resolve();
          }
        });
      });
    };
    Client.prototype.query = function(config, values, callback) {
      let query;
      let result;
      let readTimeout;
      let readTimeoutTimer;
      let queryCallback;
      if (config === null || config === void 0) {
        throw new TypeError("Client was passed a null or undefined query");
      } else if (typeof config.submit === "function") {
        readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
        result = query = config;
        if (typeof values === "function") {
          config.callback = values;
        }
      } else {
        readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
        query = new NativeQuery(config, values, callback);
        if (!query.callback) {
          let resolveOut, rejectOut;
          result = new this._Promise((resolve, reject) => {
            resolveOut = resolve;
            rejectOut = reject;
          }).catch((err) => {
            Error.captureStackTrace(err);
            throw err;
          });
          query.callback = (err, res) => err ? rejectOut(err) : resolveOut(res);
        }
      }
      if (readTimeout) {
        queryCallback = query.callback;
        readTimeoutTimer = setTimeout(() => {
          const error = new Error("Query read timeout");
          process.nextTick(() => {
            query.handleError(error, this.connection);
          });
          queryCallback(error);
          query.callback = () => {
          };
          const index = this._queryQueue.indexOf(query);
          if (index > -1) {
            this._queryQueue.splice(index, 1);
          }
          this._pulseQueryQueue();
        }, readTimeout);
        query.callback = (err, res) => {
          clearTimeout(readTimeoutTimer);
          queryCallback(err, res);
        };
      }
      if (!this._queryable) {
        query.native = this.native;
        process.nextTick(() => {
          query.handleError(new Error("Client has encountered a connection error and is not queryable"));
        });
        return result;
      }
      if (this._ending) {
        query.native = this.native;
        process.nextTick(() => {
          query.handleError(new Error("Client was closed and is not queryable"));
        });
        return result;
      }
      this._queryQueue.push(query);
      this._pulseQueryQueue();
      return result;
    };
    Client.prototype.end = function(cb) {
      const self2 = this;
      this._ending = true;
      if (!this._connected) {
        this.once("connect", this.end.bind(this, cb));
      }
      let result;
      if (!cb) {
        result = new this._Promise(function(resolve, reject) {
          cb = (err) => err ? reject(err) : resolve();
        });
      }
      this.native.end(function() {
        self2._errorAllQueries(new Error("Connection terminated"));
        process.nextTick(() => {
          self2.emit("end");
          if (cb) cb();
        });
      });
      return result;
    };
    Client.prototype._hasActiveQuery = function() {
      return this._activeQuery && this._activeQuery.state !== "error" && this._activeQuery.state !== "end";
    };
    Client.prototype._pulseQueryQueue = function(initialConnection) {
      if (!this._connected) {
        return;
      }
      if (this._hasActiveQuery()) {
        return;
      }
      const query = this._queryQueue.shift();
      if (!query) {
        if (!initialConnection) {
          this.emit("drain");
        }
        return;
      }
      this._activeQuery = query;
      query.submit(this);
      const self2 = this;
      query.once("_done", function() {
        self2._pulseQueryQueue();
      });
    };
    Client.prototype.cancel = function(query) {
      if (this._activeQuery === query) {
        this.native.cancel(function() {
        });
      } else if (this._queryQueue.indexOf(query) !== -1) {
        this._queryQueue.splice(this._queryQueue.indexOf(query), 1);
      }
    };
    Client.prototype.ref = function() {
    };
    Client.prototype.unref = function() {
    };
    Client.prototype.setTypeParser = function(oid, format, parseFn) {
      return this._types.setTypeParser(oid, format, parseFn);
    };
    Client.prototype.getTypeParser = function(oid, format) {
      return this._types.getTypeParser(oid, format);
    };
  }
});

// node_modules/pg/lib/native/index.js
var require_native = __commonJS({
  "node_modules/pg/lib/native/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_client2();
  }
});

// node_modules/pg/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/pg/lib/index.js"(exports2, module2) {
    "use strict";
    var Client = require_client();
    var defaults = require_defaults();
    var Connection2 = require_connection();
    var Result = require_result();
    var utils = require_utils();
    var Pool = require_pg_pool();
    var TypeOverrides = require_type_overrides();
    var { DatabaseError } = require_dist();
    var { escapeIdentifier, escapeLiteral } = require_utils();
    var poolFactory = (Client2) => {
      return class BoundPool extends Pool {
        constructor(options) {
          super(options, Client2);
        }
      };
    };
    var PG = function(clientConstructor) {
      this.defaults = defaults;
      this.Client = clientConstructor;
      this.Query = this.Client.Query;
      this.Pool = poolFactory(this.Client);
      this._pools = [];
      this.Connection = Connection2;
      this.types = require_pg_types();
      this.DatabaseError = DatabaseError;
      this.TypeOverrides = TypeOverrides;
      this.escapeIdentifier = escapeIdentifier;
      this.escapeLiteral = escapeLiteral;
      this.Result = Result;
      this.utils = utils;
    };
    if (typeof process.env.NODE_PG_FORCE_NATIVE !== "undefined") {
      module2.exports = new PG(require_native());
    } else {
      module2.exports = new PG(Client);
      Object.defineProperty(module2.exports, "native", {
        configurable: true,
        enumerable: false,
        get() {
          let native = null;
          try {
            native = new PG(require_native());
          } catch (err) {
            if (err.code !== "MODULE_NOT_FOUND") {
              throw err;
            }
          }
          Object.defineProperty(module2.exports, "native", {
            value: native
          });
          return native;
        }
      });
    }
  }
});

// node_modules/typeorm/platform/PlatformTools.js
var require_PlatformTools = __commonJS({
  "node_modules/typeorm/platform/PlatformTools.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PlatformTools = exports2.Writable = exports2.Readable = exports2.ReadStream = exports2.EventEmitter = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var ansis_1 = tslib_1.__importDefault(require_ansis());
    var dotenv_1 = tslib_1.__importDefault(require_main());
    var fs_1 = tslib_1.__importDefault(require("fs"));
    var path_1 = tslib_1.__importDefault(require("path"));
    var sql_highlight_1 = require_lib();
    var formatter_1 = require_sqlFormatter();
    var events_1 = require("events");
    Object.defineProperty(exports2, "EventEmitter", { enumerable: true, get: function() {
      return events_1.EventEmitter;
    } });
    var fs_2 = require("fs");
    Object.defineProperty(exports2, "ReadStream", { enumerable: true, get: function() {
      return fs_2.ReadStream;
    } });
    var stream_1 = require("stream");
    Object.defineProperty(exports2, "Readable", { enumerable: true, get: function() {
      return stream_1.Readable;
    } });
    Object.defineProperty(exports2, "Writable", { enumerable: true, get: function() {
      return stream_1.Writable;
    } });
    var PlatformTools = class {
      /**
       * Gets global variable where global stuff can be stored.
       */
      static getGlobalVariable() {
        return global;
      }
      /**
       * Loads ("require"-s) given file or package.
       * This operation only supports on node platform
       */
      static load(name) {
        try {
          switch (name) {
            /**
             * spanner
             */
            case "spanner":
              return require("@google-cloud/spanner");
            /**
             * mongodb
             */
            case "mongodb":
              return require("mongodb");
            /**
             * hana
             */
            case "@sap/hana-client":
              return require("@sap/hana-client");
            case "@sap/hana-client/extension/Stream":
              return require("@sap/hana-client/extension/Stream");
            /**
             * mysql
             */
            case "mysql":
              return require("mysql");
            case "mysql2":
              return require("mysql2");
            /**
             * oracle
             */
            case "oracledb":
              return require("oracledb");
            /**
             * postgres
             */
            case "pg":
              return require_lib3();
            case "pg-native":
              return require("pg-native");
            case "pg-query-stream":
              return require("pg-query-stream");
            case "typeorm-aurora-data-api-driver":
              return require("typeorm-aurora-data-api-driver");
            /**
             * redis
             */
            case "redis":
              return require("redis");
            case "ioredis":
              return require("ioredis");
            /**
             * better-sqlite3
             */
            case "better-sqlite3":
              return require("better-sqlite3");
            /**
             * sqlite
             */
            case "sqlite3":
              return require("sqlite3");
            /**
             * sql.js
             */
            case "sql.js":
              return require("sql.js");
            /**
             * sqlserver
             */
            case "mssql":
              return require("mssql");
            /**
             * react-native-sqlite
             */
            case "react-native-sqlite-storage":
              return require("react-native-sqlite-storage");
          }
        } catch (err) {
          return require(path_1.default.resolve(process.cwd() + "/node_modules/" + name));
        }
        throw new TypeError(`Invalid Package for PlatformTools.load: ${name}`);
      }
      /**
       * Normalizes given path. Does "path.normalize" and replaces backslashes with forward slashes on Windows.
       */
      static pathNormalize(pathStr) {
        let normalizedPath = path_1.default.normalize(pathStr);
        if (process.platform === "win32")
          normalizedPath = normalizedPath.replace(/\\/g, "/");
        return normalizedPath;
      }
      /**
       * Gets file extension. Does "path.extname".
       */
      static pathExtname(pathStr) {
        return path_1.default.extname(pathStr);
      }
      /**
       * Resolved given path. Does "path.resolve".
       */
      static pathResolve(pathStr) {
        return path_1.default.resolve(pathStr);
      }
      /**
       * Synchronously checks if file exist. Does "fs.existsSync".
       */
      static fileExist(pathStr) {
        return fs_1.default.existsSync(pathStr);
      }
      static readFileSync(filename) {
        return fs_1.default.readFileSync(filename);
      }
      static appendFileSync(filename, data) {
        fs_1.default.appendFileSync(filename, data);
      }
      static async writeFile(path, data) {
        return fs_1.default.promises.writeFile(path, data);
      }
      /**
       * Loads a dotenv file into the environment variables.
       *
       * @param path The file to load as a dotenv configuration
       */
      static dotenv(pathStr) {
        dotenv_1.default.config({ path: pathStr });
      }
      /**
       * Gets environment variable.
       */
      static getEnvVariable(name) {
        return process.env[name];
      }
      /**
       * Highlights sql string to be printed in the console.
       */
      static highlightSql(sql) {
        return (0, sql_highlight_1.highlight)(sql, {
          colors: {
            keyword: ansis_1.default.blueBright.open,
            function: ansis_1.default.magentaBright.open,
            number: ansis_1.default.green.open,
            string: ansis_1.default.white.open,
            identifier: ansis_1.default.white.open,
            special: ansis_1.default.white.open,
            bracket: ansis_1.default.white.open,
            comment: ansis_1.default.gray.open,
            clear: ansis_1.default.reset.open
          }
        });
      }
      /**
       * Pretty-print sql string to be print in the console.
       */
      static formatSql(sql, dataSourceType) {
        const databaseLanguageMap = {
          oracle: "pl/sql"
        };
        const databaseLanguage = dataSourceType ? databaseLanguageMap[dataSourceType] || "sql" : "sql";
        return (0, formatter_1.format)(sql, {
          language: databaseLanguage,
          indent: "    "
        });
      }
      /**
       * Logging functions needed by AdvancedConsoleLogger
       */
      static logInfo(prefix, info) {
        console.log(ansis_1.default.gray.underline(prefix), info);
      }
      static logError(prefix, error) {
        console.log(ansis_1.default.underline.red(prefix), error);
      }
      static logWarn(prefix, warning) {
        console.log(ansis_1.default.underline.yellow(prefix), warning);
      }
      static log(message) {
        console.log(ansis_1.default.underline(message));
      }
      static info(info) {
        return ansis_1.default.gray(info);
      }
      static error(error) {
        return ansis_1.default.red(error);
      }
      static warn(message) {
        return ansis_1.default.yellow(message);
      }
      static logCmdErr(prefix, err) {
        console.log(ansis_1.default.black.bgRed(prefix));
        if (err)
          console.error(err);
      }
    };
    exports2.PlatformTools = PlatformTools;
    PlatformTools.type = "node";
  }
});

// node_modules/app-root-path/lib/resolve.js
var require_resolve = __commonJS({
  "node_modules/app-root-path/lib/resolve.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var globalPaths = require("module").globalPaths;
    var npmGlobalPrefix;
    if ("win32" === process.platform) {
      npmGlobalPrefix = path.dirname(process.execPath);
    } else {
      npmGlobalPrefix = path.dirname(path.dirname(process.execPath));
    }
    var npmGlobalModuleDir = path.resolve(npmGlobalPrefix, "lib", "node_modules");
    var sep = path.sep;
    var requireFunction = "function" === typeof __webpack_require__ || "function" === typeof __non_webpack_require__ ? __non_webpack_require__ : require;
    var isInstalledWithPNPM = function(resolved) {
      const pnpmDir = sep + ".pnpm";
      for (const globalPath of globalPaths) {
        if (-1 !== globalPath.indexOf(pnpmDir) && -1 !== resolved.indexOf(pnpmDir)) {
          return true;
        }
      }
      return false;
    };
    var getFirstPartFromNodeModules = function(resolved) {
      const nodeModulesDir = sep + "node_modules";
      if (-1 !== resolved.indexOf(nodeModulesDir)) {
        const parts = resolved.split(nodeModulesDir);
        if (parts.length) {
          return parts[0];
        }
      }
      return null;
    };
    module2.exports = function resolve(dirname) {
      if (process.env.APP_ROOT_PATH) {
        return path.resolve(process.env.APP_ROOT_PATH);
      }
      if (process.versions.pnp) {
        try {
          var pnp = requireFunction("pnpapi");
          return pnp.getPackageInformation(pnp.topLevel).packageLocation;
        } catch (e) {
        }
      }
      if ("undefined" !== typeof window && window.process && "renderer" === window.process.type) {
        try {
          var remote = requireFunction("electron").remote;
          return remote.require("app-root-path").path;
        } catch (e) {
        }
      }
      if (process.env.LAMBDA_TASK_ROOT && process.env.AWS_EXECUTION_ENV) {
        return process.env.LAMBDA_TASK_ROOT;
      }
      var resolved = path.resolve(dirname);
      var alternateMethod = false;
      var appRootPath = null;
      if (isInstalledWithPNPM(resolved)) {
        appRootPath = getFirstPartFromNodeModules(resolved);
        if (appRootPath) {
          return appRootPath;
        }
      }
      globalPaths.forEach(function(globalPath) {
        if (!alternateMethod && 0 === resolved.indexOf(globalPath)) {
          alternateMethod = true;
        }
      });
      if (!alternateMethod) {
        appRootPath = getFirstPartFromNodeModules(resolved);
      }
      if (alternateMethod || null == appRootPath) {
        if (requireFunction.main) {
          appRootPath = path.dirname(requireFunction.main.filename);
        } else {
          appRootPath = path.dirname(process.argv[1]);
        }
      }
      if (alternateMethod && -1 !== appRootPath.indexOf(npmGlobalModuleDir) && appRootPath.length - 4 === appRootPath.indexOf(sep + "bin")) {
        appRootPath = appRootPath.slice(0, -4);
      }
      return appRootPath;
    };
  }
});

// node_modules/app-root-path/lib/app-root-path.js
var require_app_root_path = __commonJS({
  "node_modules/app-root-path/lib/app-root-path.js"(exports2, module2) {
    "use strict";
    module2.exports = function(dirname) {
      var path = require("path");
      var resolve = require_resolve();
      var appRootPath = resolve(dirname);
      var publicInterface = {
        resolve: function(pathToModule) {
          return path.join(appRootPath, pathToModule);
        },
        require: function(pathToModule) {
          return require(publicInterface.resolve(pathToModule));
        },
        toString: function() {
          return appRootPath;
        },
        setPath: function(explicitlySetPath) {
          appRootPath = path.resolve(explicitlySetPath);
          publicInterface.path = appRootPath;
        },
        path: appRootPath
      };
      return publicInterface;
    };
  }
});

// node_modules/app-root-path/index.js
var require_app_root_path2 = __commonJS({
  "node_modules/app-root-path/index.js"(exports2, module2) {
    "use strict";
    var lib = require_app_root_path();
    module2.exports = lib(__dirname);
  }
});

// node_modules/typeorm/error/TypeORMError.js
var require_TypeORMError = __commonJS({
  "node_modules/typeorm/error/TypeORMError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeORMError = void 0;
    var TypeORMError2 = class extends Error {
      get name() {
        return this.constructor.name;
      }
      constructor(message) {
        super(message);
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, new.target.prototype);
        } else {
          ;
          this.__proto__ = new.target.prototype;
        }
      }
    };
    exports2.TypeORMError = TypeORMError2;
  }
});

// node_modules/typeorm/error/CannotReflectMethodParameterTypeError.js
var require_CannotReflectMethodParameterTypeError = __commonJS({
  "node_modules/typeorm/error/CannotReflectMethodParameterTypeError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CannotReflectMethodParameterTypeError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var CannotReflectMethodParameterTypeError2 = class extends TypeORMError_1.TypeORMError {
      constructor(target, methodName) {
        super(`Cannot get reflected type for a "${methodName}" method's parameter of "${target.name}" class. Make sure you have turned on an "emitDecoratorMetadata": true option in tsconfig.json. Also make sure you have imported "reflect-metadata" on top of the main entry file in your application.`);
      }
    };
    exports2.CannotReflectMethodParameterTypeError = CannotReflectMethodParameterTypeError2;
  }
});

// node_modules/typeorm/error/AlreadyHasActiveConnectionError.js
var require_AlreadyHasActiveConnectionError = __commonJS({
  "node_modules/typeorm/error/AlreadyHasActiveConnectionError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AlreadyHasActiveConnectionError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var AlreadyHasActiveConnectionError2 = class extends TypeORMError_1.TypeORMError {
      constructor(connectionName) {
        super(`Cannot create a new connection named "${connectionName}", because connection with such name already exist and it now has an active connection session.`);
      }
    };
    exports2.AlreadyHasActiveConnectionError = AlreadyHasActiveConnectionError2;
  }
});

// node_modules/typeorm/error/SubjectWithoutIdentifierError.js
var require_SubjectWithoutIdentifierError = __commonJS({
  "node_modules/typeorm/error/SubjectWithoutIdentifierError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SubjectWithoutIdentifierError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var SubjectWithoutIdentifierError2 = class extends TypeORMError_1.TypeORMError {
      constructor(subject) {
        super(`Internal error. Subject ${subject.metadata.targetName} must have an identifier to perform operation.`);
      }
    };
    exports2.SubjectWithoutIdentifierError = SubjectWithoutIdentifierError2;
  }
});

// node_modules/typeorm/error/CannotConnectAlreadyConnectedError.js
var require_CannotConnectAlreadyConnectedError = __commonJS({
  "node_modules/typeorm/error/CannotConnectAlreadyConnectedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CannotConnectAlreadyConnectedError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var CannotConnectAlreadyConnectedError2 = class extends TypeORMError_1.TypeORMError {
      constructor(connectionName) {
        super(`Cannot create a "${connectionName}" connection because connection to the database already established.`);
      }
    };
    exports2.CannotConnectAlreadyConnectedError = CannotConnectAlreadyConnectedError2;
  }
});

// node_modules/typeorm/error/LockNotSupportedOnGivenDriverError.js
var require_LockNotSupportedOnGivenDriverError = __commonJS({
  "node_modules/typeorm/error/LockNotSupportedOnGivenDriverError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LockNotSupportedOnGivenDriverError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var LockNotSupportedOnGivenDriverError2 = class extends TypeORMError_1.TypeORMError {
      constructor() {
        super(`Locking not supported on given driver.`);
      }
    };
    exports2.LockNotSupportedOnGivenDriverError = LockNotSupportedOnGivenDriverError2;
  }
});

// node_modules/typeorm/error/ConnectionIsNotSetError.js
var require_ConnectionIsNotSetError = __commonJS({
  "node_modules/typeorm/error/ConnectionIsNotSetError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectionIsNotSetError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var ConnectionIsNotSetError2 = class extends TypeORMError_1.TypeORMError {
      constructor(dbType) {
        super(`Connection with ${dbType} database is not established. Check connection configuration.`);
      }
    };
    exports2.ConnectionIsNotSetError = ConnectionIsNotSetError2;
  }
});

// node_modules/typeorm/error/CannotCreateEntityIdMapError.js
var require_CannotCreateEntityIdMapError = __commonJS({
  "node_modules/typeorm/error/CannotCreateEntityIdMapError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CannotCreateEntityIdMapError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var CannotCreateEntityIdMapError2 = class extends TypeORMError_1.TypeORMError {
      constructor(metadata, id) {
        super();
        const objectExample = metadata.primaryColumns.reduce((object, column, index) => {
          column.setEntityValue(object, index + 1);
          return object;
        }, {});
        this.message = `Cannot use given entity id "${id}" because "${metadata.targetName}" contains multiple primary columns, you must provide object in following form: ${JSON.stringify(objectExample)} as an id.`;
      }
    };
    exports2.CannotCreateEntityIdMapError = CannotCreateEntityIdMapError2;
  }
});

// node_modules/typeorm/error/MetadataAlreadyExistsError.js
var require_MetadataAlreadyExistsError = __commonJS({
  "node_modules/typeorm/error/MetadataAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MetadataAlreadyExistsError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var MetadataAlreadyExistsError2 = class extends TypeORMError_1.TypeORMError {
      constructor(metadataType, constructor, propertyName) {
        super(metadataType + " metadata already exists for the class constructor " + JSON.stringify(constructor) + (propertyName ? " on property " + propertyName : ". If you previously renamed or moved entity class, make sure that compiled version of old entity class source wasn't left in the compiler output directory."));
      }
    };
    exports2.MetadataAlreadyExistsError = MetadataAlreadyExistsError2;
  }
});

// node_modules/typeorm/error/CannotDetermineEntityError.js
var require_CannotDetermineEntityError = __commonJS({
  "node_modules/typeorm/error/CannotDetermineEntityError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CannotDetermineEntityError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var CannotDetermineEntityError2 = class extends TypeORMError_1.TypeORMError {
      constructor(operation) {
        super(`Cannot ${operation}, given value must be instance of entity class, instead object literal is given. Or you must specify an entity target to method call.`);
      }
    };
    exports2.CannotDetermineEntityError = CannotDetermineEntityError2;
  }
});

// node_modules/typeorm/error/UpdateValuesMissingError.js
var require_UpdateValuesMissingError = __commonJS({
  "node_modules/typeorm/error/UpdateValuesMissingError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UpdateValuesMissingError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var UpdateValuesMissingError2 = class extends TypeORMError_1.TypeORMError {
      constructor() {
        super(`Cannot perform update query because update values are not defined. Call "qb.set(...)" method to specify updated values.`);
      }
    };
    exports2.UpdateValuesMissingError = UpdateValuesMissingError2;
  }
});

// node_modules/typeorm/error/TreeRepositoryNotSupportedError.js
var require_TreeRepositoryNotSupportedError = __commonJS({
  "node_modules/typeorm/error/TreeRepositoryNotSupportedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TreeRepositoryNotSupportedError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var TreeRepositoryNotSupportedError2 = class extends TypeORMError_1.TypeORMError {
      constructor(driver) {
        super(`Tree repositories are not supported in ${driver.options.type} driver.`);
      }
    };
    exports2.TreeRepositoryNotSupportedError = TreeRepositoryNotSupportedError2;
  }
});

// node_modules/typeorm/error/CustomRepositoryNotFoundError.js
var require_CustomRepositoryNotFoundError = __commonJS({
  "node_modules/typeorm/error/CustomRepositoryNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CustomRepositoryNotFoundError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var CustomRepositoryNotFoundError2 = class extends TypeORMError_1.TypeORMError {
      constructor(repository) {
        super(`Custom repository ${typeof repository === "function" ? repository.name : repository.constructor.name} was not found. Did you forgot to put @EntityRepository decorator on it?`);
      }
    };
    exports2.CustomRepositoryNotFoundError = CustomRepositoryNotFoundError2;
  }
});

// node_modules/typeorm/error/TransactionNotStartedError.js
var require_TransactionNotStartedError = __commonJS({
  "node_modules/typeorm/error/TransactionNotStartedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransactionNotStartedError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var TransactionNotStartedError2 = class extends TypeORMError_1.TypeORMError {
      constructor() {
        super(`Transaction is not started yet, start transaction before committing or rolling it back.`);
      }
    };
    exports2.TransactionNotStartedError = TransactionNotStartedError2;
  }
});

// node_modules/typeorm/error/TransactionAlreadyStartedError.js
var require_TransactionAlreadyStartedError = __commonJS({
  "node_modules/typeorm/error/TransactionAlreadyStartedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransactionAlreadyStartedError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var TransactionAlreadyStartedError2 = class extends TypeORMError_1.TypeORMError {
      constructor() {
        super(`Transaction already started for the given connection, commit current transaction before starting a new one.`);
      }
    };
    exports2.TransactionAlreadyStartedError = TransactionAlreadyStartedError2;
  }
});

// node_modules/typeorm/util/ObjectUtils.js
var require_ObjectUtils = __commonJS({
  "node_modules/typeorm/util/ObjectUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ObjectUtils = void 0;
    var ObjectUtils = class {
      /**
       * Checks if given value is an object.
       * We cannot use instanceof because it has problems when running on different contexts.
       * And we don't simply use typeof because typeof null === "object".
       */
      static isObject(val) {
        return val !== null && typeof val === "object";
      }
      /**
       * Checks if given value is an object.
       * We cannot use instanceof because it has problems when running on different contexts.
       * And we don't simply use typeof because typeof null === "object".
       */
      static isObjectWithName(val) {
        return val !== null && typeof val === "object" && val["name"] !== void 0;
      }
      /**
       * Copy the values of all of the enumerable own properties from one or more source objects to a
       * target object.
       * @param target The target object to copy to.
       * @param sources One or more source objects from which to copy properties
       */
      static assign(target, ...sources) {
        for (const source of sources) {
          for (const prop of Object.getOwnPropertyNames(source)) {
            ;
            target[prop] = source[prop];
          }
        }
      }
      /**
       * Converts MixedList<T> to strictly an array of its T items.
       */
      static mixedListToArray(list) {
        if (list !== null && typeof list === "object") {
          return Object.keys(list).map((key) => list[key]);
        } else {
          return list;
        }
      }
    };
    exports2.ObjectUtils = ObjectUtils;
  }
});

// node_modules/typeorm/util/InstanceChecker.js
var require_InstanceChecker = __commonJS({
  "node_modules/typeorm/util/InstanceChecker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InstanceChecker = void 0;
    var InstanceChecker2 = class {
      static isMssqlParameter(obj) {
        return this.check(obj, "MssqlParameter");
      }
      static isEntityMetadata(obj) {
        return this.check(obj, "EntityMetadata");
      }
      static isColumnMetadata(obj) {
        return this.check(obj, "ColumnMetadata");
      }
      static isSelectQueryBuilder(obj) {
        return this.check(obj, "SelectQueryBuilder");
      }
      static isInsertQueryBuilder(obj) {
        return this.check(obj, "InsertQueryBuilder");
      }
      static isDeleteQueryBuilder(obj) {
        return this.check(obj, "DeleteQueryBuilder");
      }
      static isUpdateQueryBuilder(obj) {
        return this.check(obj, "UpdateQueryBuilder");
      }
      static isSoftDeleteQueryBuilder(obj) {
        return this.check(obj, "SoftDeleteQueryBuilder");
      }
      static isRelationQueryBuilder(obj) {
        return this.check(obj, "RelationQueryBuilder");
      }
      static isBrackets(obj) {
        return this.check(obj, "Brackets") || this.check(obj, "NotBrackets");
      }
      static isNotBrackets(obj) {
        return this.check(obj, "NotBrackets");
      }
      static isSubject(obj) {
        return this.check(obj, "Subject");
      }
      static isRdbmsSchemaBuilder(obj) {
        return this.check(obj, "RdbmsSchemaBuilder");
      }
      static isMongoEntityManager(obj) {
        return this.check(obj, "MongoEntityManager");
      }
      static isSqljsEntityManager(obj) {
        return this.check(obj, "SqljsEntityManager");
      }
      static isEntitySchema(obj) {
        return this.check(obj, "EntitySchema");
      }
      static isBaseEntityConstructor(obj) {
        return typeof obj === "function" && typeof obj.hasId === "function" && typeof obj.save === "function" && typeof obj.useDataSource === "function";
      }
      static isFindOperator(obj) {
        return this.check(obj, "FindOperator") || this.check(obj, "EqualOperator");
      }
      static isEqualOperator(obj) {
        return this.check(obj, "EqualOperator");
      }
      static isQuery(obj) {
        return this.check(obj, "Query");
      }
      static isTable(obj) {
        return this.check(obj, "Table");
      }
      static isTableCheck(obj) {
        return this.check(obj, "TableCheck");
      }
      static isTableColumn(obj) {
        return this.check(obj, "TableColumn");
      }
      static isTableExclusion(obj) {
        return this.check(obj, "TableExclusion");
      }
      static isTableForeignKey(obj) {
        return this.check(obj, "TableForeignKey");
      }
      static isTableIndex(obj) {
        return this.check(obj, "TableIndex");
      }
      static isTableUnique(obj) {
        return this.check(obj, "TableUnique");
      }
      static isView(obj) {
        return this.check(obj, "View");
      }
      static isDataSource(obj) {
        return this.check(obj, "DataSource");
      }
      static check(obj, name) {
        return typeof obj === "object" && obj !== null && obj["@instanceof"] === Symbol.for(name);
      }
    };
    exports2.InstanceChecker = InstanceChecker2;
  }
});

// node_modules/typeorm/error/EntityNotFoundError.js
var require_EntityNotFoundError = __commonJS({
  "node_modules/typeorm/error/EntityNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EntityNotFoundError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var ObjectUtils_1 = require_ObjectUtils();
    var InstanceChecker_1 = require_InstanceChecker();
    var EntityNotFoundError2 = class extends TypeORMError_1.TypeORMError {
      constructor(entityClass, criteria) {
        super();
        this.entityClass = entityClass;
        this.criteria = criteria;
        this.message = `Could not find any entity of type "${this.stringifyTarget(entityClass)}" matching: ${this.stringifyCriteria(criteria)}`;
      }
      stringifyTarget(target) {
        if (InstanceChecker_1.InstanceChecker.isEntitySchema(target)) {
          return target.options.name;
        } else if (typeof target === "function") {
          return target.name;
        } else if (ObjectUtils_1.ObjectUtils.isObject(target) && "name" in target) {
          return target.name;
        } else {
          return target;
        }
      }
      stringifyCriteria(criteria) {
        try {
          return JSON.stringify(criteria, null, 4);
        } catch (e) {
        }
        return "" + criteria;
      }
    };
    exports2.EntityNotFoundError = EntityNotFoundError2;
  }
});

// node_modules/typeorm/error/EntityMetadataNotFoundError.js
var require_EntityMetadataNotFoundError = __commonJS({
  "node_modules/typeorm/error/EntityMetadataNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EntityMetadataNotFoundError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var ObjectUtils_1 = require_ObjectUtils();
    var InstanceChecker_1 = require_InstanceChecker();
    var EntityMetadataNotFoundError2 = class extends TypeORMError_1.TypeORMError {
      constructor(target) {
        super();
        this.message = `No metadata for "${this.stringifyTarget(target)}" was found.`;
      }
      stringifyTarget(target) {
        if (InstanceChecker_1.InstanceChecker.isEntitySchema(target)) {
          return target.options.name;
        } else if (typeof target === "function") {
          return target.name;
        } else if (ObjectUtils_1.ObjectUtils.isObject(target) && "name" in target) {
          return target.name;
        } else {
          return target;
        }
      }
    };
    exports2.EntityMetadataNotFoundError = EntityMetadataNotFoundError2;
  }
});

// node_modules/typeorm/error/MustBeEntityError.js
var require_MustBeEntityError = __commonJS({
  "node_modules/typeorm/error/MustBeEntityError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MustBeEntityError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var MustBeEntityError2 = class extends TypeORMError_1.TypeORMError {
      constructor(operation, wrongValue) {
        super(`Cannot ${operation}, given value must be an entity, instead "${wrongValue}" is given.`);
      }
    };
    exports2.MustBeEntityError = MustBeEntityError2;
  }
});

// node_modules/typeorm/error/OptimisticLockVersionMismatchError.js
var require_OptimisticLockVersionMismatchError = __commonJS({
  "node_modules/typeorm/error/OptimisticLockVersionMismatchError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OptimisticLockVersionMismatchError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var OptimisticLockVersionMismatchError2 = class extends TypeORMError_1.TypeORMError {
      constructor(entity, expectedVersion, actualVersion) {
        super(`The optimistic lock on entity ${entity} failed, version ${expectedVersion} was expected, but is actually ${actualVersion}.`);
      }
    };
    exports2.OptimisticLockVersionMismatchError = OptimisticLockVersionMismatchError2;
  }
});

// node_modules/typeorm/error/LimitOnUpdateNotSupportedError.js
var require_LimitOnUpdateNotSupportedError = __commonJS({
  "node_modules/typeorm/error/LimitOnUpdateNotSupportedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LimitOnUpdateNotSupportedError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var LimitOnUpdateNotSupportedError2 = class extends TypeORMError_1.TypeORMError {
      constructor() {
        super(`Your database does not support LIMIT on UPDATE statements.`);
      }
    };
    exports2.LimitOnUpdateNotSupportedError = LimitOnUpdateNotSupportedError2;
  }
});

// node_modules/typeorm/error/PrimaryColumnCannotBeNullableError.js
var require_PrimaryColumnCannotBeNullableError = __commonJS({
  "node_modules/typeorm/error/PrimaryColumnCannotBeNullableError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PrimaryColumnCannotBeNullableError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var PrimaryColumnCannotBeNullableError2 = class extends TypeORMError_1.TypeORMError {
      constructor(object, propertyName) {
        super(`Primary column ${object.constructor.name}#${propertyName} cannot be nullable. Its not allowed for primary keys. Try to remove nullable option.`);
      }
    };
    exports2.PrimaryColumnCannotBeNullableError = PrimaryColumnCannotBeNullableError2;
  }
});

// node_modules/typeorm/error/CustomRepositoryCannotInheritRepositoryError.js
var require_CustomRepositoryCannotInheritRepositoryError = __commonJS({
  "node_modules/typeorm/error/CustomRepositoryCannotInheritRepositoryError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CustomRepositoryCannotInheritRepositoryError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var CustomRepositoryCannotInheritRepositoryError2 = class extends TypeORMError_1.TypeORMError {
      constructor(repository) {
        super(`Custom entity repository ${typeof repository === "function" ? repository.name : repository.constructor.name}  cannot inherit Repository class without entity being set in the @EntityRepository decorator.`);
      }
    };
    exports2.CustomRepositoryCannotInheritRepositoryError = CustomRepositoryCannotInheritRepositoryError2;
  }
});

// node_modules/typeorm/error/QueryRunnerProviderAlreadyReleasedError.js
var require_QueryRunnerProviderAlreadyReleasedError = __commonJS({
  "node_modules/typeorm/error/QueryRunnerProviderAlreadyReleasedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryRunnerProviderAlreadyReleasedError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var QueryRunnerProviderAlreadyReleasedError2 = class extends TypeORMError_1.TypeORMError {
      constructor() {
        super(`Database connection provided by a query runner was already released, cannot continue to use its querying methods anymore.`);
      }
    };
    exports2.QueryRunnerProviderAlreadyReleasedError = QueryRunnerProviderAlreadyReleasedError2;
  }
});

// node_modules/typeorm/error/CannotAttachTreeChildrenEntityError.js
var require_CannotAttachTreeChildrenEntityError = __commonJS({
  "node_modules/typeorm/error/CannotAttachTreeChildrenEntityError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CannotAttachTreeChildrenEntityError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var CannotAttachTreeChildrenEntityError2 = class extends TypeORMError_1.TypeORMError {
      constructor(entityName) {
        super(`Cannot attach entity "${entityName}" to its parent. Please make sure parent is saved in the database before saving children nodes.`);
      }
    };
    exports2.CannotAttachTreeChildrenEntityError = CannotAttachTreeChildrenEntityError2;
  }
});

// node_modules/typeorm/error/CustomRepositoryDoesNotHaveEntityError.js
var require_CustomRepositoryDoesNotHaveEntityError = __commonJS({
  "node_modules/typeorm/error/CustomRepositoryDoesNotHaveEntityError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CustomRepositoryDoesNotHaveEntityError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var CustomRepositoryDoesNotHaveEntityError2 = class extends TypeORMError_1.TypeORMError {
      constructor(repository) {
        super(`Custom repository ${typeof repository === "function" ? repository.name : repository.constructor.name} does not have managed entity. Did you forget to specify entity for it @EntityRepository(MyEntity)? `);
      }
    };
    exports2.CustomRepositoryDoesNotHaveEntityError = CustomRepositoryDoesNotHaveEntityError2;
  }
});

// node_modules/typeorm/error/MissingDeleteDateColumnError.js
var require_MissingDeleteDateColumnError = __commonJS({
  "node_modules/typeorm/error/MissingDeleteDateColumnError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MissingDeleteDateColumnError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var MissingDeleteDateColumnError2 = class extends TypeORMError_1.TypeORMError {
      constructor(entityMetadata) {
        super(`Entity "${entityMetadata.name}" does not have delete date columns.`);
      }
    };
    exports2.MissingDeleteDateColumnError = MissingDeleteDateColumnError2;
  }
});

// node_modules/typeorm/error/NoConnectionForRepositoryError.js
var require_NoConnectionForRepositoryError = __commonJS({
  "node_modules/typeorm/error/NoConnectionForRepositoryError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NoConnectionForRepositoryError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var NoConnectionForRepositoryError2 = class extends TypeORMError_1.TypeORMError {
      constructor(connectionName) {
        super(`Cannot get a Repository for "${connectionName} connection, because connection with the database is not established yet. Call connection#connect method to establish connection.`);
      }
    };
    exports2.NoConnectionForRepositoryError = NoConnectionForRepositoryError2;
  }
});

// node_modules/typeorm/error/CircularRelationsError.js
var require_CircularRelationsError = __commonJS({
  "node_modules/typeorm/error/CircularRelationsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CircularRelationsError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var CircularRelationsError2 = class extends TypeORMError_1.TypeORMError {
      constructor(path) {
        super(`Circular relations detected: ${path}. To resolve this issue you need to set nullable: true somewhere in this dependency structure.`);
      }
    };
    exports2.CircularRelationsError = CircularRelationsError2;
  }
});

// node_modules/typeorm/error/ReturningStatementNotSupportedError.js
var require_ReturningStatementNotSupportedError = __commonJS({
  "node_modules/typeorm/error/ReturningStatementNotSupportedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReturningStatementNotSupportedError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var ReturningStatementNotSupportedError2 = class extends TypeORMError_1.TypeORMError {
      constructor() {
        super(`OUTPUT or RETURNING clause only supported by PostgreSQL, MariaDB, Microsoft SqlServer or Google Spanner.`);
      }
    };
    exports2.ReturningStatementNotSupportedError = ReturningStatementNotSupportedError2;
  }
});

// node_modules/typeorm/error/UsingJoinTableIsNotAllowedError.js
var require_UsingJoinTableIsNotAllowedError = __commonJS({
  "node_modules/typeorm/error/UsingJoinTableIsNotAllowedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UsingJoinTableIsNotAllowedError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var UsingJoinTableIsNotAllowedError2 = class extends TypeORMError_1.TypeORMError {
      constructor(entityMetadata, relation) {
        super(`Using JoinTable on ${entityMetadata.name}#${relation.propertyName} is wrong. ${entityMetadata.name}#${relation.propertyName} has ${relation.relationType} relation, however you can use JoinTable only on many-to-many relations.`);
      }
    };
    exports2.UsingJoinTableIsNotAllowedError = UsingJoinTableIsNotAllowedError2;
  }
});

// node_modules/typeorm/error/MissingJoinColumnError.js
var require_MissingJoinColumnError = __commonJS({
  "node_modules/typeorm/error/MissingJoinColumnError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MissingJoinColumnError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var MissingJoinColumnError2 = class extends TypeORMError_1.TypeORMError {
      constructor(entityMetadata, relation) {
        super();
        if (relation.inverseRelation) {
          this.message = `JoinColumn is missing on both sides of ${entityMetadata.name}#${relation.propertyName} and ${relation.inverseEntityMetadata.name}#${relation.inverseRelation.propertyName} one-to-one relationship. You need to put JoinColumn decorator on one of the sides.`;
        } else {
          this.message = `JoinColumn is missing on ${entityMetadata.name}#${relation.propertyName} one-to-one relationship. You need to put JoinColumn decorator on it.`;
        }
      }
    };
    exports2.MissingJoinColumnError = MissingJoinColumnError2;
  }
});

// node_modules/typeorm/error/MissingPrimaryColumnError.js
var require_MissingPrimaryColumnError = __commonJS({
  "node_modules/typeorm/error/MissingPrimaryColumnError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MissingPrimaryColumnError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var MissingPrimaryColumnError2 = class extends TypeORMError_1.TypeORMError {
      constructor(entityMetadata) {
        super(`Entity "${entityMetadata.name}" does not have a primary column. Primary column is required to have in all your entities. Use @PrimaryColumn decorator to add a primary column to your entity.`);
      }
    };
    exports2.MissingPrimaryColumnError = MissingPrimaryColumnError2;
  }
});

// node_modules/typeorm/error/EntityPropertyNotFoundError.js
var require_EntityPropertyNotFoundError = __commonJS({
  "node_modules/typeorm/error/EntityPropertyNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EntityPropertyNotFoundError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var EntityPropertyNotFoundError2 = class _EntityPropertyNotFoundError extends TypeORMError_1.TypeORMError {
      constructor(propertyPath, metadata) {
        super(propertyPath);
        Object.setPrototypeOf(this, _EntityPropertyNotFoundError.prototype);
        this.message = `Property "${propertyPath}" was not found in "${metadata.targetName}". Make sure your query is correct.`;
      }
    };
    exports2.EntityPropertyNotFoundError = EntityPropertyNotFoundError2;
  }
});

// node_modules/typeorm/error/MissingDriverError.js
var require_MissingDriverError = __commonJS({
  "node_modules/typeorm/error/MissingDriverError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MissingDriverError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var MissingDriverError2 = class extends TypeORMError_1.TypeORMError {
      constructor(driverType, availableDrivers = []) {
        super(`Wrong driver: "${driverType}" given. Supported drivers are: ${availableDrivers.map((d) => `"${d}"`).join(", ")}.`);
      }
    };
    exports2.MissingDriverError = MissingDriverError2;
  }
});

// node_modules/typeorm/error/DriverPackageNotInstalledError.js
var require_DriverPackageNotInstalledError = __commonJS({
  "node_modules/typeorm/error/DriverPackageNotInstalledError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DriverPackageNotInstalledError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var DriverPackageNotInstalledError2 = class extends TypeORMError_1.TypeORMError {
      constructor(driverName, packageName) {
        super(`${driverName} package has not been found installed. Please run "npm install ${packageName}".`);
      }
    };
    exports2.DriverPackageNotInstalledError = DriverPackageNotInstalledError2;
  }
});

// node_modules/typeorm/error/CannotGetEntityManagerNotConnectedError.js
var require_CannotGetEntityManagerNotConnectedError = __commonJS({
  "node_modules/typeorm/error/CannotGetEntityManagerNotConnectedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CannotGetEntityManagerNotConnectedError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var CannotGetEntityManagerNotConnectedError2 = class extends TypeORMError_1.TypeORMError {
      constructor(connectionName) {
        super(`Cannot get entity manager for "${connectionName}" connection because connection is not yet established.`);
      }
    };
    exports2.CannotGetEntityManagerNotConnectedError = CannotGetEntityManagerNotConnectedError2;
  }
});

// node_modules/typeorm/error/ConnectionNotFoundError.js
var require_ConnectionNotFoundError = __commonJS({
  "node_modules/typeorm/error/ConnectionNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectionNotFoundError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var ConnectionNotFoundError2 = class extends TypeORMError_1.TypeORMError {
      constructor(name) {
        super(`Connection "${name}" was not found.`);
      }
    };
    exports2.ConnectionNotFoundError = ConnectionNotFoundError2;
  }
});

// node_modules/typeorm/error/NoVersionOrUpdateDateColumnError.js
var require_NoVersionOrUpdateDateColumnError = __commonJS({
  "node_modules/typeorm/error/NoVersionOrUpdateDateColumnError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NoVersionOrUpdateDateColumnError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var NoVersionOrUpdateDateColumnError2 = class extends TypeORMError_1.TypeORMError {
      constructor(entity) {
        super(`Entity ${entity} does not have version or update date columns.`);
      }
    };
    exports2.NoVersionOrUpdateDateColumnError = NoVersionOrUpdateDateColumnError2;
  }
});

// node_modules/typeorm/error/InsertValuesMissingError.js
var require_InsertValuesMissingError = __commonJS({
  "node_modules/typeorm/error/InsertValuesMissingError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InsertValuesMissingError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var InsertValuesMissingError2 = class extends TypeORMError_1.TypeORMError {
      constructor() {
        super(`Cannot perform insert query because values are not defined. Call "qb.values(...)" method to specify inserted values.`);
      }
    };
    exports2.InsertValuesMissingError = InsertValuesMissingError2;
  }
});

// node_modules/typeorm/error/OptimisticLockCanNotBeUsedError.js
var require_OptimisticLockCanNotBeUsedError = __commonJS({
  "node_modules/typeorm/error/OptimisticLockCanNotBeUsedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OptimisticLockCanNotBeUsedError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var OptimisticLockCanNotBeUsedError2 = class extends TypeORMError_1.TypeORMError {
      constructor() {
        super(`The optimistic lock can be used only with getOne() method.`);
      }
    };
    exports2.OptimisticLockCanNotBeUsedError = OptimisticLockCanNotBeUsedError2;
  }
});

// node_modules/typeorm/error/MetadataWithSuchNameAlreadyExistsError.js
var require_MetadataWithSuchNameAlreadyExistsError = __commonJS({
  "node_modules/typeorm/error/MetadataWithSuchNameAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MetadataWithSuchNameAlreadyExistsError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var MetadataWithSuchNameAlreadyExistsError2 = class extends TypeORMError_1.TypeORMError {
      constructor(metadataType, name) {
        super(metadataType + " metadata with such name " + name + " already exists. Do you apply decorator twice? Or maybe try to change a name?");
      }
    };
    exports2.MetadataWithSuchNameAlreadyExistsError = MetadataWithSuchNameAlreadyExistsError2;
  }
});

// node_modules/typeorm/error/DriverOptionNotSetError.js
var require_DriverOptionNotSetError = __commonJS({
  "node_modules/typeorm/error/DriverOptionNotSetError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DriverOptionNotSetError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var DriverOptionNotSetError2 = class extends TypeORMError_1.TypeORMError {
      constructor(optionName) {
        super(`Driver option (${optionName}) is not set. Please set it to perform connection to the database.`);
      }
    };
    exports2.DriverOptionNotSetError = DriverOptionNotSetError2;
  }
});

// node_modules/typeorm/error/FindRelationsNotFoundError.js
var require_FindRelationsNotFoundError = __commonJS({
  "node_modules/typeorm/error/FindRelationsNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FindRelationsNotFoundError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var FindRelationsNotFoundError2 = class extends TypeORMError_1.TypeORMError {
      constructor(notFoundRelations) {
        super();
        if (notFoundRelations.length === 1) {
          this.message = `Relation "${notFoundRelations[0]}" was not found; please check if it is correct and really exists in your entity.`;
        } else {
          this.message = `Relations ${notFoundRelations.map((relation) => `"${relation}"`).join(", ")} were not found; please check if relations are correct and they exist in your entities.`;
        }
      }
    };
    exports2.FindRelationsNotFoundError = FindRelationsNotFoundError2;
  }
});

// node_modules/typeorm/error/PessimisticLockTransactionRequiredError.js
var require_PessimisticLockTransactionRequiredError = __commonJS({
  "node_modules/typeorm/error/PessimisticLockTransactionRequiredError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PessimisticLockTransactionRequiredError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var PessimisticLockTransactionRequiredError2 = class extends TypeORMError_1.TypeORMError {
      constructor() {
        super(`An open transaction is required for pessimistic lock.`);
      }
    };
    exports2.PessimisticLockTransactionRequiredError = PessimisticLockTransactionRequiredError2;
  }
});

// node_modules/typeorm/error/RepositoryNotTreeError.js
var require_RepositoryNotTreeError = __commonJS({
  "node_modules/typeorm/error/RepositoryNotTreeError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RepositoryNotTreeError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var ObjectUtils_1 = require_ObjectUtils();
    var InstanceChecker_1 = require_InstanceChecker();
    var RepositoryNotTreeError2 = class extends TypeORMError_1.TypeORMError {
      constructor(entityClass) {
        super();
        let targetName;
        if (InstanceChecker_1.InstanceChecker.isEntitySchema(entityClass)) {
          targetName = entityClass.options.name;
        } else if (typeof entityClass === "function") {
          targetName = entityClass.name;
        } else if (ObjectUtils_1.ObjectUtils.isObject(entityClass) && "name" in entityClass) {
          targetName = entityClass.name;
        } else {
          targetName = entityClass;
        }
        this.message = `Repository of the "${targetName}" class is not a TreeRepository. Try to apply @Tree decorator on your entity.`;
      }
    };
    exports2.RepositoryNotTreeError = RepositoryNotTreeError2;
  }
});

// node_modules/typeorm/error/DataTypeNotSupportedError.js
var require_DataTypeNotSupportedError = __commonJS({
  "node_modules/typeorm/error/DataTypeNotSupportedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DataTypeNotSupportedError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var DataTypeNotSupportedError2 = class extends TypeORMError_1.TypeORMError {
      constructor(column, dataType, database) {
        super();
        const type = typeof dataType === "string" ? dataType : dataType.name;
        this.message = `Data type "${type}" in "${column.entityMetadata.targetName}.${column.propertyName}" is not supported by "${database}" database.`;
      }
    };
    exports2.DataTypeNotSupportedError = DataTypeNotSupportedError2;
  }
});

// node_modules/typeorm/error/InitializedRelationError.js
var require_InitializedRelationError = __commonJS({
  "node_modules/typeorm/error/InitializedRelationError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InitializedRelationError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var InitializedRelationError2 = class extends TypeORMError_1.TypeORMError {
      constructor(relation) {
        super(`Array initializations are not allowed in entity relations. Please remove array initialization (= []) from "${relation.entityMetadata.targetName}#${relation.propertyPath}". This is ORM requirement to make relations to work properly. Refer docs for more information.`);
      }
    };
    exports2.InitializedRelationError = InitializedRelationError2;
  }
});

// node_modules/typeorm/error/MissingJoinTableError.js
var require_MissingJoinTableError = __commonJS({
  "node_modules/typeorm/error/MissingJoinTableError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MissingJoinTableError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var MissingJoinTableError2 = class extends TypeORMError_1.TypeORMError {
      constructor(entityMetadata, relation) {
        super();
        if (relation.inverseRelation) {
          this.message = `JoinTable is missing on both sides of ${entityMetadata.name}#${relation.propertyName} and ${relation.inverseEntityMetadata.name}#${relation.inverseRelation.propertyName} many-to-many relationship. You need to put decorator decorator on one of the sides.`;
        } else {
          this.message = `JoinTable is missing on ${entityMetadata.name}#${relation.propertyName} many-to-many relationship. You need to put JoinTable decorator on it.`;
        }
      }
    };
    exports2.MissingJoinTableError = MissingJoinTableError2;
  }
});

// node_modules/typeorm/error/QueryFailedError.js
var require_QueryFailedError = __commonJS({
  "node_modules/typeorm/error/QueryFailedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryFailedError = void 0;
    var ObjectUtils_1 = require_ObjectUtils();
    var TypeORMError_1 = require_TypeORMError();
    var QueryFailedError2 = class extends TypeORMError_1.TypeORMError {
      constructor(query, parameters, driverError) {
        super(driverError.toString().replace(/^error: /, "").replace(/^Error: /, "").replace(/^Request/, ""));
        this.query = query;
        this.parameters = parameters;
        this.driverError = driverError;
        if (driverError) {
          const {
            name: _,
            // eslint-disable-line
            ...otherProperties
          } = driverError;
          ObjectUtils_1.ObjectUtils.assign(this, {
            ...otherProperties
          });
        }
      }
    };
    exports2.QueryFailedError = QueryFailedError2;
  }
});

// node_modules/typeorm/error/NoNeedToReleaseEntityManagerError.js
var require_NoNeedToReleaseEntityManagerError = __commonJS({
  "node_modules/typeorm/error/NoNeedToReleaseEntityManagerError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NoNeedToReleaseEntityManagerError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var NoNeedToReleaseEntityManagerError2 = class extends TypeORMError_1.TypeORMError {
      constructor() {
        super(`Entity manager is not using single database connection and cannot be released. Only entity managers created by connection#createEntityManagerWithSingleDatabaseConnection methods have a single database connection and they should be released.`);
      }
    };
    exports2.NoNeedToReleaseEntityManagerError = NoNeedToReleaseEntityManagerError2;
  }
});

// node_modules/typeorm/error/UsingJoinColumnOnlyOnOneSideAllowedError.js
var require_UsingJoinColumnOnlyOnOneSideAllowedError = __commonJS({
  "node_modules/typeorm/error/UsingJoinColumnOnlyOnOneSideAllowedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UsingJoinColumnOnlyOnOneSideAllowedError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var UsingJoinColumnOnlyOnOneSideAllowedError2 = class extends TypeORMError_1.TypeORMError {
      constructor(entityMetadata, relation) {
        super(`Using JoinColumn is allowed only on one side of the one-to-one relationship. Both ${entityMetadata.name}#${relation.propertyName} and ${relation.inverseEntityMetadata.name}#${relation.inverseRelation.propertyName} has JoinTable decorators. Choose one of them and left JoinTable decorator only on it.`);
      }
    };
    exports2.UsingJoinColumnOnlyOnOneSideAllowedError = UsingJoinColumnOnlyOnOneSideAllowedError2;
  }
});

// node_modules/typeorm/error/UsingJoinTableOnlyOnOneSideAllowedError.js
var require_UsingJoinTableOnlyOnOneSideAllowedError = __commonJS({
  "node_modules/typeorm/error/UsingJoinTableOnlyOnOneSideAllowedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UsingJoinTableOnlyOnOneSideAllowedError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var UsingJoinTableOnlyOnOneSideAllowedError2 = class extends TypeORMError_1.TypeORMError {
      constructor(entityMetadata, relation) {
        super(`Using JoinTable is allowed only on one side of the many-to-many relationship. Both ${entityMetadata.name}#${relation.propertyName} and ${relation.inverseEntityMetadata.name}#${relation.inverseRelation.propertyName} has JoinTable decorators. Choose one of them and left JoinColumn decorator only on it.`);
      }
    };
    exports2.UsingJoinTableOnlyOnOneSideAllowedError = UsingJoinTableOnlyOnOneSideAllowedError2;
  }
});

// node_modules/typeorm/error/SubjectRemovedAndUpdatedError.js
var require_SubjectRemovedAndUpdatedError = __commonJS({
  "node_modules/typeorm/error/SubjectRemovedAndUpdatedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SubjectRemovedAndUpdatedError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var SubjectRemovedAndUpdatedError2 = class extends TypeORMError_1.TypeORMError {
      constructor(subject) {
        super(`Removed entity "${subject.metadata.name}" is also scheduled for update operation. Make sure you are not updating and removing same object (note that update or remove may be executed by cascade operations).`);
      }
    };
    exports2.SubjectRemovedAndUpdatedError = SubjectRemovedAndUpdatedError2;
  }
});

// node_modules/typeorm/error/PersistedEntityNotFoundError.js
var require_PersistedEntityNotFoundError = __commonJS({
  "node_modules/typeorm/error/PersistedEntityNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PersistedEntityNotFoundError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var PersistedEntityNotFoundError2 = class extends TypeORMError_1.TypeORMError {
      constructor() {
        super(`Internal error. Persisted entity was not found in the list of prepared operated entities.`);
      }
    };
    exports2.PersistedEntityNotFoundError = PersistedEntityNotFoundError2;
  }
});

// node_modules/typeorm/error/UsingJoinColumnIsNotAllowedError.js
var require_UsingJoinColumnIsNotAllowedError = __commonJS({
  "node_modules/typeorm/error/UsingJoinColumnIsNotAllowedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UsingJoinColumnIsNotAllowedError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var UsingJoinColumnIsNotAllowedError2 = class extends TypeORMError_1.TypeORMError {
      constructor(entityMetadata, relation) {
        super(`Using JoinColumn on ${entityMetadata.name}#${relation.propertyName} is wrong. You can use JoinColumn only on one-to-one and many-to-one relations.`);
      }
    };
    exports2.UsingJoinColumnIsNotAllowedError = UsingJoinColumnIsNotAllowedError2;
  }
});

// node_modules/typeorm/error/ColumnTypeUndefinedError.js
var require_ColumnTypeUndefinedError = __commonJS({
  "node_modules/typeorm/error/ColumnTypeUndefinedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ColumnTypeUndefinedError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var ColumnTypeUndefinedError2 = class extends TypeORMError_1.TypeORMError {
      constructor(object, propertyName) {
        super(`Column type for ${object.constructor.name}#${propertyName} is not defined and cannot be guessed. Make sure you have turned on an "emitDecoratorMetadata": true option in tsconfig.json. Also make sure you have imported "reflect-metadata" on top of the main entry file in your application (before any entity imported).If you are using JavaScript instead of TypeScript you must explicitly provide a column type.`);
      }
    };
    exports2.ColumnTypeUndefinedError = ColumnTypeUndefinedError2;
  }
});

// node_modules/typeorm/error/QueryRunnerAlreadyReleasedError.js
var require_QueryRunnerAlreadyReleasedError = __commonJS({
  "node_modules/typeorm/error/QueryRunnerAlreadyReleasedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryRunnerAlreadyReleasedError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var QueryRunnerAlreadyReleasedError2 = class extends TypeORMError_1.TypeORMError {
      constructor() {
        super(`Query runner already released. Cannot run queries anymore.`);
      }
    };
    exports2.QueryRunnerAlreadyReleasedError = QueryRunnerAlreadyReleasedError2;
  }
});

// node_modules/typeorm/error/OffsetWithoutLimitNotSupportedError.js
var require_OffsetWithoutLimitNotSupportedError = __commonJS({
  "node_modules/typeorm/error/OffsetWithoutLimitNotSupportedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OffsetWithoutLimitNotSupportedError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var OffsetWithoutLimitNotSupportedError2 = class extends TypeORMError_1.TypeORMError {
      constructor() {
        super(`RDBMS does not support OFFSET without LIMIT in SELECT statements. You must use limit in conjunction with offset function (or take in conjunction with skip function if you are using pagination).`);
      }
    };
    exports2.OffsetWithoutLimitNotSupportedError = OffsetWithoutLimitNotSupportedError2;
  }
});

// node_modules/typeorm/error/CannotExecuteNotConnectedError.js
var require_CannotExecuteNotConnectedError = __commonJS({
  "node_modules/typeorm/error/CannotExecuteNotConnectedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CannotExecuteNotConnectedError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var CannotExecuteNotConnectedError2 = class extends TypeORMError_1.TypeORMError {
      constructor(connectionName) {
        super(`Cannot execute operation on "${connectionName}" connection because connection is not yet established.`);
      }
    };
    exports2.CannotExecuteNotConnectedError = CannotExecuteNotConnectedError2;
  }
});

// node_modules/typeorm/error/NoConnectionOptionError.js
var require_NoConnectionOptionError = __commonJS({
  "node_modules/typeorm/error/NoConnectionOptionError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NoConnectionOptionError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var NoConnectionOptionError2 = class extends TypeORMError_1.TypeORMError {
      constructor(optionName) {
        super(`Option "${optionName}" is not set in your connection options, please define "${optionName}" option in your connection options or ormconfig.json`);
      }
    };
    exports2.NoConnectionOptionError = NoConnectionOptionError2;
  }
});

// node_modules/typeorm/error/ForbiddenTransactionModeOverrideError.js
var require_ForbiddenTransactionModeOverrideError = __commonJS({
  "node_modules/typeorm/error/ForbiddenTransactionModeOverrideError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ForbiddenTransactionModeOverrideError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var ForbiddenTransactionModeOverrideError2 = class extends TypeORMError_1.TypeORMError {
      constructor(migrationsOverridingTransactionMode) {
        const migrationNames = migrationsOverridingTransactionMode.map((migration) => `"${migration.name}"`);
        super(`Migrations ${migrationNames.join(", ")} override the transaction mode, but the global transaction mode is "all"`);
      }
    };
    exports2.ForbiddenTransactionModeOverrideError = ForbiddenTransactionModeOverrideError2;
  }
});

// node_modules/typeorm/error/index.js
var require_error = __commonJS({
  "node_modules/typeorm/error/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_CannotReflectMethodParameterTypeError(), exports2);
    tslib_1.__exportStar(require_AlreadyHasActiveConnectionError(), exports2);
    tslib_1.__exportStar(require_SubjectWithoutIdentifierError(), exports2);
    tslib_1.__exportStar(require_CannotConnectAlreadyConnectedError(), exports2);
    tslib_1.__exportStar(require_LockNotSupportedOnGivenDriverError(), exports2);
    tslib_1.__exportStar(require_ConnectionIsNotSetError(), exports2);
    tslib_1.__exportStar(require_CannotCreateEntityIdMapError(), exports2);
    tslib_1.__exportStar(require_MetadataAlreadyExistsError(), exports2);
    tslib_1.__exportStar(require_CannotDetermineEntityError(), exports2);
    tslib_1.__exportStar(require_UpdateValuesMissingError(), exports2);
    tslib_1.__exportStar(require_TreeRepositoryNotSupportedError(), exports2);
    tslib_1.__exportStar(require_CustomRepositoryNotFoundError(), exports2);
    tslib_1.__exportStar(require_TransactionNotStartedError(), exports2);
    tslib_1.__exportStar(require_TransactionAlreadyStartedError(), exports2);
    tslib_1.__exportStar(require_EntityNotFoundError(), exports2);
    tslib_1.__exportStar(require_EntityMetadataNotFoundError(), exports2);
    tslib_1.__exportStar(require_MustBeEntityError(), exports2);
    tslib_1.__exportStar(require_OptimisticLockVersionMismatchError(), exports2);
    tslib_1.__exportStar(require_LimitOnUpdateNotSupportedError(), exports2);
    tslib_1.__exportStar(require_PrimaryColumnCannotBeNullableError(), exports2);
    tslib_1.__exportStar(require_CustomRepositoryCannotInheritRepositoryError(), exports2);
    tslib_1.__exportStar(require_QueryRunnerProviderAlreadyReleasedError(), exports2);
    tslib_1.__exportStar(require_CannotAttachTreeChildrenEntityError(), exports2);
    tslib_1.__exportStar(require_CustomRepositoryDoesNotHaveEntityError(), exports2);
    tslib_1.__exportStar(require_MissingDeleteDateColumnError(), exports2);
    tslib_1.__exportStar(require_NoConnectionForRepositoryError(), exports2);
    tslib_1.__exportStar(require_CircularRelationsError(), exports2);
    tslib_1.__exportStar(require_ReturningStatementNotSupportedError(), exports2);
    tslib_1.__exportStar(require_UsingJoinTableIsNotAllowedError(), exports2);
    tslib_1.__exportStar(require_MissingJoinColumnError(), exports2);
    tslib_1.__exportStar(require_MissingPrimaryColumnError(), exports2);
    tslib_1.__exportStar(require_EntityPropertyNotFoundError(), exports2);
    tslib_1.__exportStar(require_MissingDriverError(), exports2);
    tslib_1.__exportStar(require_DriverPackageNotInstalledError(), exports2);
    tslib_1.__exportStar(require_CannotGetEntityManagerNotConnectedError(), exports2);
    tslib_1.__exportStar(require_ConnectionNotFoundError(), exports2);
    tslib_1.__exportStar(require_NoVersionOrUpdateDateColumnError(), exports2);
    tslib_1.__exportStar(require_InsertValuesMissingError(), exports2);
    tslib_1.__exportStar(require_OptimisticLockCanNotBeUsedError(), exports2);
    tslib_1.__exportStar(require_MetadataWithSuchNameAlreadyExistsError(), exports2);
    tslib_1.__exportStar(require_DriverOptionNotSetError(), exports2);
    tslib_1.__exportStar(require_FindRelationsNotFoundError(), exports2);
    tslib_1.__exportStar(require_PessimisticLockTransactionRequiredError(), exports2);
    tslib_1.__exportStar(require_RepositoryNotTreeError(), exports2);
    tslib_1.__exportStar(require_DataTypeNotSupportedError(), exports2);
    tslib_1.__exportStar(require_InitializedRelationError(), exports2);
    tslib_1.__exportStar(require_MissingJoinTableError(), exports2);
    tslib_1.__exportStar(require_QueryFailedError(), exports2);
    tslib_1.__exportStar(require_NoNeedToReleaseEntityManagerError(), exports2);
    tslib_1.__exportStar(require_UsingJoinColumnOnlyOnOneSideAllowedError(), exports2);
    tslib_1.__exportStar(require_UsingJoinTableOnlyOnOneSideAllowedError(), exports2);
    tslib_1.__exportStar(require_SubjectRemovedAndUpdatedError(), exports2);
    tslib_1.__exportStar(require_PersistedEntityNotFoundError(), exports2);
    tslib_1.__exportStar(require_UsingJoinColumnIsNotAllowedError(), exports2);
    tslib_1.__exportStar(require_ColumnTypeUndefinedError(), exports2);
    tslib_1.__exportStar(require_QueryRunnerAlreadyReleasedError(), exports2);
    tslib_1.__exportStar(require_OffsetWithoutLimitNotSupportedError(), exports2);
    tslib_1.__exportStar(require_CannotExecuteNotConnectedError(), exports2);
    tslib_1.__exportStar(require_NoConnectionOptionError(), exports2);
    tslib_1.__exportStar(require_TypeORMError(), exports2);
    tslib_1.__exportStar(require_ForbiddenTransactionModeOverrideError(), exports2);
  }
});

// node_modules/typeorm/util/ImportUtils.js
var require_ImportUtils = __commonJS({
  "node_modules/typeorm/util/ImportUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.importOrRequireFile = importOrRequireFile;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var promises_1 = tslib_1.__importDefault(require("fs/promises"));
    var path_1 = tslib_1.__importDefault(require("path"));
    var url_1 = require("url");
    async function importOrRequireFile(filePath) {
      const tryToImport = async () => {
        return [
          // eslint-disable-next-line @typescript-eslint/no-implied-eval
          await Function("return filePath => import(filePath)")()(filePath.startsWith("file://") ? filePath : (0, url_1.pathToFileURL)(filePath).toString()),
          "esm"
        ];
      };
      const tryToRequire = () => {
        return [require(filePath), "commonjs"];
      };
      const extension = filePath.substring(filePath.lastIndexOf(".") + ".".length);
      if (extension === "mjs" || extension === "mts")
        return tryToImport();
      else if (extension === "cjs" || extension === "cts")
        return tryToRequire();
      else if (extension === "js" || extension === "ts") {
        const packageJson = await getNearestPackageJson(filePath);
        if (packageJson != null) {
          const isModule = packageJson?.type === "module";
          if (isModule)
            return tryToImport();
          else
            return tryToRequire();
        } else
          return tryToRequire();
      }
      return tryToRequire();
    }
    async function getNearestPackageJson(filePath) {
      let currentPath = filePath;
      while (currentPath !== path_1.default.dirname(currentPath)) {
        currentPath = path_1.default.dirname(currentPath);
        const potentialPackageJson = path_1.default.join(currentPath, "package.json");
        try {
          const stats = await promises_1.default.stat(potentialPackageJson);
          if (!stats.isFile()) {
            continue;
          }
          try {
            return JSON.parse(await promises_1.default.readFile(potentialPackageJson, "utf8"));
          } catch {
            return null;
          }
        } catch {
          continue;
        }
      }
      return null;
    }
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function") throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/to-buffer/node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/to-buffer/node_modules/isarray/index.js"(exports2, module2) {
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/es-errors/type.js
var require_type = __commonJS({
  "node_modules/es-errors/type.js"(exports2, module2) {
    "use strict";
    module2.exports = TypeError;
  }
});

// node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  "node_modules/es-object-atoms/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Object;
  }
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "node_modules/es-errors/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Error;
  }
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "node_modules/es-errors/eval.js"(exports2, module2) {
    "use strict";
    module2.exports = EvalError;
  }
});

// node_modules/es-errors/range.js
var require_range = __commonJS({
  "node_modules/es-errors/range.js"(exports2, module2) {
    "use strict";
    module2.exports = RangeError;
  }
});

// node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "node_modules/es-errors/ref.js"(exports2, module2) {
    "use strict";
    module2.exports = ReferenceError;
  }
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "node_modules/es-errors/syntax.js"(exports2, module2) {
    "use strict";
    module2.exports = SyntaxError;
  }
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "node_modules/es-errors/uri.js"(exports2, module2) {
    "use strict";
    module2.exports = URIError;
  }
});

// node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({
  "node_modules/math-intrinsics/abs.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.abs;
  }
});

// node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({
  "node_modules/math-intrinsics/floor.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.floor;
  }
});

// node_modules/math-intrinsics/max.js
var require_max = __commonJS({
  "node_modules/math-intrinsics/max.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.max;
  }
});

// node_modules/math-intrinsics/min.js
var require_min = __commonJS({
  "node_modules/math-intrinsics/min.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.min;
  }
});

// node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({
  "node_modules/math-intrinsics/pow.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.pow;
  }
});

// node_modules/math-intrinsics/round.js
var require_round = __commonJS({
  "node_modules/math-intrinsics/round.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.round;
  }
});

// node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS({
  "node_modules/math-intrinsics/isNaN.js"(exports2, module2) {
    "use strict";
    module2.exports = Number.isNaN || function isNaN2(a) {
      return a !== a;
    };
  }
});

// node_modules/math-intrinsics/sign.js
var require_sign = __commonJS({
  "node_modules/math-intrinsics/sign.js"(exports2, module2) {
    "use strict";
    var $isNaN = require_isNaN();
    module2.exports = function sign(number) {
      if ($isNaN(number) || number === 0) {
        return number;
      }
      return number < 0 ? -1 : 1;
    };
  }
});

// node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "node_modules/gopd/gOPD.js"(exports2, module2) {
    "use strict";
    module2.exports = Object.getOwnPropertyDescriptor;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports2, module2) {
    "use strict";
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module2.exports = $gOPD;
  }
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "node_modules/es-define-property/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module2.exports = $defineProperty;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _ in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Reflect.getPrototypeOf.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  }
});

// node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Object.getPrototypeOf.js"(exports2, module2) {
    "use strict";
    var $Object = require_es_object_atoms();
    module2.exports = $Object.getPrototypeOf || null;
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  "node_modules/call-bind-apply-helpers/functionCall.js"(exports2, module2) {
    "use strict";
    module2.exports = Function.prototype.call;
  }
});

// node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  "node_modules/call-bind-apply-helpers/functionApply.js"(exports2, module2) {
    "use strict";
    module2.exports = Function.prototype.apply;
  }
});

// node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  "node_modules/call-bind-apply-helpers/reflectApply.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  }
});

// node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  "node_modules/call-bind-apply-helpers/actualApply.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module2.exports = $reflectApply || bind.call($call, $apply);
  }
});

// node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  "node_modules/call-bind-apply-helpers/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module2.exports = function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind, $call, args);
    };
  }
});

// node_modules/dunder-proto/get.js
var require_get = __commonJS({
  "node_modules/dunder-proto/get.js"(exports2, module2) {
    "use strict";
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e) {
      if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
        throw e;
      }
    }
    var desc = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module2.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      function getDunder(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      }
    ) : false;
  }
});

// node_modules/get-proto/index.js
var require_get_proto = __commonJS({
  "node_modules/get-proto/index.js"(exports2, module2) {
    "use strict";
    var reflectGetProto = require_Reflect_getPrototypeOf();
    var originalGetProto = require_Object_getPrototypeOf();
    var getDunderProto = require_get();
    module2.exports = reflectGetProto ? function getProto(O) {
      return reflectGetProto(O);
    } : originalGetProto ? function getProto(O) {
      if (!O || typeof O !== "object" && typeof O !== "function") {
        throw new TypeError("getProto: not an object");
      }
      return originalGetProto(O);
    } : getDunderProto ? function getProto(O) {
      return getDunderProto(O);
    } : null;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports2, module2) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module2.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var abs = require_abs();
    var floor = require_floor();
    var max = require_max();
    var min = require_min();
    var pow = require_pow();
    var round = require_round();
    var sign = require_sign();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? (function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    })() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = require_get_proto();
    var $ObjectGPO = require_Object_getPrototypeOf();
    var $ReflectGPO = require_Reflect_getPrototypeOf();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs,
      "%Math.floor%": floor,
      "%Math.max%": max,
      "%Math.min%": min,
      "%Math.pow%": pow,
      "%Math.round%": round,
      "%Math.sign%": sign,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call($call, Array.prototype.concat);
    var $spliceApply = bind.call($apply, Array.prototype.splice);
    var $replace = bind.call($call, String.prototype.replace);
    var $strSlice = bind.call($call, String.prototype.slice);
    var $exec = bind.call($call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void undefined2;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/call-bound/index.js
var require_call_bound = __commonJS({
  "node_modules/call-bound/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBindBasic = require_call_bind_apply_helpers();
    var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
    module2.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = (
        /** @type {(this: unknown, ...args: unknown[]) => unknown} */
        GetIntrinsic(name, !!allowMissing)
      );
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBindBasic(
          /** @type {const} */
          [intrinsic]
        );
      }
      return intrinsic;
    };
  }
});

// node_modules/is-callable/index.js
var require_is_callable = __commonJS({
  "node_modules/is-callable/index.js"(exports2, module2) {
    "use strict";
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: function() {
            throw isCallableMarker;
          }
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_) {
        if (_ !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var objectClass = "[object Object]";
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var ddaClass = "[object HTMLAllCollection]";
    var ddaClass2 = "[object HTML document.all class]";
    var ddaClass3 = "[object HTMLCollection]";
    var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
    var isIE68 = !(0 in [,]);
    var isDDA = function isDocumentDotAll() {
      return false;
    };
    if (typeof document === "object") {
      all = document.all;
      if (toStr.call(all) === toStr.call(document.all)) {
        isDDA = function isDocumentDotAll(value) {
          if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
            try {
              var str = toStr.call(value);
              return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
            } catch (e) {
            }
          }
          return false;
        };
      }
    }
    var all;
    module2.exports = reflectApply ? function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      try {
        reflectApply(value, null, badArrayLike);
      } catch (e) {
        if (e !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value) && tryFunctionObject(value);
    } : function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass = toStr.call(value);
      if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
        return false;
      }
      return tryFunctionObject(value);
    };
  }
});

// node_modules/for-each/index.js
var require_for_each = __commonJS({
  "node_modules/for-each/index.js"(exports2, module2) {
    "use strict";
    var isCallable = require_is_callable();
    var toStr = Object.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var forEachArray = function forEachArray2(array, iterator, receiver) {
      for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
          if (receiver == null) {
            iterator(array[i], i, array);
          } else {
            iterator.call(receiver, array[i], i, array);
          }
        }
      }
    };
    var forEachString = function forEachString2(string, iterator, receiver) {
      for (var i = 0, len = string.length; i < len; i++) {
        if (receiver == null) {
          iterator(string.charAt(i), i, string);
        } else {
          iterator.call(receiver, string.charAt(i), i, string);
        }
      }
    };
    var forEachObject = function forEachObject2(object, iterator, receiver) {
      for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
          if (receiver == null) {
            iterator(object[k], k, object);
          } else {
            iterator.call(receiver, object[k], k, object);
          }
        }
      }
    };
    function isArray(x) {
      return toStr.call(x) === "[object Array]";
    }
    module2.exports = function forEach(list, iterator, thisArg) {
      if (!isCallable(iterator)) {
        throw new TypeError("iterator must be a function");
      }
      var receiver;
      if (arguments.length >= 3) {
        receiver = thisArg;
      }
      if (isArray(list)) {
        forEachArray(list, iterator, receiver);
      } else if (typeof list === "string") {
        forEachString(list, iterator, receiver);
      } else {
        forEachObject(list, iterator, receiver);
      }
    };
  }
});

// node_modules/possible-typed-array-names/index.js
var require_possible_typed_array_names = __commonJS({
  "node_modules/possible-typed-array-names/index.js"(exports2, module2) {
    "use strict";
    module2.exports = [
      "Float16Array",
      "Float32Array",
      "Float64Array",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "BigInt64Array",
      "BigUint64Array"
    ];
  }
});

// node_modules/available-typed-arrays/index.js
var require_available_typed_arrays = __commonJS({
  "node_modules/available-typed-arrays/index.js"(exports2, module2) {
    "use strict";
    var possibleNames = require_possible_typed_array_names();
    var g = typeof globalThis === "undefined" ? global : globalThis;
    module2.exports = function availableTypedArrays() {
      var out = [];
      for (var i = 0; i < possibleNames.length; i++) {
        if (typeof g[possibleNames[i]] === "function") {
          out[out.length] = possibleNames[i];
        }
      }
      return out;
    };
  }
});

// node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "node_modules/define-data-property/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var gopd = require_gopd();
    module2.exports = function defineDataProperty(obj, property, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property !== "string" && typeof property !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property);
      if ($defineProperty) {
        $defineProperty(obj, property, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
  }
});

// node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "node_modules/has-property-descriptors/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      return !!$defineProperty;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!$defineProperty) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e) {
        return true;
      }
    };
    module2.exports = hasPropertyDescriptors;
  }
});

// node_modules/set-function-length/index.js
var require_set_function_length = __commonJS({
  "node_modules/set-function-length/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var define2 = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var gOPD = require_gopd();
    var $TypeError = require_type();
    var $floor = GetIntrinsic("%Math.floor%");
    module2.exports = function setFunctionLength(fn, length) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
        throw new $TypeError("`length` must be a positive 32-bit integer");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      var functionLengthIsConfigurable = true;
      var functionLengthIsWritable = true;
      if ("length" in fn && gOPD) {
        var desc = gOPD(fn, "length");
        if (desc && !desc.configurable) {
          functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
          functionLengthIsWritable = false;
        }
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length,
            true,
            true
          );
        } else {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length
          );
        }
      }
      return fn;
    };
  }
});

// node_modules/call-bind-apply-helpers/applyBind.js
var require_applyBind = __commonJS({
  "node_modules/call-bind-apply-helpers/applyBind.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var actualApply = require_actualApply();
    module2.exports = function applyBind() {
      return actualApply(bind, $apply, arguments);
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports2, module2) {
    "use strict";
    var setFunctionLength = require_set_function_length();
    var $defineProperty = require_es_define_property();
    var callBindBasic = require_call_bind_apply_helpers();
    var applyBind = require_applyBind();
    module2.exports = function callBind(originalFunction) {
      var func = callBindBasic(arguments);
      var adjustedLength = originalFunction.length - (arguments.length - 1);
      return setFunctionLength(
        func,
        1 + (adjustedLength > 0 ? adjustedLength : 0),
        true
      );
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  }
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "node_modules/has-tostringtag/shams.js"(exports2, module2) {
    "use strict";
    var hasSymbols = require_shams();
    module2.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// node_modules/which-typed-array/index.js
var require_which_typed_array = __commonJS({
  "node_modules/which-typed-array/index.js"(exports2, module2) {
    "use strict";
    var forEach = require_for_each();
    var availableTypedArrays = require_available_typed_arrays();
    var callBind = require_call_bind();
    var callBound = require_call_bound();
    var gOPD = require_gopd();
    var getProto = require_get_proto();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var g = typeof globalThis === "undefined" ? global : globalThis;
    var typedArrays = availableTypedArrays();
    var $slice = callBound("String.prototype.slice");
    var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
      for (var i = 0; i < array.length; i += 1) {
        if (array[i] === value) {
          return i;
        }
      }
      return -1;
    };
    var cache = { __proto__: null };
    if (hasToStringTag && gOPD && getProto) {
      forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        if (Symbol.toStringTag in arr && getProto) {
          var proto = getProto(arr);
          var descriptor = gOPD(proto, Symbol.toStringTag);
          if (!descriptor && proto) {
            var superProto = getProto(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
          }
          cache["$" + typedArray] = callBind(descriptor.get);
        }
      });
    } else {
      forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        var fn = arr.slice || arr.set;
        if (fn) {
          cache[
            /** @type {`$${import('.').TypedArrayName}`} */
            "$" + typedArray
          ] = /** @type {import('./types').BoundSlice | import('./types').BoundSet} */
          // @ts-expect-error TODO FIXME
          callBind(fn);
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var found = false;
      forEach(
        /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
        cache,
        /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
        function(getter, typedArray) {
          if (!found) {
            try {
              if ("$" + getter(value) === typedArray) {
                found = /** @type {import('.').TypedArrayName} */
                $slice(typedArray, 1);
              }
            } catch (e) {
            }
          }
        }
      );
      return found;
    };
    var trySlices = function tryAllSlices(value) {
      var found = false;
      forEach(
        /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
        cache,
        /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
        function(getter, name) {
          if (!found) {
            try {
              getter(value);
              found = /** @type {import('.').TypedArrayName} */
              $slice(name, 1);
            } catch (e) {
            }
          }
        }
      );
      return found;
    };
    module2.exports = function whichTypedArray(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      if (!hasToStringTag) {
        var tag = $slice($toString(value), 8, -1);
        if ($indexOf(typedArrays, tag) > -1) {
          return tag;
        }
        if (tag !== "Object") {
          return false;
        }
        return trySlices(value);
      }
      if (!gOPD) {
        return null;
      }
      return tryTypedArrays(value);
    };
  }
});

// node_modules/is-typed-array/index.js
var require_is_typed_array = __commonJS({
  "node_modules/is-typed-array/index.js"(exports2, module2) {
    "use strict";
    var whichTypedArray = require_which_typed_array();
    module2.exports = function isTypedArray(value) {
      return !!whichTypedArray(value);
    };
  }
});

// node_modules/typed-array-buffer/index.js
var require_typed_array_buffer = __commonJS({
  "node_modules/typed-array-buffer/index.js"(exports2, module2) {
    "use strict";
    var $TypeError = require_type();
    var callBound = require_call_bound();
    var $typedArrayBuffer = callBound("TypedArray.prototype.buffer", true);
    var isTypedArray = require_is_typed_array();
    module2.exports = $typedArrayBuffer || function typedArrayBuffer(x) {
      if (!isTypedArray(x)) {
        throw new $TypeError("Not a Typed Array");
      }
      return x.buffer;
    };
  }
});

// node_modules/to-buffer/index.js
var require_to_buffer = __commonJS({
  "node_modules/to-buffer/index.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isArray = require_isarray();
    var typedArrayBuffer = require_typed_array_buffer();
    var isView = ArrayBuffer.isView || function isView2(obj) {
      try {
        typedArrayBuffer(obj);
        return true;
      } catch (e) {
        return false;
      }
    };
    var useUint8Array = typeof Uint8Array !== "undefined";
    var useArrayBuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
    var useFromArrayBuffer = useArrayBuffer && (Buffer2.prototype instanceof Uint8Array || Buffer2.TYPED_ARRAY_SUPPORT);
    module2.exports = function toBuffer(data, encoding) {
      if (data instanceof Buffer2) {
        return data;
      }
      if (typeof data === "string") {
        return Buffer2.from(data, encoding);
      }
      if (useArrayBuffer && isView(data)) {
        if (data.byteLength === 0) {
          return Buffer2.alloc(0);
        }
        if (useFromArrayBuffer) {
          var res = Buffer2.from(data.buffer, data.byteOffset, data.byteLength);
          if (res.byteLength === data.byteLength) {
            return res;
          }
        }
        var uint8 = data instanceof Uint8Array ? data : new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
        var result = Buffer2.from(uint8);
        if (result.length === data.byteLength) {
          return result;
        }
      }
      if (useUint8Array && data instanceof Uint8Array) {
        return Buffer2.from(data);
      }
      var isArr = isArray(data);
      if (isArr) {
        for (var i = 0; i < data.length; i += 1) {
          var x = data[i];
          if (typeof x !== "number" || x < 0 || x > 255 || ~~x !== x) {
            throw new RangeError("Array items must be numbers in the range 0-255.");
          }
        }
      }
      if (isArr || Buffer2.isBuffer(data) && data.constructor && typeof data.constructor.isBuffer === "function" && data.constructor.isBuffer(data)) {
        return Buffer2.from(data);
      }
      throw new TypeError('The "data" argument must be a string, an Array, a Buffer, a Uint8Array, or a DataView.');
    };
  }
});

// node_modules/sha.js/hash.js
var require_hash = __commonJS({
  "node_modules/sha.js/hash.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var toBuffer = require_to_buffer();
    function Hash(blockSize, finalSize) {
      this._block = Buffer2.alloc(blockSize);
      this._finalSize = finalSize;
      this._blockSize = blockSize;
      this._len = 0;
    }
    Hash.prototype.update = function(data, enc) {
      data = toBuffer(data, enc || "utf8");
      var block = this._block;
      var blockSize = this._blockSize;
      var length = data.length;
      var accum = this._len;
      for (var offset = 0; offset < length; ) {
        var assigned = accum % blockSize;
        var remainder = Math.min(length - offset, blockSize - assigned);
        for (var i = 0; i < remainder; i++) {
          block[assigned + i] = data[offset + i];
        }
        accum += remainder;
        offset += remainder;
        if (accum % blockSize === 0) {
          this._update(block);
        }
      }
      this._len += length;
      return this;
    };
    Hash.prototype.digest = function(enc) {
      var rem = this._len % this._blockSize;
      this._block[rem] = 128;
      this._block.fill(0, rem + 1);
      if (rem >= this._finalSize) {
        this._update(this._block);
        this._block.fill(0);
      }
      var bits = this._len * 8;
      if (bits <= 4294967295) {
        this._block.writeUInt32BE(bits, this._blockSize - 4);
      } else {
        var lowBits = (bits & 4294967295) >>> 0;
        var highBits = (bits - lowBits) / 4294967296;
        this._block.writeUInt32BE(highBits, this._blockSize - 8);
        this._block.writeUInt32BE(lowBits, this._blockSize - 4);
      }
      this._update(this._block);
      var hash = this._hash();
      return enc ? hash.toString(enc) : hash;
    };
    Hash.prototype._update = function() {
      throw new Error("_update must be implemented by subclass");
    };
    module2.exports = Hash;
  }
});

// node_modules/sha.js/sha.js
var require_sha = __commonJS({
  "node_modules/sha.js/sha.js"(exports2, module2) {
    "use strict";
    var inherits = require_inherits();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W = new Array(80);
    function Sha() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha, Hash);
    Sha.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    function ft(s, b, c, d) {
      if (s === 0) {
        return b & c | ~b & d;
      }
      if (s === 2) {
        return b & c | b & d | c & d;
      }
      return b ^ c ^ d;
    }
    Sha.prototype._update = function(M) {
      var w = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      for (var i = 0; i < 16; ++i) {
        w[i] = M.readInt32BE(i * 4);
      }
      for (; i < 80; ++i) {
        w[i] = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
      }
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + w[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
    };
    Sha.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(20);
      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);
      return H;
    };
    module2.exports = Sha;
  }
});

// node_modules/sha.js/sha1.js
var require_sha1 = __commonJS({
  "node_modules/sha.js/sha1.js"(exports2, module2) {
    "use strict";
    var inherits = require_inherits();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W = new Array(80);
    function Sha1() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha1, Hash);
    Sha1.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl1(num) {
      return num << 1 | num >>> 31;
    }
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    function ft(s, b, c, d) {
      if (s === 0) {
        return b & c | ~b & d;
      }
      if (s === 2) {
        return b & c | b & d | c & d;
      }
      return b ^ c ^ d;
    }
    Sha1.prototype._update = function(M) {
      var w = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      for (var i = 0; i < 16; ++i) {
        w[i] = M.readInt32BE(i * 4);
      }
      for (; i < 80; ++i) {
        w[i] = rotl1(w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]);
      }
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + w[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
    };
    Sha1.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(20);
      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);
      return H;
    };
    module2.exports = Sha1;
  }
});

// node_modules/sha.js/sha256.js
var require_sha256 = __commonJS({
  "node_modules/sha.js/sha256.js"(exports2, module2) {
    "use strict";
    var inherits = require_inherits();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    var W = new Array(64);
    function Sha256() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha256, Hash);
    Sha256.prototype.init = function() {
      this._a = 1779033703;
      this._b = 3144134277;
      this._c = 1013904242;
      this._d = 2773480762;
      this._e = 1359893119;
      this._f = 2600822924;
      this._g = 528734635;
      this._h = 1541459225;
      return this;
    };
    function ch(x, y, z) {
      return z ^ x & (y ^ z);
    }
    function maj(x, y, z) {
      return x & y | z & (x | y);
    }
    function sigma0(x) {
      return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
    }
    function sigma1(x) {
      return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
    }
    function gamma0(x) {
      return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
    }
    function gamma1(x) {
      return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
    }
    Sha256.prototype._update = function(M) {
      var w = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      var f = this._f | 0;
      var g = this._g | 0;
      var h = this._h | 0;
      for (var i = 0; i < 16; ++i) {
        w[i] = M.readInt32BE(i * 4);
      }
      for (; i < 64; ++i) {
        w[i] = gamma1(w[i - 2]) + w[i - 7] + gamma0(w[i - 15]) + w[i - 16] | 0;
      }
      for (var j = 0; j < 64; ++j) {
        var T1 = h + sigma1(e) + ch(e, f, g) + K[j] + w[j] | 0;
        var T2 = sigma0(a) + maj(a, b, c) | 0;
        h = g;
        g = f;
        f = e;
        e = d + T1 | 0;
        d = c;
        c = b;
        b = a;
        a = T1 + T2 | 0;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
      this._f = f + this._f | 0;
      this._g = g + this._g | 0;
      this._h = h + this._h | 0;
    };
    Sha256.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(32);
      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);
      H.writeInt32BE(this._h, 28);
      return H;
    };
    module2.exports = Sha256;
  }
});

// node_modules/sha.js/sha224.js
var require_sha224 = __commonJS({
  "node_modules/sha.js/sha224.js"(exports2, module2) {
    "use strict";
    var inherits = require_inherits();
    var Sha256 = require_sha256();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var W = new Array(64);
    function Sha224() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha224, Sha256);
    Sha224.prototype.init = function() {
      this._a = 3238371032;
      this._b = 914150663;
      this._c = 812702999;
      this._d = 4144912697;
      this._e = 4290775857;
      this._f = 1750603025;
      this._g = 1694076839;
      this._h = 3204075428;
      return this;
    };
    Sha224.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(28);
      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);
      return H;
    };
    module2.exports = Sha224;
  }
});

// node_modules/sha.js/sha512.js
var require_sha512 = __commonJS({
  "node_modules/sha.js/sha512.js"(exports2, module2) {
    "use strict";
    var inherits = require_inherits();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    var W = new Array(160);
    function Sha512() {
      this.init();
      this._w = W;
      Hash.call(this, 128, 112);
    }
    inherits(Sha512, Hash);
    Sha512.prototype.init = function() {
      this._ah = 1779033703;
      this._bh = 3144134277;
      this._ch = 1013904242;
      this._dh = 2773480762;
      this._eh = 1359893119;
      this._fh = 2600822924;
      this._gh = 528734635;
      this._hh = 1541459225;
      this._al = 4089235720;
      this._bl = 2227873595;
      this._cl = 4271175723;
      this._dl = 1595750129;
      this._el = 2917565137;
      this._fl = 725511199;
      this._gl = 4215389547;
      this._hl = 327033209;
      return this;
    };
    function Ch(x, y, z) {
      return z ^ x & (y ^ z);
    }
    function maj(x, y, z) {
      return x & y | z & (x | y);
    }
    function sigma0(x, xl) {
      return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
    }
    function sigma1(x, xl) {
      return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
    }
    function Gamma0(x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
    }
    function Gamma0l(x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
    }
    function Gamma1(x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
    }
    function Gamma1l(x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
    }
    function getCarry(a, b) {
      return a >>> 0 < b >>> 0 ? 1 : 0;
    }
    Sha512.prototype._update = function(M) {
      var w = this._w;
      var ah = this._ah | 0;
      var bh = this._bh | 0;
      var ch = this._ch | 0;
      var dh = this._dh | 0;
      var eh = this._eh | 0;
      var fh = this._fh | 0;
      var gh = this._gh | 0;
      var hh = this._hh | 0;
      var al = this._al | 0;
      var bl = this._bl | 0;
      var cl = this._cl | 0;
      var dl = this._dl | 0;
      var el = this._el | 0;
      var fl = this._fl | 0;
      var gl = this._gl | 0;
      var hl = this._hl | 0;
      for (var i = 0; i < 32; i += 2) {
        w[i] = M.readInt32BE(i * 4);
        w[i + 1] = M.readInt32BE(i * 4 + 4);
      }
      for (; i < 160; i += 2) {
        var xh = w[i - 15 * 2];
        var xl = w[i - 15 * 2 + 1];
        var gamma0 = Gamma0(xh, xl);
        var gamma0l = Gamma0l(xl, xh);
        xh = w[i - 2 * 2];
        xl = w[i - 2 * 2 + 1];
        var gamma1 = Gamma1(xh, xl);
        var gamma1l = Gamma1l(xl, xh);
        var Wi7h = w[i - 7 * 2];
        var Wi7l = w[i - 7 * 2 + 1];
        var Wi16h = w[i - 16 * 2];
        var Wi16l = w[i - 16 * 2 + 1];
        var Wil = gamma0l + Wi7l | 0;
        var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
        Wil = Wil + gamma1l | 0;
        Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
        Wil = Wil + Wi16l | 0;
        Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
        w[i] = Wih;
        w[i + 1] = Wil;
      }
      for (var j = 0; j < 160; j += 2) {
        Wih = w[j];
        Wil = w[j + 1];
        var majh = maj(ah, bh, ch);
        var majl = maj(al, bl, cl);
        var sigma0h = sigma0(ah, al);
        var sigma0l = sigma0(al, ah);
        var sigma1h = sigma1(eh, el);
        var sigma1l = sigma1(el, eh);
        var Kih = K[j];
        var Kil = K[j + 1];
        var chh = Ch(eh, fh, gh);
        var chl = Ch(el, fl, gl);
        var t1l = hl + sigma1l | 0;
        var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
        t1l = t1l + chl | 0;
        t1h = t1h + chh + getCarry(t1l, chl) | 0;
        t1l = t1l + Kil | 0;
        t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
        t1l = t1l + Wil | 0;
        t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
        var t2l = sigma0l + majl | 0;
        var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        el = dl + t1l | 0;
        eh = dh + t1h + getCarry(el, dl) | 0;
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        al = t1l + t2l | 0;
        ah = t1h + t2h + getCarry(al, t1l) | 0;
      }
      this._al = this._al + al | 0;
      this._bl = this._bl + bl | 0;
      this._cl = this._cl + cl | 0;
      this._dl = this._dl + dl | 0;
      this._el = this._el + el | 0;
      this._fl = this._fl + fl | 0;
      this._gl = this._gl + gl | 0;
      this._hl = this._hl + hl | 0;
      this._ah = this._ah + ah + getCarry(this._al, al) | 0;
      this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
      this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
      this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
      this._eh = this._eh + eh + getCarry(this._el, el) | 0;
      this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
      this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
      this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
    };
    Sha512.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(64);
      function writeInt64BE(h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      writeInt64BE(this._gh, this._gl, 48);
      writeInt64BE(this._hh, this._hl, 56);
      return H;
    };
    module2.exports = Sha512;
  }
});

// node_modules/sha.js/sha384.js
var require_sha384 = __commonJS({
  "node_modules/sha.js/sha384.js"(exports2, module2) {
    "use strict";
    var inherits = require_inherits();
    var SHA512 = require_sha512();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var W = new Array(160);
    function Sha384() {
      this.init();
      this._w = W;
      Hash.call(this, 128, 112);
    }
    inherits(Sha384, SHA512);
    Sha384.prototype.init = function() {
      this._ah = 3418070365;
      this._bh = 1654270250;
      this._ch = 2438529370;
      this._dh = 355462360;
      this._eh = 1731405415;
      this._fh = 2394180231;
      this._gh = 3675008525;
      this._hh = 1203062813;
      this._al = 3238371032;
      this._bl = 914150663;
      this._cl = 812702999;
      this._dl = 4144912697;
      this._el = 4290775857;
      this._fl = 1750603025;
      this._gl = 1694076839;
      this._hl = 3204075428;
      return this;
    };
    Sha384.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(48);
      function writeInt64BE(h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      return H;
    };
    module2.exports = Sha384;
  }
});

// node_modules/sha.js/index.js
var require_sha2 = __commonJS({
  "node_modules/sha.js/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function SHA(algorithm) {
      var alg = algorithm.toLowerCase();
      var Algorithm = module2.exports[alg];
      if (!Algorithm) {
        throw new Error(alg + " is not supported (we accept pull requests)");
      }
      return new Algorithm();
    };
    module2.exports.sha = require_sha();
    module2.exports.sha1 = require_sha1();
    module2.exports.sha224 = require_sha224();
    module2.exports.sha256 = require_sha256();
    module2.exports.sha384 = require_sha384();
    module2.exports.sha512 = require_sha512();
  }
});

// node_modules/typeorm/util/StringUtils.js
var require_StringUtils = __commonJS({
  "node_modules/typeorm/util/StringUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.camelCase = camelCase;
    exports2.snakeCase = snakeCase;
    exports2.titleCase = titleCase;
    exports2.abbreviate = abbreviate;
    exports2.shorten = shorten;
    exports2.hash = hash;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var sha_js_1 = tslib_1.__importDefault(require_sha2());
    function camelCase(str, firstCapital = false) {
      if (firstCapital)
        str = " " + str;
      return str.replace(/^([A-Z])|[\s-_](\w)/g, function(match, p1, p2) {
        if (p2)
          return p2.toUpperCase();
        return p1.toLowerCase();
      });
    }
    function snakeCase(str) {
      return str.replace(/([A-Z])([A-Z])([a-z])/g, "$1_$2$3").replace(/([a-z0-9])([A-Z])/g, "$1_$2").toLowerCase();
    }
    function titleCase(str) {
      return str.replace(/\w\S*/g, (txt) => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase());
    }
    function abbreviate(str, abbrLettersCount = 1) {
      const words = str.replace(/([a-z\xE0-\xFF])([A-Z\xC0\xDF])/g, "$1 $2").split(" ");
      return words.reduce((res, word) => {
        res += word.substr(0, abbrLettersCount);
        return res;
      }, "");
    }
    function shorten(input, options = {}) {
      const { segmentLength = 4, separator = "__", termLength = 2 } = options;
      const segments = input.split(separator);
      const shortSegments = segments.reduce((acc, val) => {
        const segmentTerms = val.replace(/([a-z\xE0-\xFF])([A-Z\xC0-\xDF])/g, "$1 $2").split(" ");
        const length = segmentTerms.length > 1 ? termLength : segmentLength;
        const shortSegment = segmentTerms.map((term) => term.substr(0, length)).join("");
        acc.push(shortSegment);
        return acc;
      }, []);
      return shortSegments.join(separator);
    }
    function hash(input, options = {}) {
      const hashFunction = (0, sha_js_1.default)("sha1");
      hashFunction.update(input, "utf8");
      const hashedInput = hashFunction.digest("hex");
      if (options.length) {
        return hashedInput.slice(0, options.length);
      }
      return hashedInput;
    }
  }
});

// node_modules/typeorm/util/PathUtils.js
var require_PathUtils = __commonJS({
  "node_modules/typeorm/util/PathUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toPortablePath = toPortablePath;
    exports2.filepathToName = filepathToName;
    exports2.isAbsolute = isAbsolute;
    var StringUtils_1 = require_StringUtils();
    var WINDOWS_PATH_REGEXP = /^([a-zA-Z]:.*)$/;
    var UNC_WINDOWS_PATH_REGEXP = /^\\\\(\.\\)?(.*)$/;
    function toPortablePath(filepath) {
      if (process.platform !== `win32`)
        return filepath;
      if (filepath.match(WINDOWS_PATH_REGEXP))
        filepath = filepath.replace(WINDOWS_PATH_REGEXP, `/$1`);
      else if (filepath.match(UNC_WINDOWS_PATH_REGEXP))
        filepath = filepath.replace(UNC_WINDOWS_PATH_REGEXP, (match, p1, p2) => `/unc/${p1 ? `.dot/` : ``}${p2}`);
      return filepath.replace(/\\/g, `/`);
    }
    function filepathToName(filepath) {
      const uniq = toPortablePath(filepath).toLowerCase();
      return (0, StringUtils_1.hash)(uniq, { length: 63 });
    }
    function isAbsolute(filepath) {
      return !!filepath.match(/^(?:[a-z]:|[\\]|[/])/i);
    }
  }
});

// node_modules/typeorm/util/OrmUtils.js
var require_OrmUtils = __commonJS({
  "node_modules/typeorm/util/OrmUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OrmUtils = void 0;
    var OrmUtils = class _OrmUtils {
      // -------------------------------------------------------------------------
      // Public methods
      // -------------------------------------------------------------------------
      /**
       * Chunks array into pieces.
       */
      static chunk(array, size) {
        return Array.from(Array(Math.ceil(array.length / size)), (_, i) => {
          return array.slice(i * size, i * size + size);
        });
      }
      static splitClassesAndStrings(classesAndStrings) {
        return [
          classesAndStrings.filter((cls) => typeof cls !== "string"),
          classesAndStrings.filter((str) => typeof str === "string")
        ];
      }
      static groupBy(array, propertyCallback) {
        return array.reduce((groupedArray, value) => {
          const key = propertyCallback(value);
          let grouped = groupedArray.find((i) => i.id === key);
          if (!grouped) {
            grouped = { id: key, items: [] };
            groupedArray.push(grouped);
          }
          grouped.items.push(value);
          return groupedArray;
        }, []);
      }
      static uniq(array, criteriaOrProperty) {
        return array.reduce((uniqueArray, item) => {
          let found = false;
          if (typeof criteriaOrProperty === "function") {
            const itemValue = criteriaOrProperty(item);
            found = !!uniqueArray.find((uniqueItem) => criteriaOrProperty(uniqueItem) === itemValue);
          } else if (typeof criteriaOrProperty === "string") {
            found = !!uniqueArray.find((uniqueItem) => uniqueItem[criteriaOrProperty] === item[criteriaOrProperty]);
          } else {
            found = uniqueArray.indexOf(item) !== -1;
          }
          if (!found)
            uniqueArray.push(item);
          return uniqueArray;
        }, []);
      }
      /**
       * Deep Object.assign.
       */
      static mergeDeep(target, ...sources) {
        if (!sources.length) {
          return target;
        }
        for (const source of sources) {
          _OrmUtils.merge(target, source);
        }
        return target;
      }
      /**
       * Creates a shallow copy of the object, without invoking the constructor
       */
      static cloneObject(object) {
        if (object === null || object === void 0) {
          return object;
        }
        return Object.assign(Object.create(Object.getPrototypeOf(object)), object);
      }
      /**
       * Deep compare objects.
       *
       * @see http://stackoverflow.com/a/1144249
       */
      static deepCompare(...args) {
        let i, l, leftChain, rightChain;
        if (args.length < 1) {
          return true;
        }
        for (i = 1, l = args.length; i < l; i++) {
          leftChain = [];
          rightChain = [];
          if (!_OrmUtils.compare2Objects(leftChain, rightChain, args[0], args[i])) {
            return false;
          }
        }
        return true;
      }
      /**
       * Gets deeper value of object.
       */
      static deepValue(obj, path) {
        const segments = path.split(".");
        for (let i = 0, len = segments.length; i < len; i++) {
          obj = obj[segments[i]];
        }
        return obj;
      }
      static replaceEmptyObjectsWithBooleans(obj) {
        for (const key in obj) {
          if (obj[key] && typeof obj[key] === "object") {
            if (Object.keys(obj[key]).length === 0) {
              obj[key] = true;
            } else {
              _OrmUtils.replaceEmptyObjectsWithBooleans(obj[key]);
            }
          }
        }
      }
      static propertyPathsToTruthyObject(paths) {
        const obj = {};
        for (const path of paths) {
          const props = path.split(".");
          if (!props.length)
            continue;
          if (!obj[props[0]] || obj[props[0]] === true) {
            obj[props[0]] = {};
          }
          let recursiveChild = obj[props[0]];
          for (const [key, prop] of props.entries()) {
            if (key === 0)
              continue;
            if (recursiveChild[prop]) {
              recursiveChild = recursiveChild[prop];
            } else if (key === props.length - 1) {
              recursiveChild[prop] = {};
              recursiveChild = null;
            } else {
              recursiveChild[prop] = {};
              recursiveChild = recursiveChild[prop];
            }
          }
        }
        _OrmUtils.replaceEmptyObjectsWithBooleans(obj);
        return obj;
      }
      /**
       * Check if two entity-id-maps are the same
       */
      static compareIds(firstId, secondId) {
        if (firstId === void 0 || firstId === null || secondId === void 0 || secondId === null)
          return false;
        if ((typeof firstId.id === "string" && typeof secondId.id === "string" || typeof firstId.id === "number" && typeof secondId.id === "number") && Object.keys(firstId).length === 1 && Object.keys(secondId).length === 1) {
          return firstId.id === secondId.id;
        }
        return _OrmUtils.deepCompare(firstId, secondId);
      }
      /**
       * Transforms given value into boolean value.
       */
      static toBoolean(value) {
        if (typeof value === "boolean")
          return value;
        if (typeof value === "string")
          return value === "true" || value === "1";
        if (typeof value === "number")
          return value > 0;
        return false;
      }
      /**
       * Checks if two arrays of unique values contain the same values
       */
      static isArraysEqual(arr1, arr2) {
        if (arr1.length !== arr2.length) {
          return false;
        }
        return arr1.every((element) => arr2.includes(element));
      }
      static areMutuallyExclusive(...lists) {
        const haveSharedObjects = lists.some((list) => {
          const otherLists = lists.filter((otherList) => otherList !== list);
          return list.some((item) => otherLists.some((otherList) => otherList.includes(item)));
        });
        return !haveSharedObjects;
      }
      /**
       * Parses the CHECK constraint on the specified column and returns
       * all values allowed by the constraint or undefined if the constraint
       * is not present.
       */
      static parseSqlCheckExpression(sql, columnName) {
        const enumMatch = sql.match(new RegExp(`"${columnName}" varchar CHECK\\s*\\(\\s*"${columnName}"\\s+IN\\s*`));
        if (enumMatch && enumMatch.index) {
          const afterMatch = sql.substring(enumMatch.index + enumMatch[0].length);
          const chars = afterMatch;
          let currentQuotes = "";
          let nextValue = "";
          const enumValues = [];
          for (let idx = 0; idx < chars.length; idx++) {
            const char = chars[idx];
            switch (char) {
              case ",":
                if (currentQuotes == "") {
                  enumValues.push(nextValue);
                  nextValue = "";
                } else {
                  nextValue += char;
                }
                break;
              case "'":
                if (currentQuotes == char) {
                  const isNextCharQuote = chars[idx + 1] === char;
                  if (isNextCharQuote) {
                    nextValue += char;
                    idx += 1;
                  } else {
                    currentQuotes = "";
                  }
                } else {
                  currentQuotes = char;
                }
                break;
              case ")":
                if (currentQuotes == "") {
                  enumValues.push(nextValue);
                  return enumValues;
                } else {
                  nextValue += char;
                }
                break;
              default:
                if (currentQuotes != "") {
                  nextValue += char;
                }
            }
          }
        }
        return void 0;
      }
      /**
       * Checks if given criteria is null or empty.
       */
      static isCriteriaNullOrEmpty(criteria) {
        return criteria === void 0 || criteria === null || criteria === "" || Array.isArray(criteria) && criteria.length === 0 || _OrmUtils.isPlainObject(criteria) && Object.keys(criteria).length === 0;
      }
      /**
       * Checks if given criteria is a primitive value.
       * Primitive values are strings, numbers and dates.
       */
      static isSinglePrimitiveCriteria(criteria) {
        return typeof criteria === "string" || typeof criteria === "number" || criteria instanceof Date;
      }
      /**
       * Checks if given criteria is a primitive value or an array of primitive values.
       */
      static isPrimitiveCriteria(criteria) {
        if (Array.isArray(criteria)) {
          return criteria.every((value) => _OrmUtils.isSinglePrimitiveCriteria(value));
        }
        return _OrmUtils.isSinglePrimitiveCriteria(criteria);
      }
      // -------------------------------------------------------------------------
      // Private methods
      // -------------------------------------------------------------------------
      static compare2Objects(leftChain, rightChain, x, y) {
        let p;
        if (Number.isNaN(x) && Number.isNaN(y))
          return true;
        if (x === y)
          return true;
        if (x === null || y === null || x === void 0 || y === void 0)
          return false;
        if ((typeof x.equals === "function" || typeof x.equals === "function") && x.equals(y))
          return true;
        if (typeof x === "function" && typeof y === "function" || x instanceof Date && y instanceof Date || x instanceof RegExp && y instanceof RegExp || typeof x === "string" && typeof y === "string" || typeof x === "number" && typeof y === "number")
          return x.toString() === y.toString();
        if (!(typeof x === "object" && typeof y === "object"))
          return false;
        if (Object.prototype.isPrototypeOf.call(x, y) || Object.prototype.isPrototypeOf.call(y, x))
          return false;
        if (x.constructor !== y.constructor)
          return false;
        if (x.prototype !== y.prototype)
          return false;
        if (leftChain.indexOf(x) > -1 || rightChain.indexOf(y) > -1)
          return false;
        for (p in y) {
          if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
            return false;
          } else if (typeof y[p] !== typeof x[p]) {
            return false;
          }
        }
        for (p in x) {
          if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
            return false;
          } else if (typeof y[p] !== typeof x[p]) {
            return false;
          }
          switch (typeof x[p]) {
            case "object":
            case "function":
              leftChain.push(x);
              rightChain.push(y);
              if (!_OrmUtils.compare2Objects(leftChain, rightChain, x[p], y[p])) {
                return false;
              }
              leftChain.pop();
              rightChain.pop();
              break;
            default:
              if (x[p] !== y[p]) {
                return false;
              }
              break;
          }
        }
        return true;
      }
      // Checks if it's an object made by Object.create(null), {} or new Object()
      static isPlainObject(item) {
        if (item === null || item === void 0) {
          return false;
        }
        return !item.constructor || item.constructor === Object;
      }
      static mergeArrayKey(target, key, value, memo) {
        if (memo.has(value)) {
          target[key] = memo.get(value);
          return;
        }
        if (value instanceof Promise) {
          return;
        }
        if (!_OrmUtils.isPlainObject(value) && !Array.isArray(value)) {
          target[key] = value;
          return;
        }
        if (!target[key]) {
          target[key] = Array.isArray(value) ? [] : {};
        }
        memo.set(value, target[key]);
        _OrmUtils.merge(target[key], value, memo);
        memo.delete(value);
      }
      static mergeObjectKey(target, key, value, memo) {
        if (memo.has(value)) {
          Object.assign(target, { [key]: memo.get(value) });
          return;
        }
        if (value instanceof Promise) {
          return;
        }
        if (!_OrmUtils.isPlainObject(value) && !Array.isArray(value)) {
          Object.assign(target, { [key]: value });
          return;
        }
        if (!target[key]) {
          Object.assign(target, { [key]: Array.isArray(value) ? [] : {} });
        }
        memo.set(value, target[key]);
        _OrmUtils.merge(target[key], value, memo);
        memo.delete(value);
      }
      static merge(target, source, memo = /* @__PURE__ */ new Map()) {
        if (_OrmUtils.isPlainObject(target) && _OrmUtils.isPlainObject(source)) {
          for (const [key, value] of Object.entries(source)) {
            if (key === "__proto__")
              continue;
            _OrmUtils.mergeObjectKey(target, key, value, memo);
          }
        }
        if (Array.isArray(target) && Array.isArray(source)) {
          for (let key = 0; key < source.length; key++) {
            _OrmUtils.mergeArrayKey(target, key, source[key], memo);
          }
        }
      }
    };
    exports2.OrmUtils = OrmUtils;
  }
});

// node_modules/typeorm/connection/options-reader/ConnectionOptionsEnvReader.js
var require_ConnectionOptionsEnvReader = __commonJS({
  "node_modules/typeorm/connection/options-reader/ConnectionOptionsEnvReader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectionOptionsEnvReader = void 0;
    var PlatformTools_1 = require_PlatformTools();
    var OrmUtils_1 = require_OrmUtils();
    var ConnectionOptionsEnvReader = class {
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Reads connection options from environment variables.
       */
      read() {
        return [
          {
            type: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_CONNECTION") || (PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_URL") ? PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_URL").split("://")[0] : void 0),
            url: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_URL"),
            host: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_HOST"),
            port: this.stringToNumber(PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_PORT")),
            username: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_USERNAME"),
            password: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_PASSWORD"),
            database: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_DATABASE"),
            sid: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_SID"),
            schema: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_SCHEMA"),
            extra: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_DRIVER_EXTRA") ? JSON.parse(PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_DRIVER_EXTRA")) : void 0,
            synchronize: OrmUtils_1.OrmUtils.toBoolean(PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_SYNCHRONIZE")),
            dropSchema: OrmUtils_1.OrmUtils.toBoolean(PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_DROP_SCHEMA")),
            migrationsRun: OrmUtils_1.OrmUtils.toBoolean(PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_MIGRATIONS_RUN")),
            entities: this.stringToArray(PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_ENTITIES")),
            migrations: this.stringToArray(PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_MIGRATIONS")),
            migrationsTableName: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_MIGRATIONS_TABLE_NAME"),
            metadataTableName: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_METADATA_TABLE_NAME"),
            subscribers: this.stringToArray(PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_SUBSCRIBERS")),
            logging: this.transformLogging(PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_LOGGING")),
            logger: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_LOGGER"),
            entityPrefix: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_ENTITY_PREFIX"),
            maxQueryExecutionTime: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_MAX_QUERY_EXECUTION_TIME"),
            debug: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_DEBUG"),
            cache: this.transformCaching(),
            uuidExtension: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_UUID_EXTENSION")
          }
        ];
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Transforms logging string into real logging value connection requires.
       */
      transformLogging(logging) {
        if (logging === "true" || logging === "TRUE" || logging === "1")
          return true;
        if (logging === "all")
          return "all";
        return this.stringToArray(logging);
      }
      /**
       * Transforms caching option into real caching value option requires.
       */
      transformCaching() {
        const caching = PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_CACHE");
        if (caching === "true" || caching === "TRUE" || caching === "1")
          return true;
        if (caching === "false" || caching === "FALSE" || caching === "0")
          return false;
        if (caching === "redis" || caching === "ioredis" || caching === "database")
          return {
            type: caching,
            options: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_CACHE_OPTIONS") ? JSON.parse(PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_CACHE_OPTIONS")) : void 0,
            alwaysEnabled: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_CACHE_ALWAYS_ENABLED"),
            duration: parseInt(PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_CACHE_DURATION"))
          };
        return void 0;
      }
      /**
       * Converts a string which contains multiple elements split by comma into a string array of strings.
       */
      stringToArray(variable) {
        if (!variable)
          return [];
        return variable.split(",").map((str) => str.trim());
      }
      /**
       * Converts a string which contains a number into a javascript number
       */
      stringToNumber(value) {
        if (!value) {
          return void 0;
        }
        return parseInt(value);
      }
    };
    exports2.ConnectionOptionsEnvReader = ConnectionOptionsEnvReader;
  }
});

// node_modules/typeorm/connection/ConnectionOptionsReader.js
var require_ConnectionOptionsReader = __commonJS({
  "node_modules/typeorm/connection/ConnectionOptionsReader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectionOptionsReader = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var app_root_path_1 = tslib_1.__importDefault(require_app_root_path2());
    var path_1 = tslib_1.__importDefault(require("path"));
    var error_1 = require_error();
    var PlatformTools_1 = require_PlatformTools();
    var ImportUtils_1 = require_ImportUtils();
    var PathUtils_1 = require_PathUtils();
    var ConnectionOptionsEnvReader_1 = require_ConnectionOptionsEnvReader();
    var ConnectionOptionsReader2 = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(options) {
        this.options = options;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Returns all connection options read from the ormconfig.
       */
      async all() {
        const options = await this.load();
        if (!options)
          throw new error_1.TypeORMError(`No connection options were found in any orm configuration files.`);
        return options;
      }
      /**
       * Gets a connection with a given name read from ormconfig.
       * If connection with such name would not be found then it throw error.
       */
      async get(name) {
        const allOptions = await this.all();
        const targetOptions = allOptions.find((options) => options.name === name || name === "default" && !options.name);
        if (!targetOptions)
          throw new error_1.TypeORMError(`Cannot find connection ${name} because its not defined in any orm configuration files.`);
        return targetOptions;
      }
      /**
       * Checks if there is a TypeORM configuration file.
       */
      async has(name) {
        const allOptions = await this.load();
        if (!allOptions)
          return false;
        const targetOptions = allOptions.find((options) => options.name === name || name === "default" && !options.name);
        return !!targetOptions;
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Loads all connection options from a configuration file.
       *
       * todo: get in count NODE_ENV somehow
       */
      async load() {
        let connectionOptions = void 0;
        const fileFormats = [
          "env",
          "js",
          "mjs",
          "cjs",
          "ts",
          "mts",
          "cts",
          "json"
        ];
        const possibleExtension = this.baseFilePath.substr(this.baseFilePath.lastIndexOf("."));
        const fileExtension = fileFormats.find((extension) => `.${extension}` === possibleExtension);
        const foundFileFormat = fileExtension || fileFormats.find((format) => {
          return PlatformTools_1.PlatformTools.fileExist(this.baseFilePath + "." + format);
        });
        const configFile = fileExtension ? this.baseFilePath : this.baseFilePath + "." + foundFileFormat;
        if (foundFileFormat === "env") {
          PlatformTools_1.PlatformTools.dotenv(configFile);
        } else if (PlatformTools_1.PlatformTools.fileExist(this.baseDirectory + "/.env")) {
          PlatformTools_1.PlatformTools.dotenv(this.baseDirectory + "/.env");
        }
        if (PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_CONNECTION") || PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_URL")) {
          connectionOptions = new ConnectionOptionsEnvReader_1.ConnectionOptionsEnvReader().read();
        } else if (foundFileFormat === "js" || foundFileFormat === "mjs" || foundFileFormat === "cjs" || foundFileFormat === "ts" || foundFileFormat === "mts" || foundFileFormat === "cts") {
          const [importOrRequireResult, moduleSystem] = await (0, ImportUtils_1.importOrRequireFile)(configFile);
          const configModule = await importOrRequireResult;
          if (moduleSystem === "esm" || configModule && "__esModule" in configModule && "default" in configModule) {
            connectionOptions = configModule.default;
          } else {
            connectionOptions = configModule;
          }
        } else if (foundFileFormat === "json") {
          connectionOptions = require(configFile);
        }
        if (connectionOptions) {
          return this.normalizeConnectionOptions(connectionOptions);
        }
        return void 0;
      }
      /**
       * Normalize connection options.
       */
      normalizeConnectionOptions(connectionOptions) {
        if (!Array.isArray(connectionOptions))
          connectionOptions = [connectionOptions];
        connectionOptions.forEach((options) => {
          options.baseDirectory = this.baseDirectory;
          if (options.entities) {
            const entities = options.entities.map((entity) => {
              if (typeof entity === "string" && entity.substr(0, 1) !== "/")
                return this.baseDirectory + "/" + entity;
              return entity;
            });
            Object.assign(connectionOptions, { entities });
          }
          if (options.subscribers) {
            const subscribers = options.subscribers.map((subscriber) => {
              if (typeof subscriber === "string" && subscriber.substr(0, 1) !== "/")
                return this.baseDirectory + "/" + subscriber;
              return subscriber;
            });
            Object.assign(connectionOptions, { subscribers });
          }
          if (options.migrations) {
            const migrations = options.migrations.map((migration) => {
              if (typeof migration === "string" && migration.substr(0, 1) !== "/")
                return this.baseDirectory + "/" + migration;
              return migration;
            });
            Object.assign(connectionOptions, { migrations });
          }
          if (options.type === "sqlite" || options.type === "better-sqlite3") {
            if (typeof options.database === "string" && !(0, PathUtils_1.isAbsolute)(options.database) && options.database.substr(0, 1) !== "/" && // unix absolute
            options.database.substr(1, 2) !== ":\\" && // windows absolute
            options.database !== ":memory:") {
              Object.assign(options, {
                database: this.baseDirectory + "/" + options.database
              });
            }
          }
        });
        return connectionOptions;
      }
      /**
       * Gets directory where configuration file should be located and configuration file name.
       */
      get baseFilePath() {
        return path_1.default.resolve(this.baseDirectory, this.baseConfigName);
      }
      /**
       * Gets directory where configuration file should be located.
       */
      get baseDirectory() {
        return this.options?.root ?? app_root_path_1.default.path;
      }
      /**
       * Gets configuration file name.
       */
      get baseConfigName() {
        return this.options?.configName ?? "ormconfig";
      }
    };
    exports2.ConnectionOptionsReader = ConnectionOptionsReader2;
  }
});

// node_modules/typeorm/query-builder/Alias.js
var require_Alias = __commonJS({
  "node_modules/typeorm/query-builder/Alias.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Alias = void 0;
    var ObjectUtils_1 = require_ObjectUtils();
    var error_1 = require_error();
    var Alias = class {
      constructor(alias) {
        ObjectUtils_1.ObjectUtils.assign(this, alias || {});
      }
      get target() {
        return this.metadata.target;
      }
      get hasMetadata() {
        return !!this._metadata;
      }
      set metadata(metadata) {
        this._metadata = metadata;
      }
      get metadata() {
        if (!this._metadata)
          throw new error_1.TypeORMError(`Cannot get entity metadata for the given alias "${this.name}"`);
        return this._metadata;
      }
    };
    exports2.Alias = Alias;
  }
});

// node_modules/typeorm/query-builder/QueryBuilderUtils.js
var require_QueryBuilderUtils = __commonJS({
  "node_modules/typeorm/query-builder/QueryBuilderUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryBuilderUtils = void 0;
    var QueryBuilderUtils = class {
      /**
       * Checks if given value is a string representation of alias property,
       * e.g. "post.category" or "post.id".
       */
      static isAliasProperty(str) {
        if (typeof str !== "string" || str.indexOf(".") === -1)
          return false;
        const [aliasName, propertyName] = str.split(".");
        if (!aliasName || !propertyName)
          return false;
        if (str.indexOf("(") !== -1 || str.indexOf(")") !== -1)
          return false;
        return true;
      }
    };
    exports2.QueryBuilderUtils = QueryBuilderUtils;
  }
});

// node_modules/typeorm/util/VersionUtils.js
var require_VersionUtils = __commonJS({
  "node_modules/typeorm/util/VersionUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VersionUtils = void 0;
    var VersionUtils = class {
      static isGreaterOrEqual(version, targetVersion) {
        if (!version) {
          return false;
        }
        const v1 = parseVersion(version);
        const v2 = parseVersion(targetVersion);
        for (let i = 0; i < v1.length && i < v2.length; i++) {
          if (v1[i] > v2[i]) {
            return true;
          } else if (v1[i] < v2[i]) {
            return false;
          }
        }
        return true;
      }
    };
    exports2.VersionUtils = VersionUtils;
    function parseVersion(version) {
      return version.split(".").map((value) => parseInt(value, 10));
    }
  }
});

// node_modules/typeorm/driver/DriverUtils.js
var require_DriverUtils = __commonJS({
  "node_modules/typeorm/driver/DriverUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DriverUtils = void 0;
    var StringUtils_1 = require_StringUtils();
    var VersionUtils_1 = require_VersionUtils();
    var DriverUtils = class {
      // -------------------------------------------------------------------------
      // Public Static Methods
      // -------------------------------------------------------------------------
      /**
       * Returns true if given driver is SQLite-based driver.
       */
      static isSQLiteFamily(driver) {
        return [
          "sqlite",
          "cordova",
          "react-native",
          "nativescript",
          "sqljs",
          "expo",
          "better-sqlite3",
          "capacitor"
        ].includes(driver.options.type);
      }
      /**
       * Returns true if given driver is MySQL-based driver.
       */
      static isMySQLFamily(driver) {
        return ["mysql", "mariadb"].includes(driver.options.type);
      }
      static isReleaseVersionOrGreater(driver, version) {
        return VersionUtils_1.VersionUtils.isGreaterOrEqual(driver.version, version);
      }
      static isPostgresFamily(driver) {
        return ["postgres", "aurora-postgres", "cockroachdb"].includes(driver.options.type);
      }
      /**
       * Normalizes and builds a new driver options.
       * Extracts settings from connection url and sets to a new options object.
       */
      static buildDriverOptions(options, buildOptions) {
        if (options.url) {
          const urlDriverOptions = this.parseConnectionUrl(options.url);
          if (buildOptions && buildOptions.useSid && urlDriverOptions.database) {
            urlDriverOptions.sid = urlDriverOptions.database;
          }
          for (const key of Object.keys(urlDriverOptions)) {
            if (typeof urlDriverOptions[key] === "undefined") {
              delete urlDriverOptions[key];
            }
          }
          return Object.assign({}, options, urlDriverOptions);
        }
        return Object.assign({}, options);
      }
      /**
       * buildDriverOptions for MongodDB only to support replica set
       */
      static buildMongoDBDriverOptions(options, buildOptions) {
        if (options.url) {
          const urlDriverOptions = this.parseMongoDBConnectionUrl(options.url);
          if (buildOptions && buildOptions.useSid && urlDriverOptions.database) {
            urlDriverOptions.sid = urlDriverOptions.database;
          }
          for (const key of Object.keys(urlDriverOptions)) {
            if (typeof urlDriverOptions[key] === "undefined") {
              delete urlDriverOptions[key];
            }
          }
          return Object.assign({}, options, urlDriverOptions);
        }
        return Object.assign({}, options);
      }
      /**
       * Joins and shortens alias if needed.
       *
       * If the alias length is greater than the limit allowed by the current
       * driver, replaces it with a shortend string, if the shortend string
       * is still too long, it will then hash the alias.
       *
       * @param driver Current `Driver`.
       * @param buildOptions Optional settings.
       * @param alias Alias parts.
       *
       * @return An alias that is no longer than the divers max alias length.
       */
      static buildAlias({ maxAliasLength }, buildOptions, ...alias) {
        const joiner = buildOptions && buildOptions.joiner ? buildOptions.joiner : "_";
        const newAlias = alias.length === 1 ? alias[0] : alias.join(joiner);
        if (maxAliasLength && maxAliasLength > 0 && newAlias.length > maxAliasLength) {
          if (buildOptions && buildOptions.shorten === true) {
            const shortenedAlias = (0, StringUtils_1.shorten)(newAlias);
            if (shortenedAlias.length < maxAliasLength) {
              return shortenedAlias;
            }
          }
          return (0, StringUtils_1.hash)(newAlias, { length: maxAliasLength });
        }
        return newAlias;
      }
      /**
       * @deprecated use `buildAlias` instead.
       */
      static buildColumnAlias({ maxAliasLength }, buildOptions, ...alias) {
        if (typeof buildOptions === "string") {
          alias.unshift(buildOptions);
          buildOptions = { shorten: false, joiner: "_" };
        } else {
          buildOptions = Object.assign({ shorten: false, joiner: "_" }, buildOptions);
        }
        return this.buildAlias({ maxAliasLength }, buildOptions, ...alias);
      }
      // -------------------------------------------------------------------------
      // Private Static Methods
      // -------------------------------------------------------------------------
      /**
       * Extracts connection data from the connection url.
       */
      static parseConnectionUrl(url) {
        const type = url.split(":")[0];
        const firstSlashes = url.indexOf("//");
        const preBase = url.substr(firstSlashes + 2);
        const secondSlash = preBase.indexOf("/");
        const base = secondSlash !== -1 ? preBase.substr(0, secondSlash) : preBase;
        let afterBase = secondSlash !== -1 ? preBase.substr(secondSlash + 1) : void 0;
        if (afterBase && afterBase.indexOf("?") !== -1) {
          afterBase = afterBase.substr(0, afterBase.indexOf("?"));
        }
        const lastAtSign = base.lastIndexOf("@");
        const usernameAndPassword = base.substr(0, lastAtSign);
        const hostAndPort = base.substr(lastAtSign + 1);
        let username = usernameAndPassword;
        let password = "";
        const firstColon = usernameAndPassword.indexOf(":");
        if (firstColon !== -1) {
          username = usernameAndPassword.substr(0, firstColon);
          password = usernameAndPassword.substr(firstColon + 1);
        }
        const [host, port] = hostAndPort.split(":");
        return {
          type,
          host,
          username: decodeURIComponent(username),
          password: decodeURIComponent(password),
          port: port ? parseInt(port) : void 0,
          database: afterBase || void 0
        };
      }
      /**
       * Extracts connection data from the connection url for MongoDB to support replica set.
       */
      static parseMongoDBConnectionUrl(url) {
        const type = url.split(":")[0];
        const firstSlashes = url.indexOf("//");
        const preBase = url.substr(firstSlashes + 2);
        const secondSlash = preBase.indexOf("/");
        const base = secondSlash !== -1 ? preBase.substr(0, secondSlash) : preBase;
        let afterBase = secondSlash !== -1 ? preBase.substr(secondSlash + 1) : void 0;
        let afterQuestionMark = "";
        let host = void 0;
        let port = void 0;
        let hostReplicaSet = void 0;
        let replicaSet = void 0;
        const optionsObject = {};
        if (afterBase && afterBase.indexOf("?") !== -1) {
          afterQuestionMark = afterBase.substr(afterBase.indexOf("?") + 1, afterBase.length);
          const optionsList = afterQuestionMark.split("&");
          let optionKey;
          let optionValue;
          optionsList.forEach((optionItem) => {
            optionKey = optionItem.split("=")[0];
            optionValue = optionItem.split("=")[1];
            optionsObject[optionKey] = optionValue;
          });
          replicaSet = optionsObject["replicaSet"];
          afterBase = afterBase.substr(0, afterBase.indexOf("?"));
        }
        const lastAtSign = base.lastIndexOf("@");
        const usernameAndPassword = base.substr(0, lastAtSign);
        const hostAndPort = base.substr(lastAtSign + 1);
        let username = usernameAndPassword;
        let password = "";
        const firstColon = usernameAndPassword.indexOf(":");
        if (firstColon !== -1) {
          username = usernameAndPassword.substr(0, firstColon);
          password = usernameAndPassword.substr(firstColon + 1);
        }
        if (replicaSet) {
          hostReplicaSet = hostAndPort;
        } else {
          ;
          [host, port] = hostAndPort.split(":");
        }
        const connectionUrl = {
          type,
          host,
          hostReplicaSet,
          username: decodeURIComponent(username),
          password: decodeURIComponent(password),
          port: port ? parseInt(port) : void 0,
          database: afterBase || void 0
        };
        for (const [key, value] of Object.entries(optionsObject)) {
          connectionUrl[key] = value;
        }
        return connectionUrl;
      }
    };
    exports2.DriverUtils = DriverUtils;
  }
});

// node_modules/typeorm/query-builder/JoinAttribute.js
var require_JoinAttribute = __commonJS({
  "node_modules/typeorm/query-builder/JoinAttribute.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.JoinAttribute = void 0;
    var QueryBuilderUtils_1 = require_QueryBuilderUtils();
    var ObjectUtils_1 = require_ObjectUtils();
    var error_1 = require_error();
    var DriverUtils_1 = require_DriverUtils();
    var JoinAttribute = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection, queryExpressionMap, joinAttribute) {
        this.connection = connection;
        this.queryExpressionMap = queryExpressionMap;
        this.isSelectedEvaluated = false;
        this.relationEvaluated = false;
        if (joinAttribute) {
          ObjectUtils_1.ObjectUtils.assign(this, joinAttribute);
        }
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      get isMany() {
        if (this.isMappingMany !== void 0)
          return this.isMappingMany;
        if (this.relation)
          return this.relation.isManyToMany || this.relation.isOneToMany;
        return false;
      }
      /**
       * Indicates if this join is selected.
       */
      get isSelected() {
        if (!this.isSelectedEvaluated) {
          const getValue = () => {
            for (const select of this.queryExpressionMap.selects) {
              if (select.selection === this.alias.name)
                return true;
              if (this.metadata && !!this.metadata.columns.find((column) => select.selection === this.alias.name + "." + column.propertyPath))
                return true;
            }
            return false;
          };
          this.isSelectedCache = getValue();
          this.isSelectedEvaluated = true;
        }
        return this.isSelectedCache;
      }
      /**
       * Name of the table which we should join.
       */
      get tablePath() {
        return this.metadata ? this.metadata.tablePath : this.entityOrProperty;
      }
      /**
       * Alias of the parent of this join.
       * For example, if we join ("post.category", "categoryAlias") then "post" is a parent alias.
       * This value is extracted from entityOrProperty value.
       * This is available when join was made using "post.category" syntax.
       */
      get parentAlias() {
        if (!QueryBuilderUtils_1.QueryBuilderUtils.isAliasProperty(this.entityOrProperty))
          return void 0;
        return this.entityOrProperty.substr(0, this.entityOrProperty.indexOf("."));
      }
      /**
       * Relation property name of the parent.
       * This is used to understand what is joined.
       * For example, if we join ("post.category", "categoryAlias") then "category" is a relation property.
       * This value is extracted from entityOrProperty value.
       * This is available when join was made using "post.category" syntax.
       */
      get relationPropertyPath() {
        if (!QueryBuilderUtils_1.QueryBuilderUtils.isAliasProperty(this.entityOrProperty))
          return void 0;
        return this.entityOrProperty.substr(this.entityOrProperty.indexOf(".") + 1);
      }
      /**
       * Relation of the parent.
       * This is used to understand what is joined.
       * This is available when join was made using "post.category" syntax.
       * Relation can be undefined if entityOrProperty is regular entity or custom table.
       */
      get relation() {
        if (!this.relationEvaluated) {
          const getValue = () => {
            if (!QueryBuilderUtils_1.QueryBuilderUtils.isAliasProperty(this.entityOrProperty))
              return void 0;
            const relationOwnerSelection = this.queryExpressionMap.findAliasByName(this.parentAlias);
            let relation = relationOwnerSelection.metadata.findRelationWithPropertyPath(this.relationPropertyPath);
            if (relation) {
              return relation;
            }
            if (relationOwnerSelection.metadata.parentEntityMetadata) {
              relation = relationOwnerSelection.metadata.parentEntityMetadata.findRelationWithPropertyPath(this.relationPropertyPath);
              if (relation) {
                return relation;
              }
            }
            throw new error_1.TypeORMError(`Relation with property path ${this.relationPropertyPath} in entity was not found.`);
          };
          this.relationCache = getValue.bind(this)();
          this.relationEvaluated = true;
        }
        return this.relationCache;
      }
      /**
       * Metadata of the joined entity.
       * If table without entity was joined, then it will return undefined.
       */
      get metadata() {
        if (this.relation)
          return this.relation.inverseEntityMetadata;
        if (this.connection.hasMetadata(this.entityOrProperty))
          return this.connection.getMetadata(this.entityOrProperty);
        if (this.mapAsEntity && this.connection.hasMetadata(this.mapAsEntity)) {
          return this.connection.getMetadata(this.mapAsEntity);
        }
        return void 0;
      }
      /**
       * Generates alias of junction table, whose ids we get.
       */
      get junctionAlias() {
        if (!this.relation) {
          throw new error_1.TypeORMError(`Cannot get junction table for join without relation.`);
        }
        if (typeof this.entityOrProperty !== "string") {
          throw new error_1.TypeORMError(`Junction property is not defined.`);
        }
        const aliasProperty = this.entityOrProperty.substr(0, this.entityOrProperty.indexOf("."));
        if (this.relation.isOwning) {
          return DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, void 0, aliasProperty, this.alias.name);
        } else {
          return DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, void 0, this.alias.name, aliasProperty);
        }
      }
      get mapToPropertyParentAlias() {
        if (!this.mapToProperty)
          return void 0;
        return this.mapToProperty.split(".")[0];
      }
      get mapToPropertyPropertyName() {
        if (!this.mapToProperty)
          return void 0;
        return this.mapToProperty.split(".")[1];
      }
    };
    exports2.JoinAttribute = JoinAttribute;
  }
});

// node_modules/typeorm/query-builder/relation-id/RelationIdAttribute.js
var require_RelationIdAttribute = __commonJS({
  "node_modules/typeorm/query-builder/relation-id/RelationIdAttribute.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RelationIdAttribute = void 0;
    var QueryBuilderUtils_1 = require_QueryBuilderUtils();
    var ObjectUtils_1 = require_ObjectUtils();
    var TypeORMError_1 = require_TypeORMError();
    var RelationIdAttribute = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(queryExpressionMap, relationIdAttribute) {
        this.queryExpressionMap = queryExpressionMap;
        this.disableMixedMap = false;
        ObjectUtils_1.ObjectUtils.assign(this, relationIdAttribute || {});
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      get joinInverseSideMetadata() {
        return this.relation.inverseEntityMetadata;
      }
      /**
       * Alias of the parent of this join.
       * For example, if we join ("post.category", "categoryAlias") then "post" is a parent alias.
       * This value is extracted from entityOrProperty value.
       * This is available when join was made using "post.category" syntax.
       */
      get parentAlias() {
        if (!QueryBuilderUtils_1.QueryBuilderUtils.isAliasProperty(this.relationName))
          throw new TypeORMError_1.TypeORMError(`Given value must be a string representation of alias property`);
        return this.relationName.substr(0, this.relationName.indexOf("."));
      }
      /**
       * Relation property name of the parent.
       * This is used to understand what is joined.
       * For example, if we join ("post.category", "categoryAlias") then "category" is a relation property.
       * This value is extracted from entityOrProperty value.
       * This is available when join was made using "post.category" syntax.
       */
      get relationPropertyPath() {
        if (!QueryBuilderUtils_1.QueryBuilderUtils.isAliasProperty(this.relationName))
          throw new TypeORMError_1.TypeORMError(`Given value must be a string representation of alias property`);
        return this.relationName.substr(this.relationName.indexOf(".") + 1);
      }
      /**
       * Relation of the parent.
       * This is used to understand what is joined.
       * This is available when join was made using "post.category" syntax.
       */
      get relation() {
        if (!QueryBuilderUtils_1.QueryBuilderUtils.isAliasProperty(this.relationName))
          throw new TypeORMError_1.TypeORMError(`Given value must be a string representation of alias property`);
        const relationOwnerSelection = this.queryExpressionMap.findAliasByName(this.parentAlias);
        const relation = relationOwnerSelection.metadata.findRelationWithPropertyPath(this.relationPropertyPath);
        if (!relation)
          throw new TypeORMError_1.TypeORMError(`Relation with property path ${this.relationPropertyPath} in entity was not found.`);
        return relation;
      }
      /**
       * Generates alias of junction table, whose ids we get.
       */
      get junctionAlias() {
        const [parentAlias, relationProperty] = this.relationName.split(".");
        return parentAlias + "_" + relationProperty + "_rid";
      }
      /**
       * Metadata of the joined entity.
       * If extra condition without entity was joined, then it will return undefined.
       */
      get junctionMetadata() {
        return this.relation.junctionEntityMetadata;
      }
      get mapToPropertyParentAlias() {
        return this.mapToProperty.substr(0, this.mapToProperty.indexOf("."));
      }
      get mapToPropertyPropertyPath() {
        return this.mapToProperty.substr(this.mapToProperty.indexOf(".") + 1);
      }
    };
    exports2.RelationIdAttribute = RelationIdAttribute;
  }
});

// node_modules/typeorm/query-builder/relation-count/RelationCountAttribute.js
var require_RelationCountAttribute = __commonJS({
  "node_modules/typeorm/query-builder/relation-count/RelationCountAttribute.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RelationCountAttribute = void 0;
    var QueryBuilderUtils_1 = require_QueryBuilderUtils();
    var ObjectUtils_1 = require_ObjectUtils();
    var TypeORMError_1 = require_TypeORMError();
    var RelationCountAttribute = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(expressionMap, relationCountAttribute) {
        this.expressionMap = expressionMap;
        ObjectUtils_1.ObjectUtils.assign(this, relationCountAttribute || {});
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      get joinInverseSideMetadata() {
        return this.relation.inverseEntityMetadata;
      }
      /**
       * Alias of the parent of this join.
       * For example, if we join ("post.category", "categoryAlias") then "post" is a parent alias.
       * This value is extracted from entityOrProperty value.
       * This is available when join was made using "post.category" syntax.
       */
      get parentAlias() {
        if (!QueryBuilderUtils_1.QueryBuilderUtils.isAliasProperty(this.relationName))
          throw new TypeORMError_1.TypeORMError(`Given value must be a string representation of alias property`);
        return this.relationName.split(".")[0];
      }
      /**
       * Relation property name of the parent.
       * This is used to understand what is joined.
       * For example, if we join ("post.category", "categoryAlias") then "category" is a relation property.
       * This value is extracted from entityOrProperty value.
       * This is available when join was made using "post.category" syntax.
       */
      get relationProperty() {
        if (!QueryBuilderUtils_1.QueryBuilderUtils.isAliasProperty(this.relationName))
          throw new TypeORMError_1.TypeORMError(`Given value is a string representation of alias property`);
        return this.relationName.split(".")[1];
      }
      get junctionAlias() {
        const [parentAlias, relationProperty] = this.relationName.split(".");
        return parentAlias + "_" + relationProperty + "_rc";
      }
      /**
       * Relation of the parent.
       * This is used to understand what is joined.
       * This is available when join was made using "post.category" syntax.
       */
      get relation() {
        if (!QueryBuilderUtils_1.QueryBuilderUtils.isAliasProperty(this.relationName))
          throw new TypeORMError_1.TypeORMError(`Given value is a string representation of alias property`);
        const [parentAlias, propertyPath] = this.relationName.split(".");
        const relationOwnerSelection = this.expressionMap.findAliasByName(parentAlias);
        const relation = relationOwnerSelection.metadata.findRelationWithPropertyPath(propertyPath);
        if (!relation)
          throw new TypeORMError_1.TypeORMError(`Relation with property path ${propertyPath} in entity was not found.`);
        return relation;
      }
      /**
       * Metadata of the joined entity.
       * If table without entity was joined, then it will return undefined.
       */
      get metadata() {
        if (!QueryBuilderUtils_1.QueryBuilderUtils.isAliasProperty(this.relationName))
          throw new TypeORMError_1.TypeORMError(`Given value is a string representation of alias property`);
        const parentAlias = this.relationName.split(".")[0];
        const selection = this.expressionMap.findAliasByName(parentAlias);
        return selection.metadata;
      }
      get mapToPropertyPropertyName() {
        return this.mapToProperty.split(".")[1];
      }
    };
    exports2.RelationCountAttribute = RelationCountAttribute;
  }
});

// node_modules/typeorm/query-builder/QueryExpressionMap.js
var require_QueryExpressionMap = __commonJS({
  "node_modules/typeorm/query-builder/QueryExpressionMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryExpressionMap = void 0;
    var Alias_1 = require_Alias();
    var JoinAttribute_1 = require_JoinAttribute();
    var RelationIdAttribute_1 = require_RelationIdAttribute();
    var RelationCountAttribute_1 = require_RelationCountAttribute();
    var error_1 = require_error();
    var QueryExpressionMap = class _QueryExpressionMap {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection) {
        this.connection = connection;
        this.relationLoadStrategy = "join";
        this.queryEntity = false;
        this.aliases = [];
        this.queryType = "select";
        this.selects = [];
        this.maxExecutionTime = 0;
        this.selectDistinct = false;
        this.selectDistinctOn = [];
        this.extraReturningColumns = [];
        this.onConflict = "";
        this.onIgnore = false;
        this.joinAttributes = [];
        this.relationIdAttributes = [];
        this.relationCountAttributes = [];
        this.wheres = [];
        this.havings = [];
        this.orderBys = {};
        this.groupBys = [];
        this.withDeleted = false;
        this.parameters = {};
        this.disableEscaping = true;
        this.enableRelationIdValues = false;
        this.extraAppendedAndWhereCondition = "";
        this.subQuery = false;
        this.aliasNamePrefixingEnabled = true;
        this.options = [];
        this.insertColumns = [];
        this.whereEntities = [];
        this.updateEntity = true;
        this.callListeners = true;
        this.useTransaction = false;
        this.nativeParameters = {};
        this.locallyGenerated = {};
        this.commonTableExpressions = [];
        if (connection.options.relationLoadStrategy) {
          this.relationLoadStrategy = connection.options.relationLoadStrategy;
        }
        this.timeTravel = connection.options?.timeTravelQueries || false;
      }
      // -------------------------------------------------------------------------
      // Accessors
      // -------------------------------------------------------------------------
      /**
       * Get all ORDER BY queries - if order by is specified by user then it uses them,
       * otherwise it uses default entity order by if it was set.
       */
      get allOrderBys() {
        if (!Object.keys(this.orderBys).length && this.mainAlias.hasMetadata && this.options.indexOf("disable-global-order") === -1) {
          const entityOrderBy = this.mainAlias.metadata.orderBy || {};
          return Object.keys(entityOrderBy).reduce((orderBy, key) => {
            orderBy[this.mainAlias.name + "." + key] = entityOrderBy[key];
            return orderBy;
          }, {});
        }
        return this.orderBys;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Creates a main alias and adds it to the current expression map.
       */
      setMainAlias(alias) {
        this.mainAlias = alias;
        return alias;
      }
      /**
       * Creates a new alias and adds it to the current expression map.
       */
      createAlias(options) {
        let aliasName = options.name;
        if (!aliasName && options.tablePath)
          aliasName = options.tablePath;
        if (!aliasName && typeof options.target === "function")
          aliasName = options.target.name;
        if (!aliasName && typeof options.target === "string")
          aliasName = options.target;
        const alias = new Alias_1.Alias();
        alias.type = options.type;
        if (aliasName)
          alias.name = aliasName;
        if (options.metadata)
          alias.metadata = options.metadata;
        if (options.target && !alias.hasMetadata)
          alias.metadata = this.connection.getMetadata(options.target);
        if (options.tablePath)
          alias.tablePath = options.tablePath;
        if (options.subQuery)
          alias.subQuery = options.subQuery;
        this.aliases.push(alias);
        return alias;
      }
      /**
       * Finds alias with the given name.
       * If alias was not found it throw an exception.
       */
      findAliasByName(aliasName) {
        const alias = this.aliases.find((alias2) => alias2.name === aliasName);
        if (!alias)
          throw new error_1.TypeORMError(`"${aliasName}" alias was not found. Maybe you forgot to join it?`);
        return alias;
      }
      findColumnByAliasExpression(aliasExpression) {
        const [aliasName, propertyPath] = aliasExpression.split(".");
        const alias = this.findAliasByName(aliasName);
        return alias.metadata.findColumnWithPropertyName(propertyPath);
      }
      /**
       * Gets relation metadata of the relation this query builder works with.
       *
       * todo: add proper exceptions
       */
      get relationMetadata() {
        if (!this.mainAlias)
          throw new error_1.TypeORMError(`Entity to work with is not specified!`);
        const relationMetadata = this.mainAlias.metadata.findRelationWithPropertyPath(this.relationPropertyPath);
        if (!relationMetadata)
          throw new error_1.TypeORMError(`Relation ${this.relationPropertyPath} was not found in entity ${this.mainAlias.name}`);
        return relationMetadata;
      }
      /**
       * Copies all properties of the current QueryExpressionMap into a new one.
       * Useful when QueryBuilder needs to create a copy of itself.
       */
      clone() {
        const map = new _QueryExpressionMap(this.connection);
        map.queryType = this.queryType;
        map.selects = this.selects.map((select) => select);
        map.maxExecutionTime = this.maxExecutionTime;
        map.selectDistinct = this.selectDistinct;
        map.selectDistinctOn = this.selectDistinctOn;
        this.aliases.forEach((alias) => map.aliases.push(new Alias_1.Alias(alias)));
        map.relationLoadStrategy = this.relationLoadStrategy;
        map.mainAlias = this.mainAlias;
        map.valuesSet = this.valuesSet;
        map.returning = this.returning;
        map.onConflict = this.onConflict;
        map.onIgnore = this.onIgnore;
        map.onUpdate = this.onUpdate;
        map.joinAttributes = this.joinAttributes.map((join) => new JoinAttribute_1.JoinAttribute(this.connection, this, join));
        map.relationIdAttributes = this.relationIdAttributes.map((relationId) => new RelationIdAttribute_1.RelationIdAttribute(this, relationId));
        map.relationCountAttributes = this.relationCountAttributes.map((relationCount) => new RelationCountAttribute_1.RelationCountAttribute(this, relationCount));
        map.wheres = this.wheres.map((where) => ({ ...where }));
        map.havings = this.havings.map((having) => ({ ...having }));
        map.orderBys = Object.assign({}, this.orderBys);
        map.groupBys = this.groupBys.map((groupBy) => groupBy);
        map.limit = this.limit;
        map.offset = this.offset;
        map.skip = this.skip;
        map.take = this.take;
        map.useIndex = this.useIndex;
        map.lockMode = this.lockMode;
        map.onLocked = this.onLocked;
        map.lockVersion = this.lockVersion;
        map.lockTables = this.lockTables;
        map.withDeleted = this.withDeleted;
        map.parameters = Object.assign({}, this.parameters);
        map.disableEscaping = this.disableEscaping;
        map.enableRelationIdValues = this.enableRelationIdValues;
        map.extraAppendedAndWhereCondition = this.extraAppendedAndWhereCondition;
        map.subQuery = this.subQuery;
        map.aliasNamePrefixingEnabled = this.aliasNamePrefixingEnabled;
        map.cache = this.cache;
        map.cacheId = this.cacheId;
        map.cacheDuration = this.cacheDuration;
        map.relationPropertyPath = this.relationPropertyPath;
        map.of = this.of;
        map.insertColumns = this.insertColumns;
        map.whereEntities = this.whereEntities;
        map.updateEntity = this.updateEntity;
        map.callListeners = this.callListeners;
        map.useTransaction = this.useTransaction;
        map.timeTravel = this.timeTravel;
        map.nativeParameters = Object.assign({}, this.nativeParameters);
        map.comment = this.comment;
        map.commonTableExpressions = this.commonTableExpressions.map((cteOptions) => ({
          alias: cteOptions.alias,
          queryBuilder: typeof cteOptions.queryBuilder === "string" ? cteOptions.queryBuilder : cteOptions.queryBuilder.clone(),
          options: cteOptions.options
        }));
        return map;
      }
    };
    exports2.QueryExpressionMap = QueryExpressionMap;
  }
});

// node_modules/typeorm/query-builder/Brackets.js
var require_Brackets = __commonJS({
  "node_modules/typeorm/query-builder/Brackets.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Brackets = void 0;
    var Brackets2 = class {
      /**
       * Given WHERE query builder that will build a WHERE expression that will be taken into brackets.
       */
      constructor(whereFactory) {
        this["@instanceof"] = Symbol.for("Brackets");
        this.whereFactory = whereFactory;
      }
    };
    exports2.Brackets = Brackets2;
  }
});

// node_modules/typeorm/util/ApplyValueTransformers.js
var require_ApplyValueTransformers = __commonJS({
  "node_modules/typeorm/util/ApplyValueTransformers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApplyValueTransformers = void 0;
    var ApplyValueTransformers = class {
      static transformFrom(transformer, databaseValue) {
        if (Array.isArray(transformer)) {
          const reverseTransformers = transformer.slice().reverse();
          return reverseTransformers.reduce((transformedValue, _transformer) => {
            return _transformer.from(transformedValue);
          }, databaseValue);
        }
        return transformer.from(databaseValue);
      }
      static transformTo(transformer, entityValue) {
        if (Array.isArray(transformer)) {
          return transformer.reduce((transformedValue, _transformer) => {
            return _transformer.to(transformedValue);
          }, entityValue);
        }
        return transformer.to(entityValue);
      }
    };
    exports2.ApplyValueTransformers = ApplyValueTransformers;
  }
});

// node_modules/typeorm/find-options/FindOperator.js
var require_FindOperator = __commonJS({
  "node_modules/typeorm/find-options/FindOperator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FindOperator = void 0;
    var InstanceChecker_1 = require_InstanceChecker();
    var ApplyValueTransformers_1 = require_ApplyValueTransformers();
    var FindOperator2 = class _FindOperator {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(type, value, useParameter = true, multipleParameters = false, getSql, objectLiteralParameters) {
        this["@instanceof"] = Symbol.for("FindOperator");
        this._type = type;
        this._value = value;
        this._useParameter = useParameter;
        this._multipleParameters = multipleParameters;
        this._getSql = getSql;
        this._objectLiteralParameters = objectLiteralParameters;
      }
      // -------------------------------------------------------------------------
      // Accessors
      // -------------------------------------------------------------------------
      /**
       * Indicates if parameter is used or not for this operator.
       * Extracts final value if value is another find operator.
       */
      get useParameter() {
        if (InstanceChecker_1.InstanceChecker.isFindOperator(this._value))
          return this._value.useParameter;
        return this._useParameter;
      }
      /**
       * Indicates if multiple parameters must be used for this operator.
       * Extracts final value if value is another find operator.
       */
      get multipleParameters() {
        if (InstanceChecker_1.InstanceChecker.isFindOperator(this._value))
          return this._value.multipleParameters;
        return this._multipleParameters;
      }
      /**
       * Gets the Type of this FindOperator
       */
      get type() {
        return this._type;
      }
      /**
       * Gets the final value needs to be used as parameter value.
       */
      get value() {
        if (InstanceChecker_1.InstanceChecker.isFindOperator(this._value))
          return this._value.value;
        return this._value;
      }
      /**
       * Gets ObjectLiteral parameters.
       */
      get objectLiteralParameters() {
        if (InstanceChecker_1.InstanceChecker.isFindOperator(this._value))
          return this._value.objectLiteralParameters;
        return this._objectLiteralParameters;
      }
      /**
       * Gets the child FindOperator if it exists
       */
      get child() {
        if (InstanceChecker_1.InstanceChecker.isFindOperator(this._value))
          return this._value;
        return void 0;
      }
      /**
       * Gets the SQL generator
       */
      get getSql() {
        if (InstanceChecker_1.InstanceChecker.isFindOperator(this._value))
          return this._value.getSql;
        return this._getSql;
      }
      transformValue(transformer) {
        if (this._value instanceof _FindOperator) {
          this._value.transformValue(transformer);
        } else {
          this._value = Array.isArray(this._value) && this._multipleParameters ? this._value.map((v) => transformer && ApplyValueTransformers_1.ApplyValueTransformers.transformTo(transformer, v)) : ApplyValueTransformers_1.ApplyValueTransformers.transformTo(transformer, this._value);
        }
      }
    };
    exports2.FindOperator = FindOperator2;
  }
});

// node_modules/typeorm/find-options/operator/In.js
var require_In = __commonJS({
  "node_modules/typeorm/find-options/operator/In.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.In = In2;
    var FindOperator_1 = require_FindOperator();
    function In2(value) {
      return new FindOperator_1.FindOperator("in", value, true, true);
    }
  }
});

// node_modules/typeorm/util/escapeRegExp.js
var require_escapeRegExp2 = __commonJS({
  "node_modules/typeorm/util/escapeRegExp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.escapeRegExp = void 0;
    var ESCAPE_REGEXP = /[.*+\-?^${}()|[\]\\]/g;
    var escapeRegExp = (s) => s.replace(ESCAPE_REGEXP, "\\$&");
    exports2.escapeRegExp = escapeRegExp;
  }
});

// node_modules/typeorm/query-builder/QueryBuilder.js
var require_QueryBuilder = __commonJS({
  "node_modules/typeorm/query-builder/QueryBuilder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryBuilder = void 0;
    var QueryExpressionMap_1 = require_QueryExpressionMap();
    var Brackets_1 = require_Brackets();
    var FindOperator_1 = require_FindOperator();
    var In_1 = require_In();
    var error_1 = require_error();
    var EntityPropertyNotFoundError_1 = require_EntityPropertyNotFoundError();
    var InstanceChecker_1 = require_InstanceChecker();
    var escapeRegExp_1 = require_escapeRegExp2();
    var QueryBuilder2 = class _QueryBuilder {
      /**
       * QueryBuilder can be initialized from given Connection and QueryRunner objects or from given other QueryBuilder.
       */
      constructor(connectionOrQueryBuilder, queryRunner) {
        this["@instanceof"] = Symbol.for("QueryBuilder");
        this.parameterIndex = 0;
        if (InstanceChecker_1.InstanceChecker.isDataSource(connectionOrQueryBuilder)) {
          this.connection = connectionOrQueryBuilder;
          this.queryRunner = queryRunner;
          this.expressionMap = new QueryExpressionMap_1.QueryExpressionMap(this.connection);
        } else {
          this.connection = connectionOrQueryBuilder.connection;
          this.queryRunner = connectionOrQueryBuilder.queryRunner;
          this.expressionMap = connectionOrQueryBuilder.expressionMap.clone();
        }
      }
      static registerQueryBuilderClass(name, factory) {
        _QueryBuilder.queryBuilderRegistry[name] = factory;
      }
      // -------------------------------------------------------------------------
      // Accessors
      // -------------------------------------------------------------------------
      /**
       * Gets the main alias string used in this query builder.
       */
      get alias() {
        if (!this.expressionMap.mainAlias)
          throw new error_1.TypeORMError(`Main alias is not set`);
        return this.expressionMap.mainAlias.name;
      }
      /**
       * Creates SELECT query and selects given data.
       * Replaces all previous selections if they exist.
       */
      select(selection, selectionAliasName) {
        this.expressionMap.queryType = "select";
        if (Array.isArray(selection)) {
          this.expressionMap.selects = selection.map((selection2) => ({
            selection: selection2
          }));
        } else if (selection) {
          this.expressionMap.selects = [
            { selection, aliasName: selectionAliasName }
          ];
        }
        if (InstanceChecker_1.InstanceChecker.isSelectQueryBuilder(this))
          return this;
        return _QueryBuilder.queryBuilderRegistry["SelectQueryBuilder"](this);
      }
      /**
       * Creates INSERT query.
       */
      insert() {
        this.expressionMap.queryType = "insert";
        if (InstanceChecker_1.InstanceChecker.isInsertQueryBuilder(this))
          return this;
        return _QueryBuilder.queryBuilderRegistry["InsertQueryBuilder"](this);
      }
      /**
       * Creates UPDATE query and applies given update values.
       */
      update(entityOrTableNameUpdateSet, maybeUpdateSet) {
        const updateSet = maybeUpdateSet ? maybeUpdateSet : entityOrTableNameUpdateSet;
        entityOrTableNameUpdateSet = InstanceChecker_1.InstanceChecker.isEntitySchema(entityOrTableNameUpdateSet) ? entityOrTableNameUpdateSet.options.name : entityOrTableNameUpdateSet;
        if (typeof entityOrTableNameUpdateSet === "function" || typeof entityOrTableNameUpdateSet === "string") {
          const mainAlias = this.createFromAlias(entityOrTableNameUpdateSet);
          this.expressionMap.setMainAlias(mainAlias);
        }
        this.expressionMap.queryType = "update";
        this.expressionMap.valuesSet = updateSet;
        if (InstanceChecker_1.InstanceChecker.isUpdateQueryBuilder(this))
          return this;
        return _QueryBuilder.queryBuilderRegistry["UpdateQueryBuilder"](this);
      }
      /**
       * Creates DELETE query.
       */
      delete() {
        this.expressionMap.queryType = "delete";
        if (InstanceChecker_1.InstanceChecker.isDeleteQueryBuilder(this))
          return this;
        return _QueryBuilder.queryBuilderRegistry["DeleteQueryBuilder"](this);
      }
      softDelete() {
        this.expressionMap.queryType = "soft-delete";
        if (InstanceChecker_1.InstanceChecker.isSoftDeleteQueryBuilder(this))
          return this;
        return _QueryBuilder.queryBuilderRegistry["SoftDeleteQueryBuilder"](this);
      }
      restore() {
        this.expressionMap.queryType = "restore";
        if (InstanceChecker_1.InstanceChecker.isSoftDeleteQueryBuilder(this))
          return this;
        return _QueryBuilder.queryBuilderRegistry["SoftDeleteQueryBuilder"](this);
      }
      /**
       * Sets entity's relation with which this query builder gonna work.
       */
      relation(entityTargetOrPropertyPath, maybePropertyPath) {
        const entityTarget = arguments.length === 2 ? entityTargetOrPropertyPath : void 0;
        const propertyPath = arguments.length === 2 ? maybePropertyPath : entityTargetOrPropertyPath;
        this.expressionMap.queryType = "relation";
        this.expressionMap.relationPropertyPath = propertyPath;
        if (entityTarget) {
          const mainAlias = this.createFromAlias(entityTarget);
          this.expressionMap.setMainAlias(mainAlias);
        }
        if (InstanceChecker_1.InstanceChecker.isRelationQueryBuilder(this))
          return this;
        return _QueryBuilder.queryBuilderRegistry["RelationQueryBuilder"](this);
      }
      /**
       * Checks if given relation or relations exist in the entity.
       * Returns true if relation exists, false otherwise.
       *
       * todo: move this method to manager? or create a shortcut?
       */
      hasRelation(target, relation) {
        const entityMetadata = this.connection.getMetadata(target);
        const relations = Array.isArray(relation) ? relation : [relation];
        return relations.every((relation2) => {
          return !!entityMetadata.findRelationWithPropertyPath(relation2);
        });
      }
      /**
       * Check the existence of a parameter for this query builder.
       */
      hasParameter(key) {
        return this.parentQueryBuilder?.hasParameter(key) || key in this.expressionMap.parameters;
      }
      /**
       * Sets parameter name and its value.
       *
       * The key for this parameter may contain numbers, letters, underscores, or periods.
       */
      setParameter(key, value) {
        if (typeof value === "function") {
          throw new error_1.TypeORMError(`Function parameter isn't supported in the parameters. Please check "${key}" parameter.`);
        }
        if (!key.match(/^([A-Za-z0-9_.]+)$/)) {
          throw new error_1.TypeORMError("QueryBuilder parameter keys may only contain numbers, letters, underscores, or periods.");
        }
        if (this.parentQueryBuilder) {
          this.parentQueryBuilder.setParameter(key, value);
        }
        this.expressionMap.parameters[key] = value;
        return this;
      }
      /**
       * Adds all parameters from the given object.
       */
      setParameters(parameters) {
        for (const [key, value] of Object.entries(parameters)) {
          this.setParameter(key, value);
        }
        return this;
      }
      createParameter(value) {
        let parameterName;
        do {
          parameterName = `orm_param_${this.parameterIndex++}`;
        } while (this.hasParameter(parameterName));
        this.setParameter(parameterName, value);
        return `:${parameterName}`;
      }
      /**
       * Adds native parameters from the given object.
       *
       * @deprecated Use `setParameters` instead
       */
      setNativeParameters(parameters) {
        if (this.parentQueryBuilder) {
          this.parentQueryBuilder.setNativeParameters(parameters);
        }
        Object.keys(parameters).forEach((key) => {
          this.expressionMap.nativeParameters[key] = parameters[key];
        });
        return this;
      }
      /**
       * Gets all parameters.
       */
      getParameters() {
        const parameters = Object.assign({}, this.expressionMap.parameters);
        if (this.expressionMap.mainAlias && this.expressionMap.mainAlias.hasMetadata) {
          const metadata = this.expressionMap.mainAlias.metadata;
          if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {
            const values = metadata.childEntityMetadatas.filter((childMetadata) => childMetadata.discriminatorColumn).map((childMetadata) => childMetadata.discriminatorValue);
            values.push(metadata.discriminatorValue);
            parameters["discriminatorColumnValues"] = values;
          }
        }
        return parameters;
      }
      /**
       * Prints sql to stdout using console.log.
       */
      printSql() {
        const [query, parameters] = this.getQueryAndParameters();
        this.connection.logger.logQuery(query, parameters);
        return this;
      }
      /**
       * Gets generated sql that will be executed.
       * Parameters in the query are escaped for the currently used driver.
       */
      getSql() {
        return this.getQueryAndParameters()[0];
      }
      /**
       * Gets query to be executed with all parameters used in it.
       */
      getQueryAndParameters() {
        const query = this.getQuery();
        const parameters = this.getParameters();
        return this.connection.driver.escapeQueryWithParameters(query, parameters, this.expressionMap.nativeParameters);
      }
      /**
       * Executes sql generated by query builder and returns raw database results.
       */
      async execute() {
        const [sql, parameters] = this.getQueryAndParameters();
        const queryRunner = this.obtainQueryRunner();
        try {
          return await queryRunner.query(sql, parameters);
        } finally {
          if (queryRunner !== this.queryRunner) {
            await queryRunner.release();
          }
        }
      }
      /**
       * Creates a completely new query builder.
       * Uses same query runner as current QueryBuilder.
       */
      createQueryBuilder(queryRunner) {
        return new this.constructor(this.connection, queryRunner ?? this.queryRunner);
      }
      /**
       * Clones query builder as it is.
       * Note: it uses new query runner, if you want query builder that uses exactly same query runner,
       * you can create query builder using its constructor, for example new SelectQueryBuilder(queryBuilder)
       * where queryBuilder is cloned QueryBuilder.
       */
      clone() {
        return new this.constructor(this);
      }
      /**
       * Includes a Query comment in the query builder.  This is helpful for debugging purposes,
       * such as finding a specific query in the database server's logs, or for categorization using
       * an APM product.
       */
      comment(comment) {
        this.expressionMap.comment = comment;
        return this;
      }
      /**
       * Disables escaping.
       */
      disableEscaping() {
        this.expressionMap.disableEscaping = false;
        return this;
      }
      /**
       * Escapes table name, column name or alias name using current database's escaping character.
       */
      escape(name) {
        if (!this.expressionMap.disableEscaping)
          return name;
        return this.connection.driver.escape(name);
      }
      /**
       * Sets or overrides query builder's QueryRunner.
       */
      setQueryRunner(queryRunner) {
        this.queryRunner = queryRunner;
        return this;
      }
      /**
       * Indicates if listeners and subscribers must be called before and after query execution.
       * Enabled by default.
       */
      callListeners(enabled) {
        this.expressionMap.callListeners = enabled;
        return this;
      }
      /**
       * If set to true the query will be wrapped into a transaction.
       */
      useTransaction(enabled) {
        this.expressionMap.useTransaction = enabled;
        return this;
      }
      /**
       * Adds CTE to query
       */
      addCommonTableExpression(queryBuilder, alias, options) {
        this.expressionMap.commonTableExpressions.push({
          queryBuilder,
          alias,
          options: options || {}
        });
        return this;
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Gets escaped table name with schema name if SqlServer driver used with custom
       * schema name, otherwise returns escaped table name.
       */
      getTableName(tablePath) {
        return tablePath.split(".").map((i) => {
          if (i === "")
            return i;
          return this.escape(i);
        }).join(".");
      }
      /**
       * Gets name of the table where insert should be performed.
       */
      getMainTableName() {
        if (!this.expressionMap.mainAlias)
          throw new error_1.TypeORMError(`Entity where values should be inserted is not specified. Call "qb.into(entity)" method to specify it.`);
        if (this.expressionMap.mainAlias.hasMetadata)
          return this.expressionMap.mainAlias.metadata.tablePath;
        return this.expressionMap.mainAlias.tablePath;
      }
      /**
       * Specifies FROM which entity's table select/update/delete will be executed.
       * Also sets a main string alias of the selection data.
       */
      createFromAlias(entityTarget, aliasName) {
        if (this.connection.hasMetadata(entityTarget)) {
          const metadata = this.connection.getMetadata(entityTarget);
          return this.expressionMap.createAlias({
            type: "from",
            name: aliasName,
            metadata: this.connection.getMetadata(entityTarget),
            tablePath: metadata.tablePath
          });
        } else {
          if (typeof entityTarget === "string") {
            const isSubquery = entityTarget.substr(0, 1) === "(" && entityTarget.substr(-1) === ")";
            return this.expressionMap.createAlias({
              type: "from",
              name: aliasName,
              tablePath: !isSubquery ? entityTarget : void 0,
              subQuery: isSubquery ? entityTarget : void 0
            });
          }
          const subQueryBuilder = entityTarget(this.subQuery());
          this.setParameters(subQueryBuilder.getParameters());
          const subquery = subQueryBuilder.getQuery();
          return this.expressionMap.createAlias({
            type: "from",
            name: aliasName,
            subQuery: subquery
          });
        }
      }
      /**
       * @deprecated this way of replace property names is too slow.
       *  Instead, we'll replace property names at the end - once query is build.
       */
      replacePropertyNames(statement) {
        return statement;
      }
      /**
       * Replaces all entity's propertyName to name in the given SQL string.
       */
      replacePropertyNamesForTheWholeQuery(statement) {
        const replacements = {};
        for (const alias of this.expressionMap.aliases) {
          if (!alias.hasMetadata)
            continue;
          const replaceAliasNamePrefix = this.expressionMap.aliasNamePrefixingEnabled && alias.name ? `${alias.name}.` : "";
          if (!replacements[replaceAliasNamePrefix]) {
            replacements[replaceAliasNamePrefix] = {};
          }
          for (const relation of alias.metadata.relations) {
            if (relation.joinColumns.length > 0)
              replacements[replaceAliasNamePrefix][relation.propertyPath] = relation.joinColumns[0].databaseName;
          }
          for (const relation of alias.metadata.relations) {
            const allColumns = [
              ...relation.joinColumns,
              ...relation.inverseJoinColumns
            ];
            for (const joinColumn of allColumns) {
              const propertyKey = `${relation.propertyPath}.${joinColumn.referencedColumn.propertyPath}`;
              replacements[replaceAliasNamePrefix][propertyKey] = joinColumn.databaseName;
            }
          }
          for (const column of alias.metadata.columns) {
            replacements[replaceAliasNamePrefix][column.databaseName] = column.databaseName;
          }
          for (const column of alias.metadata.columns) {
            replacements[replaceAliasNamePrefix][column.propertyName] = column.databaseName;
          }
          for (const column of alias.metadata.columns) {
            replacements[replaceAliasNamePrefix][column.propertyPath] = column.databaseName;
          }
        }
        const replacementKeys = Object.keys(replacements);
        const replaceAliasNamePrefixes = replacementKeys.map((key) => (0, escapeRegExp_1.escapeRegExp)(key)).join("|");
        if (replacementKeys.length > 0) {
          statement = statement.replace(new RegExp(
            // Avoid a lookbehind here since it's not well supported
            `([ =(]|^.{0})${replaceAliasNamePrefixes ? "(" + replaceAliasNamePrefixes + ")" : ""}([^ =(),]+)(?=[ =),]|.{0}$)`,
            "gm"
          ), (...matches) => {
            let match, pre, p;
            if (replaceAliasNamePrefixes) {
              match = matches[0];
              pre = matches[1];
              p = matches[3];
              if (replacements[matches[2]][p]) {
                return `${pre}${this.escape(matches[2].substring(0, matches[2].length - 1))}.${this.escape(replacements[matches[2]][p])}`;
              }
            } else {
              match = matches[0];
              pre = matches[1];
              p = matches[2];
              if (replacements[""][p]) {
                return `${pre}${this.escape(replacements[""][p])}`;
              }
            }
            return match;
          });
        }
        return statement;
      }
      createComment() {
        if (!this.expressionMap.comment) {
          return "";
        }
        return `/* ${this.expressionMap.comment.replace(/\*\//g, "")} */ `;
      }
      /**
       * Time travel queries for CockroachDB
       */
      createTimeTravelQuery() {
        if (this.expressionMap.queryType === "select" && this.expressionMap.timeTravel) {
          return ` AS OF SYSTEM TIME ${this.expressionMap.timeTravel}`;
        }
        return "";
      }
      /**
       * Creates "WHERE" expression.
       */
      createWhereExpression() {
        const conditionsArray = [];
        const whereExpression = this.createWhereClausesExpression(this.expressionMap.wheres);
        if (whereExpression.length > 0 && whereExpression !== "1=1") {
          conditionsArray.push(this.replacePropertyNames(whereExpression));
        }
        if (this.expressionMap.mainAlias.hasMetadata) {
          const metadata = this.expressionMap.mainAlias.metadata;
          if (this.expressionMap.queryType === "select" && !this.expressionMap.withDeleted && metadata.deleteDateColumn) {
            const column = this.expressionMap.aliasNamePrefixingEnabled ? this.expressionMap.mainAlias.name + "." + metadata.deleteDateColumn.propertyName : metadata.deleteDateColumn.propertyName;
            const condition2 = `${this.replacePropertyNames(column)} IS NULL`;
            conditionsArray.push(condition2);
          }
          if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {
            const column = this.expressionMap.aliasNamePrefixingEnabled ? this.expressionMap.mainAlias.name + "." + metadata.discriminatorColumn.databaseName : metadata.discriminatorColumn.databaseName;
            const condition2 = `${this.replacePropertyNames(column)} IN (:...discriminatorColumnValues)`;
            conditionsArray.push(condition2);
          }
        }
        if (this.expressionMap.extraAppendedAndWhereCondition) {
          const condition2 = this.replacePropertyNames(this.expressionMap.extraAppendedAndWhereCondition);
          conditionsArray.push(condition2);
        }
        let condition = "";
        condition += this.createTimeTravelQuery();
        if (!conditionsArray.length) {
          condition += "";
        } else if (conditionsArray.length === 1) {
          condition += ` WHERE ${conditionsArray[0]}`;
        } else {
          condition += ` WHERE ( ${conditionsArray.join(" ) AND ( ")} )`;
        }
        return condition;
      }
      /**
       * Creates "RETURNING" / "OUTPUT" expression.
       */
      createReturningExpression(returningType) {
        const columns = this.getReturningColumns();
        const driver = this.connection.driver;
        if (typeof this.expressionMap.returning !== "string" && this.expressionMap.extraReturningColumns.length > 0 && driver.isReturningSqlSupported(returningType)) {
          columns.push(...this.expressionMap.extraReturningColumns.filter((column) => {
            return columns.indexOf(column) === -1;
          }));
        }
        if (columns.length) {
          let columnsExpression = columns.map((column) => {
            const name = this.escape(column.databaseName);
            if (driver.options.type === "mssql") {
              if (this.expressionMap.queryType === "insert" || this.expressionMap.queryType === "update" || this.expressionMap.queryType === "soft-delete" || this.expressionMap.queryType === "restore") {
                return "INSERTED." + name;
              } else {
                return this.escape(this.getMainTableName()) + "." + name;
              }
            } else {
              return name;
            }
          }).join(", ");
          if (driver.options.type === "oracle") {
            columnsExpression += " INTO " + columns.map((column) => {
              return this.createParameter({
                type: driver.columnTypeToNativeParameter(column.type),
                dir: driver.oracle.BIND_OUT
              });
            }).join(", ");
          }
          if (driver.options.type === "mssql") {
            if (this.expressionMap.queryType === "insert" || this.expressionMap.queryType === "update") {
              columnsExpression += " INTO @OutputTable";
            }
          }
          return columnsExpression;
        } else if (typeof this.expressionMap.returning === "string") {
          return this.expressionMap.returning;
        }
        return "";
      }
      /**
       * If returning / output cause is set to array of column names,
       * then this method will return all column metadatas of those column names.
       */
      getReturningColumns() {
        const columns = [];
        if (Array.isArray(this.expressionMap.returning)) {
          ;
          this.expressionMap.returning.forEach((columnName) => {
            if (this.expressionMap.mainAlias.hasMetadata) {
              columns.push(...this.expressionMap.mainAlias.metadata.findColumnsWithPropertyPath(columnName));
            }
          });
        }
        return columns;
      }
      createWhereClausesExpression(clauses) {
        return clauses.map((clause, index) => {
          const expression = this.createWhereConditionExpression(clause.condition);
          switch (clause.type) {
            case "and":
              return (index > 0 ? "AND " : "") + `${this.connection.options.isolateWhereStatements ? "(" : ""}${expression}${this.connection.options.isolateWhereStatements ? ")" : ""}`;
            case "or":
              return (index > 0 ? "OR " : "") + `${this.connection.options.isolateWhereStatements ? "(" : ""}${expression}${this.connection.options.isolateWhereStatements ? ")" : ""}`;
          }
          return expression;
        }).join(" ").trim();
      }
      /**
       * Computes given where argument - transforms to a where string all forms it can take.
       */
      createWhereConditionExpression(condition, alwaysWrap = false) {
        if (typeof condition === "string")
          return condition;
        if (Array.isArray(condition)) {
          if (condition.length === 0) {
            return "1=1";
          }
          if (condition.length === 1 && !alwaysWrap) {
            return this.createWhereClausesExpression(condition);
          }
          return "(" + this.createWhereClausesExpression(condition) + ")";
        }
        const { driver } = this.connection;
        switch (condition.operator) {
          case "lessThan":
            return `${condition.parameters[0]} < ${condition.parameters[1]}`;
          case "lessThanOrEqual":
            return `${condition.parameters[0]} <= ${condition.parameters[1]}`;
          case "arrayContains":
            return `${condition.parameters[0]} @> ${condition.parameters[1]}`;
          case "jsonContains":
            return `${condition.parameters[0]} ::jsonb @> ${condition.parameters[1]}`;
          case "arrayContainedBy":
            return `${condition.parameters[0]} <@ ${condition.parameters[1]}`;
          case "arrayOverlap":
            return `${condition.parameters[0]} && ${condition.parameters[1]}`;
          case "moreThan":
            return `${condition.parameters[0]} > ${condition.parameters[1]}`;
          case "moreThanOrEqual":
            return `${condition.parameters[0]} >= ${condition.parameters[1]}`;
          case "notEqual":
            return `${condition.parameters[0]} != ${condition.parameters[1]}`;
          case "equal":
            return `${condition.parameters[0]} = ${condition.parameters[1]}`;
          case "ilike":
            if (driver.options.type === "postgres" || driver.options.type === "cockroachdb") {
              return `${condition.parameters[0]} ILIKE ${condition.parameters[1]}`;
            }
            return `UPPER(${condition.parameters[0]}) LIKE UPPER(${condition.parameters[1]})`;
          case "like":
            return `${condition.parameters[0]} LIKE ${condition.parameters[1]}`;
          case "between":
            return `${condition.parameters[0]} BETWEEN ${condition.parameters[1]} AND ${condition.parameters[2]}`;
          case "in":
            if (condition.parameters.length <= 1) {
              return "0=1";
            }
            return `${condition.parameters[0]} IN (${condition.parameters.slice(1).join(", ")})`;
          case "any":
            if (driver.options.type === "cockroachdb") {
              return `${condition.parameters[0]}::STRING = ANY(${condition.parameters[1]}::STRING[])`;
            }
            return `${condition.parameters[0]} = ANY(${condition.parameters[1]})`;
          case "isNull":
            return `${condition.parameters[0]} IS NULL`;
          case "not":
            return `NOT(${this.createWhereConditionExpression(condition.condition)})`;
          case "brackets":
            return `${this.createWhereConditionExpression(condition.condition, true)}`;
          case "and":
            return "(" + condition.parameters.join(" AND ") + ")";
          case "or":
            return "(" + condition.parameters.join(" OR ") + ")";
        }
        throw new TypeError(`Unsupported FindOperator ${FindOperator_1.FindOperator.constructor.name}`);
      }
      createCteExpression() {
        if (!this.hasCommonTableExpressions()) {
          return "";
        }
        const databaseRequireRecusiveHint = this.connection.driver.cteCapabilities.requiresRecursiveHint;
        const cteStrings = this.expressionMap.commonTableExpressions.map((cte) => {
          let cteBodyExpression = typeof cte.queryBuilder === "string" ? cte.queryBuilder : "";
          if (typeof cte.queryBuilder !== "string") {
            if (cte.queryBuilder.hasCommonTableExpressions()) {
              throw new error_1.TypeORMError(`Nested CTEs aren't supported (CTE: ${cte.alias})`);
            }
            cteBodyExpression = cte.queryBuilder.getQuery();
            if (!this.connection.driver.cteCapabilities.writable && !InstanceChecker_1.InstanceChecker.isSelectQueryBuilder(cte.queryBuilder)) {
              throw new error_1.TypeORMError(`Only select queries are supported in CTEs in ${this.connection.options.type} (CTE: ${cte.alias})`);
            }
            this.setParameters(cte.queryBuilder.getParameters());
          }
          let cteHeader = this.escape(cte.alias);
          if (cte.options.columnNames) {
            const escapedColumnNames = cte.options.columnNames.map((column) => this.escape(column));
            if (InstanceChecker_1.InstanceChecker.isSelectQueryBuilder(cte.queryBuilder)) {
              if (cte.queryBuilder.expressionMap.selects.length && cte.options.columnNames.length !== cte.queryBuilder.expressionMap.selects.length) {
                throw new error_1.TypeORMError(`cte.options.columnNames length (${cte.options.columnNames.length}) doesn't match subquery select list length ${cte.queryBuilder.expressionMap.selects.length} (CTE: ${cte.alias})`);
              }
            }
            cteHeader += `(${escapedColumnNames.join(", ")})`;
          }
          const recursiveClause = cte.options.recursive && databaseRequireRecusiveHint ? "RECURSIVE" : "";
          let materializeClause = "";
          if (this.connection.driver.cteCapabilities.materializedHint && cte.options.materialized !== void 0) {
            materializeClause = cte.options.materialized ? "MATERIALIZED" : "NOT MATERIALIZED";
          }
          return [
            recursiveClause,
            cteHeader,
            "AS",
            materializeClause,
            `(${cteBodyExpression})`
          ].filter(Boolean).join(" ");
        });
        return "WITH " + cteStrings.join(", ") + " ";
      }
      /**
       * Creates "WHERE" condition for an in-ids condition.
       */
      getWhereInIdsCondition(ids) {
        const metadata = this.expressionMap.mainAlias.metadata;
        const normalized = (Array.isArray(ids) ? ids : [ids]).map((id) => metadata.ensureEntityIdMap(id));
        if (!metadata.hasMultiplePrimaryKeys) {
          const primaryColumn = metadata.primaryColumns[0];
          if (!primaryColumn.transformer && !primaryColumn.relationMetadata && !primaryColumn.embeddedMetadata) {
            return {
              [primaryColumn.propertyName]: (0, In_1.In)(normalized.map((id) => primaryColumn.getEntityValue(id, false)))
            };
          }
        }
        return new Brackets_1.Brackets((qb) => {
          for (const data of normalized) {
            qb.orWhere(new Brackets_1.Brackets((qb2) => qb2.where(data)));
          }
        });
      }
      getExistsCondition(subQuery) {
        const query = subQuery.clone().orderBy().groupBy().offset(void 0).limit(void 0).skip(void 0).take(void 0).select("1").setOption("disable-global-order");
        return [`EXISTS (${query.getQuery()})`, query.getParameters()];
      }
      findColumnsForPropertyPath(propertyPath) {
        let alias = this.expressionMap.mainAlias;
        const root = [];
        const propertyPathParts = propertyPath.split(".");
        while (propertyPathParts.length > 1) {
          const part = propertyPathParts[0];
          if (!alias?.hasMetadata) {
            break;
          }
          if (alias.metadata.hasEmbeddedWithPropertyPath(part)) {
            propertyPathParts.unshift(`${propertyPathParts.shift()}.${propertyPathParts.shift()}`);
            continue;
          }
          if (alias.metadata.hasRelationWithPropertyPath(part)) {
            const joinAttr = this.expressionMap.joinAttributes.find((joinAttr2) => joinAttr2.relationPropertyPath === part);
            if (!joinAttr?.alias) {
              const fullRelationPath = root.length > 0 ? `${root.join(".")}.${part}` : part;
              throw new Error(`Cannot find alias for relation at ${fullRelationPath}`);
            }
            alias = joinAttr.alias;
            root.push(...part.split("."));
            propertyPathParts.shift();
            continue;
          }
          break;
        }
        if (!alias) {
          throw new Error(`Cannot find alias for property ${propertyPath}`);
        }
        const aliasPropertyPath = propertyPathParts.join(".");
        const columns = alias.metadata.findColumnsWithPropertyPath(aliasPropertyPath);
        if (!columns.length) {
          throw new EntityPropertyNotFoundError_1.EntityPropertyNotFoundError(propertyPath, alias.metadata);
        }
        return [alias, root, columns];
      }
      /**
       * Creates a property paths for a given ObjectLiteral.
       */
      createPropertyPath(metadata, entity, prefix = "") {
        const paths = [];
        for (const key of Object.keys(entity)) {
          const path = prefix ? `${prefix}.${key}` : key;
          if (entity[key] === null || typeof entity[key] !== "object" || InstanceChecker_1.InstanceChecker.isFindOperator(entity[key])) {
            paths.push(path);
            continue;
          }
          if (metadata.hasEmbeddedWithPropertyPath(path)) {
            const subPaths = this.createPropertyPath(metadata, entity[key], path);
            paths.push(...subPaths);
            continue;
          }
          if (metadata.hasRelationWithPropertyPath(path)) {
            const relation = metadata.findRelationWithPropertyPath(path);
            if (relation.relationType === "one-to-one" || relation.relationType === "many-to-one") {
              const joinColumns = relation.joinColumns.map((j) => j.referencedColumn).filter((j) => !!j);
              const hasAllJoinColumns = joinColumns.length > 0 && joinColumns.every((column) => column.getEntityValue(entity[key], false));
              if (hasAllJoinColumns) {
                paths.push(path);
                continue;
              }
            }
            if (relation.relationType === "one-to-many" || relation.relationType === "many-to-many") {
              throw new Error(`Cannot query across ${relation.relationType} for property ${path}`);
            }
            const primaryColumns = relation.inverseEntityMetadata.primaryColumns;
            const hasAllPrimaryKeys = primaryColumns.length > 0 && primaryColumns.every((column) => column.getEntityValue(entity[key], false));
            if (hasAllPrimaryKeys) {
              const subPaths2 = primaryColumns.map((column) => `${path}.${column.propertyPath}`);
              paths.push(...subPaths2);
              continue;
            }
            const subPaths = this.createPropertyPath(relation.inverseEntityMetadata, entity[key]).map((p) => `${path}.${p}`);
            paths.push(...subPaths);
            continue;
          }
          paths.push(path);
        }
        return paths;
      }
      *getPredicates(where) {
        if (this.expressionMap.mainAlias.hasMetadata) {
          const propertyPaths = this.createPropertyPath(this.expressionMap.mainAlias.metadata, where);
          for (const propertyPath of propertyPaths) {
            const [alias, aliasPropertyPath, columns] = this.findColumnsForPropertyPath(propertyPath);
            for (const column of columns) {
              let containedWhere = where;
              for (const part of aliasPropertyPath) {
                if (!containedWhere || !(part in containedWhere)) {
                  containedWhere = {};
                  break;
                }
                containedWhere = containedWhere[part];
              }
              const aliasPath = this.expressionMap.aliasNamePrefixingEnabled ? `${alias.name}.${column.propertyPath}` : column.propertyPath;
              const parameterValue = column.getEntityValue(containedWhere, true);
              yield [aliasPath, parameterValue];
            }
          }
        } else {
          for (const key of Object.keys(where)) {
            const parameterValue = where[key];
            const aliasPath = this.expressionMap.aliasNamePrefixingEnabled ? `${this.alias}.${key}` : key;
            yield [aliasPath, parameterValue];
          }
        }
      }
      getWherePredicateCondition(aliasPath, parameterValue) {
        if (InstanceChecker_1.InstanceChecker.isFindOperator(parameterValue)) {
          const parameters = [];
          if (parameterValue.useParameter) {
            if (parameterValue.objectLiteralParameters) {
              this.setParameters(parameterValue.objectLiteralParameters);
            } else if (parameterValue.multipleParameters) {
              for (const v of parameterValue.value) {
                parameters.push(this.createParameter(v));
              }
            } else {
              parameters.push(this.createParameter(parameterValue.value));
            }
          }
          if (parameterValue.type === "raw") {
            if (parameterValue.getSql) {
              return parameterValue.getSql(aliasPath);
            } else {
              return {
                operator: "equal",
                parameters: [aliasPath, parameterValue.value]
              };
            }
          } else if (parameterValue.type === "not") {
            if (parameterValue.child) {
              return {
                operator: parameterValue.type,
                condition: this.getWherePredicateCondition(aliasPath, parameterValue.child)
              };
            } else {
              return {
                operator: "notEqual",
                parameters: [aliasPath, ...parameters]
              };
            }
          } else if (parameterValue.type === "and") {
            const values = parameterValue.value;
            return {
              operator: parameterValue.type,
              parameters: values.map((operator) => this.createWhereConditionExpression(this.getWherePredicateCondition(aliasPath, operator)))
            };
          } else if (parameterValue.type === "or") {
            const values = parameterValue.value;
            return {
              operator: parameterValue.type,
              parameters: values.map((operator) => this.createWhereConditionExpression(this.getWherePredicateCondition(aliasPath, operator)))
            };
          } else {
            return {
              operator: parameterValue.type,
              parameters: [aliasPath, ...parameters]
            };
          }
        } else {
          return {
            operator: "equal",
            parameters: [aliasPath, this.createParameter(parameterValue)]
          };
        }
      }
      getWhereCondition(where) {
        if (typeof where === "string") {
          return where;
        }
        if (InstanceChecker_1.InstanceChecker.isBrackets(where)) {
          const whereQueryBuilder = this.createQueryBuilder();
          whereQueryBuilder.parentQueryBuilder = this;
          whereQueryBuilder.expressionMap.mainAlias = this.expressionMap.mainAlias;
          whereQueryBuilder.expressionMap.aliasNamePrefixingEnabled = this.expressionMap.aliasNamePrefixingEnabled;
          whereQueryBuilder.expressionMap.parameters = this.expressionMap.parameters;
          whereQueryBuilder.expressionMap.nativeParameters = this.expressionMap.nativeParameters;
          whereQueryBuilder.expressionMap.wheres = [];
          where.whereFactory(whereQueryBuilder);
          return {
            operator: InstanceChecker_1.InstanceChecker.isNotBrackets(where) ? "not" : "brackets",
            condition: whereQueryBuilder.expressionMap.wheres
          };
        }
        if (typeof where === "function") {
          return where(this);
        }
        const wheres = Array.isArray(where) ? where : [where];
        const clauses = [];
        for (const where2 of wheres) {
          const conditions = [];
          for (const [aliasPath, parameterValue] of this.getPredicates(where2)) {
            conditions.push({
              type: "and",
              condition: this.getWherePredicateCondition(aliasPath, parameterValue)
            });
          }
          clauses.push({ type: "or", condition: conditions });
        }
        if (clauses.length === 1) {
          return clauses[0].condition;
        }
        return clauses;
      }
      /**
       * Creates a query builder used to execute sql queries inside this query builder.
       */
      obtainQueryRunner() {
        return this.queryRunner || this.connection.createQueryRunner();
      }
      hasCommonTableExpressions() {
        return this.expressionMap.commonTableExpressions.length > 0;
      }
    };
    exports2.QueryBuilder = QueryBuilder2;
    QueryBuilder2.queryBuilderRegistry = {};
  }
});

// node_modules/typeorm/query-builder/result/DeleteResult.js
var require_DeleteResult = __commonJS({
  "node_modules/typeorm/query-builder/result/DeleteResult.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeleteResult = void 0;
    var DeleteResult2 = class {
      static from(queryResult) {
        const result = new this();
        result.raw = queryResult.records;
        result.affected = queryResult.affected;
        return result;
      }
    };
    exports2.DeleteResult = DeleteResult2;
  }
});

// node_modules/typeorm/query-builder/DeleteQueryBuilder.js
var require_DeleteQueryBuilder = __commonJS({
  "node_modules/typeorm/query-builder/DeleteQueryBuilder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeleteQueryBuilder = void 0;
    var QueryBuilder_1 = require_QueryBuilder();
    var DeleteResult_1 = require_DeleteResult();
    var ReturningStatementNotSupportedError_1 = require_ReturningStatementNotSupportedError();
    var InstanceChecker_1 = require_InstanceChecker();
    var DeleteQueryBuilder2 = class extends QueryBuilder_1.QueryBuilder {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connectionOrQueryBuilder, queryRunner) {
        super(connectionOrQueryBuilder, queryRunner);
        this["@instanceof"] = Symbol.for("DeleteQueryBuilder");
        this.expressionMap.aliasNamePrefixingEnabled = false;
      }
      // -------------------------------------------------------------------------
      // Public Implemented Methods
      // -------------------------------------------------------------------------
      /**
       * Gets generated SQL query without parameters being replaced.
       */
      getQuery() {
        let sql = this.createComment();
        sql += this.createCteExpression();
        sql += this.createDeleteExpression();
        return this.replacePropertyNamesForTheWholeQuery(sql.trim());
      }
      /**
       * Executes sql generated by query builder and returns raw database results.
       */
      async execute() {
        const [sql, parameters] = this.getQueryAndParameters();
        const queryRunner = this.obtainQueryRunner();
        let transactionStartedByUs = false;
        try {
          if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {
            await queryRunner.startTransaction();
            transactionStartedByUs = true;
          }
          if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {
            await queryRunner.broadcaster.broadcast("BeforeRemove", this.expressionMap.mainAlias.metadata);
          }
          const queryResult = await queryRunner.query(sql, parameters, true);
          const deleteResult = DeleteResult_1.DeleteResult.from(queryResult);
          if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {
            await queryRunner.broadcaster.broadcast("AfterRemove", this.expressionMap.mainAlias.metadata);
          }
          if (transactionStartedByUs)
            await queryRunner.commitTransaction();
          return deleteResult;
        } catch (error) {
          if (transactionStartedByUs) {
            try {
              await queryRunner.rollbackTransaction();
            } catch (rollbackError) {
            }
          }
          throw error;
        } finally {
          if (queryRunner !== this.queryRunner) {
            await queryRunner.release();
          }
        }
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Specifies FROM which entity's table select/update/delete will be executed.
       * Also sets a main string alias of the selection data.
       */
      from(entityTarget, aliasName) {
        entityTarget = InstanceChecker_1.InstanceChecker.isEntitySchema(entityTarget) ? entityTarget.options.name : entityTarget;
        const mainAlias = this.createFromAlias(entityTarget, aliasName);
        this.expressionMap.setMainAlias(mainAlias);
        return this;
      }
      /**
       * Sets WHERE condition in the query builder.
       * If you had previously WHERE expression defined,
       * calling this function will override previously set WHERE conditions.
       * Additionally you can add parameters used in where expression.
       */
      where(where, parameters) {
        this.expressionMap.wheres = [];
        const condition = this.getWhereCondition(where);
        if (condition)
          this.expressionMap.wheres = [
            { type: "simple", condition }
          ];
        if (parameters)
          this.setParameters(parameters);
        return this;
      }
      /**
       * Adds new AND WHERE condition in the query builder.
       * Additionally you can add parameters used in where expression.
       */
      andWhere(where, parameters) {
        this.expressionMap.wheres.push({
          type: "and",
          condition: this.getWhereCondition(where)
        });
        if (parameters)
          this.setParameters(parameters);
        return this;
      }
      /**
       * Adds new OR WHERE condition in the query builder.
       * Additionally you can add parameters used in where expression.
       */
      orWhere(where, parameters) {
        this.expressionMap.wheres.push({
          type: "or",
          condition: this.getWhereCondition(where)
        });
        if (parameters)
          this.setParameters(parameters);
        return this;
      }
      /**
       * Sets WHERE condition in the query builder with a condition for the given ids.
       * If you had previously WHERE expression defined,
       * calling this function will override previously set WHERE conditions.
       */
      whereInIds(ids) {
        return this.where(this.getWhereInIdsCondition(ids));
      }
      /**
       * Adds new AND WHERE with conditions for the given ids.
       */
      andWhereInIds(ids) {
        return this.andWhere(this.getWhereInIdsCondition(ids));
      }
      /**
       * Adds new OR WHERE with conditions for the given ids.
       */
      orWhereInIds(ids) {
        return this.orWhere(this.getWhereInIdsCondition(ids));
      }
      /**
       * Optional returning/output clause.
       */
      output(output) {
        return this.returning(output);
      }
      /**
       * Optional returning/output clause.
       */
      returning(returning) {
        if (!this.connection.driver.isReturningSqlSupported("delete")) {
          throw new ReturningStatementNotSupportedError_1.ReturningStatementNotSupportedError();
        }
        this.expressionMap.returning = returning;
        return this;
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Creates DELETE express used to perform query.
       */
      createDeleteExpression() {
        const tableName = this.getTableName(this.getMainTableName());
        const whereExpression = this.createWhereExpression();
        const returningExpression = this.createReturningExpression("delete");
        if (returningExpression === "") {
          return `DELETE FROM ${tableName}${whereExpression}`;
        }
        if (this.connection.driver.options.type === "mssql") {
          return `DELETE FROM ${tableName} OUTPUT ${returningExpression}${whereExpression}`;
        }
        if (this.connection.driver.options.type === "spanner") {
          return `DELETE FROM ${tableName}${whereExpression} THEN RETURN ${returningExpression}`;
        }
        return `DELETE FROM ${tableName}${whereExpression} RETURNING ${returningExpression}`;
      }
    };
    exports2.DeleteQueryBuilder = DeleteQueryBuilder2;
  }
});

// node_modules/typeorm/node_modules/uuid/dist/cjs/max.js
var require_max2 = __commonJS({
  "node_modules/typeorm/node_modules/uuid/dist/cjs/max.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = "ffffffff-ffff-ffff-ffff-ffffffffffff";
  }
});

// node_modules/typeorm/node_modules/uuid/dist/cjs/nil.js
var require_nil = __commonJS({
  "node_modules/typeorm/node_modules/uuid/dist/cjs/nil.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = "00000000-0000-0000-0000-000000000000";
  }
});

// node_modules/typeorm/node_modules/uuid/dist/cjs/regex.js
var require_regex = __commonJS({
  "node_modules/typeorm/node_modules/uuid/dist/cjs/regex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
  }
});

// node_modules/typeorm/node_modules/uuid/dist/cjs/validate.js
var require_validate = __commonJS({
  "node_modules/typeorm/node_modules/uuid/dist/cjs/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var regex_js_1 = require_regex();
    function validate(uuid) {
      return typeof uuid === "string" && regex_js_1.default.test(uuid);
    }
    exports2.default = validate;
  }
});

// node_modules/typeorm/node_modules/uuid/dist/cjs/parse.js
var require_parse = __commonJS({
  "node_modules/typeorm/node_modules/uuid/dist/cjs/parse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var validate_js_1 = require_validate();
    function parse(uuid) {
      if (!(0, validate_js_1.default)(uuid)) {
        throw TypeError("Invalid UUID");
      }
      let v;
      return Uint8Array.of((v = parseInt(uuid.slice(0, 8), 16)) >>> 24, v >>> 16 & 255, v >>> 8 & 255, v & 255, (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255, v / 4294967296 & 255, v >>> 24 & 255, v >>> 16 & 255, v >>> 8 & 255, v & 255);
    }
    exports2.default = parse;
  }
});

// node_modules/typeorm/node_modules/uuid/dist/cjs/stringify.js
var require_stringify = __commonJS({
  "node_modules/typeorm/node_modules/uuid/dist/cjs/stringify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unsafeStringify = void 0;
    var validate_js_1 = require_validate();
    var byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).slice(1));
    }
    function unsafeStringify(arr, offset = 0) {
      return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    }
    exports2.unsafeStringify = unsafeStringify;
    function stringify(arr, offset = 0) {
      const uuid = unsafeStringify(arr, offset);
      if (!(0, validate_js_1.default)(uuid)) {
        throw TypeError("Stringified UUID is invalid");
      }
      return uuid;
    }
    exports2.default = stringify;
  }
});

// node_modules/typeorm/node_modules/uuid/dist/cjs/rng.js
var require_rng = __commonJS({
  "node_modules/typeorm/node_modules/uuid/dist/cjs/rng.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto_1 = require("crypto");
    var rnds8Pool = new Uint8Array(256);
    var poolPtr = rnds8Pool.length;
    function rng() {
      if (poolPtr > rnds8Pool.length - 16) {
        (0, crypto_1.randomFillSync)(rnds8Pool);
        poolPtr = 0;
      }
      return rnds8Pool.slice(poolPtr, poolPtr += 16);
    }
    exports2.default = rng;
  }
});

// node_modules/typeorm/node_modules/uuid/dist/cjs/v1.js
var require_v1 = __commonJS({
  "node_modules/typeorm/node_modules/uuid/dist/cjs/v1.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.updateV1State = void 0;
    var rng_js_1 = require_rng();
    var stringify_js_1 = require_stringify();
    var _state = {};
    function v1(options, buf, offset) {
      let bytes;
      const isV6 = options?._v6 ?? false;
      if (options) {
        const optionsKeys = Object.keys(options);
        if (optionsKeys.length === 1 && optionsKeys[0] === "_v6") {
          options = void 0;
        }
      }
      if (options) {
        bytes = v1Bytes(options.random ?? options.rng?.() ?? (0, rng_js_1.default)(), options.msecs, options.nsecs, options.clockseq, options.node, buf, offset);
      } else {
        const now = Date.now();
        const rnds = (0, rng_js_1.default)();
        updateV1State(_state, now, rnds);
        bytes = v1Bytes(rnds, _state.msecs, _state.nsecs, isV6 ? void 0 : _state.clockseq, isV6 ? void 0 : _state.node, buf, offset);
      }
      return buf ?? (0, stringify_js_1.unsafeStringify)(bytes);
    }
    function updateV1State(state, now, rnds) {
      state.msecs ?? (state.msecs = -Infinity);
      state.nsecs ?? (state.nsecs = 0);
      if (now === state.msecs) {
        state.nsecs++;
        if (state.nsecs >= 1e4) {
          state.node = void 0;
          state.nsecs = 0;
        }
      } else if (now > state.msecs) {
        state.nsecs = 0;
      } else if (now < state.msecs) {
        state.node = void 0;
      }
      if (!state.node) {
        state.node = rnds.slice(10, 16);
        state.node[0] |= 1;
        state.clockseq = (rnds[8] << 8 | rnds[9]) & 16383;
      }
      state.msecs = now;
      return state;
    }
    exports2.updateV1State = updateV1State;
    function v1Bytes(rnds, msecs, nsecs, clockseq, node, buf, offset = 0) {
      if (rnds.length < 16) {
        throw new Error("Random bytes length must be >= 16");
      }
      if (!buf) {
        buf = new Uint8Array(16);
        offset = 0;
      } else {
        if (offset < 0 || offset + 16 > buf.length) {
          throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
        }
      }
      msecs ?? (msecs = Date.now());
      nsecs ?? (nsecs = 0);
      clockseq ?? (clockseq = (rnds[8] << 8 | rnds[9]) & 16383);
      node ?? (node = rnds.slice(10, 16));
      msecs += 122192928e5;
      const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      buf[offset++] = tl >>> 24 & 255;
      buf[offset++] = tl >>> 16 & 255;
      buf[offset++] = tl >>> 8 & 255;
      buf[offset++] = tl & 255;
      const tmh = msecs / 4294967296 * 1e4 & 268435455;
      buf[offset++] = tmh >>> 8 & 255;
      buf[offset++] = tmh & 255;
      buf[offset++] = tmh >>> 24 & 15 | 16;
      buf[offset++] = tmh >>> 16 & 255;
      buf[offset++] = clockseq >>> 8 | 128;
      buf[offset++] = clockseq & 255;
      for (let n = 0; n < 6; ++n) {
        buf[offset++] = node[n];
      }
      return buf;
    }
    exports2.default = v1;
  }
});

// node_modules/typeorm/node_modules/uuid/dist/cjs/v1ToV6.js
var require_v1ToV6 = __commonJS({
  "node_modules/typeorm/node_modules/uuid/dist/cjs/v1ToV6.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var parse_js_1 = require_parse();
    var stringify_js_1 = require_stringify();
    function v1ToV6(uuid) {
      const v1Bytes = typeof uuid === "string" ? (0, parse_js_1.default)(uuid) : uuid;
      const v6Bytes = _v1ToV6(v1Bytes);
      return typeof uuid === "string" ? (0, stringify_js_1.unsafeStringify)(v6Bytes) : v6Bytes;
    }
    exports2.default = v1ToV6;
    function _v1ToV6(v1Bytes) {
      return Uint8Array.of((v1Bytes[6] & 15) << 4 | v1Bytes[7] >> 4 & 15, (v1Bytes[7] & 15) << 4 | (v1Bytes[4] & 240) >> 4, (v1Bytes[4] & 15) << 4 | (v1Bytes[5] & 240) >> 4, (v1Bytes[5] & 15) << 4 | (v1Bytes[0] & 240) >> 4, (v1Bytes[0] & 15) << 4 | (v1Bytes[1] & 240) >> 4, (v1Bytes[1] & 15) << 4 | (v1Bytes[2] & 240) >> 4, 96 | v1Bytes[2] & 15, v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);
    }
  }
});

// node_modules/typeorm/node_modules/uuid/dist/cjs/md5.js
var require_md5 = __commonJS({
  "node_modules/typeorm/node_modules/uuid/dist/cjs/md5.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto_1 = require("crypto");
    function md5(bytes) {
      if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
      } else if (typeof bytes === "string") {
        bytes = Buffer.from(bytes, "utf8");
      }
      return (0, crypto_1.createHash)("md5").update(bytes).digest();
    }
    exports2.default = md5;
  }
});

// node_modules/typeorm/node_modules/uuid/dist/cjs/v35.js
var require_v35 = __commonJS({
  "node_modules/typeorm/node_modules/uuid/dist/cjs/v35.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.URL = exports2.DNS = exports2.stringToBytes = void 0;
    var parse_js_1 = require_parse();
    var stringify_js_1 = require_stringify();
    function stringToBytes(str) {
      str = unescape(encodeURIComponent(str));
      const bytes = new Uint8Array(str.length);
      for (let i = 0; i < str.length; ++i) {
        bytes[i] = str.charCodeAt(i);
      }
      return bytes;
    }
    exports2.stringToBytes = stringToBytes;
    exports2.DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    exports2.URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    function v35(version, hash, value, namespace, buf, offset) {
      const valueBytes = typeof value === "string" ? stringToBytes(value) : value;
      const namespaceBytes = typeof namespace === "string" ? (0, parse_js_1.default)(namespace) : namespace;
      if (typeof namespace === "string") {
        namespace = (0, parse_js_1.default)(namespace);
      }
      if (namespace?.length !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      let bytes = new Uint8Array(16 + valueBytes.length);
      bytes.set(namespaceBytes);
      bytes.set(valueBytes, namespaceBytes.length);
      bytes = hash(bytes);
      bytes[6] = bytes[6] & 15 | version;
      bytes[8] = bytes[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0; i < 16; ++i) {
          buf[offset + i] = bytes[i];
        }
        return buf;
      }
      return (0, stringify_js_1.unsafeStringify)(bytes);
    }
    exports2.default = v35;
  }
});

// node_modules/typeorm/node_modules/uuid/dist/cjs/v3.js
var require_v3 = __commonJS({
  "node_modules/typeorm/node_modules/uuid/dist/cjs/v3.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.URL = exports2.DNS = void 0;
    var md5_js_1 = require_md5();
    var v35_js_1 = require_v35();
    var v35_js_2 = require_v35();
    Object.defineProperty(exports2, "DNS", { enumerable: true, get: function() {
      return v35_js_2.DNS;
    } });
    Object.defineProperty(exports2, "URL", { enumerable: true, get: function() {
      return v35_js_2.URL;
    } });
    function v3(value, namespace, buf, offset) {
      return (0, v35_js_1.default)(48, md5_js_1.default, value, namespace, buf, offset);
    }
    v3.DNS = v35_js_1.DNS;
    v3.URL = v35_js_1.URL;
    exports2.default = v3;
  }
});

// node_modules/typeorm/node_modules/uuid/dist/cjs/native.js
var require_native2 = __commonJS({
  "node_modules/typeorm/node_modules/uuid/dist/cjs/native.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto_1 = require("crypto");
    exports2.default = { randomUUID: crypto_1.randomUUID };
  }
});

// node_modules/typeorm/node_modules/uuid/dist/cjs/v4.js
var require_v4 = __commonJS({
  "node_modules/typeorm/node_modules/uuid/dist/cjs/v4.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var native_js_1 = require_native2();
    var rng_js_1 = require_rng();
    var stringify_js_1 = require_stringify();
    function v4(options, buf, offset) {
      if (native_js_1.default.randomUUID && !buf && !options) {
        return native_js_1.default.randomUUID();
      }
      options = options || {};
      const rnds = options.random ?? options.rng?.() ?? (0, rng_js_1.default)();
      if (rnds.length < 16) {
        throw new Error("Random bytes length must be >= 16");
      }
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        if (offset < 0 || offset + 16 > buf.length) {
          throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
        }
        for (let i = 0; i < 16; ++i) {
          buf[offset + i] = rnds[i];
        }
        return buf;
      }
      return (0, stringify_js_1.unsafeStringify)(rnds);
    }
    exports2.default = v4;
  }
});

// node_modules/typeorm/node_modules/uuid/dist/cjs/sha1.js
var require_sha12 = __commonJS({
  "node_modules/typeorm/node_modules/uuid/dist/cjs/sha1.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto_1 = require("crypto");
    function sha1(bytes) {
      if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
      } else if (typeof bytes === "string") {
        bytes = Buffer.from(bytes, "utf8");
      }
      return (0, crypto_1.createHash)("sha1").update(bytes).digest();
    }
    exports2.default = sha1;
  }
});

// node_modules/typeorm/node_modules/uuid/dist/cjs/v5.js
var require_v5 = __commonJS({
  "node_modules/typeorm/node_modules/uuid/dist/cjs/v5.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.URL = exports2.DNS = void 0;
    var sha1_js_1 = require_sha12();
    var v35_js_1 = require_v35();
    var v35_js_2 = require_v35();
    Object.defineProperty(exports2, "DNS", { enumerable: true, get: function() {
      return v35_js_2.DNS;
    } });
    Object.defineProperty(exports2, "URL", { enumerable: true, get: function() {
      return v35_js_2.URL;
    } });
    function v5(value, namespace, buf, offset) {
      return (0, v35_js_1.default)(80, sha1_js_1.default, value, namespace, buf, offset);
    }
    v5.DNS = v35_js_1.DNS;
    v5.URL = v35_js_1.URL;
    exports2.default = v5;
  }
});

// node_modules/typeorm/node_modules/uuid/dist/cjs/v6.js
var require_v6 = __commonJS({
  "node_modules/typeorm/node_modules/uuid/dist/cjs/v6.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var stringify_js_1 = require_stringify();
    var v1_js_1 = require_v1();
    var v1ToV6_js_1 = require_v1ToV6();
    function v6(options, buf, offset) {
      options ?? (options = {});
      offset ?? (offset = 0);
      let bytes = (0, v1_js_1.default)({ ...options, _v6: true }, new Uint8Array(16));
      bytes = (0, v1ToV6_js_1.default)(bytes);
      if (buf) {
        for (let i = 0; i < 16; i++) {
          buf[offset + i] = bytes[i];
        }
        return buf;
      }
      return (0, stringify_js_1.unsafeStringify)(bytes);
    }
    exports2.default = v6;
  }
});

// node_modules/typeorm/node_modules/uuid/dist/cjs/v6ToV1.js
var require_v6ToV1 = __commonJS({
  "node_modules/typeorm/node_modules/uuid/dist/cjs/v6ToV1.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var parse_js_1 = require_parse();
    var stringify_js_1 = require_stringify();
    function v6ToV1(uuid) {
      const v6Bytes = typeof uuid === "string" ? (0, parse_js_1.default)(uuid) : uuid;
      const v1Bytes = _v6ToV1(v6Bytes);
      return typeof uuid === "string" ? (0, stringify_js_1.unsafeStringify)(v1Bytes) : v1Bytes;
    }
    exports2.default = v6ToV1;
    function _v6ToV1(v6Bytes) {
      return Uint8Array.of((v6Bytes[3] & 15) << 4 | v6Bytes[4] >> 4 & 15, (v6Bytes[4] & 15) << 4 | (v6Bytes[5] & 240) >> 4, (v6Bytes[5] & 15) << 4 | v6Bytes[6] & 15, v6Bytes[7], (v6Bytes[1] & 15) << 4 | (v6Bytes[2] & 240) >> 4, (v6Bytes[2] & 15) << 4 | (v6Bytes[3] & 240) >> 4, 16 | (v6Bytes[0] & 240) >> 4, (v6Bytes[0] & 15) << 4 | (v6Bytes[1] & 240) >> 4, v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);
    }
  }
});

// node_modules/typeorm/node_modules/uuid/dist/cjs/v7.js
var require_v7 = __commonJS({
  "node_modules/typeorm/node_modules/uuid/dist/cjs/v7.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.updateV7State = void 0;
    var rng_js_1 = require_rng();
    var stringify_js_1 = require_stringify();
    var _state = {};
    function v7(options, buf, offset) {
      let bytes;
      if (options) {
        bytes = v7Bytes(options.random ?? options.rng?.() ?? (0, rng_js_1.default)(), options.msecs, options.seq, buf, offset);
      } else {
        const now = Date.now();
        const rnds = (0, rng_js_1.default)();
        updateV7State(_state, now, rnds);
        bytes = v7Bytes(rnds, _state.msecs, _state.seq, buf, offset);
      }
      return buf ?? (0, stringify_js_1.unsafeStringify)(bytes);
    }
    function updateV7State(state, now, rnds) {
      state.msecs ?? (state.msecs = -Infinity);
      state.seq ?? (state.seq = 0);
      if (now > state.msecs) {
        state.seq = rnds[6] << 23 | rnds[7] << 16 | rnds[8] << 8 | rnds[9];
        state.msecs = now;
      } else {
        state.seq = state.seq + 1 | 0;
        if (state.seq === 0) {
          state.msecs++;
        }
      }
      return state;
    }
    exports2.updateV7State = updateV7State;
    function v7Bytes(rnds, msecs, seq, buf, offset = 0) {
      if (rnds.length < 16) {
        throw new Error("Random bytes length must be >= 16");
      }
      if (!buf) {
        buf = new Uint8Array(16);
        offset = 0;
      } else {
        if (offset < 0 || offset + 16 > buf.length) {
          throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
        }
      }
      msecs ?? (msecs = Date.now());
      seq ?? (seq = rnds[6] * 127 << 24 | rnds[7] << 16 | rnds[8] << 8 | rnds[9]);
      buf[offset++] = msecs / 1099511627776 & 255;
      buf[offset++] = msecs / 4294967296 & 255;
      buf[offset++] = msecs / 16777216 & 255;
      buf[offset++] = msecs / 65536 & 255;
      buf[offset++] = msecs / 256 & 255;
      buf[offset++] = msecs & 255;
      buf[offset++] = 112 | seq >>> 28 & 15;
      buf[offset++] = seq >>> 20 & 255;
      buf[offset++] = 128 | seq >>> 14 & 63;
      buf[offset++] = seq >>> 6 & 255;
      buf[offset++] = seq << 2 & 255 | rnds[10] & 3;
      buf[offset++] = rnds[11];
      buf[offset++] = rnds[12];
      buf[offset++] = rnds[13];
      buf[offset++] = rnds[14];
      buf[offset++] = rnds[15];
      return buf;
    }
    exports2.default = v7;
  }
});

// node_modules/typeorm/node_modules/uuid/dist/cjs/version.js
var require_version = __commonJS({
  "node_modules/typeorm/node_modules/uuid/dist/cjs/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var validate_js_1 = require_validate();
    function version(uuid) {
      if (!(0, validate_js_1.default)(uuid)) {
        throw TypeError("Invalid UUID");
      }
      return parseInt(uuid.slice(14, 15), 16);
    }
    exports2.default = version;
  }
});

// node_modules/typeorm/node_modules/uuid/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/typeorm/node_modules/uuid/dist/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.version = exports2.validate = exports2.v7 = exports2.v6ToV1 = exports2.v6 = exports2.v5 = exports2.v4 = exports2.v3 = exports2.v1ToV6 = exports2.v1 = exports2.stringify = exports2.parse = exports2.NIL = exports2.MAX = void 0;
    var max_js_1 = require_max2();
    Object.defineProperty(exports2, "MAX", { enumerable: true, get: function() {
      return max_js_1.default;
    } });
    var nil_js_1 = require_nil();
    Object.defineProperty(exports2, "NIL", { enumerable: true, get: function() {
      return nil_js_1.default;
    } });
    var parse_js_1 = require_parse();
    Object.defineProperty(exports2, "parse", { enumerable: true, get: function() {
      return parse_js_1.default;
    } });
    var stringify_js_1 = require_stringify();
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return stringify_js_1.default;
    } });
    var v1_js_1 = require_v1();
    Object.defineProperty(exports2, "v1", { enumerable: true, get: function() {
      return v1_js_1.default;
    } });
    var v1ToV6_js_1 = require_v1ToV6();
    Object.defineProperty(exports2, "v1ToV6", { enumerable: true, get: function() {
      return v1ToV6_js_1.default;
    } });
    var v3_js_1 = require_v3();
    Object.defineProperty(exports2, "v3", { enumerable: true, get: function() {
      return v3_js_1.default;
    } });
    var v4_js_1 = require_v4();
    Object.defineProperty(exports2, "v4", { enumerable: true, get: function() {
      return v4_js_1.default;
    } });
    var v5_js_1 = require_v5();
    Object.defineProperty(exports2, "v5", { enumerable: true, get: function() {
      return v5_js_1.default;
    } });
    var v6_js_1 = require_v6();
    Object.defineProperty(exports2, "v6", { enumerable: true, get: function() {
      return v6_js_1.default;
    } });
    var v6ToV1_js_1 = require_v6ToV1();
    Object.defineProperty(exports2, "v6ToV1", { enumerable: true, get: function() {
      return v6ToV1_js_1.default;
    } });
    var v7_js_1 = require_v7();
    Object.defineProperty(exports2, "v7", { enumerable: true, get: function() {
      return v7_js_1.default;
    } });
    var validate_js_1 = require_validate();
    Object.defineProperty(exports2, "validate", { enumerable: true, get: function() {
      return validate_js_1.default;
    } });
    var version_js_1 = require_version();
    Object.defineProperty(exports2, "version", { enumerable: true, get: function() {
      return version_js_1.default;
    } });
  }
});

// node_modules/typeorm/subscriber/BroadcasterResult.js
var require_BroadcasterResult = __commonJS({
  "node_modules/typeorm/subscriber/BroadcasterResult.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BroadcasterResult = void 0;
    var BroadcasterResult = class {
      constructor() {
        this.count = 0;
        this.promises = [];
      }
      /**
       * Wait for all promises to settle
       */
      async wait() {
        if (this.promises.length > 0) {
          await Promise.all(this.promises);
        }
        return this;
      }
    };
    exports2.BroadcasterResult = BroadcasterResult;
  }
});

// node_modules/typeorm/query-builder/result/InsertResult.js
var require_InsertResult = __commonJS({
  "node_modules/typeorm/query-builder/result/InsertResult.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InsertResult = void 0;
    var InsertResult2 = class {
      constructor() {
        this.identifiers = [];
        this.generatedMaps = [];
      }
      static from(queryResult) {
        const result = new this();
        result.raw = queryResult.raw;
        return result;
      }
    };
    exports2.InsertResult = InsertResult2;
  }
});

// node_modules/typeorm/query-builder/ReturningResultsEntityUpdator.js
var require_ReturningResultsEntityUpdator = __commonJS({
  "node_modules/typeorm/query-builder/ReturningResultsEntityUpdator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReturningResultsEntityUpdator = void 0;
    var error_1 = require_error();
    var ReturningResultsEntityUpdator = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(queryRunner, expressionMap) {
        this.queryRunner = queryRunner;
        this.expressionMap = expressionMap;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Updates entities with a special columns after updation query execution.
       */
      async update(updateResult, entities) {
        const metadata = this.expressionMap.mainAlias.metadata;
        await Promise.all(entities.map(async (entity, entityIndex) => {
          if (this.queryRunner.connection.driver.isReturningSqlSupported("update")) {
            if (this.queryRunner.connection.driver.options.type === "oracle" && Array.isArray(updateResult.raw) && this.expressionMap.extraReturningColumns.length > 0) {
              updateResult.raw = updateResult.raw.reduce((newRaw, rawItem, rawItemIndex) => {
                newRaw[this.expressionMap.extraReturningColumns[rawItemIndex].databaseName] = rawItem[0];
                return newRaw;
              }, {});
            }
            const result = Array.isArray(updateResult.raw) ? updateResult.raw[entityIndex] : updateResult.raw;
            const returningColumns = this.queryRunner.connection.driver.createGeneratedMap(metadata, result);
            if (returningColumns) {
              this.queryRunner.manager.merge(metadata.target, entity, returningColumns);
              updateResult.generatedMaps.push(returningColumns);
            }
          } else {
            const updationColumns = this.expressionMap.extraReturningColumns;
            if (updationColumns.length > 0) {
              const entityId = this.expressionMap.mainAlias.metadata.getEntityIdMap(entity);
              if (!entityId)
                throw new error_1.TypeORMError(`Cannot update entity because entity id is not set in the entity.`);
              const loadedReturningColumns = await this.queryRunner.manager.createQueryBuilder().select(metadata.primaryColumns.map((column) => metadata.targetName + "." + column.propertyPath)).addSelect(updationColumns.map((column) => metadata.targetName + "." + column.propertyPath)).from(metadata.target, metadata.targetName).where(entityId).withDeleted().setOption("create-pojo").getOne();
              if (loadedReturningColumns) {
                this.queryRunner.manager.merge(metadata.target, entity, loadedReturningColumns);
                updateResult.generatedMaps.push(loadedReturningColumns);
              }
            }
          }
        }));
      }
      /**
       * Updates entities with a special columns after insertion query execution.
       */
      async insert(insertResult, entities) {
        const metadata = this.expressionMap.mainAlias.metadata;
        let insertionColumns = metadata.getInsertionReturningColumns();
        const needToCheckGenerated = this.queryRunner.connection.driver.isReturningSqlSupported("insert");
        insertionColumns = insertionColumns.filter((column) => {
          if (!column.isGenerated)
            return true;
          return needToCheckGenerated === true;
        });
        const generatedMaps = entities.map((entity, entityIndex) => {
          if (Array.isArray(insertResult.raw) && this.expressionMap.extraReturningColumns.length > 0) {
            if (this.queryRunner.connection.driver.options.type === "oracle") {
              insertResult.raw = insertResult.raw.reduce((newRaw, rawItem, rawItemIndex) => {
                newRaw[this.expressionMap.extraReturningColumns[rawItemIndex].databaseName] = rawItem[0];
                return newRaw;
              }, {});
            } else if (this.queryRunner.connection.driver.options.type === "spanner") {
              insertResult.raw = insertResult.raw[0];
            }
          }
          const result = Array.isArray(insertResult.raw) ? insertResult.raw[entityIndex] : insertResult.raw;
          const generatedMap = this.queryRunner.connection.driver.createGeneratedMap(metadata, result, entityIndex, entities.length) || {};
          if (entityIndex in this.expressionMap.locallyGenerated) {
            this.queryRunner.manager.merge(metadata.target, generatedMap, this.expressionMap.locallyGenerated[entityIndex]);
          }
          this.queryRunner.manager.merge(metadata.target, entity, generatedMap);
          return generatedMap;
        });
        if (insertionColumns.length > 0 && !this.queryRunner.connection.driver.isReturningSqlSupported("insert")) {
          const entityIds = entities.map((entity) => {
            const entityId = metadata.getEntityIdMap(entity);
            if (!entityId)
              throw new error_1.TypeORMError(`Cannot update entity because entity id is not set in the entity.`);
            return entityId;
          });
          const returningResult = await this.queryRunner.manager.createQueryBuilder().select(metadata.primaryColumns.map((column) => metadata.targetName + "." + column.propertyPath)).addSelect(insertionColumns.map((column) => metadata.targetName + "." + column.propertyPath)).from(metadata.target, metadata.targetName).where(entityIds).setOption("create-pojo").getMany();
          entities.forEach((entity, entityIndex) => {
            this.queryRunner.manager.merge(metadata.target, generatedMaps[entityIndex], returningResult[entityIndex]);
            this.queryRunner.manager.merge(metadata.target, entity, returningResult[entityIndex]);
          });
        }
        entities.forEach((entity, entityIndex) => {
          const entityId = metadata.getEntityIdMap(entity);
          insertResult.identifiers.push(entityId);
          insertResult.generatedMaps.push(generatedMaps[entityIndex]);
        });
      }
      /**
       * Columns we need to be returned from the database when we update entity.
       */
      getUpdationReturningColumns() {
        return this.expressionMap.mainAlias.metadata.columns.filter((column) => {
          return column.asExpression !== void 0 || column.isUpdateDate || column.isVersion;
        });
      }
      /**
       * Columns we need to be returned from the database when we soft delete and restore entity.
       */
      getSoftDeletionReturningColumns() {
        return this.expressionMap.mainAlias.metadata.columns.filter((column) => {
          return column.asExpression !== void 0 || column.isUpdateDate || column.isVersion || column.isDeleteDate;
        });
      }
    };
    exports2.ReturningResultsEntityUpdator = ReturningResultsEntityUpdator;
  }
});

// node_modules/typeorm/query-builder/InsertQueryBuilder.js
var require_InsertQueryBuilder = __commonJS({
  "node_modules/typeorm/query-builder/InsertQueryBuilder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InsertQueryBuilder = void 0;
    var uuid_1 = require_cjs();
    var DriverUtils_1 = require_DriverUtils();
    var error_1 = require_error();
    var InsertValuesMissingError_1 = require_InsertValuesMissingError();
    var ReturningStatementNotSupportedError_1 = require_ReturningStatementNotSupportedError();
    var BroadcasterResult_1 = require_BroadcasterResult();
    var InstanceChecker_1 = require_InstanceChecker();
    var ObjectUtils_1 = require_ObjectUtils();
    var QueryBuilder_1 = require_QueryBuilder();
    var InsertResult_1 = require_InsertResult();
    var ReturningResultsEntityUpdator_1 = require_ReturningResultsEntityUpdator();
    var InsertQueryBuilder2 = class extends QueryBuilder_1.QueryBuilder {
      constructor() {
        super(...arguments);
        this["@instanceof"] = Symbol.for("InsertQueryBuilder");
      }
      // -------------------------------------------------------------------------
      // Public Implemented Methods
      // -------------------------------------------------------------------------
      /**
       * Gets generated SQL query without parameters being replaced.
       */
      getQuery() {
        let sql = this.createComment();
        sql += this.createCteExpression();
        sql += this.createInsertExpression();
        return this.replacePropertyNamesForTheWholeQuery(sql.trim());
      }
      /**
       * Executes sql generated by query builder and returns raw database results.
       */
      async execute() {
        const valueSets = this.getValueSets();
        if (valueSets.length === 0)
          return new InsertResult_1.InsertResult();
        const queryRunner = this.obtainQueryRunner();
        let transactionStartedByUs = false;
        try {
          if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {
            await queryRunner.startTransaction();
            transactionStartedByUs = true;
          }
          if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {
            const broadcastResult = new BroadcasterResult_1.BroadcasterResult();
            valueSets.forEach((valueSet) => {
              queryRunner.broadcaster.broadcastBeforeInsertEvent(broadcastResult, this.expressionMap.mainAlias.metadata, valueSet);
            });
            await broadcastResult.wait();
          }
          let declareSql = null;
          let selectOutputSql = null;
          const returningResultsEntityUpdator = new ReturningResultsEntityUpdator_1.ReturningResultsEntityUpdator(queryRunner, this.expressionMap);
          const returningColumns = [];
          if (Array.isArray(this.expressionMap.returning) && this.expressionMap.mainAlias.hasMetadata) {
            for (const columnPath of this.expressionMap.returning) {
              returningColumns.push(...this.expressionMap.mainAlias.metadata.findColumnsWithPropertyPath(columnPath));
            }
          }
          if (this.expressionMap.updateEntity === true && this.expressionMap.mainAlias.hasMetadata) {
            if (!(valueSets.length > 1 && this.connection.driver.options.type === "oracle")) {
              this.expressionMap.extraReturningColumns = this.expressionMap.mainAlias.metadata.getInsertionReturningColumns();
            }
            returningColumns.push(...this.expressionMap.extraReturningColumns.filter((c) => !returningColumns.includes(c)));
          }
          if (returningColumns.length > 0 && this.connection.driver.options.type === "mssql") {
            declareSql = this.connection.driver.buildTableVariableDeclaration("@OutputTable", returningColumns);
            selectOutputSql = `SELECT * FROM @OutputTable`;
          }
          const [insertSql, parameters] = this.getQueryAndParameters();
          const statements = [declareSql, insertSql, selectOutputSql];
          const sql = statements.filter((s) => s != null).join(";\n\n");
          const queryResult = await queryRunner.query(sql, parameters, true);
          const insertResult = InsertResult_1.InsertResult.from(queryResult);
          if (this.expressionMap.updateEntity === true && this.expressionMap.mainAlias.hasMetadata) {
            await returningResultsEntityUpdator.insert(insertResult, valueSets);
          }
          if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {
            const broadcastResult = new BroadcasterResult_1.BroadcasterResult();
            valueSets.forEach((valueSet) => {
              queryRunner.broadcaster.broadcastAfterInsertEvent(broadcastResult, this.expressionMap.mainAlias.metadata, valueSet);
            });
            await broadcastResult.wait();
          }
          if (transactionStartedByUs) {
            await queryRunner.commitTransaction();
          }
          return insertResult;
        } catch (error) {
          if (transactionStartedByUs) {
            try {
              await queryRunner.rollbackTransaction();
            } catch (rollbackError) {
            }
          }
          throw error;
        } finally {
          if (queryRunner !== this.queryRunner) {
            await queryRunner.release();
          }
        }
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Specifies INTO which entity's table insertion will be executed.
       */
      into(entityTarget, columns) {
        entityTarget = InstanceChecker_1.InstanceChecker.isEntitySchema(entityTarget) ? entityTarget.options.name : entityTarget;
        const mainAlias = this.createFromAlias(entityTarget);
        this.expressionMap.setMainAlias(mainAlias);
        this.expressionMap.insertColumns = columns || [];
        return this;
      }
      /**
       * Values needs to be inserted into table.
       */
      values(values) {
        this.expressionMap.valuesSet = values;
        return this;
      }
      /**
       * Optional returning/output clause.
       */
      output(output) {
        return this.returning(output);
      }
      /**
       * Optional returning/output clause.
       */
      returning(returning) {
        if (!this.connection.driver.isReturningSqlSupported("insert")) {
          throw new ReturningStatementNotSupportedError_1.ReturningStatementNotSupportedError();
        }
        this.expressionMap.returning = returning;
        return this;
      }
      /**
       * Indicates if entity must be updated after insertion operations.
       * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).
       * Enabled by default.
       */
      updateEntity(enabled) {
        this.expressionMap.updateEntity = enabled;
        return this;
      }
      /**
       * Adds additional ON CONFLICT statement supported in postgres and cockroach.
       *
       * @deprecated Use `orIgnore` or `orUpdate`
       */
      onConflict(statement) {
        this.expressionMap.onConflict = statement;
        return this;
      }
      /**
       * Adds additional ignore statement supported in databases.
       */
      orIgnore(statement = true) {
        this.expressionMap.onIgnore = !!statement;
        return this;
      }
      /**
       * Adds additional update statement supported in databases.
       */
      orUpdate(statementOrOverwrite, conflictTarget, orUpdateOptions) {
        const { where, parameters } = orUpdateOptions?.overwriteCondition ?? {};
        let wheres;
        if (where) {
          const condition = this.getWhereCondition(where);
          if (Array.isArray(condition) ? condition.length !== 0 : condition)
            wheres = [{ type: "simple", condition }];
        }
        if (parameters)
          this.setParameters(parameters);
        if (!Array.isArray(statementOrOverwrite)) {
          this.expressionMap.onUpdate = {
            conflict: statementOrOverwrite?.conflict_target,
            columns: statementOrOverwrite?.columns,
            overwrite: statementOrOverwrite?.overwrite,
            skipUpdateIfNoValuesChanged: orUpdateOptions?.skipUpdateIfNoValuesChanged,
            upsertType: orUpdateOptions?.upsertType,
            overwriteCondition: wheres
          };
          return this;
        }
        this.expressionMap.onUpdate = {
          overwrite: statementOrOverwrite,
          conflict: conflictTarget,
          skipUpdateIfNoValuesChanged: orUpdateOptions?.skipUpdateIfNoValuesChanged,
          indexPredicate: orUpdateOptions?.indexPredicate,
          upsertType: orUpdateOptions?.upsertType,
          overwriteCondition: wheres
        };
        return this;
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Creates INSERT express used to perform insert query.
       */
      createInsertExpression() {
        var _a;
        if (this.expressionMap.onUpdate || this.expressionMap.onIgnore) {
          if ((this.expressionMap.onUpdate?.upsertType ?? "merge-into") === "merge-into" && this.connection.driver.supportedUpsertTypes.includes("merge-into"))
            return this.createMergeExpression();
        }
        const tableName = this.getTableName(this.getMainTableName());
        const tableOrAliasName = this.alias !== this.getMainTableName() ? this.escape(this.alias) : tableName;
        const valuesExpression = this.createValuesExpression();
        const returningExpression = this.connection.driver.options.type === "oracle" && this.getValueSets().length > 1 ? null : this.createReturningExpression("insert");
        const columnsExpression = this.createColumnNamesExpression();
        let query = "INSERT ";
        if (this.expressionMap.onUpdate?.upsertType === "primary-key") {
          query = "UPSERT ";
        }
        if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql") {
          query += `${this.expressionMap.onIgnore ? " IGNORE " : ""}`;
        }
        query += `INTO ${tableName}`;
        if (this.alias !== this.getMainTableName() && DriverUtils_1.DriverUtils.isPostgresFamily(this.connection.driver)) {
          query += ` AS "${this.alias}"`;
        }
        if (columnsExpression) {
          query += `(${columnsExpression})`;
        } else {
          if (!valuesExpression && (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql"))
            query += "()";
        }
        if (returningExpression && this.connection.driver.options.type === "mssql") {
          query += ` OUTPUT ${returningExpression}`;
        }
        if (valuesExpression) {
          if ((this.connection.driver.options.type === "oracle" || this.connection.driver.options.type === "sap") && this.getValueSets().length > 1) {
            query += ` ${valuesExpression}`;
          } else {
            query += ` VALUES ${valuesExpression}`;
          }
        } else {
          if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql") {
            query += " VALUES ()";
          } else {
            query += ` DEFAULT VALUES`;
          }
        }
        if (this.expressionMap.onUpdate?.upsertType !== "primary-key") {
          if (this.connection.driver.supportedUpsertTypes.includes("on-conflict-do-update")) {
            if (this.expressionMap.onIgnore) {
              query += " ON CONFLICT DO NOTHING ";
            } else if (this.expressionMap.onConflict) {
              query += ` ON CONFLICT ${this.expressionMap.onConflict} `;
            } else if (this.expressionMap.onUpdate) {
              const { overwrite, columns, conflict, skipUpdateIfNoValuesChanged, indexPredicate } = this.expressionMap.onUpdate;
              let conflictTarget = "ON CONFLICT";
              if (Array.isArray(conflict)) {
                conflictTarget += ` ( ${conflict.map((column) => this.escape(column)).join(", ")} )`;
                if (indexPredicate && !DriverUtils_1.DriverUtils.isPostgresFamily(this.connection.driver)) {
                  throw new error_1.TypeORMError(`indexPredicate option is not supported by the current database driver`);
                }
                if (indexPredicate && DriverUtils_1.DriverUtils.isPostgresFamily(this.connection.driver)) {
                  conflictTarget += ` WHERE ( ${indexPredicate} )`;
                }
              } else if (conflict) {
                conflictTarget += ` ON CONSTRAINT ${this.escape(conflict)}`;
              }
              const updatePart = [];
              if (Array.isArray(overwrite)) {
                updatePart.push(...overwrite.map((column) => `${this.escape(column)} = EXCLUDED.${this.escape(column)}`));
              } else if (columns) {
                updatePart.push(...columns.map((column) => `${this.escape(column)} = :${column}`));
              }
              if (updatePart.length > 0) {
                query += ` ${conflictTarget} DO UPDATE SET `;
                updatePart.push(...this.expressionMap.mainAlias.metadata.columns.filter((column) => column.isUpdateDate && !overwrite?.includes(column.databaseName) && !(this.connection.driver.options.type === "oracle" && this.getValueSets().length > 1 || DriverUtils_1.DriverUtils.isSQLiteFamily(this.connection.driver) || this.connection.driver.options.type === "sap" || this.connection.driver.options.type === "spanner")).map((column) => `${this.escape(column.databaseName)} = DEFAULT`));
                query += updatePart.join(", ");
              }
              if (Array.isArray(overwrite) && skipUpdateIfNoValuesChanged) {
                (_a = this.expressionMap.onUpdate).overwriteCondition ?? (_a.overwriteCondition = []);
                const wheres = overwrite.map((column) => ({
                  type: "or",
                  condition: `${tableOrAliasName}.${this.escape(column)} IS DISTINCT FROM EXCLUDED.${this.escape(column)}`
                }));
                this.expressionMap.onUpdate.overwriteCondition.push({
                  type: "and",
                  condition: wheres
                });
              }
              if (DriverUtils_1.DriverUtils.isPostgresFamily(this.connection.driver) && this.expressionMap.onUpdate.overwriteCondition && this.expressionMap.onUpdate.overwriteCondition.length > 0) {
                query += ` WHERE ${this.createUpsertConditionExpression()}`;
              }
            }
          } else if (this.connection.driver.supportedUpsertTypes.includes("on-duplicate-key-update")) {
            if (this.expressionMap.onUpdate) {
              const { overwrite, columns } = this.expressionMap.onUpdate;
              if (Array.isArray(overwrite)) {
                query += " ON DUPLICATE KEY UPDATE ";
                query += overwrite.map((column) => `${this.escape(column)} = VALUES(${this.escape(column)})`).join(", ");
                query += " ";
              } else if (Array.isArray(columns)) {
                query += " ON DUPLICATE KEY UPDATE ";
                query += columns.map((column) => `${this.escape(column)} = :${column}`).join(", ");
                query += " ";
              }
            }
          } else {
            if (this.expressionMap.onUpdate) {
              throw new error_1.TypeORMError(`onUpdate is not supported by the current database driver`);
            }
          }
        }
        if (returningExpression && (DriverUtils_1.DriverUtils.isPostgresFamily(this.connection.driver) || this.connection.driver.options.type === "oracle" || this.connection.driver.options.type === "cockroachdb" || DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver))) {
          query += ` RETURNING ${returningExpression}`;
        }
        if (returningExpression && this.connection.driver.options.type === "spanner") {
          query += ` THEN RETURN ${returningExpression}`;
        }
        if (this.connection.driver.options.type === "mssql" && this.expressionMap.mainAlias.hasMetadata && this.expressionMap.mainAlias.metadata.columns.filter((column) => this.expressionMap.insertColumns.length > 0 ? this.expressionMap.insertColumns.indexOf(column.propertyPath) !== -1 : column.isInsert).some((column) => this.isOverridingAutoIncrementBehavior(column))) {
          query = `SET IDENTITY_INSERT ${tableName} ON; ${query}; SET IDENTITY_INSERT ${tableName} OFF`;
        }
        return query;
      }
      /**
       * Gets list of columns where values must be inserted to.
       */
      getInsertedColumns() {
        if (!this.expressionMap.mainAlias.hasMetadata)
          return [];
        return this.expressionMap.mainAlias.metadata.columns.filter((column) => {
          if (this.expressionMap.insertColumns.length)
            return this.expressionMap.insertColumns.indexOf(column.propertyPath) !== -1;
          if (!column.isInsert) {
            return false;
          }
          if (column.isGenerated && column.generationStrategy === "increment" && !(this.connection.driver.options.type === "spanner") && !(this.connection.driver.options.type === "oracle") && !DriverUtils_1.DriverUtils.isSQLiteFamily(this.connection.driver) && !DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) && !(this.connection.driver.options.type === "aurora-mysql") && !(this.connection.driver.options.type === "mssql" && this.isOverridingAutoIncrementBehavior(column)))
            return false;
          return true;
        });
      }
      /**
       * Creates a columns string where values must be inserted to for INSERT INTO expression.
       */
      createColumnNamesExpression() {
        const columns = this.getInsertedColumns();
        if (columns.length > 0)
          return columns.map((column) => this.escape(column.databaseName)).join(", ");
        if (!this.expressionMap.mainAlias.hasMetadata && !this.expressionMap.insertColumns.length) {
          const valueSets = this.getValueSets();
          if (valueSets.length === 1)
            return Object.keys(valueSets[0]).map((columnName) => this.escape(columnName)).join(", ");
        }
        return this.expressionMap.insertColumns.map((columnName) => this.escape(columnName)).join(", ");
      }
      /**
       * Creates list of values needs to be inserted in the VALUES expression.
       */
      createValuesExpression() {
        const valueSets = this.getValueSets();
        const columns = this.getInsertedColumns();
        if (columns.length > 0) {
          let expression = "";
          valueSets.forEach((valueSet, valueSetIndex) => {
            columns.forEach((column, columnIndex) => {
              if (columnIndex === 0) {
                if (this.connection.driver.options.type === "oracle" && valueSets.length > 1) {
                  expression += " SELECT ";
                } else if (this.connection.driver.options.type === "sap" && valueSets.length > 1) {
                  expression += " SELECT ";
                } else {
                  expression += "(";
                }
              }
              expression += this.createColumnValueExpression(valueSets, valueSetIndex, column);
              if (columnIndex === columns.length - 1) {
                if (valueSetIndex === valueSets.length - 1) {
                  if (["oracle", "sap"].includes(this.connection.driver.options.type) && valueSets.length > 1) {
                    expression += " FROM " + this.connection.driver.dummyTableName;
                  } else {
                    expression += ")";
                  }
                } else {
                  if (["oracle", "sap"].includes(this.connection.driver.options.type) && valueSets.length > 1) {
                    expression += " FROM " + this.connection.driver.dummyTableName + " UNION ALL ";
                  } else {
                    expression += "), ";
                  }
                }
              } else {
                expression += ", ";
              }
            });
          });
          if (expression === "()")
            return "";
          return expression;
        } else {
          let expression = "";
          valueSets.forEach((valueSet, insertionIndex) => {
            const columns2 = Object.keys(valueSet);
            columns2.forEach((columnName, columnIndex) => {
              if (columnIndex === 0) {
                expression += "(";
              }
              const value = valueSet[columnName];
              if (typeof value === "function") {
                expression += value();
              } else if (value === void 0) {
                if (this.connection.driver.options.type === "oracle" && valueSets.length > 1 || DriverUtils_1.DriverUtils.isSQLiteFamily(this.connection.driver) || this.connection.driver.options.type === "sap" || this.connection.driver.options.type === "spanner") {
                  expression += "NULL";
                } else {
                  expression += "DEFAULT";
                }
              } else if (value === null && this.connection.driver.options.type === "spanner") {
              } else {
                expression += this.createParameter(value);
              }
              if (columnIndex === Object.keys(valueSet).length - 1) {
                if (insertionIndex === valueSets.length - 1) {
                  expression += ")";
                } else {
                  expression += "), ";
                }
              } else {
                expression += ", ";
              }
            });
          });
          if (expression === "()")
            return "";
          return expression;
        }
      }
      /**
       * Gets array of values need to be inserted into the target table.
       */
      getValueSets() {
        if (Array.isArray(this.expressionMap.valuesSet))
          return this.expressionMap.valuesSet;
        if (ObjectUtils_1.ObjectUtils.isObject(this.expressionMap.valuesSet))
          return [this.expressionMap.valuesSet];
        throw new InsertValuesMissingError_1.InsertValuesMissingError();
      }
      /**
       * Checks if column is an auto-generated primary key, but the current insertion specifies a value for it.
       *
       * @param column
       */
      isOverridingAutoIncrementBehavior(column) {
        return column.isPrimary && column.isGenerated && column.generationStrategy === "increment" && this.getValueSets().some((valueSet) => column.getEntityValue(valueSet) !== void 0 && column.getEntityValue(valueSet) !== null);
      }
      /**
       * Creates MERGE express used to perform insert query.
       */
      createMergeExpression() {
        var _a;
        if (!this.connection.driver.supportedUpsertTypes.includes("merge-into"))
          throw new error_1.TypeORMError(`Upsert type "merge-into" is not supported by current database driver`);
        if (this.expressionMap.onUpdate?.upsertType && this.expressionMap.onUpdate.upsertType !== "merge-into") {
          throw new error_1.TypeORMError(`Upsert type "${this.expressionMap.onUpdate.upsertType}" is not supported by current database driver`);
        }
        const tableName = this.getTableName(this.getMainTableName());
        const tableAlias = this.escape(this.alias);
        const columns = this.getInsertedColumns();
        const columnsExpression = this.createColumnNamesExpression();
        let query = `MERGE INTO ${tableName} ${this.escape(this.alias)}`;
        const mergeSourceAlias = this.escape("mergeIntoSource");
        const mergeSourceExpression = this.createMergeIntoSourceExpression(mergeSourceAlias);
        query += ` ${mergeSourceExpression}`;
        if (this.expressionMap.onIgnore) {
          const primaryKey = columns.find((column) => column.isPrimary);
          if (primaryKey) {
            query += ` ON (${tableAlias}.${this.escape(primaryKey.databaseName)} = ${mergeSourceAlias}.${this.escape(primaryKey.databaseName)})`;
          } else {
            query += `ON (${this.expressionMap.mainAlias.metadata.uniques.map((unique) => {
              return `(${unique.columns.map((column) => {
                return `${tableAlias}.${this.escape(column.databaseName)} = ${mergeSourceAlias}.${this.escape(column.databaseName)}`;
              }).join(" AND ")})`;
            }).join(" OR ")})`;
          }
        } else if (this.expressionMap.onUpdate) {
          const { conflict, indexPredicate } = this.expressionMap.onUpdate;
          if (indexPredicate) {
            throw new error_1.TypeORMError(`indexPredicate option is not supported by upsert type "merge-into"`);
          }
          if (Array.isArray(conflict)) {
            query += ` ON (${conflict.map((column) => `${tableAlias}.${this.escape(column)} = ${mergeSourceAlias}.${this.escape(column)}`).join(" AND ")})`;
          } else if (conflict) {
            query += ` ON (${tableAlias}.${this.escape(conflict)} = ${mergeSourceAlias}.${this.escape(conflict)})`;
          } else {
            query += `ON (${this.expressionMap.mainAlias.metadata.uniques.map((unique) => {
              return `(${unique.columns.map((column) => {
                return `${tableAlias}.${this.escape(column.databaseName)} = ${mergeSourceAlias}.${this.escape(column.databaseName)}`;
              }).join(" AND ")})`;
            }).join(" OR ")})`;
          }
        }
        if (this.expressionMap.onUpdate) {
          const { overwrite, columns: columns2, conflict, skipUpdateIfNoValuesChanged } = this.expressionMap.onUpdate;
          let updateExpression = "";
          if (Array.isArray(overwrite)) {
            updateExpression += (overwrite || columns2)?.filter((column) => !conflict?.includes(column)).map((column) => `${tableAlias}.${this.escape(column)} = ${mergeSourceAlias}.${this.escape(column)}`).join(", ");
          }
          if (Array.isArray(overwrite) && skipUpdateIfNoValuesChanged) {
            (_a = this.expressionMap.onUpdate).overwriteCondition ?? (_a.overwriteCondition = []);
            const wheres = overwrite.map((column) => ({
              type: "or",
              condition: {
                operator: "notEqual",
                parameters: [
                  `${tableAlias}.${this.escape(column)}`,
                  `${mergeSourceAlias}.${this.escape(column)}`
                ]
              }
            }));
            this.expressionMap.onUpdate.overwriteCondition.push({
              type: "and",
              condition: wheres
            });
          }
          const mergeCondition = this.createUpsertConditionExpression();
          if (updateExpression.trim()) {
            if ((this.connection.driver.options.type === "mssql" || this.connection.driver.options.type === "sap") && mergeCondition != "") {
              query += ` WHEN MATCHED AND ${mergeCondition} THEN UPDATE SET ${updateExpression}`;
            } else {
              query += ` WHEN MATCHED THEN UPDATE SET ${updateExpression}`;
              if (mergeCondition != "") {
                query += ` WHERE ${mergeCondition}`;
              }
            }
          }
        }
        const valuesExpression = this.createMergeIntoInsertValuesExpression(mergeSourceAlias);
        const returningExpression = this.connection.driver.options.type === "mssql" ? this.createReturningExpression("insert") : null;
        query += " WHEN NOT MATCHED THEN INSERT";
        if (columnsExpression) {
          query += `(${columnsExpression})`;
        }
        if (valuesExpression) {
          query += ` VALUES ${valuesExpression}`;
        }
        if (returningExpression && this.connection.driver.options.type === "mssql") {
          query += ` OUTPUT ${returningExpression}`;
        }
        if (this.connection.driver.options.type === "mssql") {
          query += `;`;
        }
        return query;
      }
      /**
       * Creates list of values needs to be inserted in the VALUES expression.
       */
      createMergeIntoSourceExpression(mergeSourceAlias) {
        const valueSets = this.getValueSets();
        const columns = this.getInsertedColumns();
        let expression = "USING (";
        if (columns.length > 0) {
          if (this.connection.driver.options.type === "mssql") {
            expression += "VALUES ";
          }
          valueSets.forEach((valueSet, valueSetIndex) => {
            columns.forEach((column, columnIndex) => {
              if (columnIndex === 0) {
                if (this.connection.driver.options.type === "mssql") {
                  expression += "(";
                } else {
                  expression += "SELECT ";
                }
              }
              const value = column.getEntityValue(valueSet);
              if (value === void 0 && !(column.isGenerated && column.generationStrategy === "uuid" && !this.connection.driver.isUUIDGenerationSupported())) {
                if (column.default !== void 0 && column.default !== null) {
                  expression += this.connection.driver.normalizeDefault(column);
                } else {
                  expression += "NULL";
                }
              } else if (value === null) {
                expression += "NULL";
              } else {
                expression += this.createColumnValueExpression(valueSets, valueSetIndex, column);
              }
              if (this.connection.driver.options.type !== "mssql")
                expression += ` AS ${this.escape(column.databaseName)}`;
              if (columnIndex === columns.length - 1) {
                if (valueSetIndex === valueSets.length - 1) {
                  if (["oracle", "sap"].includes(this.connection.driver.options.type)) {
                    expression += " FROM " + this.connection.driver.dummyTableName;
                  } else if (this.connection.driver.options.type === "mssql") {
                    expression += ")";
                  }
                } else {
                  if (["oracle", "sap"].includes(this.connection.driver.options.type) && valueSets.length > 1) {
                    expression += " FROM " + this.connection.driver.dummyTableName + " UNION ALL ";
                  } else if (this.connection.driver.options.type === "mssql") {
                    expression += "), ";
                  } else {
                    expression += " UNION ALL ";
                  }
                }
              } else {
                expression += ", ";
              }
            });
          });
        } else {
          throw new error_1.TypeORMError('Upsert type "merge-into" is not supported without metadata tables');
        }
        expression += `) ${mergeSourceAlias}`;
        if (this.connection.driver.options.type === "mssql")
          expression += ` (${columns.map((column) => this.escape(column.databaseName)).join(", ")})`;
        return expression;
      }
      /**
       * Creates list of values needs to be inserted in the VALUES expression.
       */
      createMergeIntoInsertValuesExpression(mergeSourceAlias) {
        const columns = this.getInsertedColumns();
        let expression = "";
        if (columns.length > 0) {
          columns.forEach((column, columnIndex) => {
            if (columnIndex === 0) {
              expression += "(";
            }
            if (column.isGenerated && column.generationStrategy === "uuid" && this.connection.driver.isUUIDGenerationSupported() || column.isGenerated && column.generationStrategy !== "uuid") {
              expression += `DEFAULT`;
            } else {
              expression += `${mergeSourceAlias}.${this.escape(column.databaseName)}`;
            }
            if (columnIndex === columns.length - 1) {
              expression += ")";
            } else {
              expression += ", ";
            }
          });
        } else {
          throw new error_1.TypeORMError('Upsert type "merge-into" is not supported without metadata tables');
        }
        if (expression === "()")
          return "";
        return expression;
      }
      /**
       * Create upsert search condition expression.
       */
      createUpsertConditionExpression() {
        if (!this.expressionMap.onUpdate.overwriteCondition)
          return "";
        const conditionsArray = [];
        const whereExpression = this.createWhereClausesExpression(this.expressionMap.onUpdate.overwriteCondition);
        if (whereExpression.length > 0 && whereExpression !== "1=1") {
          conditionsArray.push(whereExpression);
        }
        if (this.expressionMap.mainAlias.hasMetadata) {
          const metadata = this.expressionMap.mainAlias.metadata;
          if (this.expressionMap.queryType === "select" && !this.expressionMap.withDeleted && metadata.deleteDateColumn) {
            const column = this.expressionMap.aliasNamePrefixingEnabled ? this.expressionMap.mainAlias.name + "." + metadata.deleteDateColumn.propertyName : metadata.deleteDateColumn.propertyName;
            const condition2 = `${column} IS NULL`;
            conditionsArray.push(condition2);
          }
          if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {
            const column = this.expressionMap.aliasNamePrefixingEnabled ? this.expressionMap.mainAlias.name + "." + metadata.discriminatorColumn.databaseName : metadata.discriminatorColumn.databaseName;
            const condition2 = `${column} IN (:...discriminatorColumnValues)`;
            conditionsArray.push(condition2);
          }
        }
        if (this.expressionMap.extraAppendedAndWhereCondition) {
          const condition2 = this.expressionMap.extraAppendedAndWhereCondition;
          conditionsArray.push(condition2);
        }
        let condition = "";
        if (!conditionsArray.length) {
          condition += "";
        } else if (conditionsArray.length === 1) {
          condition += `${conditionsArray[0]}`;
        } else {
          condition += `( ${conditionsArray.join(" ) AND ( ")} )`;
        }
        return condition;
      }
      createColumnValueExpression(valueSets, valueSetIndex, column) {
        const valueSet = valueSets[valueSetIndex];
        let expression = "";
        let value = column.getEntityValue(valueSet);
        if (!(typeof value === "function")) {
          value = this.connection.driver.preparePersistentValue(value, column);
        }
        if (column.isVersion && value === void 0) {
          expression += "1";
        } else if (column.isDiscriminator) {
          expression += this.createParameter(this.expressionMap.mainAlias.metadata.discriminatorValue);
        } else if (column.isGenerated && column.generationStrategy === "uuid" && !this.connection.driver.isUUIDGenerationSupported() && value === void 0) {
          value = (0, uuid_1.v4)();
          expression += this.createParameter(value);
          if (!(valueSetIndex in this.expressionMap.locallyGenerated)) {
            this.expressionMap.locallyGenerated[valueSetIndex] = {};
          }
          column.setEntityValue(this.expressionMap.locallyGenerated[valueSetIndex], value);
        } else if (value === void 0) {
          if (this.connection.driver.options.type === "oracle" && valueSets.length > 1 || DriverUtils_1.DriverUtils.isSQLiteFamily(this.connection.driver) || this.connection.driver.options.type === "sap" || this.connection.driver.options.type === "spanner") {
            if (column.default !== void 0 && column.default !== null) {
              expression += this.connection.driver.normalizeDefault(column);
            } else if (this.connection.driver.options.type === "spanner" && column.isGenerated && column.generationStrategy === "uuid") {
              expression += "GENERATE_UUID()";
            } else {
              expression += "NULL";
            }
          } else {
            expression += "DEFAULT";
          }
        } else if (value === null && (this.connection.driver.options.type === "spanner" || this.connection.driver.options.type === "oracle")) {
          expression += "NULL";
        } else if (typeof value === "function") {
          expression += value();
        } else {
          if (this.connection.driver.options.type === "mssql")
            value = this.connection.driver.parametrizeValue(column, value);
          const paramName = this.createParameter(value);
          if ((DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql") && this.connection.driver.spatialTypes.includes(column.type)) {
            const useLegacy = this.connection.driver.options.legacySpatialSupport;
            const geomFromText = useLegacy ? "GeomFromText" : "ST_GeomFromText";
            if (column.srid != null) {
              expression += `${geomFromText}(${paramName}, ${column.srid})`;
            } else {
              expression += `${geomFromText}(${paramName})`;
            }
          } else if (DriverUtils_1.DriverUtils.isPostgresFamily(this.connection.driver) && this.connection.driver.spatialTypes.includes(column.type)) {
            if (column.srid != null) {
              expression += `ST_SetSRID(ST_GeomFromGeoJSON(${paramName}), ${column.srid})::${column.type}`;
            } else {
              expression += `ST_GeomFromGeoJSON(${paramName})::${column.type}`;
            }
          } else if (this.connection.driver.options.type === "mssql" && this.connection.driver.spatialTypes.includes(column.type)) {
            expression += column.type + "::STGeomFromText(" + paramName + ", " + (column.srid || "0") + ")";
          } else {
            expression += paramName;
          }
        }
        return expression;
      }
    };
    exports2.InsertQueryBuilder = InsertQueryBuilder2;
  }
});

// node_modules/typeorm/query-builder/RelationUpdater.js
var require_RelationUpdater = __commonJS({
  "node_modules/typeorm/query-builder/RelationUpdater.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RelationUpdater = void 0;
    var error_1 = require_error();
    var ObjectUtils_1 = require_ObjectUtils();
    var RelationUpdater = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(queryBuilder, expressionMap) {
        this.queryBuilder = queryBuilder;
        this.expressionMap = expressionMap;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Performs set or add operation on a relation.
       */
      async update(value) {
        const relation = this.expressionMap.relationMetadata;
        if (relation.isManyToOne || relation.isOneToOneOwner) {
          const updateSet = relation.joinColumns.reduce((updateSet2, joinColumn) => {
            const relationValue = ObjectUtils_1.ObjectUtils.isObject(value) ? joinColumn.referencedColumn.getEntityValue(value) : value;
            joinColumn.setEntityValue(updateSet2, relationValue);
            return updateSet2;
          }, {});
          if (!this.expressionMap.of || Array.isArray(this.expressionMap.of) && !this.expressionMap.of.length)
            return;
          await this.queryBuilder.createQueryBuilder().update(relation.entityMetadata.target).set(updateSet).whereInIds(this.expressionMap.of).execute();
        } else if ((relation.isOneToOneNotOwner || relation.isOneToMany) && value === null) {
          const updateSet = {};
          relation.inverseRelation.joinColumns.forEach((column) => {
            updateSet[column.propertyName] = null;
          });
          const ofs = Array.isArray(this.expressionMap.of) ? this.expressionMap.of : [this.expressionMap.of];
          const parameters = {};
          const conditions = [];
          ofs.forEach((of, ofIndex) => {
            relation.inverseRelation.joinColumns.map((column, columnIndex) => {
              const parameterName = "joinColumn_" + ofIndex + "_" + columnIndex;
              parameters[parameterName] = ObjectUtils_1.ObjectUtils.isObject(of) ? column.referencedColumn.getEntityValue(of) : of;
              conditions.push(`${column.propertyPath} = :${parameterName}`);
            });
          });
          const condition = conditions.map((str) => "(" + str + ")").join(" OR ");
          if (!condition)
            return;
          await this.queryBuilder.createQueryBuilder().update(relation.inverseEntityMetadata.target).set(updateSet).where(condition).setParameters(parameters).execute();
        } else if (relation.isOneToOneNotOwner || relation.isOneToMany) {
          if (Array.isArray(this.expressionMap.of))
            throw new error_1.TypeORMError(`You cannot update relations of multiple entities with the same related object. Provide a single entity into .of method.`);
          const of = this.expressionMap.of;
          const updateSet = relation.inverseRelation.joinColumns.reduce((updateSet2, joinColumn) => {
            const relationValue = ObjectUtils_1.ObjectUtils.isObject(of) ? joinColumn.referencedColumn.getEntityValue(of) : of;
            joinColumn.setEntityValue(updateSet2, relationValue);
            return updateSet2;
          }, {});
          if (!value || Array.isArray(value) && !value.length)
            return;
          await this.queryBuilder.createQueryBuilder().update(relation.inverseEntityMetadata.target).set(updateSet).whereInIds(value).execute();
        } else {
          const junctionMetadata = relation.junctionEntityMetadata;
          const ofs = Array.isArray(this.expressionMap.of) ? this.expressionMap.of : [this.expressionMap.of];
          const values = Array.isArray(value) ? value : [value];
          const firstColumnValues = relation.isManyToManyOwner ? ofs : values;
          const secondColumnValues = relation.isManyToManyOwner ? values : ofs;
          const bulkInserted = [];
          firstColumnValues.forEach((firstColumnVal) => {
            secondColumnValues.forEach((secondColumnVal) => {
              const inserted = {};
              junctionMetadata.ownerColumns.forEach((column) => {
                inserted[column.databaseName] = ObjectUtils_1.ObjectUtils.isObject(firstColumnVal) ? column.referencedColumn.getEntityValue(firstColumnVal) : firstColumnVal;
              });
              junctionMetadata.inverseColumns.forEach((column) => {
                inserted[column.databaseName] = ObjectUtils_1.ObjectUtils.isObject(secondColumnVal) ? column.referencedColumn.getEntityValue(secondColumnVal) : secondColumnVal;
              });
              bulkInserted.push(inserted);
            });
          });
          if (!bulkInserted.length)
            return;
          if (this.queryBuilder.connection.driver.options.type === "oracle" || this.queryBuilder.connection.driver.options.type === "sap") {
            await Promise.all(bulkInserted.map((value2) => {
              return this.queryBuilder.createQueryBuilder().insert().into(junctionMetadata.tableName).values(value2).execute();
            }));
          } else {
            await this.queryBuilder.createQueryBuilder().insert().into(junctionMetadata.tableName).values(bulkInserted).execute();
          }
        }
      }
    };
    exports2.RelationUpdater = RelationUpdater;
  }
});

// node_modules/typeorm/query-builder/RelationRemover.js
var require_RelationRemover = __commonJS({
  "node_modules/typeorm/query-builder/RelationRemover.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RelationRemover = void 0;
    var ObjectUtils_1 = require_ObjectUtils();
    var RelationRemover = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(queryBuilder, expressionMap) {
        this.queryBuilder = queryBuilder;
        this.expressionMap = expressionMap;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Performs remove operation on a relation.
       */
      async remove(value) {
        const relation = this.expressionMap.relationMetadata;
        if (relation.isOneToMany) {
          const ofs = Array.isArray(this.expressionMap.of) ? this.expressionMap.of : [this.expressionMap.of];
          const values = Array.isArray(value) ? value : [value];
          const updateSet = {};
          relation.inverseRelation.joinColumns.forEach((column) => {
            updateSet[column.propertyName] = null;
          });
          const parameters = {};
          const conditions = [];
          ofs.forEach((of, ofIndex) => {
            conditions.push(...values.map((value2, valueIndex) => {
              return [
                ...relation.inverseRelation.joinColumns.map((column, columnIndex) => {
                  const parameterName = "joinColumn_" + ofIndex + "_" + valueIndex + "_" + columnIndex;
                  parameters[parameterName] = ObjectUtils_1.ObjectUtils.isObject(of) ? column.referencedColumn.getEntityValue(of) : of;
                  return `${column.propertyPath} = :${parameterName}`;
                }),
                ...relation.inverseRelation.entityMetadata.primaryColumns.map((column, columnIndex) => {
                  const parameterName = "primaryColumn_" + valueIndex + "_" + valueIndex + "_" + columnIndex;
                  parameters[parameterName] = ObjectUtils_1.ObjectUtils.isObject(value2) ? column.getEntityValue(value2) : value2;
                  return `${column.propertyPath} = :${parameterName}`;
                })
              ].join(" AND ");
            }));
          });
          const condition = conditions.map((str) => "(" + str + ")").join(" OR ");
          if (!condition)
            return;
          await this.queryBuilder.createQueryBuilder().update(relation.inverseEntityMetadata.target).set(updateSet).where(condition).setParameters(parameters).execute();
        } else {
          const junctionMetadata = relation.junctionEntityMetadata;
          const ofs = Array.isArray(this.expressionMap.of) ? this.expressionMap.of : [this.expressionMap.of];
          const values = Array.isArray(value) ? value : [value];
          const firstColumnValues = relation.isManyToManyOwner ? ofs : values;
          const secondColumnValues = relation.isManyToManyOwner ? values : ofs;
          const parameters = {};
          const conditions = [];
          firstColumnValues.forEach((firstColumnVal, firstColumnValIndex) => {
            conditions.push(...secondColumnValues.map((secondColumnVal, secondColumnValIndex) => {
              return [
                ...junctionMetadata.ownerColumns.map((column, columnIndex) => {
                  const parameterName = "firstValue_" + firstColumnValIndex + "_" + secondColumnValIndex + "_" + columnIndex;
                  parameters[parameterName] = ObjectUtils_1.ObjectUtils.isObject(firstColumnVal) ? column.referencedColumn.getEntityValue(firstColumnVal) : firstColumnVal;
                  return `${column.databaseName} = :${parameterName}`;
                }),
                ...junctionMetadata.inverseColumns.map((column, columnIndex) => {
                  const parameterName = "secondValue_" + firstColumnValIndex + "_" + secondColumnValIndex + "_" + columnIndex;
                  parameters[parameterName] = ObjectUtils_1.ObjectUtils.isObject(secondColumnVal) ? column.referencedColumn.getEntityValue(secondColumnVal) : secondColumnVal;
                  return `${column.databaseName} = :${parameterName}`;
                })
              ].join(" AND ");
            }));
          });
          const condition = conditions.map((str) => "(" + str + ")").join(" OR ");
          await this.queryBuilder.createQueryBuilder().delete().from(junctionMetadata.tableName).where(condition).setParameters(parameters).execute();
        }
      }
    };
    exports2.RelationRemover = RelationRemover;
  }
});

// node_modules/typeorm/query-builder/RelationQueryBuilder.js
var require_RelationQueryBuilder = __commonJS({
  "node_modules/typeorm/query-builder/RelationQueryBuilder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RelationQueryBuilder = void 0;
    var QueryBuilder_1 = require_QueryBuilder();
    var RelationUpdater_1 = require_RelationUpdater();
    var RelationRemover_1 = require_RelationRemover();
    var error_1 = require_error();
    var ObjectUtils_1 = require_ObjectUtils();
    var RelationQueryBuilder2 = class extends QueryBuilder_1.QueryBuilder {
      constructor() {
        super(...arguments);
        this["@instanceof"] = Symbol.for("RelationQueryBuilder");
      }
      // -------------------------------------------------------------------------
      // Public Implemented Methods
      // -------------------------------------------------------------------------
      /**
       * Gets generated SQL query without parameters being replaced.
       */
      getQuery() {
        return "";
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Sets entity (target) which relations will be updated.
       */
      of(entity) {
        this.expressionMap.of = entity;
        return this;
      }
      /**
       * Sets entity relation's value.
       * Value can be entity, entity id or entity id map (if entity has composite ids).
       * Works only for many-to-one and one-to-one relations.
       * For many-to-many and one-to-many relations use #add and #remove methods instead.
       */
      async set(value) {
        const relation = this.expressionMap.relationMetadata;
        if (!this.expressionMap.of)
          throw new error_1.TypeORMError(`Entity whose relation needs to be set is not set. Use .of method to define whose relation you want to set.`);
        if (relation.isManyToMany || relation.isOneToMany)
          throw new error_1.TypeORMError(`Set operation is only supported for many-to-one and one-to-one relations. However given "${relation.propertyPath}" has ${relation.relationType} relation. Use .add() method instead.`);
        if (relation.joinColumns && relation.joinColumns.length > 1 && (!ObjectUtils_1.ObjectUtils.isObject(value) || Object.keys(value).length < relation.joinColumns.length))
          throw new error_1.TypeORMError(`Value to be set into the relation must be a map of relation ids, for example: .set({ firstName: "...", lastName: "..." })`);
        const updater = new RelationUpdater_1.RelationUpdater(this, this.expressionMap);
        return updater.update(value);
      }
      /**
       * Adds (binds) given value to entity relation.
       * Value can be entity, entity id or entity id map (if entity has composite ids).
       * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).
       * Works only for many-to-many and one-to-many relations.
       * For many-to-one and one-to-one use #set method instead.
       */
      async add(value) {
        if (Array.isArray(value) && value.length === 0)
          return;
        const relation = this.expressionMap.relationMetadata;
        if (!this.expressionMap.of)
          throw new error_1.TypeORMError(`Entity whose relation needs to be set is not set. Use .of method to define whose relation you want to set.`);
        if (relation.isManyToOne || relation.isOneToOne)
          throw new error_1.TypeORMError(`Add operation is only supported for many-to-many and one-to-many relations. However given "${relation.propertyPath}" has ${relation.relationType} relation. Use .set() method instead.`);
        if (relation.joinColumns && relation.joinColumns.length > 1 && (!ObjectUtils_1.ObjectUtils.isObject(value) || Object.keys(value).length < relation.joinColumns.length))
          throw new error_1.TypeORMError(`Value to be set into the relation must be a map of relation ids, for example: .set({ firstName: "...", lastName: "..." })`);
        const updater = new RelationUpdater_1.RelationUpdater(this, this.expressionMap);
        return updater.update(value);
      }
      /**
       * Removes (unbinds) given value from entity relation.
       * Value can be entity, entity id or entity id map (if entity has composite ids).
       * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).
       * Works only for many-to-many and one-to-many relations.
       * For many-to-one and one-to-one use #set method instead.
       */
      async remove(value) {
        if (Array.isArray(value) && value.length === 0)
          return;
        const relation = this.expressionMap.relationMetadata;
        if (!this.expressionMap.of)
          throw new error_1.TypeORMError(`Entity whose relation needs to be set is not set. Use .of method to define whose relation you want to set.`);
        if (relation.isManyToOne || relation.isOneToOne)
          throw new error_1.TypeORMError(`Add operation is only supported for many-to-many and one-to-many relations. However given "${relation.propertyPath}" has ${relation.relationType} relation. Use .set(null) method instead.`);
        const remover = new RelationRemover_1.RelationRemover(this, this.expressionMap);
        return remover.remove(value);
      }
      /**
       * Adds (binds) and removes (unbinds) given values to/from entity relation.
       * Value can be entity, entity id or entity id map (if entity has composite ids).
       * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).
       * Works only for many-to-many and one-to-many relations.
       * For many-to-one and one-to-one use #set method instead.
       */
      async addAndRemove(added, removed) {
        await this.remove(removed);
        await this.add(added);
      }
      /**
           * Gets entity's relation id.
          async getId(): Promise<any> {
      
          }*/
      /**
       * Gets entity's relation ids.
      async getIds(): Promise<any[]> {
          return [];
      }*/
      /**
       * Loads a single entity (relational) from the relation.
       * You can also provide id of relational entity to filter by.
       */
      async loadOne() {
        return this.loadMany().then((results) => results[0]);
      }
      /**
       * Loads many entities (relational) from the relation.
       * You can also provide ids of relational entities to filter by.
       */
      async loadMany() {
        let of = this.expressionMap.of;
        if (!ObjectUtils_1.ObjectUtils.isObject(of)) {
          const metadata = this.expressionMap.mainAlias.metadata;
          if (metadata.hasMultiplePrimaryKeys)
            throw new error_1.TypeORMError(`Cannot load entity because only one primary key was specified, however entity contains multiple primary keys`);
          of = metadata.primaryColumns[0].createValueMap(of);
        }
        return this.connection.relationLoader.load(this.expressionMap.relationMetadata, of, this.queryRunner);
      }
    };
    exports2.RelationQueryBuilder = RelationQueryBuilder2;
  }
});

// node_modules/typeorm/query-builder/transformer/RawSqlResultsToEntityTransformer.js
var require_RawSqlResultsToEntityTransformer = __commonJS({
  "node_modules/typeorm/query-builder/transformer/RawSqlResultsToEntityTransformer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RawSqlResultsToEntityTransformer = void 0;
    var OrmUtils_1 = require_OrmUtils();
    var DriverUtils_1 = require_DriverUtils();
    var ObjectUtils_1 = require_ObjectUtils();
    var RawSqlResultsToEntityTransformer = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(expressionMap, driver, rawRelationIdResults, rawRelationCountResults, queryRunner) {
        this.expressionMap = expressionMap;
        this.driver = driver;
        this.rawRelationIdResults = rawRelationIdResults;
        this.rawRelationCountResults = rawRelationCountResults;
        this.queryRunner = queryRunner;
        this.pojo = this.expressionMap.options.includes("create-pojo");
        this.selections = new Set(this.expressionMap.selects.map((s) => s.selection));
        this.aliasCache = /* @__PURE__ */ new Map();
        this.columnsCache = /* @__PURE__ */ new Map();
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated
       * we need to group our result and we must have some unique id (primary key in our case)
       */
      transform(rawResults, alias) {
        const group = this.group(rawResults, alias);
        const entities = [];
        for (const results of group.values()) {
          const entity = this.transformRawResultsGroup(results, alias);
          if (entity !== void 0)
            entities.push(entity);
        }
        return entities;
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Build an alias from a name and column name.
       */
      buildAlias(aliasName, columnName) {
        let aliases = this.aliasCache.get(aliasName);
        if (!aliases) {
          aliases = /* @__PURE__ */ new Map();
          this.aliasCache.set(aliasName, aliases);
        }
        let columnAlias = aliases.get(columnName);
        if (!columnAlias) {
          columnAlias = DriverUtils_1.DriverUtils.buildAlias(this.driver, void 0, aliasName, columnName);
          aliases.set(columnName, columnAlias);
        }
        return columnAlias;
      }
      /**
       * Groups given raw results by ids of given alias.
       */
      group(rawResults, alias) {
        const map = /* @__PURE__ */ new Map();
        const keys = [];
        if (alias.metadata.tableType === "view") {
          keys.push(...alias.metadata.columns.map((column) => this.buildAlias(alias.name, column.databaseName)));
        } else {
          keys.push(...alias.metadata.primaryColumns.map((column) => this.buildAlias(alias.name, column.databaseName)));
        }
        for (const rawResult of rawResults) {
          const id = keys.map((key) => {
            const keyValue = rawResult[key];
            if (Buffer.isBuffer(keyValue)) {
              return keyValue.toString("hex");
            }
            if (ObjectUtils_1.ObjectUtils.isObject(keyValue)) {
              return JSON.stringify(keyValue);
            }
            return keyValue;
          }).join("_");
          const items = map.get(id);
          if (!items) {
            map.set(id, [rawResult]);
          } else {
            items.push(rawResult);
          }
        }
        return map;
      }
      /**
       * Transforms set of data results into single entity.
       */
      transformRawResultsGroup(rawResults, alias) {
        let metadata = alias.metadata;
        if (metadata.discriminatorColumn) {
          const discriminatorValues = rawResults.map((result) => result[this.buildAlias(alias.name, alias.metadata.discriminatorColumn.databaseName)]);
          const discriminatorMetadata = metadata.childEntityMetadatas.find((childEntityMetadata) => {
            return typeof discriminatorValues.find((value) => value === childEntityMetadata.discriminatorValue) !== "undefined";
          });
          if (discriminatorMetadata)
            metadata = discriminatorMetadata;
        }
        const entity = metadata.create(this.queryRunner, {
          fromDeserializer: true,
          pojo: this.pojo
        });
        const hasColumns = this.transformColumns(rawResults, alias, entity, metadata);
        const hasRelations = this.transformJoins(rawResults, entity, alias, metadata);
        const hasRelationIds = this.transformRelationIds(rawResults, alias, entity, metadata);
        const hasRelationCounts = this.transformRelationCounts(rawResults, alias, entity);
        if (hasColumns)
          return entity;
        const hasOnlyVirtualPrimaryColumns = metadata.primaryColumns.every((column) => column.isVirtual === true);
        if (hasOnlyVirtualPrimaryColumns && (hasRelations || hasRelationIds || hasRelationCounts))
          return entity;
        return void 0;
      }
      // get value from columns selections and put them into object
      transformColumns(rawResults, alias, entity, metadata) {
        let hasData = false;
        const result = rawResults[0];
        for (const [key, column] of this.getColumnsToProcess(alias.name, metadata)) {
          const value = result[key];
          if (value === void 0)
            continue;
          else if (value !== null && !column.isVirtualProperty)
            hasData = true;
          column.setEntityValue(entity, this.driver.prepareHydratedValue(value, column));
        }
        return hasData;
      }
      /**
       * Transforms joined entities in the given raw results by a given alias and stores to the given (parent) entity
       */
      transformJoins(rawResults, entity, alias, metadata) {
        let hasData = false;
        for (const join of this.expressionMap.joinAttributes) {
          if (!join.metadata)
            continue;
          if (!join.isSelected)
            continue;
          if (join.relation && !metadata.relations.find((relation) => relation === join.relation))
            continue;
          if (join.mapToProperty) {
            if (join.mapToPropertyParentAlias !== alias.name)
              continue;
          } else {
            if (!join.relation || join.parentAlias !== alias.name || join.relationPropertyPath !== join.relation.propertyPath)
              continue;
          }
          let result = this.transform(rawResults, join.alias);
          result = !join.isMany ? result[0] : result;
          result = !join.isMany && result === void 0 ? null : result;
          if (result === void 0)
            continue;
          if (join.mapToPropertyPropertyName) {
            entity[join.mapToPropertyPropertyName] = result;
          } else {
            join.relation.setEntityValue(entity, result);
          }
          hasData = true;
        }
        return hasData;
      }
      transformRelationIds(rawSqlResults, alias, entity, metadata) {
        let hasData = false;
        for (const [index, rawRelationIdResult] of this.rawRelationIdResults.entries()) {
          if (rawRelationIdResult.relationIdAttribute.parentAlias !== alias.name)
            continue;
          const relation = rawRelationIdResult.relationIdAttribute.relation;
          const valueMap = this.createValueMapFromJoinColumns(relation, rawRelationIdResult.relationIdAttribute.parentAlias, rawSqlResults);
          if (valueMap === void 0 || valueMap === null) {
            continue;
          }
          this.prepareDataForTransformRelationIds();
          const hash = this.hashEntityIds(relation, valueMap);
          const idMaps = this.relationIdMaps[index][hash] || [];
          const properties = rawRelationIdResult.relationIdAttribute.mapToPropertyPropertyPath.split(".");
          const mapToProperty = (properties2, map, value) => {
            const property = properties2.shift();
            if (property && properties2.length === 0) {
              map[property] = value;
              return map;
            }
            if (property && properties2.length > 0) {
              mapToProperty(properties2, map[property], value);
            } else {
              return map;
            }
          };
          if (relation.isOneToOne || relation.isManyToOne) {
            if (idMaps[0] !== void 0) {
              mapToProperty(properties, entity, idMaps[0]);
              hasData = true;
            }
          } else {
            mapToProperty(properties, entity, idMaps);
            hasData = hasData || idMaps.length > 0;
          }
        }
        return hasData;
      }
      transformRelationCounts(rawSqlResults, alias, entity) {
        let hasData = false;
        for (const rawRelationCountResult of this.rawRelationCountResults) {
          if (rawRelationCountResult.relationCountAttribute.parentAlias !== alias.name)
            continue;
          const relation = rawRelationCountResult.relationCountAttribute.relation;
          let referenceColumnName;
          if (relation.isOneToMany) {
            referenceColumnName = relation.inverseRelation.joinColumns[0].referencedColumn.databaseName;
          } else {
            referenceColumnName = relation.isOwning ? relation.joinColumns[0].referencedColumn.databaseName : relation.inverseRelation.joinColumns[0].referencedColumn.databaseName;
          }
          const referenceColumnValue = rawSqlResults[0][this.buildAlias(alias.name, referenceColumnName)];
          if (referenceColumnValue !== void 0 && referenceColumnValue !== null) {
            entity[rawRelationCountResult.relationCountAttribute.mapToPropertyPropertyName] = 0;
            for (const result of rawRelationCountResult.results) {
              if (result["parentId"] !== referenceColumnValue)
                continue;
              entity[rawRelationCountResult.relationCountAttribute.mapToPropertyPropertyName] = parseInt(result["cnt"]);
              hasData = true;
            }
          }
        }
        return hasData;
      }
      getColumnsToProcess(aliasName, metadata) {
        let metadatas = this.columnsCache.get(aliasName);
        if (!metadatas) {
          metadatas = /* @__PURE__ */ new Map();
          this.columnsCache.set(aliasName, metadatas);
        }
        let columns = metadatas.get(metadata);
        if (!columns) {
          columns = metadata.columns.filter((column) => !column.isVirtual && // if user does not selected the whole entity or he used partial selection and does not select this particular column
          // then we don't add this column and its value into the entity
          (this.selections.has(aliasName) || this.selections.has(`${aliasName}.${column.propertyPath}`)) && // if table inheritance is used make sure this column is not child's column
          !metadata.childEntityMetadatas.some((childMetadata) => childMetadata.target === column.target)).map((column) => [
            this.buildAlias(aliasName, column.databaseName),
            column
          ]);
          metadatas.set(metadata, columns);
        }
        return columns;
      }
      createValueMapFromJoinColumns(relation, parentAlias, rawSqlResults) {
        let columns;
        if (relation.isManyToOne || relation.isOneToOneOwner) {
          columns = relation.entityMetadata.primaryColumns.map((joinColumn) => joinColumn);
        } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {
          columns = relation.inverseRelation.joinColumns.map((joinColumn) => joinColumn);
        } else {
          if (relation.isOwning) {
            columns = relation.joinColumns.map((joinColumn) => joinColumn);
          } else {
            columns = relation.inverseRelation.inverseJoinColumns.map((joinColumn) => joinColumn);
          }
        }
        return columns.reduce((valueMap, column) => {
          for (const rawSqlResult of rawSqlResults) {
            if (relation.isManyToOne || relation.isOneToOneOwner) {
              valueMap[column.databaseName] = this.driver.prepareHydratedValue(rawSqlResult[this.buildAlias(parentAlias, column.databaseName)], column);
            } else {
              valueMap[column.databaseName] = this.driver.prepareHydratedValue(rawSqlResult[this.buildAlias(parentAlias, column.referencedColumn.databaseName)], column.referencedColumn);
            }
          }
          return valueMap;
        }, {});
      }
      extractEntityPrimaryIds(relation, relationIdRawResult) {
        let columns;
        if (relation.isManyToOne || relation.isOneToOneOwner) {
          columns = relation.entityMetadata.primaryColumns.map((joinColumn) => joinColumn);
        } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {
          columns = relation.inverseRelation.joinColumns.map((joinColumn) => joinColumn);
        } else {
          if (relation.isOwning) {
            columns = relation.joinColumns.map((joinColumn) => joinColumn);
          } else {
            columns = relation.inverseRelation.inverseJoinColumns.map((joinColumn) => joinColumn);
          }
        }
        return columns.reduce((data, column) => {
          data[column.databaseName] = relationIdRawResult[column.databaseName];
          return data;
        }, {});
      }
      /*private removeVirtualColumns(entity: ObjectLiteral, alias: Alias) {
              const virtualColumns = this.expressionMap.selects
                  .filter(select => select.virtual)
                  .map(select => select.selection.replace(alias.name + ".", ""));
      
              virtualColumns.forEach(virtualColumn => delete entity[virtualColumn]);
          }*/
      /** Prepare data to run #transformRelationIds, as a lot of result independent data is needed in every call */
      prepareDataForTransformRelationIds() {
        if (this.relationIdMaps) {
          return;
        }
        this.relationIdMaps = this.rawRelationIdResults.map((rawRelationIdResult) => {
          const relation = rawRelationIdResult.relationIdAttribute.relation;
          let columns;
          if (relation.isManyToOne || relation.isOneToOneOwner) {
            columns = relation.joinColumns;
          } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {
            columns = relation.inverseEntityMetadata.primaryColumns;
          } else {
            if (relation.isOwning) {
              columns = relation.inverseJoinColumns;
            } else {
              columns = relation.inverseRelation.joinColumns;
            }
          }
          return rawRelationIdResult.results.reduce((agg, result) => {
            let idMap = columns.reduce((idMap2, column) => {
              let value = result[column.databaseName];
              if (relation.isOneToMany || relation.isOneToOneNotOwner) {
                if (column.isVirtual && column.referencedColumn && column.referencedColumn.propertyName !== column.propertyName) {
                  value = column.referencedColumn.createValueMap(value);
                }
                return OrmUtils_1.OrmUtils.mergeDeep(idMap2, column.createValueMap(value));
              }
              if (!column.isPrimary && column.referencedColumn.referencedColumn) {
                value = column.referencedColumn.referencedColumn.createValueMap(value);
              }
              return OrmUtils_1.OrmUtils.mergeDeep(idMap2, column.referencedColumn.createValueMap(value));
            }, {});
            if (columns.length === 1 && !rawRelationIdResult.relationIdAttribute.disableMixedMap) {
              if (relation.isOneToMany || relation.isOneToOneNotOwner) {
                idMap = columns[0].getEntityValue(idMap);
              } else {
                idMap = columns[0].referencedColumn.getEntityValue(idMap);
              }
            }
            if (idMap !== void 0) {
              const hash = this.hashEntityIds(relation, result);
              if (agg[hash]) {
                agg[hash].push(idMap);
              } else {
                agg[hash] = [idMap];
              }
            }
            return agg;
          }, {});
        });
      }
      /**
       * Use a simple JSON.stringify to create a simple hash of the primary ids of an entity.
       * As this.extractEntityPrimaryIds always creates the primary id object in the same order, if the same relation is
       * given, a simple JSON.stringify should be enough to get a unique hash per entity!
       */
      hashEntityIds(relation, data) {
        const entityPrimaryIds = this.extractEntityPrimaryIds(relation, data);
        return JSON.stringify(entityPrimaryIds);
      }
    };
    exports2.RawSqlResultsToEntityTransformer = RawSqlResultsToEntityTransformer;
  }
});

// node_modules/typeorm/query-builder/relation-id/RelationIdLoader.js
var require_RelationIdLoader = __commonJS({
  "node_modules/typeorm/query-builder/relation-id/RelationIdLoader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RelationIdLoader = void 0;
    var DriverUtils_1 = require_DriverUtils();
    var TypeORMError_1 = require_TypeORMError();
    var OrmUtils_1 = require_OrmUtils();
    var RelationIdLoader = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection, queryRunner, relationIdAttributes) {
        this.connection = connection;
        this.queryRunner = queryRunner;
        this.relationIdAttributes = relationIdAttributes;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      async load(rawEntities) {
        const promises = this.relationIdAttributes.map(async (relationIdAttr) => {
          if (relationIdAttr.relation.isManyToOne || relationIdAttr.relation.isOneToOneOwner) {
            if (relationIdAttr.queryBuilderFactory)
              throw new TypeORMError_1.TypeORMError("Additional condition can not be used with ManyToOne or OneToOne owner relations.");
            const duplicates = {};
            const results = rawEntities.map((rawEntity) => {
              const result = {};
              const duplicateParts = [];
              relationIdAttr.relation.joinColumns.forEach((joinColumn) => {
                result[joinColumn.databaseName] = this.connection.driver.prepareHydratedValue(rawEntity[DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, void 0, relationIdAttr.parentAlias, joinColumn.databaseName)], joinColumn.referencedColumn);
                const duplicatePart = `${joinColumn.databaseName}:${result[joinColumn.databaseName]}`;
                if (duplicateParts.indexOf(duplicatePart) === -1) {
                  duplicateParts.push(duplicatePart);
                }
              });
              relationIdAttr.relation.entityMetadata.primaryColumns.forEach((primaryColumn) => {
                result[primaryColumn.databaseName] = this.connection.driver.prepareHydratedValue(rawEntity[DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, void 0, relationIdAttr.parentAlias, primaryColumn.databaseName)], primaryColumn);
                const duplicatePart = `${primaryColumn.databaseName}:${result[primaryColumn.databaseName]}`;
                if (duplicateParts.indexOf(duplicatePart) === -1) {
                  duplicateParts.push(duplicatePart);
                }
              });
              duplicateParts.sort();
              const duplicate = duplicateParts.join("::");
              if (duplicates[duplicate]) {
                return null;
              }
              duplicates[duplicate] = true;
              return result;
            }).filter((v) => v);
            return {
              relationIdAttribute: relationIdAttr,
              results
            };
          } else if (relationIdAttr.relation.isOneToMany || relationIdAttr.relation.isOneToOneNotOwner) {
            const relation = relationIdAttr.relation;
            const joinColumns = relation.isOwning ? relation.joinColumns : relation.inverseRelation.joinColumns;
            const table = relation.inverseEntityMetadata.target;
            const tableName = relation.inverseEntityMetadata.tableName;
            const tableAlias = relationIdAttr.alias || tableName;
            const duplicates = {};
            const parameters = {};
            const condition = rawEntities.map((rawEntity, index) => {
              const duplicateParts = [];
              const parameterParts = {};
              const queryPart = joinColumns.map((joinColumn) => {
                const parameterName = joinColumn.databaseName + index;
                const parameterValue = rawEntity[DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, void 0, relationIdAttr.parentAlias, joinColumn.referencedColumn.databaseName)];
                const duplicatePart = `${tableAlias}:${joinColumn.propertyPath}:${parameterValue}`;
                if (duplicateParts.indexOf(duplicatePart) !== -1) {
                  return "";
                }
                duplicateParts.push(duplicatePart);
                parameterParts[parameterName] = parameterValue;
                return tableAlias + "." + joinColumn.propertyPath + " = :" + parameterName;
              }).filter((v) => v).join(" AND ");
              duplicateParts.sort();
              const duplicate = duplicateParts.join("::");
              if (duplicates[duplicate]) {
                return "";
              }
              duplicates[duplicate] = true;
              Object.assign(parameters, parameterParts);
              return queryPart;
            }).filter((v) => v).map((condition2) => "(" + condition2 + ")").join(" OR ");
            if (!condition)
              return {
                relationIdAttribute: relationIdAttr,
                results: []
              };
            const qb = this.connection.createQueryBuilder(this.queryRunner);
            const columns = OrmUtils_1.OrmUtils.uniq([
              ...joinColumns,
              ...relation.inverseRelation.entityMetadata.primaryColumns
            ], (column) => column.propertyPath);
            columns.forEach((joinColumn) => {
              qb.addSelect(tableAlias + "." + joinColumn.propertyPath, joinColumn.databaseName);
            });
            qb.from(table, tableAlias).where("(" + condition + ")").setParameters(parameters);
            if (relationIdAttr.queryBuilderFactory)
              relationIdAttr.queryBuilderFactory(qb);
            const results = await qb.getRawMany();
            results.forEach((result) => {
              joinColumns.forEach((column) => {
                result[column.databaseName] = this.connection.driver.prepareHydratedValue(result[column.databaseName], column.referencedColumn);
              });
              relation.inverseRelation.entityMetadata.primaryColumns.forEach((column) => {
                result[column.databaseName] = this.connection.driver.prepareHydratedValue(result[column.databaseName], column);
              });
            });
            return {
              relationIdAttribute: relationIdAttr,
              results
            };
          } else {
            const relation = relationIdAttr.relation;
            const joinColumns = relation.isOwning ? relation.joinColumns : relation.inverseRelation.inverseJoinColumns;
            const inverseJoinColumns = relation.isOwning ? relation.inverseJoinColumns : relation.inverseRelation.joinColumns;
            const junctionAlias = relationIdAttr.junctionAlias;
            const inverseSideTableName = relationIdAttr.joinInverseSideMetadata.tableName;
            const inverseSideTableAlias = relationIdAttr.alias || inverseSideTableName;
            const junctionTableName = relation.isOwning ? relation.junctionEntityMetadata.tableName : relation.inverseRelation.junctionEntityMetadata.tableName;
            const mappedColumns = rawEntities.map((rawEntity) => {
              return joinColumns.reduce((map, joinColumn) => {
                map[joinColumn.propertyPath] = rawEntity[DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, void 0, relationIdAttr.parentAlias, joinColumn.referencedColumn.databaseName)];
                return map;
              }, {});
            });
            if (mappedColumns.length === 0)
              return {
                relationIdAttribute: relationIdAttr,
                results: []
              };
            const parameters = {};
            const duplicates = {};
            const joinColumnConditions = mappedColumns.map((mappedColumn, index) => {
              const duplicateParts = [];
              const parameterParts = {};
              const queryPart = Object.keys(mappedColumn).map((key) => {
                const parameterName = key + index;
                const parameterValue = mappedColumn[key];
                const duplicatePart = `${junctionAlias}:${key}:${parameterValue}`;
                if (duplicateParts.indexOf(duplicatePart) !== -1) {
                  return "";
                }
                duplicateParts.push(duplicatePart);
                parameterParts[parameterName] = parameterValue;
                return junctionAlias + "." + key + " = :" + parameterName;
              }).filter((s) => s).join(" AND ");
              duplicateParts.sort();
              const duplicate = duplicateParts.join("::");
              if (duplicates[duplicate]) {
                return "";
              }
              duplicates[duplicate] = true;
              Object.assign(parameters, parameterParts);
              return queryPart;
            }).filter((s) => s);
            const inverseJoinColumnCondition = inverseJoinColumns.map((joinColumn) => {
              return junctionAlias + "." + joinColumn.propertyPath + " = " + inverseSideTableAlias + "." + joinColumn.referencedColumn.propertyPath;
            }).join(" AND ");
            const condition = joinColumnConditions.map((condition2) => {
              return "(" + condition2 + " AND " + inverseJoinColumnCondition + ")";
            }).join(" OR ");
            const qb = this.connection.createQueryBuilder(this.queryRunner);
            inverseJoinColumns.forEach((joinColumn) => {
              qb.addSelect(junctionAlias + "." + joinColumn.propertyPath, joinColumn.databaseName).addOrderBy(junctionAlias + "." + joinColumn.propertyPath);
            });
            joinColumns.forEach((joinColumn) => {
              qb.addSelect(junctionAlias + "." + joinColumn.propertyPath, joinColumn.databaseName).addOrderBy(junctionAlias + "." + joinColumn.propertyPath);
            });
            qb.from(inverseSideTableName, inverseSideTableAlias).innerJoin(junctionTableName, junctionAlias, condition).setParameters(parameters);
            if (relationIdAttr.queryBuilderFactory)
              relationIdAttr.queryBuilderFactory(qb);
            const results = await qb.getRawMany();
            results.forEach((result) => {
              ;
              [...joinColumns, ...inverseJoinColumns].forEach((column) => {
                result[column.databaseName] = this.connection.driver.prepareHydratedValue(result[column.databaseName], column.referencedColumn);
              });
            });
            return {
              relationIdAttribute: relationIdAttr,
              results
            };
          }
        });
        return Promise.all(promises);
      }
    };
    exports2.RelationIdLoader = RelationIdLoader;
  }
});

// node_modules/typeorm/query-builder/RelationIdLoader.js
var require_RelationIdLoader2 = __commonJS({
  "node_modules/typeorm/query-builder/RelationIdLoader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RelationIdLoader = void 0;
    var DriverUtils_1 = require_DriverUtils();
    var RelationIdLoader = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection, queryRunner) {
        this.connection = connection;
        this.queryRunner = queryRunner;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Loads relation ids of the given entity or entities.
       */
      load(relation, entityOrEntities, relatedEntityOrRelatedEntities) {
        const entities = Array.isArray(entityOrEntities) ? entityOrEntities : [entityOrEntities];
        const relatedEntities = Array.isArray(relatedEntityOrRelatedEntities) ? relatedEntityOrRelatedEntities : relatedEntityOrRelatedEntities ? [relatedEntityOrRelatedEntities] : void 0;
        if (relation.isManyToMany) {
          return this.loadForManyToMany(relation, entities, relatedEntities);
        } else if (relation.isManyToOne || relation.isOneToOneOwner) {
          return this.loadForManyToOneAndOneToOneOwner(relation, entities, relatedEntities);
        } else {
          return this.loadForOneToManyAndOneToOneNotOwner(relation, entities, relatedEntities);
        }
      }
      /**
       * Loads relation ids of the given entities and groups them into the object with parent and children.
       *
       * todo: extract this method?
       */
      async loadManyToManyRelationIdsAndGroup(relation, entitiesOrEntities, relatedEntityOrEntities, queryBuilder) {
        const isMany = relation.isManyToMany || relation.isOneToMany;
        const entities = Array.isArray(entitiesOrEntities) ? entitiesOrEntities : [entitiesOrEntities];
        if (!relatedEntityOrEntities) {
          relatedEntityOrEntities = await this.connection.relationLoader.load(relation, entitiesOrEntities, this.queryRunner, queryBuilder);
          if (!relatedEntityOrEntities.length)
            return entities.map((entity) => ({
              entity,
              related: isMany ? [] : void 0
            }));
        }
        const relationIds = await this.load(relation, entitiesOrEntities, relatedEntityOrEntities);
        const relatedEntities = Array.isArray(relatedEntityOrEntities) ? relatedEntityOrEntities : [relatedEntityOrEntities];
        let columns = [], inverseColumns = [];
        if (relation.isManyToManyOwner) {
          columns = relation.junctionEntityMetadata.inverseColumns.map((column) => column.referencedColumn);
          inverseColumns = relation.junctionEntityMetadata.ownerColumns.map((column) => column.referencedColumn);
        } else if (relation.isManyToManyNotOwner) {
          columns = relation.junctionEntityMetadata.ownerColumns.map((column) => column.referencedColumn);
          inverseColumns = relation.junctionEntityMetadata.inverseColumns.map((column) => column.referencedColumn);
        } else if (relation.isManyToOne || relation.isOneToOneOwner) {
          columns = relation.joinColumns.map((column) => column.referencedColumn);
          inverseColumns = relation.entityMetadata.primaryColumns;
        } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {
          columns = relation.inverseRelation.entityMetadata.primaryColumns;
          inverseColumns = relation.inverseRelation.joinColumns.map((column) => column.referencedColumn);
        } else {
        }
        return entities.map((entity) => {
          const group = {
            entity,
            related: isMany ? [] : void 0
          };
          const entityRelationIds = relationIds.filter((relationId) => {
            return inverseColumns.every((column) => {
              return column.compareEntityValue(entity, relationId[column.entityMetadata.name + "_" + column.propertyAliasName]);
            });
          });
          if (!entityRelationIds.length)
            return group;
          relatedEntities.forEach((relatedEntity) => {
            entityRelationIds.forEach((relationId) => {
              const relatedEntityMatched = columns.every((column) => {
                return column.compareEntityValue(relatedEntity, relationId[DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, void 0, column.entityMetadata.name + "_" + relation.propertyPath.replace(".", "_") + "_" + column.propertyPath.replace(".", "_"))]);
              });
              if (relatedEntityMatched) {
                if (isMany) {
                  ;
                  group.related.push(relatedEntity);
                } else {
                  group.related = relatedEntity;
                }
              }
            });
          });
          return group;
        });
      }
      /**
       * Loads relation ids of the given entities and maps them into the given entity property.
       async loadManyToManyRelationIdsAndMap(
       relation: RelationMetadata,
       entityOrEntities: ObjectLiteral|ObjectLiteral[],
       mapToEntityOrEntities: ObjectLiteral|ObjectLiteral[],
       propertyName: string
       ): Promise<void> {
          const relationIds = await this.loadManyToManyRelationIds(relation, entityOrEntities, mapToEntityOrEntities);
          const mapToEntities = mapToEntityOrEntities instanceof Array ? mapToEntityOrEntities : [mapToEntityOrEntities];
          const junctionMetadata = relation.junctionEntityMetadata!;
          const mainAlias = junctionMetadata.name;
          const columns = relation.isOwning ? junctionMetadata.inverseColumns : junctionMetadata.ownerColumns;
          const inverseColumns = relation.isOwning ? junctionMetadata.ownerColumns : junctionMetadata.inverseColumns;
          mapToEntities.forEach(mapToEntity => {
              mapToEntity[propertyName] = [];
              relationIds.forEach(relationId => {
                  const match = inverseColumns.every(column => {
                      return column.referencedColumn!.getEntityValue(mapToEntity) === relationId[mainAlias + "_" + column.propertyName];
                  });
                  if (match) {
                      if (columns.length === 1) {
                          mapToEntity[propertyName].push(relationId[mainAlias + "_" + columns[0].propertyName]);
                      } else {
                          const value = {};
                          columns.forEach(column => {
                              column.referencedColumn!.setEntityValue(value, relationId[mainAlias + "_" + column.propertyName]);
                          });
                          mapToEntity[propertyName].push(value);
                      }
                  }
              });
          });
      }*/
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Loads relation ids for the many-to-many relation.
       */
      loadForManyToMany(relation, entities, relatedEntities) {
        const junctionMetadata = relation.junctionEntityMetadata;
        const mainAlias = junctionMetadata.name;
        const columns = relation.isOwning ? junctionMetadata.ownerColumns : junctionMetadata.inverseColumns;
        const inverseColumns = relation.isOwning ? junctionMetadata.inverseColumns : junctionMetadata.ownerColumns;
        const qb = this.connection.createQueryBuilder(this.queryRunner);
        columns.forEach((column) => {
          const columnName = DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, void 0, column.referencedColumn.entityMetadata.name + "_" + column.referencedColumn.propertyPath.replace(".", "_"));
          qb.addSelect(mainAlias + "." + column.propertyPath, columnName);
        });
        inverseColumns.forEach((column) => {
          const columnName = DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, void 0, column.referencedColumn.entityMetadata.name + "_" + relation.propertyPath.replace(".", "_") + "_" + column.referencedColumn.propertyPath.replace(".", "_"));
          qb.addSelect(mainAlias + "." + column.propertyPath, columnName);
        });
        let condition1 = "";
        if (columns.length === 1) {
          const values = entities.map((entity) => columns[0].referencedColumn.getEntityValue(entity));
          const areAllNumbers = values.every((value) => typeof value === "number");
          if (areAllNumbers) {
            condition1 = `${mainAlias}.${columns[0].propertyPath} IN (${values.join(", ")})`;
          } else {
            qb.setParameter("values1", values);
            condition1 = mainAlias + "." + columns[0].propertyPath + " IN (:...values1)";
          }
        } else {
          condition1 = "(" + entities.map((entity, entityIndex) => {
            return columns.map((column) => {
              const paramName = "entity1_" + entityIndex + "_" + column.propertyName;
              qb.setParameter(paramName, column.referencedColumn.getEntityValue(entity));
              return mainAlias + "." + column.propertyPath + " = :" + paramName;
            }).join(" AND ");
          }).map((condition3) => "(" + condition3 + ")").join(" OR ") + ")";
        }
        let condition2 = "";
        if (relatedEntities) {
          if (inverseColumns.length === 1) {
            const values = relatedEntities.map((entity) => inverseColumns[0].referencedColumn.getEntityValue(entity));
            const areAllNumbers = values.every((value) => typeof value === "number");
            if (areAllNumbers) {
              condition2 = `${mainAlias}.${inverseColumns[0].propertyPath} IN (${values.join(", ")})`;
            } else {
              qb.setParameter("values2", values);
              condition2 = mainAlias + "." + inverseColumns[0].propertyPath + " IN (:...values2)";
            }
          } else {
            condition2 = "(" + relatedEntities.map((entity, entityIndex) => {
              return inverseColumns.map((column) => {
                const paramName = "entity2_" + entityIndex + "_" + column.propertyName;
                qb.setParameter(paramName, column.referencedColumn.getEntityValue(entity));
                return mainAlias + "." + column.propertyPath + " = :" + paramName;
              }).join(" AND ");
            }).map((condition3) => "(" + condition3 + ")").join(" OR ") + ")";
          }
        }
        const condition = [condition1, condition2].filter((v) => v.length > 0).join(" AND ");
        return qb.from(junctionMetadata.target, mainAlias).where(condition).getRawMany();
      }
      /**
       * Loads relation ids for the many-to-one and one-to-one owner relations.
       */
      loadForManyToOneAndOneToOneOwner(relation, entities, relatedEntities) {
        const mainAlias = relation.entityMetadata.targetName;
        const hasAllJoinColumnsInEntity = relation.joinColumns.every((joinColumn) => {
          return !!relation.entityMetadata.nonVirtualColumns.find((column) => column === joinColumn);
        });
        if (relatedEntities && hasAllJoinColumnsInEntity) {
          const relationIdMaps = [];
          entities.forEach((entity) => {
            const relationIdMap = {};
            relation.entityMetadata.primaryColumns.forEach((primaryColumn) => {
              const key = primaryColumn.entityMetadata.name + "_" + primaryColumn.propertyPath.replace(".", "_");
              relationIdMap[key] = primaryColumn.getEntityValue(entity);
            });
            relatedEntities.forEach((relatedEntity) => {
              relation.joinColumns.forEach((joinColumn) => {
                const entityColumnValue = joinColumn.getEntityValue(entity);
                const relatedEntityColumnValue = joinColumn.referencedColumn.getEntityValue(relatedEntity);
                if (entityColumnValue === void 0 || relatedEntityColumnValue === void 0)
                  return;
                if (entityColumnValue === relatedEntityColumnValue) {
                  const key = joinColumn.referencedColumn.entityMetadata.name + "_" + relation.propertyPath.replace(".", "_") + "_" + joinColumn.referencedColumn.propertyPath.replace(".", "_");
                  relationIdMap[key] = relatedEntityColumnValue;
                }
              });
            });
            if (Object.keys(relationIdMap).length === relation.entityMetadata.primaryColumns.length + relation.joinColumns.length) {
              relationIdMaps.push(relationIdMap);
            }
          });
          if (relationIdMaps.length === entities.length)
            return Promise.resolve(relationIdMaps);
        }
        const qb = this.connection.createQueryBuilder(this.queryRunner);
        relation.entityMetadata.primaryColumns.forEach((primaryColumn) => {
          const columnName = DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, void 0, primaryColumn.entityMetadata.name + "_" + primaryColumn.propertyPath.replace(".", "_"));
          qb.addSelect(mainAlias + "." + primaryColumn.propertyPath, columnName);
        });
        relation.joinColumns.forEach((column) => {
          const columnName = DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, void 0, column.referencedColumn.entityMetadata.name + "_" + relation.propertyPath.replace(".", "_") + "_" + column.referencedColumn.propertyPath.replace(".", "_"));
          qb.addSelect(mainAlias + "." + column.propertyPath, columnName);
        });
        let condition = "";
        if (relation.entityMetadata.primaryColumns.length === 1) {
          const values = entities.map((entity) => relation.entityMetadata.primaryColumns[0].getEntityValue(entity));
          const areAllNumbers = values.every((value) => typeof value === "number");
          if (areAllNumbers) {
            condition = `${mainAlias}.${relation.entityMetadata.primaryColumns[0].propertyPath} IN (${values.join(", ")})`;
          } else {
            qb.setParameter("values", values);
            condition = mainAlias + "." + relation.entityMetadata.primaryColumns[0].propertyPath + " IN (:...values)";
          }
        } else {
          condition = entities.map((entity, entityIndex) => {
            return relation.entityMetadata.primaryColumns.map((column, columnIndex) => {
              const paramName = "entity" + entityIndex + "_" + columnIndex;
              qb.setParameter(paramName, column.getEntityValue(entity));
              return mainAlias + "." + column.propertyPath + " = :" + paramName;
            }).join(" AND ");
          }).map((condition2) => "(" + condition2 + ")").join(" OR ");
        }
        return qb.from(relation.entityMetadata.target, mainAlias).where(condition).getRawMany();
      }
      /**
       * Loads relation ids for the one-to-many and one-to-one not owner relations.
       */
      loadForOneToManyAndOneToOneNotOwner(relation, entities, relatedEntities) {
        const originalRelation = relation;
        relation = relation.inverseRelation;
        if (relation.entityMetadata.primaryColumns.length === relation.joinColumns.length) {
          const sameReferencedColumns = relation.entityMetadata.primaryColumns.every((column) => {
            return relation.joinColumns.indexOf(column) !== -1;
          });
          if (sameReferencedColumns) {
            return Promise.resolve(entities.map((entity) => {
              const result = {};
              relation.joinColumns.forEach(function(joinColumn) {
                const value = joinColumn.referencedColumn.getEntityValue(entity);
                const joinColumnName = joinColumn.referencedColumn.entityMetadata.name + "_" + joinColumn.referencedColumn.propertyPath.replace(".", "_");
                const primaryColumnName = joinColumn.entityMetadata.name + "_" + originalRelation.propertyPath.replace(".", "_") + "_" + joinColumn.propertyPath.replace(".", "_");
                result[joinColumnName] = value;
                result[primaryColumnName] = value;
              });
              return result;
            }));
          }
        }
        const mainAlias = relation.entityMetadata.targetName;
        const qb = this.connection.createQueryBuilder(this.queryRunner);
        relation.entityMetadata.primaryColumns.forEach((primaryColumn) => {
          const columnName = DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, void 0, primaryColumn.entityMetadata.name + "_" + originalRelation.propertyPath.replace(".", "_") + "_" + primaryColumn.propertyPath.replace(".", "_"));
          qb.addSelect(mainAlias + "." + primaryColumn.propertyPath, columnName);
        });
        relation.joinColumns.forEach((column) => {
          const columnName = DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, void 0, column.referencedColumn.entityMetadata.name + "_" + column.referencedColumn.propertyPath.replace(".", "_"));
          qb.addSelect(mainAlias + "." + column.propertyPath, columnName);
        });
        let condition = "";
        if (relation.joinColumns.length === 1) {
          const values = entities.map((entity) => relation.joinColumns[0].referencedColumn.getEntityValue(entity));
          const areAllNumbers = values.every((value) => typeof value === "number");
          if (areAllNumbers) {
            condition = `${mainAlias}.${relation.joinColumns[0].propertyPath} IN (${values.join(", ")})`;
          } else {
            qb.setParameter("values", values);
            condition = mainAlias + "." + relation.joinColumns[0].propertyPath + " IN (:...values)";
          }
        } else {
          condition = entities.map((entity, entityIndex) => {
            return relation.joinColumns.map((joinColumn, joinColumnIndex) => {
              const paramName = "entity" + entityIndex + "_" + joinColumnIndex;
              qb.setParameter(paramName, joinColumn.referencedColumn.getEntityValue(entity));
              return mainAlias + "." + joinColumn.propertyPath + " = :" + paramName;
            }).join(" AND ");
          }).map((condition2) => "(" + condition2 + ")").join(" OR ");
        }
        return qb.from(relation.entityMetadata.target, mainAlias).where(condition).getRawMany();
      }
    };
    exports2.RelationIdLoader = RelationIdLoader;
  }
});

// node_modules/typeorm/query-builder/relation-id/RelationIdMetadataToAttributeTransformer.js
var require_RelationIdMetadataToAttributeTransformer = __commonJS({
  "node_modules/typeorm/query-builder/relation-id/RelationIdMetadataToAttributeTransformer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RelationIdMetadataToAttributeTransformer = void 0;
    var RelationIdAttribute_1 = require_RelationIdAttribute();
    var RelationIdMetadataToAttributeTransformer = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(expressionMap) {
        this.expressionMap = expressionMap;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      transform() {
        if (this.expressionMap.mainAlias) {
          this.expressionMap.mainAlias.metadata.relationIds.forEach((relationId) => {
            const attribute = this.metadataToAttribute(this.expressionMap.mainAlias.name, relationId);
            this.expressionMap.relationIdAttributes.push(attribute);
          });
        }
        this.expressionMap.joinAttributes.forEach((join) => {
          if (!join.metadata || join.metadata.isJunction)
            return;
          join.metadata.relationIds.forEach((relationId) => {
            const attribute = this.metadataToAttribute(join.alias.name, relationId);
            this.expressionMap.relationIdAttributes.push(attribute);
          });
        });
      }
      // -------------------------------------------------------------------------
      // Private Methods
      // -------------------------------------------------------------------------
      metadataToAttribute(parentAliasName, relationId) {
        return new RelationIdAttribute_1.RelationIdAttribute(this.expressionMap, {
          relationName: parentAliasName + "." + relationId.relation.propertyName,
          // category.images
          mapToProperty: parentAliasName + "." + relationId.propertyName,
          // category.imageIds
          alias: relationId.alias,
          queryBuilderFactory: relationId.queryBuilderFactory
        });
      }
    };
    exports2.RelationIdMetadataToAttributeTransformer = RelationIdMetadataToAttributeTransformer;
  }
});

// node_modules/typeorm/query-builder/relation-count/RelationCountLoader.js
var require_RelationCountLoader = __commonJS({
  "node_modules/typeorm/query-builder/relation-count/RelationCountLoader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RelationCountLoader = void 0;
    var RelationCountLoader = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection, queryRunner, relationCountAttributes) {
        this.connection = connection;
        this.queryRunner = queryRunner;
        this.relationCountAttributes = relationCountAttributes;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      async load(rawEntities) {
        const onlyUnique = (value, index, self2) => {
          return self2.indexOf(value) === index;
        };
        const promises = this.relationCountAttributes.map(async (relationCountAttr) => {
          if (relationCountAttr.relation.isOneToMany) {
            const relation = relationCountAttr.relation;
            const inverseRelation = relation.inverseRelation;
            const referenceColumnName = inverseRelation.joinColumns[0].referencedColumn.propertyName;
            const inverseSideTable = relation.inverseEntityMetadata.target;
            const inverseSideTableName = relation.inverseEntityMetadata.tableName;
            const inverseSideTableAlias = relationCountAttr.alias || inverseSideTableName;
            const inverseSidePropertyName = inverseRelation.propertyName;
            let referenceColumnValues = rawEntities.map((rawEntity) => rawEntity[relationCountAttr.parentAlias + "_" + referenceColumnName]).filter((value) => !!value);
            referenceColumnValues = referenceColumnValues.filter(onlyUnique);
            if (referenceColumnValues.length === 0)
              return {
                relationCountAttribute: relationCountAttr,
                results: []
              };
            const qb = this.connection.createQueryBuilder(this.queryRunner);
            qb.select(inverseSideTableAlias + "." + inverseSidePropertyName, "parentId").addSelect("COUNT(*)", "cnt").from(inverseSideTable, inverseSideTableAlias).where(inverseSideTableAlias + "." + inverseSidePropertyName + " IN (:...ids)").addGroupBy(inverseSideTableAlias + "." + inverseSidePropertyName).setParameter("ids", referenceColumnValues);
            if (relationCountAttr.queryBuilderFactory)
              relationCountAttr.queryBuilderFactory(qb);
            return {
              relationCountAttribute: relationCountAttr,
              results: await qb.getRawMany()
            };
          } else {
            let joinTableColumnName;
            let inverseJoinColumnName;
            let firstJunctionColumn;
            let secondJunctionColumn;
            if (relationCountAttr.relation.isOwning) {
              joinTableColumnName = relationCountAttr.relation.joinColumns[0].referencedColumn.databaseName;
              inverseJoinColumnName = relationCountAttr.relation.inverseJoinColumns[0].referencedColumn.databaseName;
              firstJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[0];
              secondJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[1];
            } else {
              joinTableColumnName = relationCountAttr.relation.inverseRelation.inverseJoinColumns[0].referencedColumn.databaseName;
              inverseJoinColumnName = relationCountAttr.relation.inverseRelation.joinColumns[0].referencedColumn.databaseName;
              firstJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[1];
              secondJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[0];
            }
            let referenceColumnValues = rawEntities.map((rawEntity) => rawEntity[relationCountAttr.parentAlias + "_" + joinTableColumnName]).filter((value) => !!value);
            referenceColumnValues = referenceColumnValues.filter(onlyUnique);
            if (referenceColumnValues.length === 0)
              return {
                relationCountAttribute: relationCountAttr,
                results: []
              };
            const junctionAlias = relationCountAttr.junctionAlias;
            const inverseSideTableName = relationCountAttr.joinInverseSideMetadata.tableName;
            const inverseSideTableAlias = relationCountAttr.alias || inverseSideTableName;
            const junctionTableName = relationCountAttr.relation.junctionEntityMetadata.tableName;
            const condition = junctionAlias + "." + firstJunctionColumn.propertyName + " IN (" + referenceColumnValues.map((vals) => isNaN(vals) ? "'" + vals + "'" : vals) + ") AND " + junctionAlias + "." + secondJunctionColumn.propertyName + " = " + inverseSideTableAlias + "." + inverseJoinColumnName;
            const qb = this.connection.createQueryBuilder(this.queryRunner);
            qb.select(junctionAlias + "." + firstJunctionColumn.propertyName, "parentId").addSelect("COUNT(" + qb.escape(inverseSideTableAlias) + "." + qb.escape(inverseJoinColumnName) + ")", "cnt").from(inverseSideTableName, inverseSideTableAlias).innerJoin(junctionTableName, junctionAlias, condition).addGroupBy(junctionAlias + "." + firstJunctionColumn.propertyName);
            if (relationCountAttr.queryBuilderFactory)
              relationCountAttr.queryBuilderFactory(qb);
            return {
              relationCountAttribute: relationCountAttr,
              results: await qb.getRawMany()
            };
          }
        });
        return Promise.all(promises);
      }
    };
    exports2.RelationCountLoader = RelationCountLoader;
  }
});

// node_modules/typeorm/query-builder/relation-count/RelationCountMetadataToAttributeTransformer.js
var require_RelationCountMetadataToAttributeTransformer = __commonJS({
  "node_modules/typeorm/query-builder/relation-count/RelationCountMetadataToAttributeTransformer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RelationCountMetadataToAttributeTransformer = void 0;
    var RelationCountAttribute_1 = require_RelationCountAttribute();
    var RelationCountMetadataToAttributeTransformer = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(expressionMap) {
        this.expressionMap = expressionMap;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      transform() {
        if (this.expressionMap.mainAlias) {
          this.expressionMap.mainAlias.metadata.relationCounts.forEach((relationCount) => {
            const attribute = this.metadataToAttribute(this.expressionMap.mainAlias.name, relationCount);
            this.expressionMap.relationCountAttributes.push(attribute);
          });
        }
        this.expressionMap.joinAttributes.forEach((join) => {
          if (!join.metadata || join.metadata.isJunction)
            return;
          join.metadata.relationCounts.forEach((relationCount) => {
            const attribute = this.metadataToAttribute(join.alias.name, relationCount);
            this.expressionMap.relationCountAttributes.push(attribute);
          });
        });
      }
      // -------------------------------------------------------------------------
      // Private Methods
      // -------------------------------------------------------------------------
      metadataToAttribute(parentAliasName, relationCount) {
        return new RelationCountAttribute_1.RelationCountAttribute(this.expressionMap, {
          relationName: parentAliasName + "." + relationCount.relation.propertyName,
          // category.images
          mapToProperty: parentAliasName + "." + relationCount.propertyName,
          // category.imageIds
          alias: relationCount.alias,
          queryBuilderFactory: relationCount.queryBuilderFactory
        });
      }
    };
    exports2.RelationCountMetadataToAttributeTransformer = RelationCountMetadataToAttributeTransformer;
  }
});

// node_modules/typeorm/find-options/FindOptionsUtils.js
var require_FindOptionsUtils = __commonJS({
  "node_modules/typeorm/find-options/FindOptionsUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FindOptionsUtils = void 0;
    var error_1 = require_error();
    var DriverUtils_1 = require_DriverUtils();
    var error_2 = require_error();
    var FindOptionsUtils2 = class _FindOptionsUtils {
      // -------------------------------------------------------------------------
      // Public Static Methods
      // -------------------------------------------------------------------------
      /**
       * Checks if given object is really instance of FindOneOptions interface.
       */
      static isFindOneOptions(obj) {
        const possibleOptions = obj;
        return possibleOptions && (Array.isArray(possibleOptions.select) || Array.isArray(possibleOptions.relations) || typeof possibleOptions.select === "object" || typeof possibleOptions.relations === "object" || typeof possibleOptions.where === "object" || // typeof possibleOptions.where === "string" ||
        typeof possibleOptions.join === "object" || typeof possibleOptions.order === "object" || typeof possibleOptions.cache === "object" || typeof possibleOptions.cache === "boolean" || typeof possibleOptions.cache === "number" || typeof possibleOptions.comment === "string" || typeof possibleOptions.lock === "object" || typeof possibleOptions.loadRelationIds === "object" || typeof possibleOptions.loadRelationIds === "boolean" || typeof possibleOptions.loadEagerRelations === "boolean" || typeof possibleOptions.withDeleted === "boolean" || typeof possibleOptions.relationLoadStrategy === "string" || typeof possibleOptions.transaction === "boolean");
      }
      /**
       * Checks if given object is really instance of FindManyOptions interface.
       */
      static isFindManyOptions(obj) {
        const possibleOptions = obj;
        return possibleOptions && (this.isFindOneOptions(possibleOptions) || typeof possibleOptions.skip === "number" || typeof possibleOptions.take === "number" || typeof possibleOptions.skip === "string" || typeof possibleOptions.take === "string");
      }
      /**
       * Checks if given object is really instance of FindOptions interface.
       */
      static extractFindManyOptionsAlias(object) {
        if (this.isFindManyOptions(object) && object.join)
          return object.join.alias;
        return void 0;
      }
      /**
           * Applies give find many options to the given query builder.
      
          static applyFindManyOptionsOrConditionsToQueryBuilder<T>(qb: SelectQueryBuilder<T>, options: FindManyOptions<T>|Partial<T>|undefined): SelectQueryBuilder<T> {
              if (this.isFindManyOptions(options))
                  return this.applyOptionsToQueryBuilder(qb, options);
      
              if (options)
                  return qb.where(options);
      
              return qb;
          }*/
      /**
           * Applies give find options to the given query builder.
      
          static applyOptionsToQueryBuilder<T>(qb: SelectQueryBuilder<T>, options: FindOneOptions<T>|FindManyOptions<T>|undefined): SelectQueryBuilder<T> {
      
              // if options are not set then simply return query builder. This is made for simplicity of usage.
              if (!options || (!this.isFindOneOptions(options) && !this.isFindManyOptions(options)))
                  return qb;
      
              if (options.transaction === true) {
                  qb.expressionMap.useTransaction = true;
              }
      
              if (!qb.expressionMap.mainAlias || !qb.expressionMap.mainAlias.hasMetadata)
                  return qb;
      
              const metadata = qb.expressionMap.mainAlias!.metadata;
      
              // apply all options from FindOptions
              if (options.comment) {
                  qb.comment(options.comment);
              }
      
              if (options.withDeleted) {
                  qb.withDeleted();
              }
      
              if (options.select) {
                  qb.select([]);
                  options.select.forEach(select => {
                      if (!metadata.hasColumnWithPropertyPath(`${select}`))
                          throw new TypeORMError(`${select} column was not found in the ${metadata.name} entity.`);
      
                      const columns = metadata.findColumnsWithPropertyPath(`${select}`);
      
                      for (const column of columns) {
                          qb.addSelect(qb.alias + "." + column.propertyPath);
                      }
                  });
              }
      
              if (options.relations) {
                  // Copy because `applyRelationsRecursively` modifies it
                  const allRelations = [...options.relations];
                  this.applyRelationsRecursively(qb, allRelations, qb.expressionMap.mainAlias!.name, qb.expressionMap.mainAlias!.metadata, "");
                  // recursive removes found relations from allRelations array
                  // if there are relations left in this array it means those relations were not found in the entity structure
                  // so, we give an exception about not found relations
                  if (allRelations.length > 0)
                      throw new FindRelationsNotFoundError(allRelations);
              }
      
              if (options.join) {
                  if (options.join.leftJoin)
                      Object.keys(options.join.leftJoin).forEach(key => {
                          qb.leftJoin(options.join!.leftJoin![key], key);
                      });
      
                  if (options.join.innerJoin)
                      Object.keys(options.join.innerJoin).forEach(key => {
                          qb.innerJoin(options.join!.innerJoin![key], key);
                      });
      
                  if (options.join.leftJoinAndSelect)
                      Object.keys(options.join.leftJoinAndSelect).forEach(key => {
                          qb.leftJoinAndSelect(options.join!.leftJoinAndSelect![key], key);
                      });
      
                  if (options.join.innerJoinAndSelect)
                      Object.keys(options.join.innerJoinAndSelect).forEach(key => {
                          qb.innerJoinAndSelect(options.join!.innerJoinAndSelect![key], key);
                      });
              }
      
              if (options.cache) {
                  if (options.cache instanceof Object) {
                      const cache = options.cache as { id: any, milliseconds: number };
                      qb.cache(cache.id, cache.milliseconds);
                  } else {
                      qb.cache(options.cache);
                  }
              }
      
              if (options.lock) {
                  if (options.lock.mode === "optimistic") {
                      qb.setLock(options.lock.mode, options.lock.version);
                  } else if (
                      options.lock.mode === "pessimistic_read" ||
                      options.lock.mode === "pessimistic_write" ||
                      options.lock.mode === "dirty_read" ||
                      options.lock.mode === "pessimistic_partial_write" ||
                      options.lock.mode === "pessimistic_write_or_fail" ||
                      options.lock.mode === "for_no_key_update" ||
                      options.lock.mode === "for_key_share"
                  ) {
                      const tableNames = options.lock.tables ? options.lock.tables.map((table) => {
                          const tableAlias = qb.expressionMap.aliases.find((alias) => {
                              return alias.metadata.tableNameWithoutPrefix === table;
                          });
                          if (!tableAlias) {
                              throw new TypeORMError(`"${table}" is not part of this query`);
                          }
                          return qb.escape(tableAlias.name);
                      }) : undefined;
                      qb.setLock(options.lock.mode, undefined, tableNames);
                  }
              }
      
              if (options.loadRelationIds === true) {
                  qb.loadAllRelationIds();
      
              } else if (options.loadRelationIds instanceof Object) {
                  qb.loadAllRelationIds(options.loadRelationIds as any);
              }
      
              if (options.where)
                  qb.where(options.where);
      
              if ((options as FindManyOptions<T>).skip)
                  qb.skip((options as FindManyOptions<T>).skip!);
      
              if ((options as FindManyOptions<T>).take)
                  qb.take((options as FindManyOptions<T>).take!);
      
              if (options.order)
                  Object.keys(options.order).forEach(key => {
                      const order = ((options as FindOneOptions<T>).order as any)[key as any];
      
                      if (!metadata.findColumnWithPropertyPath(key))
                          throw new Error(`${key} column was not found in the ${metadata.name} entity.`);
      
                      switch (order) {
                          case 1:
                              qb.addOrderBy(qb.alias + "." + key, "ASC");
                              break;
                          case -1:
                              qb.addOrderBy(qb.alias + "." + key, "DESC");
                              break;
                          case "ASC":
                              qb.addOrderBy(qb.alias + "." + key, "ASC");
                              break;
                          case "DESC":
                              qb.addOrderBy(qb.alias + "." + key, "DESC");
                              break;
                      }
                  });
      
              return qb;
          }*/
      static applyOptionsToTreeQueryBuilder(qb, options) {
        if (options?.relations) {
          const allRelations = [...options.relations];
          _FindOptionsUtils.applyRelationsRecursively(qb, allRelations, qb.expressionMap.mainAlias.name, qb.expressionMap.mainAlias.metadata, "");
          if (allRelations.length > 0)
            throw new error_1.FindRelationsNotFoundError(allRelations);
        }
        return qb;
      }
      // -------------------------------------------------------------------------
      // Protected Static Methods
      // -------------------------------------------------------------------------
      /**
       * Adds joins for all relations and sub-relations of the given relations provided in the find options.
       */
      static applyRelationsRecursively(qb, allRelations, alias, metadata, prefix) {
        let matchedBaseRelations = [];
        if (prefix) {
          const regexp = new RegExp("^" + prefix.replace(".", "\\.") + "\\.");
          matchedBaseRelations = allRelations.filter((relation) => relation.match(regexp)).map((relation) => metadata.findRelationWithPropertyPath(relation.replace(regexp, ""))).filter((entity) => entity);
        } else {
          matchedBaseRelations = allRelations.map((relation) => metadata.findRelationWithPropertyPath(relation)).filter((entity) => entity);
        }
        matchedBaseRelations.forEach((relation) => {
          const relationAlias = DriverUtils_1.DriverUtils.buildAlias(qb.connection.driver, { joiner: "__" }, alias, relation.propertyPath);
          const selection = alias + "." + relation.propertyPath;
          if (qb.expressionMap.relationLoadStrategy === "query") {
            qb.concatRelationMetadata(relation);
          } else {
            qb.leftJoinAndSelect(selection, relationAlias);
          }
          allRelations.splice(allRelations.indexOf(prefix ? prefix + "." + relation.propertyPath : relation.propertyPath), 1);
          let relationMetadata;
          let relationName;
          if (qb.expressionMap.relationLoadStrategy === "query") {
            relationMetadata = relation.inverseEntityMetadata;
            relationName = relationAlias;
          } else {
            const join = qb.expressionMap.joinAttributes.find((join2) => join2.entityOrProperty === selection);
            relationMetadata = join.metadata;
            relationName = join.alias.name;
          }
          if (!relationName || !relationMetadata) {
            throw new error_2.EntityPropertyNotFoundError(relation.propertyPath, metadata);
          }
          this.applyRelationsRecursively(qb, allRelations, relationName, relationMetadata, prefix ? prefix + "." + relation.propertyPath : relation.propertyPath);
          if (qb.expressionMap.relationLoadStrategy === "join") {
            const relMetadata = metadata.relations.find((metadata2) => metadata2.propertyName === relation.propertyPath);
            if (relMetadata) {
              this.joinEagerRelations(qb, relationAlias, relMetadata.inverseEntityMetadata);
            }
          }
        });
      }
      static joinEagerRelations(qb, alias, metadata) {
        metadata.eagerRelations.forEach((relation) => {
          let relationAlias = DriverUtils_1.DriverUtils.buildAlias(qb.connection.driver, { joiner: "__" }, alias, relation.propertyName);
          let addJoin = true;
          for (const join of qb.expressionMap.joinAttributes) {
            if (join.condition !== void 0 || join.mapToProperty !== void 0 || join.isMappingMany !== void 0 || join.direction !== "LEFT" || join.entityOrProperty !== `${alias}.${relation.propertyPath}`) {
              continue;
            }
            addJoin = false;
            relationAlias = join.alias.name;
            break;
          }
          const joinAlreadyAdded = Boolean(qb.expressionMap.joinAttributes.find((joinAttribute) => joinAttribute.alias.name === relationAlias));
          if (addJoin && !joinAlreadyAdded) {
            qb.leftJoin(alias + "." + relation.propertyPath, relationAlias);
          }
          let addSelect = true;
          for (const select of qb.expressionMap.selects) {
            if (select.aliasName !== void 0 || select.virtual !== void 0 || select.selection !== relationAlias) {
              continue;
            }
            addSelect = false;
            break;
          }
          if (addSelect) {
            qb.addSelect(relationAlias);
          }
          this.joinEagerRelations(qb, relationAlias, relation.inverseEntityMetadata);
        });
      }
    };
    exports2.FindOptionsUtils = FindOptionsUtils2;
  }
});

// node_modules/typeorm/query-builder/SelectQueryBuilder.js
var require_SelectQueryBuilder = __commonJS({
  "node_modules/typeorm/query-builder/SelectQueryBuilder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SelectQueryBuilder = void 0;
    var RawSqlResultsToEntityTransformer_1 = require_RawSqlResultsToEntityTransformer();
    var PessimisticLockTransactionRequiredError_1 = require_PessimisticLockTransactionRequiredError();
    var NoVersionOrUpdateDateColumnError_1 = require_NoVersionOrUpdateDateColumnError();
    var OptimisticLockVersionMismatchError_1 = require_OptimisticLockVersionMismatchError();
    var OptimisticLockCanNotBeUsedError_1 = require_OptimisticLockCanNotBeUsedError();
    var JoinAttribute_1 = require_JoinAttribute();
    var RelationIdAttribute_1 = require_RelationIdAttribute();
    var RelationCountAttribute_1 = require_RelationCountAttribute();
    var RelationIdLoader_1 = require_RelationIdLoader();
    var RelationIdLoader_2 = require_RelationIdLoader2();
    var RelationIdMetadataToAttributeTransformer_1 = require_RelationIdMetadataToAttributeTransformer();
    var RelationCountLoader_1 = require_RelationCountLoader();
    var RelationCountMetadataToAttributeTransformer_1 = require_RelationCountMetadataToAttributeTransformer();
    var QueryBuilder_1 = require_QueryBuilder();
    var LockNotSupportedOnGivenDriverError_1 = require_LockNotSupportedOnGivenDriverError();
    var OffsetWithoutLimitNotSupportedError_1 = require_OffsetWithoutLimitNotSupportedError();
    var ObjectUtils_1 = require_ObjectUtils();
    var DriverUtils_1 = require_DriverUtils();
    var EntityNotFoundError_1 = require_EntityNotFoundError();
    var error_1 = require_error();
    var FindOptionsUtils_1 = require_FindOptionsUtils();
    var OrmUtils_1 = require_OrmUtils();
    var EntityPropertyNotFoundError_1 = require_EntityPropertyNotFoundError();
    var InstanceChecker_1 = require_InstanceChecker();
    var FindOperator_1 = require_FindOperator();
    var ApplyValueTransformers_1 = require_ApplyValueTransformers();
    var SelectQueryBuilder2 = class _SelectQueryBuilder extends QueryBuilder_1.QueryBuilder {
      constructor() {
        super(...arguments);
        this["@instanceof"] = Symbol.for("SelectQueryBuilder");
        this.findOptions = {};
        this.selects = [];
        this.joins = [];
        this.conditions = "";
        this.orderBys = [];
        this.relationMetadatas = [];
      }
      // -------------------------------------------------------------------------
      // Public Implemented Methods
      // -------------------------------------------------------------------------
      /**
       * Gets generated SQL query without parameters being replaced.
       */
      getQuery() {
        let sql = this.createComment();
        sql += this.createCteExpression();
        sql += this.createSelectExpression();
        sql += this.createJoinExpression();
        sql += this.createWhereExpression();
        sql += this.createGroupByExpression();
        sql += this.createHavingExpression();
        sql += this.createOrderByExpression();
        sql += this.createLimitOffsetExpression();
        sql += this.createLockExpression();
        sql = sql.trim();
        if (this.expressionMap.subQuery)
          sql = "(" + sql + ")";
        return this.replacePropertyNamesForTheWholeQuery(sql);
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      setFindOptions(findOptions) {
        this.findOptions = findOptions;
        this.applyFindOptions();
        return this;
      }
      /**
       * Creates a subquery - query that can be used inside other queries.
       */
      subQuery() {
        const qb = this.createQueryBuilder();
        qb.expressionMap.subQuery = true;
        qb.parentQueryBuilder = this;
        return qb;
      }
      /**
       * Creates SELECT query and selects given data.
       * Replaces all previous selections if they exist.
       */
      select(selection, selectionAliasName) {
        this.expressionMap.queryType = "select";
        if (Array.isArray(selection)) {
          this.expressionMap.selects = selection.map((selection2) => ({
            selection: selection2
          }));
        } else if (typeof selection === "function") {
          const subQueryBuilder = selection(this.subQuery());
          this.setParameters(subQueryBuilder.getParameters());
          this.expressionMap.selects.push({
            selection: subQueryBuilder.getQuery(),
            aliasName: selectionAliasName
          });
        } else if (selection) {
          this.expressionMap.selects = [
            { selection, aliasName: selectionAliasName }
          ];
        }
        return this;
      }
      /**
       * Adds new selection to the SELECT query.
       */
      addSelect(selection, selectionAliasName) {
        if (!selection)
          return this;
        if (Array.isArray(selection)) {
          this.expressionMap.selects = this.expressionMap.selects.concat(selection.map((selection2) => ({ selection: selection2 })));
        } else if (typeof selection === "function") {
          const subQueryBuilder = selection(this.subQuery());
          this.setParameters(subQueryBuilder.getParameters());
          this.expressionMap.selects.push({
            selection: subQueryBuilder.getQuery(),
            aliasName: selectionAliasName
          });
        } else if (selection) {
          this.expressionMap.selects.push({
            selection,
            aliasName: selectionAliasName
          });
        }
        return this;
      }
      /**
       * Set max execution time.
       * @param milliseconds
       */
      maxExecutionTime(milliseconds) {
        this.expressionMap.maxExecutionTime = milliseconds;
        return this;
      }
      /**
       * Sets whether the selection is DISTINCT.
       */
      distinct(distinct = true) {
        this.expressionMap.selectDistinct = distinct;
        return this;
      }
      /**
       * Sets the distinct on clause for Postgres.
       */
      distinctOn(distinctOn) {
        this.expressionMap.selectDistinctOn = distinctOn;
        return this;
      }
      fromDummy() {
        return this.from(this.connection.driver.dummyTableName ?? "(SELECT 1 AS dummy_column)", "dummy_table");
      }
      /**
       * Specifies FROM which entity's table select/update/delete will be executed.
       * Also sets a main string alias of the selection data.
       * Removes all previously set from-s.
       */
      from(entityTarget, aliasName) {
        const mainAlias = this.createFromAlias(entityTarget, aliasName);
        this.expressionMap.setMainAlias(mainAlias);
        return this;
      }
      /**
       * Specifies FROM which entity's table select/update/delete will be executed.
       * Also sets a main string alias of the selection data.
       */
      addFrom(entityTarget, aliasName) {
        const alias = this.createFromAlias(entityTarget, aliasName);
        if (!this.expressionMap.mainAlias)
          this.expressionMap.setMainAlias(alias);
        return this;
      }
      /**
       * INNER JOINs (without selection).
       * You also need to specify an alias of the joined data.
       * Optionally, you can add condition and parameters used in condition.
       */
      innerJoin(entityOrProperty, alias, condition, parameters) {
        this.join("INNER", entityOrProperty, alias, condition, parameters);
        return this;
      }
      /**
       * LEFT JOINs (without selection).
       * You also need to specify an alias of the joined data.
       * Optionally, you can add condition and parameters used in condition.
       */
      leftJoin(entityOrProperty, alias, condition, parameters) {
        this.join("LEFT", entityOrProperty, alias, condition, parameters);
        return this;
      }
      /**
       * INNER JOINs and adds all selection properties to SELECT.
       * You also need to specify an alias of the joined data.
       * Optionally, you can add condition and parameters used in condition.
       */
      innerJoinAndSelect(entityOrProperty, alias, condition, parameters) {
        this.addSelect(alias);
        this.innerJoin(entityOrProperty, alias, condition, parameters);
        return this;
      }
      /**
       * LEFT JOINs and adds all selection properties to SELECT.
       * You also need to specify an alias of the joined data.
       * Optionally, you can add condition and parameters used in condition.
       */
      leftJoinAndSelect(entityOrProperty, alias, condition, parameters) {
        this.addSelect(alias);
        this.leftJoin(entityOrProperty, alias, condition, parameters);
        return this;
      }
      /**
       * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.
       * This is extremely useful when you want to select some data and map it to some virtual property.
       * It will assume that there are multiple rows of selecting data, and mapped result will be an array.
       * You also need to specify an alias of the joined data.
       * Optionally, you can add condition and parameters used in condition.
       */
      innerJoinAndMapMany(mapToProperty, entityOrProperty, alias, condition, parameters) {
        this.addSelect(alias);
        this.join("INNER", entityOrProperty, alias, condition, parameters, mapToProperty, true);
        return this;
      }
      /**
       * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.
       * This is extremely useful when you want to select some data and map it to some virtual property.
       * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.
       * You also need to specify an alias of the joined data.
       * Optionally, you can add condition and parameters used in condition.
       */
      innerJoinAndMapOne(mapToProperty, entityOrProperty, alias, condition, parameters, mapAsEntity) {
        this.addSelect(alias);
        this.join("INNER", entityOrProperty, alias, condition, parameters, mapToProperty, false, mapAsEntity);
        return this;
      }
      /**
       * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.
       * This is extremely useful when you want to select some data and map it to some virtual property.
       * It will assume that there are multiple rows of selecting data, and mapped result will be an array.
       * You also need to specify an alias of the joined data.
       * Optionally, you can add condition and parameters used in condition.
       */
      leftJoinAndMapMany(mapToProperty, entityOrProperty, alias, condition, parameters) {
        this.addSelect(alias);
        this.join("LEFT", entityOrProperty, alias, condition, parameters, mapToProperty, true);
        return this;
      }
      /**
       * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.
       * This is extremely useful when you want to select some data and map it to some virtual property.
       * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.
       * You also need to specify an alias of the joined data.
       * Optionally, you can add condition and parameters used in condition.
       */
      leftJoinAndMapOne(mapToProperty, entityOrProperty, alias, condition, parameters, mapAsEntity) {
        this.addSelect(alias);
        this.join("LEFT", entityOrProperty, alias, condition, parameters, mapToProperty, false, mapAsEntity);
        return this;
      }
      /**
       * LEFT JOINs relation id and maps it into some entity's property.
       * Optionally, you can add condition and parameters used in condition.
       */
      loadRelationIdAndMap(mapToProperty, relationName, aliasNameOrOptions, queryBuilderFactory) {
        const relationIdAttribute = new RelationIdAttribute_1.RelationIdAttribute(this.expressionMap);
        relationIdAttribute.mapToProperty = mapToProperty;
        relationIdAttribute.relationName = relationName;
        if (typeof aliasNameOrOptions === "string")
          relationIdAttribute.alias = aliasNameOrOptions;
        if (typeof aliasNameOrOptions === "object" && aliasNameOrOptions.disableMixedMap)
          relationIdAttribute.disableMixedMap = true;
        relationIdAttribute.queryBuilderFactory = queryBuilderFactory;
        this.expressionMap.relationIdAttributes.push(relationIdAttribute);
        if (relationIdAttribute.relation.junctionEntityMetadata) {
          this.expressionMap.createAlias({
            type: "other",
            name: relationIdAttribute.junctionAlias,
            metadata: relationIdAttribute.relation.junctionEntityMetadata
          });
        }
        return this;
      }
      /**
       * Counts number of entities of entity's relation and maps the value into some entity's property.
       * Optionally, you can add condition and parameters used in condition.
       */
      loadRelationCountAndMap(mapToProperty, relationName, aliasName, queryBuilderFactory) {
        const relationCountAttribute = new RelationCountAttribute_1.RelationCountAttribute(this.expressionMap);
        relationCountAttribute.mapToProperty = mapToProperty;
        relationCountAttribute.relationName = relationName;
        relationCountAttribute.alias = aliasName;
        relationCountAttribute.queryBuilderFactory = queryBuilderFactory;
        this.expressionMap.relationCountAttributes.push(relationCountAttribute);
        this.expressionMap.createAlias({
          type: "other",
          name: relationCountAttribute.junctionAlias
        });
        if (relationCountAttribute.relation.junctionEntityMetadata) {
          this.expressionMap.createAlias({
            type: "other",
            name: relationCountAttribute.junctionAlias,
            metadata: relationCountAttribute.relation.junctionEntityMetadata
          });
        }
        return this;
      }
      /**
       * Loads all relation ids for all relations of the selected entity.
       * All relation ids will be mapped to relation property themself.
       * If array of strings is given then loads only relation ids of the given properties.
       */
      loadAllRelationIds(options) {
        this.expressionMap.mainAlias.metadata.relations.forEach((relation) => {
          if (options !== void 0 && options.relations !== void 0 && options.relations.indexOf(relation.propertyPath) === -1)
            return;
          this.loadRelationIdAndMap(this.expressionMap.mainAlias.name + "." + relation.propertyPath, this.expressionMap.mainAlias.name + "." + relation.propertyPath, options);
        });
        return this;
      }
      /**
       * Sets WHERE condition in the query builder.
       * If you had previously WHERE expression defined,
       * calling this function will override previously set WHERE conditions.
       * Additionally you can add parameters used in where expression.
       */
      where(where, parameters) {
        this.expressionMap.wheres = [];
        const condition = this.getWhereCondition(where);
        if (condition) {
          this.expressionMap.wheres = [
            { type: "simple", condition }
          ];
        }
        if (parameters)
          this.setParameters(parameters);
        return this;
      }
      /**
       * Adds new AND WHERE condition in the query builder.
       * Additionally you can add parameters used in where expression.
       */
      andWhere(where, parameters) {
        this.expressionMap.wheres.push({
          type: "and",
          condition: this.getWhereCondition(where)
        });
        if (parameters)
          this.setParameters(parameters);
        return this;
      }
      /**
       * Adds new OR WHERE condition in the query builder.
       * Additionally you can add parameters used in where expression.
       */
      orWhere(where, parameters) {
        this.expressionMap.wheres.push({
          type: "or",
          condition: this.getWhereCondition(where)
        });
        if (parameters)
          this.setParameters(parameters);
        return this;
      }
      /**
       * Sets a new where EXISTS clause
       */
      whereExists(subQuery) {
        return this.where(...this.getExistsCondition(subQuery));
      }
      /**
       * Adds a new AND where EXISTS clause
       */
      andWhereExists(subQuery) {
        return this.andWhere(...this.getExistsCondition(subQuery));
      }
      /**
       * Adds a new OR where EXISTS clause
       */
      orWhereExists(subQuery) {
        return this.orWhere(...this.getExistsCondition(subQuery));
      }
      /**
       * Adds new AND WHERE with conditions for the given ids.
       *
       * Ids are mixed.
       * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].
       * If you have multiple primary keys you need to pass object with property names and values specified,
       * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]
       */
      whereInIds(ids) {
        return this.where(this.getWhereInIdsCondition(ids));
      }
      /**
       * Adds new AND WHERE with conditions for the given ids.
       *
       * Ids are mixed.
       * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].
       * If you have multiple primary keys you need to pass object with property names and values specified,
       * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]
       */
      andWhereInIds(ids) {
        return this.andWhere(this.getWhereInIdsCondition(ids));
      }
      /**
       * Adds new OR WHERE with conditions for the given ids.
       *
       * Ids are mixed.
       * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].
       * If you have multiple primary keys you need to pass object with property names and values specified,
       * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]
       */
      orWhereInIds(ids) {
        return this.orWhere(this.getWhereInIdsCondition(ids));
      }
      /**
       * Sets HAVING condition in the query builder.
       * If you had previously HAVING expression defined,
       * calling this function will override previously set HAVING conditions.
       * Additionally you can add parameters used in where expression.
       */
      having(having, parameters) {
        this.expressionMap.havings.push({ type: "simple", condition: having });
        if (parameters)
          this.setParameters(parameters);
        return this;
      }
      /**
       * Adds new AND HAVING condition in the query builder.
       * Additionally you can add parameters used in where expression.
       */
      andHaving(having, parameters) {
        this.expressionMap.havings.push({ type: "and", condition: having });
        if (parameters)
          this.setParameters(parameters);
        return this;
      }
      /**
       * Adds new OR HAVING condition in the query builder.
       * Additionally you can add parameters used in where expression.
       */
      orHaving(having, parameters) {
        this.expressionMap.havings.push({ type: "or", condition: having });
        if (parameters)
          this.setParameters(parameters);
        return this;
      }
      /**
       * Sets GROUP BY condition in the query builder.
       * If you had previously GROUP BY expression defined,
       * calling this function will override previously set GROUP BY conditions.
       */
      groupBy(groupBy) {
        if (groupBy) {
          this.expressionMap.groupBys = [groupBy];
        } else {
          this.expressionMap.groupBys = [];
        }
        return this;
      }
      /**
       * Adds GROUP BY condition in the query builder.
       */
      addGroupBy(groupBy) {
        this.expressionMap.groupBys.push(groupBy);
        return this;
      }
      /**
       * Enables time travelling for the current query (only supported by cockroach currently)
       */
      timeTravelQuery(timeTravelFn) {
        if (this.connection.driver.options.type === "cockroachdb") {
          if (timeTravelFn === void 0) {
            this.expressionMap.timeTravel = "follower_read_timestamp()";
          } else {
            this.expressionMap.timeTravel = timeTravelFn;
          }
        }
        return this;
      }
      /**
       * Sets ORDER BY condition in the query builder.
       * If you had previously ORDER BY expression defined,
       * calling this function will override previously set ORDER BY conditions.
       */
      orderBy(sort, order = "ASC", nulls) {
        if (order !== void 0 && order !== "ASC" && order !== "DESC")
          throw new error_1.TypeORMError(`SelectQueryBuilder.addOrderBy "order" can accept only "ASC" and "DESC" values.`);
        if (nulls !== void 0 && nulls !== "NULLS FIRST" && nulls !== "NULLS LAST")
          throw new error_1.TypeORMError(`SelectQueryBuilder.addOrderBy "nulls" can accept only "NULLS FIRST" and "NULLS LAST" values.`);
        if (sort) {
          if (typeof sort === "object") {
            this.expressionMap.orderBys = sort;
          } else {
            if (nulls) {
              this.expressionMap.orderBys = {
                [sort]: { order, nulls }
              };
            } else {
              this.expressionMap.orderBys = { [sort]: order };
            }
          }
        } else {
          this.expressionMap.orderBys = {};
        }
        return this;
      }
      /**
       * Adds ORDER BY condition in the query builder.
       */
      addOrderBy(sort, order = "ASC", nulls) {
        if (order !== void 0 && order !== "ASC" && order !== "DESC")
          throw new error_1.TypeORMError(`SelectQueryBuilder.addOrderBy "order" can accept only "ASC" and "DESC" values.`);
        if (nulls !== void 0 && nulls !== "NULLS FIRST" && nulls !== "NULLS LAST")
          throw new error_1.TypeORMError(`SelectQueryBuilder.addOrderBy "nulls" can accept only "NULLS FIRST" and "NULLS LAST" values.`);
        if (nulls) {
          this.expressionMap.orderBys[sort] = { order, nulls };
        } else {
          this.expressionMap.orderBys[sort] = order;
        }
        return this;
      }
      /**
       * Sets LIMIT - maximum number of rows to be selected.
       * NOTE that it may not work as you expect if you are using joins.
       * If you want to implement pagination, and you are having join in your query,
       * then use the take method instead.
       */
      limit(limit) {
        this.expressionMap.limit = this.normalizeNumber(limit);
        if (this.expressionMap.limit !== void 0 && isNaN(this.expressionMap.limit))
          throw new error_1.TypeORMError(`Provided "limit" value is not a number. Please provide a numeric value.`);
        return this;
      }
      /**
       * Sets OFFSET - selection offset.
       * NOTE that it may not work as you expect if you are using joins.
       * If you want to implement pagination, and you are having join in your query,
       * then use the skip method instead.
       */
      offset(offset) {
        this.expressionMap.offset = this.normalizeNumber(offset);
        if (this.expressionMap.offset !== void 0 && isNaN(this.expressionMap.offset))
          throw new error_1.TypeORMError(`Provided "offset" value is not a number. Please provide a numeric value.`);
        return this;
      }
      /**
       * Sets maximal number of entities to take.
       */
      take(take) {
        this.expressionMap.take = this.normalizeNumber(take);
        if (this.expressionMap.take !== void 0 && isNaN(this.expressionMap.take))
          throw new error_1.TypeORMError(`Provided "take" value is not a number. Please provide a numeric value.`);
        return this;
      }
      /**
       * Sets number of entities to skip.
       */
      skip(skip) {
        this.expressionMap.skip = this.normalizeNumber(skip);
        if (this.expressionMap.skip !== void 0 && isNaN(this.expressionMap.skip))
          throw new error_1.TypeORMError(`Provided "skip" value is not a number. Please provide a numeric value.`);
        return this;
      }
      /**
       * Set certain index to be used by the query.
       *
       * @param index Name of index to be used.
       */
      useIndex(index) {
        this.expressionMap.useIndex = index;
        return this;
      }
      /**
       * Sets locking mode.
       */
      setLock(lockMode, lockVersion, lockTables) {
        this.expressionMap.lockMode = lockMode;
        this.expressionMap.lockVersion = lockVersion;
        this.expressionMap.lockTables = lockTables;
        return this;
      }
      /**
       * Sets lock handling by adding NO WAIT or SKIP LOCKED.
       */
      setOnLocked(onLocked) {
        this.expressionMap.onLocked = onLocked;
        return this;
      }
      /**
       * Disables the global condition of "non-deleted" for the entity with delete date columns.
       */
      withDeleted() {
        this.expressionMap.withDeleted = true;
        return this;
      }
      /**
       * Gets first raw result returned by execution of generated query builder sql.
       */
      async getRawOne() {
        return (await this.getRawMany())[0];
      }
      /**
       * Gets all raw results returned by execution of generated query builder sql.
       */
      async getRawMany() {
        if (this.expressionMap.lockMode === "optimistic")
          throw new OptimisticLockCanNotBeUsedError_1.OptimisticLockCanNotBeUsedError();
        this.expressionMap.queryEntity = false;
        const queryRunner = this.obtainQueryRunner();
        let transactionStartedByUs = false;
        try {
          if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {
            await queryRunner.startTransaction();
            transactionStartedByUs = true;
          }
          const results = await this.loadRawResults(queryRunner);
          if (transactionStartedByUs) {
            await queryRunner.commitTransaction();
          }
          return results;
        } catch (error) {
          if (transactionStartedByUs) {
            try {
              await queryRunner.rollbackTransaction();
            } catch (rollbackError) {
            }
          }
          throw error;
        } finally {
          if (queryRunner !== this.queryRunner) {
            await queryRunner.release();
          }
        }
      }
      /**
       * Executes sql generated by query builder and returns object with raw results and entities created from them.
       */
      async getRawAndEntities() {
        const queryRunner = this.obtainQueryRunner();
        let transactionStartedByUs = false;
        try {
          if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {
            await queryRunner.startTransaction();
            transactionStartedByUs = true;
          }
          this.expressionMap.queryEntity = true;
          const results = await this.executeEntitiesAndRawResults(queryRunner);
          if (transactionStartedByUs) {
            await queryRunner.commitTransaction();
          }
          return results;
        } catch (error) {
          if (transactionStartedByUs) {
            try {
              await queryRunner.rollbackTransaction();
            } catch (rollbackError) {
            }
          }
          throw error;
        } finally {
          if (queryRunner !== this.queryRunner)
            await queryRunner.release();
        }
      }
      /**
       * Gets single entity returned by execution of generated query builder sql.
       */
      async getOne() {
        const results = await this.getRawAndEntities();
        const result = results.entities[0];
        if (result && this.expressionMap.lockMode === "optimistic" && this.expressionMap.lockVersion) {
          const metadata = this.expressionMap.mainAlias.metadata;
          if (this.expressionMap.lockVersion instanceof Date) {
            const actualVersion = metadata.updateDateColumn.getEntityValue(result);
            if (actualVersion.getTime() !== this.expressionMap.lockVersion.getTime())
              throw new OptimisticLockVersionMismatchError_1.OptimisticLockVersionMismatchError(metadata.name, this.expressionMap.lockVersion, actualVersion);
          } else {
            const actualVersion = metadata.versionColumn.getEntityValue(result);
            if (actualVersion !== this.expressionMap.lockVersion)
              throw new OptimisticLockVersionMismatchError_1.OptimisticLockVersionMismatchError(metadata.name, this.expressionMap.lockVersion, actualVersion);
          }
        }
        if (result === void 0) {
          return null;
        }
        return result;
      }
      /**
       * Gets the first entity returned by execution of generated query builder sql or rejects the returned promise on error.
       */
      async getOneOrFail() {
        const entity = await this.getOne();
        if (!entity) {
          throw new EntityNotFoundError_1.EntityNotFoundError(this.expressionMap.mainAlias.target, this.expressionMap.parameters);
        }
        return entity;
      }
      /**
       * Gets entities returned by execution of generated query builder sql.
       */
      async getMany() {
        if (this.expressionMap.lockMode === "optimistic")
          throw new OptimisticLockCanNotBeUsedError_1.OptimisticLockCanNotBeUsedError();
        const results = await this.getRawAndEntities();
        return results.entities;
      }
      /**
       * Gets count - number of entities selected by sql generated by this query builder.
       * Count excludes all limitations set by offset, limit, skip, and take.
       */
      async getCount() {
        if (this.expressionMap.lockMode === "optimistic")
          throw new OptimisticLockCanNotBeUsedError_1.OptimisticLockCanNotBeUsedError();
        const queryRunner = this.obtainQueryRunner();
        let transactionStartedByUs = false;
        try {
          if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {
            await queryRunner.startTransaction();
            transactionStartedByUs = true;
          }
          this.expressionMap.queryEntity = false;
          const results = await this.executeCountQuery(queryRunner);
          if (transactionStartedByUs) {
            await queryRunner.commitTransaction();
          }
          return results;
        } catch (error) {
          if (transactionStartedByUs) {
            try {
              await queryRunner.rollbackTransaction();
            } catch (rollbackError) {
            }
          }
          throw error;
        } finally {
          if (queryRunner !== this.queryRunner)
            await queryRunner.release();
        }
      }
      /**
       * Gets exists
       * Returns whether any rows exists matching current query.
       */
      async getExists() {
        if (this.expressionMap.lockMode === "optimistic")
          throw new OptimisticLockCanNotBeUsedError_1.OptimisticLockCanNotBeUsedError();
        const queryRunner = this.obtainQueryRunner();
        let transactionStartedByUs = false;
        try {
          if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {
            await queryRunner.startTransaction();
            transactionStartedByUs = true;
          }
          this.expressionMap.queryEntity = false;
          const results = await this.executeExistsQuery(queryRunner);
          if (transactionStartedByUs) {
            await queryRunner.commitTransaction();
          }
          return results;
        } catch (error) {
          if (transactionStartedByUs) {
            try {
              await queryRunner.rollbackTransaction();
            } catch (rollbackError) {
            }
          }
          throw error;
        } finally {
          if (queryRunner !== this.queryRunner)
            await queryRunner.release();
        }
      }
      /**
       * Executes built SQL query and returns entities and overall entities count (without limitation).
       * This method is useful to build pagination.
       */
      async getManyAndCount() {
        if (this.expressionMap.lockMode === "optimistic")
          throw new OptimisticLockCanNotBeUsedError_1.OptimisticLockCanNotBeUsedError();
        const queryRunner = this.obtainQueryRunner();
        let transactionStartedByUs = false;
        try {
          if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {
            await queryRunner.startTransaction();
            transactionStartedByUs = true;
          }
          this.expressionMap.queryEntity = true;
          const entitiesAndRaw = await this.executeEntitiesAndRawResults(queryRunner);
          this.expressionMap.queryEntity = false;
          let count = this.lazyCount(entitiesAndRaw);
          if (count === void 0) {
            const cacheId = this.expressionMap.cacheId;
            if (cacheId) {
              this.expressionMap.cacheId = `${cacheId}-count`;
            }
            count = await this.executeCountQuery(queryRunner);
          }
          const results = [entitiesAndRaw.entities, count];
          if (transactionStartedByUs) {
            await queryRunner.commitTransaction();
          }
          return results;
        } catch (error) {
          if (transactionStartedByUs) {
            try {
              await queryRunner.rollbackTransaction();
            } catch (rollbackError) {
            }
          }
          throw error;
        } finally {
          if (queryRunner !== this.queryRunner)
            await queryRunner.release();
        }
      }
      lazyCount(entitiesAndRaw) {
        const hasLimit = this.expressionMap.limit !== void 0 && this.expressionMap.limit !== null;
        if (this.expressionMap.joinAttributes.length > 0 && hasLimit) {
          return void 0;
        }
        const hasTake = this.expressionMap.take !== void 0 && this.expressionMap.take !== null;
        const maxResults = hasLimit ? this.expressionMap.limit : hasTake ? this.expressionMap.take : void 0;
        if (maxResults !== void 0 && entitiesAndRaw.entities.length === maxResults) {
          return void 0;
        }
        const hasSkip = this.expressionMap.skip !== void 0 && this.expressionMap.skip !== null && this.expressionMap.skip > 0;
        const hasOffset = this.expressionMap.offset !== void 0 && this.expressionMap.offset !== null && this.expressionMap.offset > 0;
        const previousResults = hasOffset ? this.expressionMap.offset : hasSkip ? this.expressionMap.skip : 0;
        return entitiesAndRaw.entities.length + previousResults;
      }
      /**
       * Executes built SQL query and returns raw data stream.
       */
      async stream() {
        this.expressionMap.queryEntity = false;
        const [sql, parameters] = this.getQueryAndParameters();
        const queryRunner = this.obtainQueryRunner();
        let transactionStartedByUs = false;
        try {
          if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {
            await queryRunner.startTransaction();
            transactionStartedByUs = true;
          }
          const releaseFn = () => {
            if (queryRunner !== this.queryRunner)
              return queryRunner.release();
            return;
          };
          const results = queryRunner.stream(sql, parameters, releaseFn, releaseFn);
          if (transactionStartedByUs) {
            await queryRunner.commitTransaction();
          }
          return results;
        } catch (error) {
          if (transactionStartedByUs) {
            try {
              await queryRunner.rollbackTransaction();
            } catch (rollbackError) {
            }
          }
          throw error;
        }
      }
      /**
       * Enables or disables query result caching.
       */
      cache(enabledOrMillisecondsOrId, maybeMilliseconds) {
        if (typeof enabledOrMillisecondsOrId === "boolean") {
          this.expressionMap.cache = enabledOrMillisecondsOrId;
        } else if (typeof enabledOrMillisecondsOrId === "number") {
          this.expressionMap.cache = true;
          this.expressionMap.cacheDuration = enabledOrMillisecondsOrId;
        } else if (typeof enabledOrMillisecondsOrId === "string" || typeof enabledOrMillisecondsOrId === "number") {
          this.expressionMap.cache = true;
          this.expressionMap.cacheId = enabledOrMillisecondsOrId;
        }
        if (maybeMilliseconds) {
          this.expressionMap.cacheDuration = maybeMilliseconds;
        }
        return this;
      }
      /**
       * Sets extra options that can be used to configure how query builder works.
       */
      setOption(option) {
        this.expressionMap.options.push(option);
        return this;
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      join(direction, entityOrProperty, aliasName, condition, parameters, mapToProperty, isMappingMany, mapAsEntity) {
        if (parameters) {
          this.setParameters(parameters);
        }
        const joinAttribute = new JoinAttribute_1.JoinAttribute(this.connection, this.expressionMap);
        joinAttribute.direction = direction;
        joinAttribute.mapAsEntity = mapAsEntity;
        joinAttribute.mapToProperty = mapToProperty;
        joinAttribute.isMappingMany = isMappingMany;
        joinAttribute.entityOrProperty = entityOrProperty;
        joinAttribute.condition = condition;
        this.expressionMap.joinAttributes.push(joinAttribute);
        const joinAttributeMetadata = joinAttribute.metadata;
        if (joinAttributeMetadata) {
          if (joinAttributeMetadata.deleteDateColumn && !this.expressionMap.withDeleted) {
            const conditionDeleteColumn = `${aliasName}.${joinAttributeMetadata.deleteDateColumn.propertyName} IS NULL`;
            joinAttribute.condition = joinAttribute.condition ? ` ${joinAttribute.condition} AND ${conditionDeleteColumn}` : `${conditionDeleteColumn}`;
          }
          joinAttribute.alias = this.expressionMap.createAlias({
            type: "join",
            name: aliasName,
            metadata: joinAttributeMetadata
          });
          if (joinAttribute.relation && joinAttribute.relation.junctionEntityMetadata) {
            this.expressionMap.createAlias({
              type: "join",
              name: joinAttribute.junctionAlias,
              metadata: joinAttribute.relation.junctionEntityMetadata
            });
          }
        } else {
          let subQuery = "";
          if (typeof entityOrProperty === "function") {
            const subQueryBuilder = entityOrProperty(this.subQuery());
            this.setParameters(subQueryBuilder.getParameters());
            subQuery = subQueryBuilder.getQuery();
          } else {
            subQuery = entityOrProperty;
          }
          const isSubQuery = typeof entityOrProperty === "function" || entityOrProperty.substr(0, 1) === "(" && entityOrProperty.substr(-1) === ")";
          joinAttribute.alias = this.expressionMap.createAlias({
            type: "join",
            name: aliasName,
            tablePath: isSubQuery === false ? entityOrProperty : void 0,
            subQuery: isSubQuery === true ? subQuery : void 0
          });
        }
      }
      /**
       * Creates "SELECT FROM" part of SQL query.
       */
      createSelectExpression() {
        if (!this.expressionMap.mainAlias)
          throw new error_1.TypeORMError("Cannot build query because main alias is not set (call qb#from method)");
        const allSelects = [];
        const excludedSelects = [];
        if (this.expressionMap.mainAlias.hasMetadata) {
          const metadata = this.expressionMap.mainAlias.metadata;
          allSelects.push(...this.buildEscapedEntityColumnSelects(this.expressionMap.mainAlias.name, metadata));
          excludedSelects.push(...this.findEntityColumnSelects(this.expressionMap.mainAlias.name, metadata));
        }
        this.expressionMap.joinAttributes.forEach((join) => {
          if (join.metadata) {
            allSelects.push(...this.buildEscapedEntityColumnSelects(join.alias.name, join.metadata));
            excludedSelects.push(...this.findEntityColumnSelects(join.alias.name, join.metadata));
          } else {
            const hasMainAlias = this.expressionMap.selects.some((select2) => select2.selection === join.alias.name);
            if (hasMainAlias) {
              allSelects.push({
                selection: this.escape(join.alias.name) + ".*"
              });
              const excludedSelect = this.expressionMap.selects.find((select2) => select2.selection === join.alias.name);
              excludedSelects.push(excludedSelect);
            }
          }
        });
        this.expressionMap.selects.filter((select2) => excludedSelects.indexOf(select2) === -1).forEach((select2) => allSelects.push({
          selection: this.replacePropertyNames(select2.selection),
          aliasName: select2.aliasName
        }));
        if (allSelects.length === 0)
          allSelects.push({ selection: "*" });
        let useIndex = "";
        if (this.expressionMap.useIndex) {
          if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver)) {
            useIndex = ` USE INDEX (${this.expressionMap.useIndex})`;
          }
        }
        const froms = this.expressionMap.aliases.filter((alias) => alias.type === "from" && (alias.tablePath || alias.subQuery)).map((alias) => {
          if (alias.subQuery)
            return alias.subQuery + " " + this.escape(alias.name);
          return this.getTableName(alias.tablePath) + " " + this.escape(alias.name);
        });
        const select = this.createSelectDistinctExpression();
        const selection = allSelects.map((select2) => select2.selection + (select2.aliasName ? " AS " + this.escape(select2.aliasName) : "")).join(", ");
        return select + selection + " FROM " + froms.join(", ") + this.createTableLockExpression() + useIndex;
      }
      /**
       * Creates select | select distinct part of SQL query.
       */
      createSelectDistinctExpression() {
        const { selectDistinct, selectDistinctOn, maxExecutionTime } = this.expressionMap;
        const { driver } = this.connection;
        let select = "SELECT ";
        if (maxExecutionTime > 0) {
          if (DriverUtils_1.DriverUtils.isMySQLFamily(driver)) {
            select += `/*+ MAX_EXECUTION_TIME(${this.expressionMap.maxExecutionTime}) */ `;
          }
        }
        if (DriverUtils_1.DriverUtils.isPostgresFamily(driver) && selectDistinctOn.length > 0) {
          const selectDistinctOnMap = selectDistinctOn.map((on) => this.replacePropertyNames(on)).join(", ");
          select = `SELECT DISTINCT ON (${selectDistinctOnMap}) `;
        } else if (selectDistinct) {
          select = "SELECT DISTINCT ";
        }
        return select;
      }
      /**
       * Creates "JOIN" part of SQL query.
       */
      createJoinExpression() {
        const joins = this.expressionMap.joinAttributes.map((joinAttr) => {
          const relation = joinAttr.relation;
          const destinationTableName = joinAttr.tablePath;
          const destinationTableAlias = joinAttr.alias.name;
          let appendedCondition = joinAttr.condition ? " AND (" + joinAttr.condition + ")" : "";
          const parentAlias = joinAttr.parentAlias;
          if (!parentAlias || !relation) {
            const destinationJoin = joinAttr.alias.subQuery ? joinAttr.alias.subQuery : this.getTableName(destinationTableName);
            return " " + joinAttr.direction + " JOIN " + destinationJoin + " " + this.escape(destinationTableAlias) + this.createTableLockExpression() + (joinAttr.condition ? " ON " + this.replacePropertyNames(joinAttr.condition) : "");
          }
          if (relation.isManyToOne || relation.isOneToOneOwner) {
            const condition = relation.joinColumns.map((joinColumn) => {
              return destinationTableAlias + "." + joinColumn.referencedColumn.propertyPath + "=" + parentAlias + "." + relation.propertyPath + "." + joinColumn.referencedColumn.propertyPath;
            }).join(" AND ");
            return " " + joinAttr.direction + " JOIN " + this.getTableName(destinationTableName) + " " + this.escape(destinationTableAlias) + this.createTableLockExpression() + " ON " + this.replacePropertyNames(condition + appendedCondition);
          } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {
            const condition = relation.inverseRelation.joinColumns.map((joinColumn) => {
              if (relation.inverseEntityMetadata.tableType === "entity-child" && relation.inverseEntityMetadata.discriminatorColumn) {
                appendedCondition += " AND " + destinationTableAlias + "." + relation.inverseEntityMetadata.discriminatorColumn.databaseName + "='" + relation.inverseEntityMetadata.discriminatorValue + "'";
              }
              return destinationTableAlias + "." + relation.inverseRelation.propertyPath + "." + joinColumn.referencedColumn.propertyPath + "=" + parentAlias + "." + joinColumn.referencedColumn.propertyPath;
            }).join(" AND ");
            if (!condition)
              throw new error_1.TypeORMError(`Relation ${relation.entityMetadata.name}.${relation.propertyName} does not have join columns.`);
            return " " + joinAttr.direction + " JOIN " + this.getTableName(destinationTableName) + " " + this.escape(destinationTableAlias) + this.createTableLockExpression() + " ON " + this.replacePropertyNames(condition + appendedCondition);
          } else {
            const junctionTableName = relation.junctionEntityMetadata.tablePath;
            const junctionAlias = joinAttr.junctionAlias;
            let junctionCondition = "", destinationCondition = "";
            if (relation.isOwning) {
              junctionCondition = relation.joinColumns.map((joinColumn) => {
                return junctionAlias + "." + joinColumn.propertyPath + "=" + parentAlias + "." + joinColumn.referencedColumn.propertyPath;
              }).join(" AND ");
              destinationCondition = relation.inverseJoinColumns.map((joinColumn) => {
                return destinationTableAlias + "." + joinColumn.referencedColumn.propertyPath + "=" + junctionAlias + "." + joinColumn.propertyPath;
              }).join(" AND ");
            } else {
              junctionCondition = relation.inverseRelation.inverseJoinColumns.map((joinColumn) => {
                return junctionAlias + "." + joinColumn.propertyPath + "=" + parentAlias + "." + joinColumn.referencedColumn.propertyPath;
              }).join(" AND ");
              destinationCondition = relation.inverseRelation.joinColumns.map((joinColumn) => {
                return destinationTableAlias + "." + joinColumn.referencedColumn.propertyPath + "=" + junctionAlias + "." + joinColumn.propertyPath;
              }).join(" AND ");
            }
            return " " + joinAttr.direction + " JOIN " + this.getTableName(junctionTableName) + " " + this.escape(junctionAlias) + this.createTableLockExpression() + " ON " + this.replacePropertyNames(junctionCondition) + " " + joinAttr.direction + " JOIN " + this.getTableName(destinationTableName) + " " + this.escape(destinationTableAlias) + this.createTableLockExpression() + " ON " + this.replacePropertyNames(destinationCondition + appendedCondition);
          }
        });
        return joins.join(" ");
      }
      /**
       * Creates "GROUP BY" part of SQL query.
       */
      createGroupByExpression() {
        if (!this.expressionMap.groupBys || !this.expressionMap.groupBys.length)
          return "";
        return " GROUP BY " + this.replacePropertyNames(this.expressionMap.groupBys.join(", "));
      }
      /**
       * Creates "ORDER BY" part of SQL query.
       */
      createOrderByExpression() {
        const orderBys = this.expressionMap.allOrderBys;
        if (Object.keys(orderBys).length === 0)
          return "";
        return " ORDER BY " + Object.keys(orderBys).map((columnName) => {
          const orderValue = typeof orderBys[columnName] === "string" ? orderBys[columnName] : orderBys[columnName].order + " " + orderBys[columnName].nulls;
          const selection = this.expressionMap.selects.find((s) => s.selection === columnName);
          if (selection && !selection.aliasName && columnName.indexOf(".") !== -1) {
            const criteriaParts = columnName.split(".");
            const aliasName = criteriaParts[0];
            const propertyPath = criteriaParts.slice(1).join(".");
            const alias = this.expressionMap.aliases.find((alias2) => alias2.name === aliasName);
            if (alias) {
              const column = alias.metadata.findColumnWithPropertyPath(propertyPath);
              if (column) {
                const orderAlias = DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, void 0, aliasName, column.databaseName);
                return this.escape(orderAlias) + " " + orderValue;
              }
            }
          }
          return this.replacePropertyNames(columnName) + " " + orderValue;
        }).join(", ");
      }
      /**
       * Creates "LIMIT" and "OFFSET" parts of SQL query.
       */
      createLimitOffsetExpression() {
        let offset = this.expressionMap.offset, limit = this.expressionMap.limit;
        if (offset === void 0 && limit === void 0 && this.expressionMap.joinAttributes.length === 0) {
          offset = this.expressionMap.skip;
          limit = this.expressionMap.take;
        }
        const hasLimit = limit !== void 0 && limit !== null;
        const hasOffset = offset !== void 0 && offset !== null;
        if (this.connection.driver.options.type === "mssql") {
          let prefix = "";
          if ((hasLimit || hasOffset) && Object.keys(this.expressionMap.allOrderBys).length <= 0) {
            prefix = " ORDER BY (SELECT NULL)";
          }
          if (hasLimit && hasOffset)
            return prefix + " OFFSET " + offset + " ROWS FETCH NEXT " + limit + " ROWS ONLY";
          if (hasLimit)
            return prefix + " OFFSET 0 ROWS FETCH NEXT " + limit + " ROWS ONLY";
          if (hasOffset)
            return prefix + " OFFSET " + offset + " ROWS";
        } else if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql" || this.connection.driver.options.type === "sap" || this.connection.driver.options.type === "spanner") {
          if (hasLimit && hasOffset)
            return " LIMIT " + limit + " OFFSET " + offset;
          if (hasLimit)
            return " LIMIT " + limit;
          if (hasOffset)
            throw new OffsetWithoutLimitNotSupportedError_1.OffsetWithoutLimitNotSupportedError();
        } else if (DriverUtils_1.DriverUtils.isSQLiteFamily(this.connection.driver)) {
          if (hasLimit && hasOffset)
            return " LIMIT " + limit + " OFFSET " + offset;
          if (hasLimit)
            return " LIMIT " + limit;
          if (hasOffset)
            return " LIMIT -1 OFFSET " + offset;
        } else if (this.connection.driver.options.type === "oracle") {
          if (hasLimit && hasOffset)
            return " OFFSET " + offset + " ROWS FETCH NEXT " + limit + " ROWS ONLY";
          if (hasLimit)
            return " FETCH NEXT " + limit + " ROWS ONLY";
          if (hasOffset)
            return " OFFSET " + offset + " ROWS";
        } else {
          if (hasLimit && hasOffset)
            return " LIMIT " + limit + " OFFSET " + offset;
          if (hasLimit)
            return " LIMIT " + limit;
          if (hasOffset)
            return " OFFSET " + offset;
        }
        return "";
      }
      /**
       * Creates "LOCK" part of SELECT Query after table Clause
       * ex.
       *  SELECT 1
       *  FROM USER U WITH (NOLOCK)
       *  JOIN ORDER O WITH (NOLOCK)
       *      ON U.ID=O.OrderID
       */
      createTableLockExpression() {
        if (this.connection.driver.options.type === "mssql") {
          switch (this.expressionMap.lockMode) {
            case "pessimistic_read":
              return " WITH (HOLDLOCK, ROWLOCK)";
            case "pessimistic_write":
              return " WITH (UPDLOCK, ROWLOCK)";
            case "dirty_read":
              return " WITH (NOLOCK)";
          }
        }
        return "";
      }
      /**
       * Creates "LOCK" part of SQL query.
       */
      createLockExpression() {
        const driver = this.connection.driver;
        let lockTablesClause = "";
        if (this.expressionMap.lockTables) {
          if (!(DriverUtils_1.DriverUtils.isPostgresFamily(driver) || driver.options.type === "cockroachdb")) {
            throw new error_1.TypeORMError("Lock tables not supported in selected driver");
          }
          if (this.expressionMap.lockTables.length < 1) {
            throw new error_1.TypeORMError("lockTables cannot be an empty array");
          }
          lockTablesClause = " OF " + this.expressionMap.lockTables.join(", ");
        }
        let onLockExpression = "";
        if (this.expressionMap.onLocked === "nowait") {
          onLockExpression = " NOWAIT";
        } else if (this.expressionMap.onLocked === "skip_locked") {
          onLockExpression = " SKIP LOCKED";
        }
        switch (this.expressionMap.lockMode) {
          case "pessimistic_read":
            if (driver.options.type === "mysql" || driver.options.type === "aurora-mysql") {
              if (DriverUtils_1.DriverUtils.isReleaseVersionOrGreater(driver, "8.0.0")) {
                return " FOR SHARE" + lockTablesClause + onLockExpression;
              } else {
                return " LOCK IN SHARE MODE";
              }
            } else if (driver.options.type === "mariadb") {
              return " LOCK IN SHARE MODE";
            } else if (DriverUtils_1.DriverUtils.isPostgresFamily(driver)) {
              return " FOR SHARE" + lockTablesClause + onLockExpression;
            } else if (driver.options.type === "oracle") {
              return " FOR UPDATE";
            } else if (driver.options.type === "mssql") {
              return "";
            } else {
              throw new LockNotSupportedOnGivenDriverError_1.LockNotSupportedOnGivenDriverError();
            }
          case "pessimistic_write":
            if (DriverUtils_1.DriverUtils.isMySQLFamily(driver) || driver.options.type === "aurora-mysql" || driver.options.type === "oracle") {
              return " FOR UPDATE" + onLockExpression;
            } else if (DriverUtils_1.DriverUtils.isPostgresFamily(driver) || driver.options.type === "cockroachdb") {
              return " FOR UPDATE" + lockTablesClause + onLockExpression;
            } else if (driver.options.type === "mssql") {
              return "";
            } else {
              throw new LockNotSupportedOnGivenDriverError_1.LockNotSupportedOnGivenDriverError();
            }
          case "pessimistic_partial_write":
            if (DriverUtils_1.DriverUtils.isPostgresFamily(driver)) {
              return " FOR UPDATE" + lockTablesClause + " SKIP LOCKED";
            } else if (DriverUtils_1.DriverUtils.isMySQLFamily(driver)) {
              return " FOR UPDATE SKIP LOCKED";
            } else {
              throw new LockNotSupportedOnGivenDriverError_1.LockNotSupportedOnGivenDriverError();
            }
          case "pessimistic_write_or_fail":
            if (DriverUtils_1.DriverUtils.isPostgresFamily(driver) || driver.options.type === "cockroachdb") {
              return " FOR UPDATE" + lockTablesClause + " NOWAIT";
            } else if (DriverUtils_1.DriverUtils.isMySQLFamily(driver)) {
              return " FOR UPDATE NOWAIT";
            } else {
              throw new LockNotSupportedOnGivenDriverError_1.LockNotSupportedOnGivenDriverError();
            }
          case "for_no_key_update":
            if (DriverUtils_1.DriverUtils.isPostgresFamily(driver) || driver.options.type === "cockroachdb") {
              return " FOR NO KEY UPDATE" + lockTablesClause + onLockExpression;
            } else {
              throw new LockNotSupportedOnGivenDriverError_1.LockNotSupportedOnGivenDriverError();
            }
          case "for_key_share":
            if (DriverUtils_1.DriverUtils.isPostgresFamily(driver)) {
              return " FOR KEY SHARE" + lockTablesClause + onLockExpression;
            } else {
              throw new LockNotSupportedOnGivenDriverError_1.LockNotSupportedOnGivenDriverError();
            }
          default:
            return "";
        }
      }
      /**
       * Creates "HAVING" part of SQL query.
       */
      createHavingExpression() {
        if (!this.expressionMap.havings || !this.expressionMap.havings.length)
          return "";
        const conditions = this.expressionMap.havings.map((having, index) => {
          switch (having.type) {
            case "and":
              return (index > 0 ? "AND " : "") + this.replacePropertyNames(having.condition);
            case "or":
              return (index > 0 ? "OR " : "") + this.replacePropertyNames(having.condition);
            default:
              return this.replacePropertyNames(having.condition);
          }
        }).join(" ");
        if (!conditions.length)
          return "";
        return " HAVING " + conditions;
      }
      buildEscapedEntityColumnSelects(aliasName, metadata) {
        const hasMainAlias = this.expressionMap.selects.some((select) => select.selection === aliasName);
        const columns = [];
        if (hasMainAlias) {
          columns.push(...metadata.columns.filter((column) => column.isSelect === true));
        }
        columns.push(...metadata.columns.filter((column) => {
          return this.expressionMap.selects.some((select) => select.selection === aliasName + "." + column.propertyPath);
        }));
        if (columns.length === 0)
          return [];
        const nonSelectedPrimaryColumns = this.expressionMap.queryEntity ? metadata.primaryColumns.filter((primaryColumn) => columns.indexOf(primaryColumn) === -1) : [];
        const allColumns = [...columns, ...nonSelectedPrimaryColumns];
        const finalSelects = [];
        const escapedAliasName = this.escape(aliasName);
        allColumns.forEach((column) => {
          let selectionPath = escapedAliasName + "." + this.escape(column.databaseName);
          if (column.isVirtualProperty && column.query) {
            selectionPath = `(${column.query(escapedAliasName)})`;
          }
          if (this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {
            if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql") {
              const useLegacy = this.connection.driver.options.legacySpatialSupport;
              const asText = useLegacy ? "AsText" : "ST_AsText";
              selectionPath = `${asText}(${selectionPath})`;
            }
            if (DriverUtils_1.DriverUtils.isPostgresFamily(this.connection.driver))
              if (column.precision) {
                selectionPath = `ST_AsGeoJSON(${selectionPath}, ${column.precision})::json`;
              } else {
                selectionPath = `ST_AsGeoJSON(${selectionPath})::json`;
              }
            if (this.connection.driver.options.type === "mssql")
              selectionPath = `${selectionPath}.ToString()`;
          }
          const selections = this.expressionMap.selects.filter((select) => select.selection === aliasName + "." + column.propertyPath);
          if (selections.length) {
            selections.forEach((selection) => {
              finalSelects.push({
                selection: selectionPath,
                aliasName: selection.aliasName ? selection.aliasName : DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, void 0, aliasName, column.databaseName),
                // todo: need to keep in mind that custom selection.aliasName breaks hydrator. fix it later!
                virtual: selection.virtual
              });
            });
          } else {
            finalSelects.push({
              selection: selectionPath,
              aliasName: DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, void 0, aliasName, column.databaseName),
              // todo: need to keep in mind that custom selection.aliasName breaks hydrator. fix it later!
              virtual: hasMainAlias
            });
          }
        });
        return finalSelects;
      }
      findEntityColumnSelects(aliasName, metadata) {
        const mainSelect = this.expressionMap.selects.find((select) => select.selection === aliasName);
        if (mainSelect)
          return [mainSelect];
        return this.expressionMap.selects.filter((select) => {
          return metadata.columns.some((column) => select.selection === aliasName + "." + column.propertyPath);
        });
      }
      computeCountExpression() {
        const mainAlias = this.expressionMap.mainAlias.name;
        const metadata = this.expressionMap.mainAlias.metadata;
        const primaryColumns = metadata.primaryColumns;
        const distinctAlias = this.escape(mainAlias);
        if (this.expressionMap.joinAttributes.length === 0 && this.expressionMap.relationIdAttributes.length === 0 && this.expressionMap.relationCountAttributes.length === 0) {
          return "COUNT(1)";
        }
        if (this.connection.driver.options.type === "cockroachdb" || DriverUtils_1.DriverUtils.isPostgresFamily(this.connection.driver)) {
          return "COUNT(DISTINCT(" + primaryColumns.map((c) => `${distinctAlias}.${this.escape(c.databaseName)}`).join(", ") + "))";
        }
        if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver)) {
          return "COUNT(DISTINCT " + primaryColumns.map((c) => `${distinctAlias}.${this.escape(c.databaseName)}`).join(", ") + ")";
        }
        if (this.connection.driver.options.type === "mssql") {
          const columnsExpression = primaryColumns.map((primaryColumn) => `${distinctAlias}.${this.escape(primaryColumn.databaseName)}`).join(", '|;|', ");
          if (primaryColumns.length === 1) {
            return `COUNT(DISTINCT(${columnsExpression}))`;
          }
          return `COUNT(DISTINCT(CONCAT(${columnsExpression})))`;
        }
        if (this.connection.driver.options.type === "spanner") {
          if (primaryColumns.length === 1) {
            return `COUNT(DISTINCT(${distinctAlias}.${this.escape(primaryColumns[0].databaseName)}))`;
          }
          const columnsExpression = primaryColumns.map((primaryColumn) => `CAST(${distinctAlias}.${this.escape(primaryColumn.databaseName)} AS STRING)`).join(", '|;|', ");
          return `COUNT(DISTINCT(CONCAT(${columnsExpression})))`;
        }
        return `COUNT(DISTINCT(` + primaryColumns.map((c) => `${distinctAlias}.${this.escape(c.databaseName)}`).join(" || '|;|' || ") + "))";
      }
      async executeCountQuery(queryRunner) {
        const countSql = this.computeCountExpression();
        const results = await this.clone().orderBy().groupBy().offset(void 0).limit(void 0).skip(void 0).take(void 0).select(countSql, "cnt").setOption("disable-global-order").loadRawResults(queryRunner);
        if (!results || !results[0] || !results[0]["cnt"])
          return 0;
        return parseInt(results[0]["cnt"]);
      }
      async executeExistsQuery(queryRunner) {
        const results = await this.connection.createQueryBuilder().fromDummy().select("1", "row_exists").whereExists(this).limit(1).loadRawResults(queryRunner);
        return results.length > 0;
      }
      applyFindOptions() {
        if (this.expressionMap.mainAlias.metadata) {
          if (this.findOptions.relationLoadStrategy) {
            this.expressionMap.relationLoadStrategy = this.findOptions.relationLoadStrategy;
          }
          if (this.findOptions.comment) {
            this.comment(this.findOptions.comment);
          }
          if (this.findOptions.withDeleted) {
            this.withDeleted();
          }
          if (this.findOptions.select) {
            const select = Array.isArray(this.findOptions.select) ? OrmUtils_1.OrmUtils.propertyPathsToTruthyObject(this.findOptions.select) : this.findOptions.select;
            this.buildSelect(select, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);
          }
          if (this.selects.length) {
            this.select(this.selects);
          }
          this.selects = [];
          if (this.findOptions.relations) {
            const relations = Array.isArray(this.findOptions.relations) ? OrmUtils_1.OrmUtils.propertyPathsToTruthyObject(this.findOptions.relations) : this.findOptions.relations;
            this.buildRelations(relations, typeof this.findOptions.select === "object" ? this.findOptions.select : void 0, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);
            if (this.findOptions.loadEagerRelations !== false && this.expressionMap.relationLoadStrategy === "join") {
              this.buildEagerRelations(relations, typeof this.findOptions.select === "object" ? this.findOptions.select : void 0, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);
            }
          }
          if (this.selects.length) {
            this.addSelect(this.selects);
          }
          if (this.findOptions.where) {
            this.conditions = this.buildWhere(this.findOptions.where, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);
            if (this.conditions.length)
              this.andWhere(this.conditions.substr(0, 1) !== "(" ? "(" + this.conditions + ")" : this.conditions);
          }
          if (this.findOptions.order) {
            this.buildOrder(this.findOptions.order, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);
          }
          if (this.joins.length) {
            this.joins.forEach((join) => {
              if (join.select && !join.selection) {
                if (join.type === "inner") {
                  this.innerJoinAndSelect(`${join.parentAlias}.${join.relationMetadata.propertyPath}`, join.alias);
                } else {
                  this.leftJoinAndSelect(`${join.parentAlias}.${join.relationMetadata.propertyPath}`, join.alias);
                }
              } else {
                if (join.type === "inner") {
                  this.innerJoin(`${join.parentAlias}.${join.relationMetadata.propertyPath}`, join.alias);
                } else {
                  this.leftJoin(`${join.parentAlias}.${join.relationMetadata.propertyPath}`, join.alias);
                }
              }
            });
          }
          if (this.findOptions.skip !== void 0) {
            this.skip(this.findOptions.skip);
          }
          if (this.findOptions.take !== void 0) {
            this.take(this.findOptions.take);
          }
          if (typeof this.findOptions.cache === "number") {
            this.cache(this.findOptions.cache);
          } else if (typeof this.findOptions.cache === "boolean") {
            this.cache(this.findOptions.cache);
          } else if (typeof this.findOptions.cache === "object") {
            this.cache(this.findOptions.cache.id, this.findOptions.cache.milliseconds);
          }
          if (this.findOptions.join) {
            if (this.findOptions.join.leftJoin)
              Object.keys(this.findOptions.join.leftJoin).forEach((key) => {
                this.leftJoin(this.findOptions.join.leftJoin[key], key);
              });
            if (this.findOptions.join.innerJoin)
              Object.keys(this.findOptions.join.innerJoin).forEach((key) => {
                this.innerJoin(this.findOptions.join.innerJoin[key], key);
              });
            if (this.findOptions.join.leftJoinAndSelect)
              Object.keys(this.findOptions.join.leftJoinAndSelect).forEach((key) => {
                this.leftJoinAndSelect(this.findOptions.join.leftJoinAndSelect[key], key);
              });
            if (this.findOptions.join.innerJoinAndSelect)
              Object.keys(this.findOptions.join.innerJoinAndSelect).forEach((key) => {
                this.innerJoinAndSelect(this.findOptions.join.innerJoinAndSelect[key], key);
              });
          }
          if (this.findOptions.lock) {
            if (this.findOptions.lock.mode === "optimistic") {
              this.setLock(this.findOptions.lock.mode, this.findOptions.lock.version);
            } else if (this.findOptions.lock.mode === "pessimistic_read" || this.findOptions.lock.mode === "pessimistic_write" || this.findOptions.lock.mode === "dirty_read" || this.findOptions.lock.mode === "pessimistic_partial_write" || this.findOptions.lock.mode === "pessimistic_write_or_fail" || this.findOptions.lock.mode === "for_no_key_update" || this.findOptions.lock.mode === "for_key_share") {
              const tableNames = this.findOptions.lock.tables ? this.findOptions.lock.tables.map((table) => {
                const tableAlias = this.expressionMap.aliases.find((alias) => {
                  return alias.metadata.tableNameWithoutPrefix === table;
                });
                if (!tableAlias) {
                  throw new error_1.TypeORMError(`"${table}" is not part of this query`);
                }
                return this.escape(tableAlias.name);
              }) : void 0;
              this.setLock(this.findOptions.lock.mode, void 0, tableNames);
              if (this.findOptions.lock.onLocked) {
                this.setOnLocked(this.findOptions.lock.onLocked);
              }
            }
          }
          if (this.findOptions.loadRelationIds === true) {
            this.loadAllRelationIds();
          } else if (typeof this.findOptions.loadRelationIds === "object") {
            this.loadAllRelationIds(this.findOptions.loadRelationIds);
          }
          if (this.findOptions.loadEagerRelations !== false) {
            FindOptionsUtils_1.FindOptionsUtils.joinEagerRelations(this, this.expressionMap.mainAlias.name, this.expressionMap.mainAlias.metadata);
          }
          if (this.findOptions.transaction === true) {
            this.expressionMap.useTransaction = true;
          }
        }
      }
      concatRelationMetadata(relationMetadata) {
        this.relationMetadatas.push(relationMetadata);
      }
      /**
       * Executes sql generated by query builder and returns object with raw results and entities created from them.
       */
      async executeEntitiesAndRawResults(queryRunner) {
        if (!this.expressionMap.mainAlias)
          throw new error_1.TypeORMError(`Alias is not set. Use "from" method to set an alias.`);
        if ((this.expressionMap.lockMode === "pessimistic_read" || this.expressionMap.lockMode === "pessimistic_write" || this.expressionMap.lockMode === "pessimistic_partial_write" || this.expressionMap.lockMode === "pessimistic_write_or_fail" || this.expressionMap.lockMode === "for_no_key_update" || this.expressionMap.lockMode === "for_key_share") && !queryRunner.isTransactionActive)
          throw new PessimisticLockTransactionRequiredError_1.PessimisticLockTransactionRequiredError();
        if (this.expressionMap.lockMode === "optimistic") {
          const metadata = this.expressionMap.mainAlias.metadata;
          if (!metadata.versionColumn && !metadata.updateDateColumn)
            throw new NoVersionOrUpdateDateColumnError_1.NoVersionOrUpdateDateColumnError(metadata.name);
        }
        const relationIdLoader = new RelationIdLoader_1.RelationIdLoader(this.connection, queryRunner, this.expressionMap.relationIdAttributes);
        const relationCountLoader = new RelationCountLoader_1.RelationCountLoader(this.connection, queryRunner, this.expressionMap.relationCountAttributes);
        const relationIdMetadataTransformer = new RelationIdMetadataToAttributeTransformer_1.RelationIdMetadataToAttributeTransformer(this.expressionMap);
        relationIdMetadataTransformer.transform();
        const relationCountMetadataTransformer = new RelationCountMetadataToAttributeTransformer_1.RelationCountMetadataToAttributeTransformer(this.expressionMap);
        relationCountMetadataTransformer.transform();
        let rawResults = [], entities = [];
        if ((this.expressionMap.skip || this.expressionMap.take) && this.expressionMap.joinAttributes.length > 0) {
          const [selects, orderBys] = this.createOrderByCombinedWithSelectExpression("distinctAlias");
          const metadata = this.expressionMap.mainAlias.metadata;
          const mainAliasName = this.expressionMap.mainAlias.name;
          const querySelects = metadata.primaryColumns.map((primaryColumn) => {
            const distinctAlias = this.escape("distinctAlias");
            const columnAlias = this.escape(DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, void 0, mainAliasName, primaryColumn.databaseName));
            if (!orderBys[columnAlias])
              orderBys[columnAlias] = "ASC";
            const alias = DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, void 0, "ids_" + mainAliasName, primaryColumn.databaseName);
            return `${distinctAlias}.${columnAlias} AS ${this.escape(alias)}`;
          });
          const originalQuery = this.clone();
          const originalQueryTimeTravel = originalQuery.expressionMap.timeTravel;
          rawResults = await new _SelectQueryBuilder(this.connection, queryRunner).select(`DISTINCT ${querySelects.join(", ")}`).addSelect(selects).from(`(${originalQuery.orderBy().timeTravelQuery(false).getQuery()})`, "distinctAlias").timeTravelQuery(originalQueryTimeTravel).offset(this.expressionMap.skip).limit(this.expressionMap.take).orderBy(orderBys).cache(this.expressionMap.cache && this.expressionMap.cacheId ? `${this.expressionMap.cacheId}-pagination` : this.expressionMap.cache, this.expressionMap.cacheDuration).setParameters(this.getParameters()).setNativeParameters(this.expressionMap.nativeParameters).getRawMany();
          if (rawResults.length > 0) {
            let condition = "";
            const parameters = {};
            if (metadata.hasMultiplePrimaryKeys) {
              condition = rawResults.map((result, index) => {
                return metadata.primaryColumns.map((primaryColumn) => {
                  const paramKey = `orm_distinct_ids_${index}_${primaryColumn.databaseName}`;
                  const paramKeyResult = DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, void 0, "ids_" + mainAliasName, primaryColumn.databaseName);
                  parameters[paramKey] = result[paramKeyResult];
                  return `${mainAliasName}.${primaryColumn.propertyPath}=:${paramKey}`;
                }).join(" AND ");
              }).join(" OR ");
            } else {
              const alias = DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, void 0, "ids_" + mainAliasName, metadata.primaryColumns[0].databaseName);
              const ids = rawResults.map((result) => result[alias]);
              const areAllNumbers = ids.every((id) => typeof id === "number");
              if (areAllNumbers) {
                condition = `${mainAliasName}.${metadata.primaryColumns[0].propertyPath} IN (${ids.join(", ")})`;
              } else {
                parameters["orm_distinct_ids"] = ids;
                condition = mainAliasName + "." + metadata.primaryColumns[0].propertyPath + " IN (:...orm_distinct_ids)";
              }
            }
            rawResults = await this.clone().mergeExpressionMap({
              extraAppendedAndWhereCondition: condition
            }).setParameters(parameters).loadRawResults(queryRunner);
          }
        } else {
          rawResults = await this.loadRawResults(queryRunner);
        }
        if (rawResults.length > 0) {
          const rawRelationIdResults = await relationIdLoader.load(rawResults);
          const rawRelationCountResults = await relationCountLoader.load(rawResults);
          const transformer = new RawSqlResultsToEntityTransformer_1.RawSqlResultsToEntityTransformer(this.expressionMap, this.connection.driver, rawRelationIdResults, rawRelationCountResults, this.queryRunner);
          entities = transformer.transform(rawResults, this.expressionMap.mainAlias);
          if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {
            await queryRunner.broadcaster.broadcast("Load", this.expressionMap.mainAlias.metadata, entities);
          }
        }
        if (this.expressionMap.relationLoadStrategy === "query") {
          const queryStrategyRelationIdLoader = new RelationIdLoader_2.RelationIdLoader(this.connection, queryRunner);
          await Promise.all(this.relationMetadatas.map(async (relation) => {
            const relationTarget = relation.inverseEntityMetadata.target;
            const relationAlias = relation.inverseEntityMetadata.targetName;
            const select = Array.isArray(this.findOptions.select) ? OrmUtils_1.OrmUtils.propertyPathsToTruthyObject(this.findOptions.select) : this.findOptions.select;
            const relations = Array.isArray(this.findOptions.relations) ? OrmUtils_1.OrmUtils.propertyPathsToTruthyObject(this.findOptions.relations) : this.findOptions.relations;
            const queryBuilder = this.createQueryBuilder(queryRunner).select(relationAlias).from(relationTarget, relationAlias).setFindOptions({
              select: select ? OrmUtils_1.OrmUtils.deepValue(select, relation.propertyPath) : void 0,
              order: this.findOptions.order ? OrmUtils_1.OrmUtils.deepValue(this.findOptions.order, relation.propertyPath) : void 0,
              relations: relations ? OrmUtils_1.OrmUtils.deepValue(relations, relation.propertyPath) : void 0,
              withDeleted: this.findOptions.withDeleted,
              relationLoadStrategy: this.findOptions.relationLoadStrategy
            });
            if (entities.length > 0) {
              const relatedEntityGroups = await queryStrategyRelationIdLoader.loadManyToManyRelationIdsAndGroup(relation, entities, void 0, queryBuilder);
              entities.forEach((entity) => {
                const relatedEntityGroup = relatedEntityGroups.find((group) => group.entity === entity);
                if (relatedEntityGroup) {
                  const value = relatedEntityGroup.related === void 0 ? null : relatedEntityGroup.related;
                  relation.setEntityValue(entity, value);
                }
              });
            }
          }));
        }
        return {
          raw: rawResults,
          entities
        };
      }
      createOrderByCombinedWithSelectExpression(parentAlias) {
        const orderBys = this.expressionMap.allOrderBys;
        const selectString = Object.keys(orderBys).map((orderCriteria) => {
          if (orderCriteria.indexOf(".") !== -1) {
            const criteriaParts = orderCriteria.split(".");
            const aliasName = criteriaParts[0];
            const propertyPath = criteriaParts.slice(1).join(".");
            const alias = this.expressionMap.findAliasByName(aliasName);
            const column = alias.metadata.findColumnWithPropertyPath(propertyPath);
            return this.escape(parentAlias) + "." + this.escape(DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, void 0, aliasName, column.databaseName));
          } else {
            if (this.expressionMap.selects.find((select) => select.selection === orderCriteria || select.aliasName === orderCriteria))
              return this.escape(parentAlias) + "." + this.escape(orderCriteria);
            return "";
          }
        }).join(", ");
        const orderByObject = {};
        Object.keys(orderBys).forEach((orderCriteria) => {
          if (orderCriteria.indexOf(".") !== -1) {
            const criteriaParts = orderCriteria.split(".");
            const aliasName = criteriaParts[0];
            const propertyPath = criteriaParts.slice(1).join(".");
            const alias = this.expressionMap.findAliasByName(aliasName);
            const column = alias.metadata.findColumnWithPropertyPath(propertyPath);
            orderByObject[this.escape(parentAlias) + "." + this.escape(DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, void 0, aliasName, column.databaseName))] = orderBys[orderCriteria];
          } else {
            if (this.expressionMap.selects.find((select) => select.selection === orderCriteria || select.aliasName === orderCriteria)) {
              orderByObject[this.escape(parentAlias) + "." + this.escape(orderCriteria)] = orderBys[orderCriteria];
            } else {
              orderByObject[orderCriteria] = orderBys[orderCriteria];
            }
          }
        });
        return [selectString, orderByObject];
      }
      /**
       * Loads raw results from the database.
       */
      async loadRawResults(queryRunner) {
        const [sql, parameters] = this.getQueryAndParameters();
        const queryId = sql + " -- PARAMETERS: " + JSON.stringify(parameters, (_, value) => typeof value === "bigint" ? value.toString() : value);
        const cacheOptions = typeof this.connection.options.cache === "object" ? this.connection.options.cache : {};
        let savedQueryResultCacheOptions = void 0;
        const isCachingEnabled = (
          // Caching is enabled globally and isn't disabled locally.
          cacheOptions.alwaysEnabled && this.expressionMap.cache !== false || // ...or it's enabled locally explicitly.
          this.expressionMap.cache === true
        );
        let cacheError = false;
        if (this.connection.queryResultCache && isCachingEnabled) {
          try {
            savedQueryResultCacheOptions = await this.connection.queryResultCache.getFromCache({
              identifier: this.expressionMap.cacheId,
              query: queryId,
              duration: this.expressionMap.cacheDuration || cacheOptions.duration || 1e3
            }, queryRunner);
            if (savedQueryResultCacheOptions && !this.connection.queryResultCache.isExpired(savedQueryResultCacheOptions)) {
              return JSON.parse(savedQueryResultCacheOptions.result);
            }
          } catch (error) {
            if (!cacheOptions.ignoreErrors) {
              throw error;
            }
            cacheError = true;
          }
        }
        const results = await queryRunner.query(sql, parameters, true);
        if (!cacheError && this.connection.queryResultCache && isCachingEnabled) {
          try {
            await this.connection.queryResultCache.storeInCache({
              identifier: this.expressionMap.cacheId,
              query: queryId,
              time: Date.now(),
              duration: this.expressionMap.cacheDuration || cacheOptions.duration || 1e3,
              result: JSON.stringify(results.records)
            }, savedQueryResultCacheOptions, queryRunner);
          } catch (error) {
            if (!cacheOptions.ignoreErrors) {
              throw error;
            }
          }
        }
        return results.records;
      }
      /**
       * Merges into expression map given expression map properties.
       */
      mergeExpressionMap(expressionMap) {
        ObjectUtils_1.ObjectUtils.assign(this.expressionMap, expressionMap);
        return this;
      }
      /**
       * Normalizes a give number - converts to int if possible.
       */
      normalizeNumber(num) {
        if (typeof num === "number" || num === void 0 || num === null)
          return num;
        return Number(num);
      }
      /**
       * Creates a query builder used to execute sql queries inside this query builder.
       */
      obtainQueryRunner() {
        return this.queryRunner || this.connection.createQueryRunner(this.connection.defaultReplicationModeForReads());
      }
      buildSelect(select, metadata, alias, embedPrefix) {
        for (const key in select) {
          if (select[key] === void 0 || select[key] === false)
            continue;
          const propertyPath = embedPrefix ? embedPrefix + "." + key : key;
          const column = metadata.findColumnWithPropertyPathStrict(propertyPath);
          const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);
          const relation = metadata.findRelationWithPropertyPath(propertyPath);
          if (!embed && !column && !relation)
            throw new EntityPropertyNotFoundError_1.EntityPropertyNotFoundError(propertyPath, metadata);
          if (column) {
            this.selects.push(alias + "." + propertyPath);
          } else if (embed) {
            this.buildSelect(select[key], metadata, alias, propertyPath);
          }
        }
      }
      buildRelations(relations, selection, metadata, alias, embedPrefix) {
        if (!relations)
          return;
        Object.keys(relations).forEach((relationName) => {
          const relationValue = relations[relationName];
          const propertyPath = embedPrefix ? embedPrefix + "." + relationName : relationName;
          const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);
          const relation = metadata.findRelationWithPropertyPath(propertyPath);
          if (!embed && !relation)
            throw new EntityPropertyNotFoundError_1.EntityPropertyNotFoundError(propertyPath, metadata);
          if (embed) {
            this.buildRelations(relationValue, typeof selection === "object" ? OrmUtils_1.OrmUtils.deepValue(selection, embed.propertyPath) : void 0, metadata, alias, propertyPath);
          } else if (relation) {
            let joinAlias = alias + "_" + propertyPath.replace(".", "_");
            joinAlias = DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, { joiner: "__" }, alias, joinAlias);
            if (relationValue === true || typeof relationValue === "object") {
              if (this.expressionMap.relationLoadStrategy === "query") {
                this.concatRelationMetadata(relation);
              } else {
                this.joins.push({
                  type: "left",
                  select: true,
                  selection: selection && typeof selection[relationName] === "object" ? selection[relationName] : void 0,
                  alias: joinAlias,
                  parentAlias: alias,
                  relationMetadata: relation
                });
                if (selection && typeof selection[relationName] === "object") {
                  this.buildSelect(selection[relationName], relation.inverseEntityMetadata, joinAlias);
                }
              }
            }
            if (typeof relationValue === "object" && this.expressionMap.relationLoadStrategy === "join") {
              this.buildRelations(relationValue, typeof selection === "object" ? OrmUtils_1.OrmUtils.deepValue(selection, relation.propertyPath) : void 0, relation.inverseEntityMetadata, joinAlias, void 0);
            }
          }
        });
      }
      buildEagerRelations(relations, selection, metadata, alias, embedPrefix) {
        if (!relations)
          return;
        Object.keys(relations).forEach((relationName) => {
          const relationValue = relations[relationName];
          const propertyPath = embedPrefix ? embedPrefix + "." + relationName : relationName;
          const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);
          const relation = metadata.findRelationWithPropertyPath(propertyPath);
          if (!embed && !relation)
            throw new EntityPropertyNotFoundError_1.EntityPropertyNotFoundError(propertyPath, metadata);
          if (embed) {
            this.buildEagerRelations(relationValue, typeof selection === "object" ? OrmUtils_1.OrmUtils.deepValue(selection, embed.propertyPath) : void 0, metadata, alias, propertyPath);
          } else if (relation) {
            let joinAlias = alias + "_" + propertyPath.replace(".", "_");
            joinAlias = DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, { joiner: "__" }, alias, joinAlias);
            if (relationValue === true || typeof relationValue === "object") {
              relation.inverseEntityMetadata.eagerRelations.forEach((eagerRelation) => {
                let eagerRelationJoinAlias = joinAlias + "_" + eagerRelation.propertyPath.replace(".", "_");
                eagerRelationJoinAlias = DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, { joiner: "__" }, joinAlias, eagerRelationJoinAlias);
                const existJoin = this.joins.find((join) => join.alias === eagerRelationJoinAlias);
                if (!existJoin) {
                  this.joins.push({
                    type: "left",
                    select: true,
                    alias: eagerRelationJoinAlias,
                    parentAlias: joinAlias,
                    selection: void 0,
                    relationMetadata: eagerRelation
                  });
                }
                if (selection && typeof selection[relationName] === "object") {
                  this.buildSelect(selection[relationName], relation.inverseEntityMetadata, joinAlias);
                }
              });
            }
            if (typeof relationValue === "object") {
              this.buildEagerRelations(relationValue, typeof selection === "object" ? OrmUtils_1.OrmUtils.deepValue(selection, relation.propertyPath) : void 0, relation.inverseEntityMetadata, joinAlias, void 0);
            }
          }
        });
      }
      buildOrder(order, metadata, alias, embedPrefix) {
        for (const key in order) {
          if (order[key] === void 0)
            continue;
          const propertyPath = embedPrefix ? embedPrefix + "." + key : key;
          const column = metadata.findColumnWithPropertyPathStrict(propertyPath);
          const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);
          const relation = metadata.findRelationWithPropertyPath(propertyPath);
          if (!embed && !column && !relation)
            throw new EntityPropertyNotFoundError_1.EntityPropertyNotFoundError(propertyPath, metadata);
          if (column) {
            let direction = typeof order[key] === "object" ? order[key].direction : order[key];
            direction = direction === "DESC" || direction === "desc" || direction === -1 ? "DESC" : "ASC";
            let nulls = typeof order[key] === "object" ? order[key].nulls : void 0;
            nulls = nulls?.toLowerCase() === "first" ? "NULLS FIRST" : nulls?.toLowerCase() === "last" ? "NULLS LAST" : void 0;
            const aliasPath = `${alias}.${propertyPath}`;
            this.addOrderBy(aliasPath, direction, nulls);
          } else if (embed) {
            this.buildOrder(order[key], metadata, alias, propertyPath);
          } else if (relation) {
            let joinAlias = alias + "_" + propertyPath.replace(".", "_");
            joinAlias = DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, { joiner: "__" }, alias, joinAlias);
            const existJoin = this.joins.find((join) => join.alias === joinAlias);
            if (!existJoin) {
              this.joins.push({
                type: "left",
                select: false,
                alias: joinAlias,
                parentAlias: alias,
                selection: void 0,
                relationMetadata: relation
              });
            }
            this.buildOrder(order[key], relation.inverseEntityMetadata, joinAlias);
          }
        }
      }
      buildWhere(where, metadata, alias, embedPrefix) {
        let condition = "";
        if (Array.isArray(where)) {
          if (where.length) {
            condition = where.map((whereItem) => {
              return this.buildWhere(whereItem, metadata, alias, embedPrefix);
            }).filter((condition2) => !!condition2).map((condition2) => "(" + condition2 + ")").join(" OR ");
          }
        } else {
          const andConditions = [];
          for (const key in where) {
            if (where[key] === void 0 || where[key] === null)
              continue;
            const propertyPath = embedPrefix ? embedPrefix + "." + key : key;
            const column = metadata.findColumnWithPropertyPathStrict(propertyPath);
            const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);
            const relation = metadata.findRelationWithPropertyPath(propertyPath);
            if (!embed && !column && !relation)
              throw new EntityPropertyNotFoundError_1.EntityPropertyNotFoundError(propertyPath, metadata);
            if (column) {
              let aliasPath = `${alias}.${propertyPath}`;
              if (column.isVirtualProperty && column.query) {
                aliasPath = `(${column.query(this.escape(alias))})`;
              }
              let parameterValue = where[key];
              if (InstanceChecker_1.InstanceChecker.isEqualOperator(where[key])) {
                parameterValue = where[key].value;
              }
              if (column.transformer) {
                if (parameterValue instanceof FindOperator_1.FindOperator) {
                  parameterValue.transformValue(column.transformer);
                } else {
                  parameterValue = ApplyValueTransformers_1.ApplyValueTransformers.transformTo(column.transformer, parameterValue);
                }
              }
              if (this.connection.driver.options.type === "mssql") {
                parameterValue = this.connection.driver.parametrizeValues(column, parameterValue);
              }
              andConditions.push(this.createWhereConditionExpression(this.getWherePredicateCondition(aliasPath, parameterValue)));
            } else if (embed) {
              const condition2 = this.buildWhere(where[key], metadata, alias, propertyPath);
              if (condition2)
                andConditions.push(condition2);
            } else if (relation) {
              if (typeof where[key] === "object") {
                const allAllUndefined = Object.keys(where[key]).every((k) => where[key][k] === void 0);
                if (allAllUndefined) {
                  continue;
                }
              }
              if (InstanceChecker_1.InstanceChecker.isFindOperator(where[key])) {
                if (where[key].type === "moreThan" || where[key].type === "lessThan" || where[key].type === "moreThanOrEqual" || where[key].type === "lessThanOrEqual") {
                  let sqlOperator = "";
                  if (where[key].type === "moreThan") {
                    sqlOperator = ">";
                  } else if (where[key].type === "lessThan") {
                    sqlOperator = "<";
                  } else if (where[key].type === "moreThanOrEqual") {
                    sqlOperator = ">=";
                  } else if (where[key].type === "lessThanOrEqual") {
                    sqlOperator = "<=";
                  }
                  const qb = this.subQuery();
                  if (relation.isManyToManyOwner) {
                    qb.select("COUNT(*)").from(relation.joinTableName, relation.joinTableName).where(relation.joinColumns.map((column2) => {
                      return `${relation.joinTableName}.${column2.propertyName} = ${alias}.${column2.referencedColumn.propertyName}`;
                    }).join(" AND "));
                  } else if (relation.isManyToManyNotOwner) {
                    qb.select("COUNT(*)").from(relation.inverseRelation.joinTableName, relation.inverseRelation.joinTableName).where(relation.inverseRelation.inverseJoinColumns.map((column2) => {
                      return `${relation.inverseRelation.joinTableName}.${column2.propertyName} = ${alias}.${column2.referencedColumn.propertyName}`;
                    }).join(" AND "));
                  } else if (relation.isOneToMany) {
                    qb.select("COUNT(*)").from(relation.inverseEntityMetadata.target, relation.inverseEntityMetadata.tableName).where(relation.inverseRelation.joinColumns.map((column2) => {
                      return `${relation.inverseEntityMetadata.tableName}.${column2.propertyName} = ${alias}.${column2.referencedColumn.propertyName}`;
                    }).join(" AND "));
                  } else {
                    throw new Error(`This relation isn't supported by given find operator`);
                  }
                  this.andWhere(qb.getSql() + " " + sqlOperator + " " + parseInt(where[key].value));
                } else {
                  if (relation.isManyToOne || relation.isOneToOne && relation.isOneToOneOwner) {
                    const aliasPath = `${alias}.${propertyPath}`;
                    andConditions.push(this.createWhereConditionExpression(this.getWherePredicateCondition(aliasPath, where[key])));
                  } else {
                    throw new Error(`This relation isn't supported by given find operator`);
                  }
                }
              } else {
                let joinAlias = alias + "_" + relation.propertyPath.replace(".", "_");
                joinAlias = DriverUtils_1.DriverUtils.buildAlias(this.connection.driver, { joiner: "__" }, alias, joinAlias);
                const existJoin = this.joins.find((join) => join.alias === joinAlias);
                if (!existJoin) {
                  this.joins.push({
                    type: "left",
                    select: false,
                    selection: void 0,
                    alias: joinAlias,
                    parentAlias: alias,
                    relationMetadata: relation
                  });
                }
                const condition2 = this.buildWhere(where[key], relation.inverseEntityMetadata, joinAlias);
                if (condition2) {
                  andConditions.push(condition2);
                }
              }
            }
          }
          condition = andConditions.length ? "(" + andConditions.join(") AND (") + ")" : andConditions.join(" AND ");
        }
        return condition.length ? "(" + condition + ")" : condition;
      }
    };
    exports2.SelectQueryBuilder = SelectQueryBuilder2;
  }
});

// node_modules/typeorm/query-builder/result/UpdateResult.js
var require_UpdateResult = __commonJS({
  "node_modules/typeorm/query-builder/result/UpdateResult.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UpdateResult = void 0;
    var UpdateResult2 = class {
      constructor() {
        this.generatedMaps = [];
      }
      static from(queryResult) {
        const result = new this();
        result.raw = queryResult.records;
        result.affected = queryResult.affected;
        return result;
      }
    };
    exports2.UpdateResult = UpdateResult2;
  }
});

// node_modules/typeorm/query-builder/SoftDeleteQueryBuilder.js
var require_SoftDeleteQueryBuilder = __commonJS({
  "node_modules/typeorm/query-builder/SoftDeleteQueryBuilder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SoftDeleteQueryBuilder = void 0;
    var QueryBuilder_1 = require_QueryBuilder();
    var UpdateResult_1 = require_UpdateResult();
    var ReturningStatementNotSupportedError_1 = require_ReturningStatementNotSupportedError();
    var ReturningResultsEntityUpdator_1 = require_ReturningResultsEntityUpdator();
    var LimitOnUpdateNotSupportedError_1 = require_LimitOnUpdateNotSupportedError();
    var MissingDeleteDateColumnError_1 = require_MissingDeleteDateColumnError();
    var UpdateValuesMissingError_1 = require_UpdateValuesMissingError();
    var error_1 = require_error();
    var DriverUtils_1 = require_DriverUtils();
    var InstanceChecker_1 = require_InstanceChecker();
    var SoftDeleteQueryBuilder = class extends QueryBuilder_1.QueryBuilder {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connectionOrQueryBuilder, queryRunner) {
        super(connectionOrQueryBuilder, queryRunner);
        this["@instanceof"] = Symbol.for("SoftDeleteQueryBuilder");
        this.expressionMap.aliasNamePrefixingEnabled = false;
      }
      // -------------------------------------------------------------------------
      // Public Implemented Methods
      // -------------------------------------------------------------------------
      /**
       * Gets generated SQL query without parameters being replaced.
       */
      getQuery() {
        let sql = this.createUpdateExpression();
        sql += this.createCteExpression();
        sql += this.createOrderByExpression();
        sql += this.createLimitExpression();
        return this.replacePropertyNamesForTheWholeQuery(sql.trim());
      }
      /**
       * Executes sql generated by query builder and returns raw database results.
       */
      async execute() {
        const queryRunner = this.obtainQueryRunner();
        let transactionStartedByUs = false;
        try {
          if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {
            await queryRunner.startTransaction();
            transactionStartedByUs = true;
          }
          if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {
            if (this.expressionMap.queryType === "soft-delete")
              await queryRunner.broadcaster.broadcast("BeforeSoftRemove", this.expressionMap.mainAlias.metadata);
            else if (this.expressionMap.queryType === "restore")
              await queryRunner.broadcaster.broadcast("BeforeRecover", this.expressionMap.mainAlias.metadata);
          }
          const returningResultsEntityUpdator = new ReturningResultsEntityUpdator_1.ReturningResultsEntityUpdator(queryRunner, this.expressionMap);
          if (this.expressionMap.updateEntity === true && this.expressionMap.mainAlias.hasMetadata && this.expressionMap.whereEntities.length > 0) {
            this.expressionMap.extraReturningColumns = returningResultsEntityUpdator.getSoftDeletionReturningColumns();
          }
          const [sql, parameters] = this.getQueryAndParameters();
          const queryResult = await queryRunner.query(sql, parameters, true);
          const updateResult = UpdateResult_1.UpdateResult.from(queryResult);
          if (this.expressionMap.updateEntity === true && this.expressionMap.mainAlias.hasMetadata && this.expressionMap.whereEntities.length > 0) {
            await returningResultsEntityUpdator.update(updateResult, this.expressionMap.whereEntities);
          }
          if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {
            if (this.expressionMap.queryType === "soft-delete")
              await queryRunner.broadcaster.broadcast("AfterSoftRemove", this.expressionMap.mainAlias.metadata);
            else if (this.expressionMap.queryType === "restore")
              await queryRunner.broadcaster.broadcast("AfterRecover", this.expressionMap.mainAlias.metadata);
          }
          if (transactionStartedByUs)
            await queryRunner.commitTransaction();
          return updateResult;
        } catch (error) {
          if (transactionStartedByUs) {
            try {
              await queryRunner.rollbackTransaction();
            } catch (rollbackError) {
            }
          }
          throw error;
        } finally {
          if (queryRunner !== this.queryRunner) {
            await queryRunner.release();
          }
        }
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Specifies FROM which entity's table select/update/delete/soft-delete will be executed.
       * Also sets a main string alias of the selection data.
       */
      from(entityTarget, aliasName) {
        entityTarget = InstanceChecker_1.InstanceChecker.isEntitySchema(entityTarget) ? entityTarget.options.name : entityTarget;
        const mainAlias = this.createFromAlias(entityTarget, aliasName);
        this.expressionMap.setMainAlias(mainAlias);
        return this;
      }
      /**
       * Sets WHERE condition in the query builder.
       * If you had previously WHERE expression defined,
       * calling this function will override previously set WHERE conditions.
       * Additionally you can add parameters used in where expression.
       */
      where(where, parameters) {
        this.expressionMap.wheres = [];
        const condition = this.getWhereCondition(where);
        if (condition)
          this.expressionMap.wheres = [
            { type: "simple", condition }
          ];
        if (parameters)
          this.setParameters(parameters);
        return this;
      }
      /**
       * Adds new AND WHERE condition in the query builder.
       * Additionally you can add parameters used in where expression.
       */
      andWhere(where, parameters) {
        this.expressionMap.wheres.push({
          type: "and",
          condition: this.getWhereCondition(where)
        });
        if (parameters)
          this.setParameters(parameters);
        return this;
      }
      /**
       * Adds new OR WHERE condition in the query builder.
       * Additionally you can add parameters used in where expression.
       */
      orWhere(where, parameters) {
        this.expressionMap.wheres.push({
          type: "or",
          condition: this.getWhereCondition(where)
        });
        if (parameters)
          this.setParameters(parameters);
        return this;
      }
      /**
       * Adds new AND WHERE with conditions for the given ids.
       */
      whereInIds(ids) {
        return this.where(this.getWhereInIdsCondition(ids));
      }
      /**
       * Adds new AND WHERE with conditions for the given ids.
       */
      andWhereInIds(ids) {
        return this.andWhere(this.getWhereInIdsCondition(ids));
      }
      /**
       * Adds new OR WHERE with conditions for the given ids.
       */
      orWhereInIds(ids) {
        return this.orWhere(this.getWhereInIdsCondition(ids));
      }
      /**
       * Optional returning/output clause.
       */
      output(output) {
        return this.returning(output);
      }
      /**
       * Optional returning/output clause.
       */
      returning(returning) {
        if (!this.connection.driver.isReturningSqlSupported("update")) {
          throw new ReturningStatementNotSupportedError_1.ReturningStatementNotSupportedError();
        }
        this.expressionMap.returning = returning;
        return this;
      }
      /**
       * Sets ORDER BY condition in the query builder.
       * If you had previously ORDER BY expression defined,
       * calling this function will override previously set ORDER BY conditions.
       */
      orderBy(sort, order = "ASC", nulls) {
        if (sort) {
          if (typeof sort === "object") {
            this.expressionMap.orderBys = sort;
          } else {
            if (nulls) {
              this.expressionMap.orderBys = {
                [sort]: { order, nulls }
              };
            } else {
              this.expressionMap.orderBys = { [sort]: order };
            }
          }
        } else {
          this.expressionMap.orderBys = {};
        }
        return this;
      }
      /**
       * Adds ORDER BY condition in the query builder.
       */
      addOrderBy(sort, order = "ASC", nulls) {
        if (nulls) {
          this.expressionMap.orderBys[sort] = { order, nulls };
        } else {
          this.expressionMap.orderBys[sort] = order;
        }
        return this;
      }
      /**
       * Sets LIMIT - maximum number of rows to be selected.
       */
      limit(limit) {
        this.expressionMap.limit = limit;
        return this;
      }
      /**
       * Indicates if entity must be updated after update operation.
       * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).
       * Enabled by default.
       */
      whereEntity(entity) {
        if (!this.expressionMap.mainAlias.hasMetadata)
          throw new error_1.TypeORMError(`.whereEntity method can only be used on queries which update real entity table.`);
        this.expressionMap.wheres = [];
        const entities = Array.isArray(entity) ? entity : [entity];
        entities.forEach((entity2) => {
          const entityIdMap = this.expressionMap.mainAlias.metadata.getEntityIdMap(entity2);
          if (!entityIdMap)
            throw new error_1.TypeORMError(`Provided entity does not have ids set, cannot perform operation.`);
          this.orWhereInIds(entityIdMap);
        });
        this.expressionMap.whereEntities = entities;
        return this;
      }
      /**
       * Indicates if entity must be updated after update operation.
       * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).
       * Enabled by default.
       */
      updateEntity(enabled) {
        this.expressionMap.updateEntity = enabled;
        return this;
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Creates UPDATE express used to perform insert query.
       */
      createUpdateExpression() {
        const metadata = this.expressionMap.mainAlias.hasMetadata ? this.expressionMap.mainAlias.metadata : void 0;
        if (!metadata)
          throw new error_1.TypeORMError(`Cannot get entity metadata for the given alias "${this.expressionMap.mainAlias}"`);
        if (!metadata.deleteDateColumn) {
          throw new MissingDeleteDateColumnError_1.MissingDeleteDateColumnError(metadata);
        }
        const updateColumnAndValues = [];
        switch (this.expressionMap.queryType) {
          case "soft-delete":
            updateColumnAndValues.push(this.escape(metadata.deleteDateColumn.databaseName) + " = CURRENT_TIMESTAMP");
            break;
          case "restore":
            updateColumnAndValues.push(this.escape(metadata.deleteDateColumn.databaseName) + " = NULL");
            break;
          default:
            throw new error_1.TypeORMError(`The queryType must be "soft-delete" or "restore"`);
        }
        if (metadata.versionColumn)
          updateColumnAndValues.push(this.escape(metadata.versionColumn.databaseName) + " = " + this.escape(metadata.versionColumn.databaseName) + " + 1");
        if (metadata.updateDateColumn)
          updateColumnAndValues.push(this.escape(metadata.updateDateColumn.databaseName) + " = CURRENT_TIMESTAMP");
        if (updateColumnAndValues.length <= 0) {
          throw new UpdateValuesMissingError_1.UpdateValuesMissingError();
        }
        const whereExpression = this.createWhereExpression();
        const returningExpression = this.createReturningExpression("update");
        if (returningExpression === "") {
          return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(", ")}${whereExpression}`;
        }
        if (this.connection.driver.options.type === "mssql") {
          return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(", ")} OUTPUT ${returningExpression}${whereExpression}`;
        }
        return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(", ")}${whereExpression} RETURNING ${returningExpression}`;
      }
      /**
       * Creates "ORDER BY" part of SQL query.
       */
      createOrderByExpression() {
        const orderBys = this.expressionMap.orderBys;
        if (Object.keys(orderBys).length > 0)
          return " ORDER BY " + Object.keys(orderBys).map((columnName) => {
            if (typeof orderBys[columnName] === "string") {
              return this.replacePropertyNames(columnName) + " " + orderBys[columnName];
            } else {
              return this.replacePropertyNames(columnName) + " " + orderBys[columnName].order + " " + orderBys[columnName].nulls;
            }
          }).join(", ");
        return "";
      }
      /**
       * Creates "LIMIT" parts of SQL query.
       */
      createLimitExpression() {
        const limit = this.expressionMap.limit;
        if (limit) {
          if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver)) {
            return " LIMIT " + limit;
          } else {
            throw new LimitOnUpdateNotSupportedError_1.LimitOnUpdateNotSupportedError();
          }
        }
        return "";
      }
    };
    exports2.SoftDeleteQueryBuilder = SoftDeleteQueryBuilder;
  }
});

// node_modules/typeorm/query-builder/UpdateQueryBuilder.js
var require_UpdateQueryBuilder = __commonJS({
  "node_modules/typeorm/query-builder/UpdateQueryBuilder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UpdateQueryBuilder = void 0;
    var QueryBuilder_1 = require_QueryBuilder();
    var UpdateResult_1 = require_UpdateResult();
    var ReturningStatementNotSupportedError_1 = require_ReturningStatementNotSupportedError();
    var ReturningResultsEntityUpdator_1 = require_ReturningResultsEntityUpdator();
    var LimitOnUpdateNotSupportedError_1 = require_LimitOnUpdateNotSupportedError();
    var UpdateValuesMissingError_1 = require_UpdateValuesMissingError();
    var error_1 = require_error();
    var EntityPropertyNotFoundError_1 = require_EntityPropertyNotFoundError();
    var DriverUtils_1 = require_DriverUtils();
    var UpdateQueryBuilder2 = class extends QueryBuilder_1.QueryBuilder {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connectionOrQueryBuilder, queryRunner) {
        super(connectionOrQueryBuilder, queryRunner);
        this["@instanceof"] = Symbol.for("UpdateQueryBuilder");
        this.expressionMap.aliasNamePrefixingEnabled = false;
      }
      // -------------------------------------------------------------------------
      // Public Implemented Methods
      // -------------------------------------------------------------------------
      /**
       * Gets generated SQL query without parameters being replaced.
       */
      getQuery() {
        let sql = this.createComment();
        sql += this.createCteExpression();
        sql += this.createUpdateExpression();
        sql += this.createOrderByExpression();
        sql += this.createLimitExpression();
        return this.replacePropertyNamesForTheWholeQuery(sql.trim());
      }
      /**
       * Executes sql generated by query builder and returns raw database results.
       */
      async execute() {
        const queryRunner = this.obtainQueryRunner();
        let transactionStartedByUs = false;
        try {
          if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {
            await queryRunner.startTransaction();
            transactionStartedByUs = true;
          }
          if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {
            await queryRunner.broadcaster.broadcast("BeforeUpdate", this.expressionMap.mainAlias.metadata, this.expressionMap.valuesSet);
          }
          let declareSql = null;
          let selectOutputSql = null;
          const returningResultsEntityUpdator = new ReturningResultsEntityUpdator_1.ReturningResultsEntityUpdator(queryRunner, this.expressionMap);
          const returningColumns = [];
          if (Array.isArray(this.expressionMap.returning) && this.expressionMap.mainAlias.hasMetadata) {
            for (const columnPath of this.expressionMap.returning) {
              returningColumns.push(...this.expressionMap.mainAlias.metadata.findColumnsWithPropertyPath(columnPath));
            }
          }
          if (this.expressionMap.updateEntity === true && this.expressionMap.mainAlias.hasMetadata && this.expressionMap.whereEntities.length > 0) {
            this.expressionMap.extraReturningColumns = returningResultsEntityUpdator.getUpdationReturningColumns();
            returningColumns.push(...this.expressionMap.extraReturningColumns.filter((c) => !returningColumns.includes(c)));
          }
          if (returningColumns.length > 0 && this.connection.driver.options.type === "mssql") {
            declareSql = this.connection.driver.buildTableVariableDeclaration("@OutputTable", returningColumns);
            selectOutputSql = `SELECT * FROM @OutputTable`;
          }
          const [updateSql, parameters] = this.getQueryAndParameters();
          const statements = [declareSql, updateSql, selectOutputSql];
          const queryResult = await queryRunner.query(statements.filter((sql) => sql != null).join(";\n\n"), parameters, true);
          const updateResult = UpdateResult_1.UpdateResult.from(queryResult);
          if (this.expressionMap.updateEntity === true && this.expressionMap.mainAlias.hasMetadata && this.expressionMap.whereEntities.length > 0) {
            await returningResultsEntityUpdator.update(updateResult, this.expressionMap.whereEntities);
          }
          if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {
            await queryRunner.broadcaster.broadcast("AfterUpdate", this.expressionMap.mainAlias.metadata, this.expressionMap.valuesSet);
          }
          if (transactionStartedByUs)
            await queryRunner.commitTransaction();
          return updateResult;
        } catch (error) {
          if (transactionStartedByUs) {
            try {
              await queryRunner.rollbackTransaction();
            } catch (rollbackError) {
            }
          }
          throw error;
        } finally {
          if (queryRunner !== this.queryRunner) {
            await queryRunner.release();
          }
        }
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Values needs to be updated.
       */
      set(values) {
        this.expressionMap.valuesSet = values;
        return this;
      }
      /**
       * Sets WHERE condition in the query builder.
       * If you had previously WHERE expression defined,
       * calling this function will override previously set WHERE conditions.
       * Additionally you can add parameters used in where expression.
       */
      where(where, parameters) {
        this.expressionMap.wheres = [];
        const condition = this.getWhereCondition(where);
        if (condition)
          this.expressionMap.wheres = [
            { type: "simple", condition }
          ];
        if (parameters)
          this.setParameters(parameters);
        return this;
      }
      /**
       * Adds new AND WHERE condition in the query builder.
       * Additionally you can add parameters used in where expression.
       */
      andWhere(where, parameters) {
        this.expressionMap.wheres.push({
          type: "and",
          condition: this.getWhereCondition(where)
        });
        if (parameters)
          this.setParameters(parameters);
        return this;
      }
      /**
       * Adds new OR WHERE condition in the query builder.
       * Additionally you can add parameters used in where expression.
       */
      orWhere(where, parameters) {
        this.expressionMap.wheres.push({
          type: "or",
          condition: this.getWhereCondition(where)
        });
        if (parameters)
          this.setParameters(parameters);
        return this;
      }
      /**
       * Sets WHERE condition in the query builder with a condition for the given ids.
       * If you had previously WHERE expression defined,
       * calling this function will override previously set WHERE conditions.
       */
      whereInIds(ids) {
        return this.where(this.getWhereInIdsCondition(ids));
      }
      /**
       * Adds new AND WHERE with conditions for the given ids.
       */
      andWhereInIds(ids) {
        return this.andWhere(this.getWhereInIdsCondition(ids));
      }
      /**
       * Adds new OR WHERE with conditions for the given ids.
       */
      orWhereInIds(ids) {
        return this.orWhere(this.getWhereInIdsCondition(ids));
      }
      /**
       * Optional returning/output clause.
       */
      output(output) {
        return this.returning(output);
      }
      /**
       * Optional returning/output clause.
       */
      returning(returning) {
        if (!this.connection.driver.isReturningSqlSupported("update")) {
          throw new ReturningStatementNotSupportedError_1.ReturningStatementNotSupportedError();
        }
        this.expressionMap.returning = returning;
        return this;
      }
      /**
       * Sets ORDER BY condition in the query builder.
       * If you had previously ORDER BY expression defined,
       * calling this function will override previously set ORDER BY conditions.
       */
      orderBy(sort, order = "ASC", nulls) {
        if (sort) {
          if (typeof sort === "object") {
            this.expressionMap.orderBys = sort;
          } else {
            if (nulls) {
              this.expressionMap.orderBys = {
                [sort]: { order, nulls }
              };
            } else {
              this.expressionMap.orderBys = { [sort]: order };
            }
          }
        } else {
          this.expressionMap.orderBys = {};
        }
        return this;
      }
      /**
       * Adds ORDER BY condition in the query builder.
       */
      addOrderBy(sort, order = "ASC", nulls) {
        if (nulls) {
          this.expressionMap.orderBys[sort] = { order, nulls };
        } else {
          this.expressionMap.orderBys[sort] = order;
        }
        return this;
      }
      /**
       * Sets LIMIT - maximum number of rows to be selected.
       */
      limit(limit) {
        this.expressionMap.limit = limit;
        return this;
      }
      /**
       * Indicates if entity must be updated after update operation.
       * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).
       * Enabled by default.
       */
      whereEntity(entity) {
        if (!this.expressionMap.mainAlias.hasMetadata)
          throw new error_1.TypeORMError(`.whereEntity method can only be used on queries which update real entity table.`);
        this.expressionMap.wheres = [];
        const entities = Array.isArray(entity) ? entity : [entity];
        entities.forEach((entity2) => {
          const entityIdMap = this.expressionMap.mainAlias.metadata.getEntityIdMap(entity2);
          if (!entityIdMap)
            throw new error_1.TypeORMError(`Provided entity does not have ids set, cannot perform operation.`);
          this.orWhereInIds(entityIdMap);
        });
        this.expressionMap.whereEntities = entities;
        return this;
      }
      /**
       * Indicates if entity must be updated after update operation.
       * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).
       * Enabled by default.
       */
      updateEntity(enabled) {
        this.expressionMap.updateEntity = enabled;
        return this;
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Creates UPDATE express used to perform insert query.
       */
      createUpdateExpression() {
        const valuesSet = this.getValueSet();
        const metadata = this.expressionMap.mainAlias.hasMetadata ? this.expressionMap.mainAlias.metadata : void 0;
        const valuesSetNormalized = {};
        for (const key in valuesSet) {
          if (valuesSet[key] !== void 0) {
            valuesSetNormalized[key] = valuesSet[key];
          }
        }
        const updateColumnAndValues = [];
        const updatedColumns = [];
        if (metadata) {
          this.createPropertyPath(metadata, valuesSetNormalized).forEach((propertyPath) => {
            const columns = metadata.findColumnsWithPropertyPath(propertyPath);
            if (columns.length <= 0) {
              throw new EntityPropertyNotFoundError_1.EntityPropertyNotFoundError(propertyPath, metadata);
            }
            columns.forEach((column) => {
              if (!column.isUpdate || updatedColumns.includes(column)) {
                return;
              }
              updatedColumns.push(column);
              let value = column.getEntityValue(valuesSetNormalized);
              if (column.referencedColumn && typeof value === "object" && !(value instanceof Date) && value !== null && !Buffer.isBuffer(value)) {
                value = column.referencedColumn.getEntityValue(value);
              } else if (!(typeof value === "function")) {
                value = this.connection.driver.preparePersistentValue(value, column);
              }
              if (typeof value === "function") {
                updateColumnAndValues.push(this.escape(column.databaseName) + " = " + value());
              } else if ((this.connection.driver.options.type === "sap" || this.connection.driver.options.type === "spanner") && value === null) {
                updateColumnAndValues.push(this.escape(column.databaseName) + " = NULL");
              } else {
                if (this.connection.driver.options.type === "mssql") {
                  value = this.connection.driver.parametrizeValue(column, value);
                }
                const paramName = this.createParameter(value);
                let expression = null;
                if ((DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql") && this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {
                  const useLegacy = this.connection.driver.options.legacySpatialSupport;
                  const geomFromText = useLegacy ? "GeomFromText" : "ST_GeomFromText";
                  if (column.srid != null) {
                    expression = `${geomFromText}(${paramName}, ${column.srid})`;
                  } else {
                    expression = `${geomFromText}(${paramName})`;
                  }
                } else if (DriverUtils_1.DriverUtils.isPostgresFamily(this.connection.driver) && this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {
                  if (column.srid != null) {
                    expression = `ST_SetSRID(ST_GeomFromGeoJSON(${paramName}), ${column.srid})::${column.type}`;
                  } else {
                    expression = `ST_GeomFromGeoJSON(${paramName})::${column.type}`;
                  }
                } else if (this.connection.driver.options.type === "mssql" && this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {
                  expression = column.type + "::STGeomFromText(" + paramName + ", " + (column.srid || "0") + ")";
                } else {
                  expression = paramName;
                }
                updateColumnAndValues.push(this.escape(column.databaseName) + " = " + expression);
              }
            });
          });
          if (updateColumnAndValues.length > 0 || Object.keys(valuesSetNormalized).length === 0) {
            if (metadata.versionColumn && updatedColumns.indexOf(metadata.versionColumn) === -1)
              updateColumnAndValues.push(this.escape(metadata.versionColumn.databaseName) + " = " + this.escape(metadata.versionColumn.databaseName) + " + 1");
            if (metadata.updateDateColumn && updatedColumns.indexOf(metadata.updateDateColumn) === -1)
              updateColumnAndValues.push(this.escape(metadata.updateDateColumn.databaseName) + " = CURRENT_TIMESTAMP");
          }
        } else {
          Object.keys(valuesSetNormalized).map((key) => {
            const value = valuesSetNormalized[key];
            if (typeof value === "function") {
              updateColumnAndValues.push(this.escape(key) + " = " + value());
            } else if ((this.connection.driver.options.type === "sap" || this.connection.driver.options.type === "spanner") && value === null) {
              updateColumnAndValues.push(this.escape(key) + " = NULL");
            } else {
              const paramName = this.createParameter(value);
              updateColumnAndValues.push(this.escape(key) + " = " + paramName);
            }
          });
        }
        if (updateColumnAndValues.length <= 0) {
          throw new UpdateValuesMissingError_1.UpdateValuesMissingError();
        }
        const whereExpression = this.createWhereExpression();
        const returningExpression = this.createReturningExpression("update");
        if (returningExpression === "") {
          return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(", ")}${whereExpression}`;
        }
        if (this.connection.driver.options.type === "mssql") {
          return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(", ")} OUTPUT ${returningExpression}${whereExpression}`;
        }
        if (this.connection.driver.options.type === "spanner") {
          return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(", ")}${whereExpression} THEN RETURN ${returningExpression}`;
        }
        return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(", ")}${whereExpression} RETURNING ${returningExpression}`;
      }
      /**
       * Creates "ORDER BY" part of SQL query.
       */
      createOrderByExpression() {
        const orderBys = this.expressionMap.orderBys;
        if (Object.keys(orderBys).length > 0)
          return " ORDER BY " + Object.keys(orderBys).map((columnName) => {
            if (typeof orderBys[columnName] === "string") {
              return this.replacePropertyNames(columnName) + " " + orderBys[columnName];
            } else {
              return this.replacePropertyNames(columnName) + " " + orderBys[columnName].order + " " + orderBys[columnName].nulls;
            }
          }).join(", ");
        return "";
      }
      /**
       * Creates "LIMIT" parts of SQL query.
       */
      createLimitExpression() {
        const limit = this.expressionMap.limit;
        if (limit) {
          if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql") {
            return " LIMIT " + limit;
          } else {
            throw new LimitOnUpdateNotSupportedError_1.LimitOnUpdateNotSupportedError();
          }
        }
        return "";
      }
      /**
       * Gets array of values need to be inserted into the target table.
       */
      getValueSet() {
        if (typeof this.expressionMap.valuesSet === "object")
          return this.expressionMap.valuesSet;
        throw new UpdateValuesMissingError_1.UpdateValuesMissingError();
      }
    };
    exports2.UpdateQueryBuilder = UpdateQueryBuilder2;
  }
});

// node_modules/typeorm/query-builder/index.js
var require_query_builder = __commonJS({
  "node_modules/typeorm/query-builder/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.registerQueryBuilders = registerQueryBuilders;
    var DeleteQueryBuilder_1 = require_DeleteQueryBuilder();
    var InsertQueryBuilder_1 = require_InsertQueryBuilder();
    var QueryBuilder_1 = require_QueryBuilder();
    var RelationQueryBuilder_1 = require_RelationQueryBuilder();
    var SelectQueryBuilder_1 = require_SelectQueryBuilder();
    var SoftDeleteQueryBuilder_1 = require_SoftDeleteQueryBuilder();
    var UpdateQueryBuilder_1 = require_UpdateQueryBuilder();
    function registerQueryBuilders() {
      QueryBuilder_1.QueryBuilder.registerQueryBuilderClass("DeleteQueryBuilder", (qb) => new DeleteQueryBuilder_1.DeleteQueryBuilder(qb));
      QueryBuilder_1.QueryBuilder.registerQueryBuilderClass("InsertQueryBuilder", (qb) => new InsertQueryBuilder_1.InsertQueryBuilder(qb));
      QueryBuilder_1.QueryBuilder.registerQueryBuilderClass("RelationQueryBuilder", (qb) => new RelationQueryBuilder_1.RelationQueryBuilder(qb));
      QueryBuilder_1.QueryBuilder.registerQueryBuilderClass("SelectQueryBuilder", (qb) => new SelectQueryBuilder_1.SelectQueryBuilder(qb));
      QueryBuilder_1.QueryBuilder.registerQueryBuilderClass("SoftDeleteQueryBuilder", (qb) => new SoftDeleteQueryBuilder_1.SoftDeleteQueryBuilder(qb));
      QueryBuilder_1.QueryBuilder.registerQueryBuilderClass("UpdateQueryBuilder", (qb) => new UpdateQueryBuilder_1.UpdateQueryBuilder(qb));
    }
  }
});

// node_modules/typeorm/util/RandomGenerator.js
var require_RandomGenerator = __commonJS({
  "node_modules/typeorm/util/RandomGenerator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RandomGenerator = void 0;
    var RandomGenerator = class {
      /**
       *  discuss at: http://locutus.io/php/sha1/
       * original by: Webtoolkit.info (http://www.webtoolkit.info/)
       * improved by: Michael White (http://getsprink.com)
       * improved by: Kevin van Zonneveld (http://kvz.io)
       *    input by: Brett Zamir (http://brett-zamir.me)
       *      note 1: Keep in mind that in accordance with PHP, the whole string is buffered and then
       *      note 1: hashed. If available, we'd recommend using Node's native crypto modules directly
       *      note 1: in a steaming fashion for faster and more efficient hashing
       *   example 1: sha1('Kevin van Zonneveld')
       *   returns 1: '54916d2e62f65b3afa6e192e6a601cdbe5cb5897'
       */
      static sha1(str) {
        const _rotLeft = function(n, s) {
          const t4 = n << s | n >>> 32 - s;
          return t4;
        };
        const _cvtHex = function(val) {
          let str2 = "";
          let i2;
          let v;
          for (i2 = 7; i2 >= 0; i2--) {
            v = val >>> i2 * 4 & 15;
            str2 += v.toString(16);
          }
          return str2;
        };
        let blockstart;
        let i, j;
        const W = new Array(80);
        let H0 = 1732584193;
        let H1 = 4023233417;
        let H2 = 2562383102;
        let H3 = 271733878;
        let H4 = 3285377520;
        let A, B, C, D, E;
        let temp;
        str = /*unescape*/
        encodeURIComponent(str);
        const strLen = str.length;
        const wordArray = [];
        for (i = 0; i < strLen - 3; i += 4) {
          j = str.charCodeAt(i) << 24 | str.charCodeAt(i + 1) << 16 | str.charCodeAt(i + 2) << 8 | str.charCodeAt(i + 3);
          wordArray.push(j);
        }
        switch (strLen % 4) {
          case 0:
            i = 2147483648;
            break;
          case 1:
            i = str.charCodeAt(strLen - 1) << 24 | 8388608;
            break;
          case 2:
            i = str.charCodeAt(strLen - 2) << 24 | str.charCodeAt(strLen - 1) << 16 | 32768;
            break;
          case 3:
            i = str.charCodeAt(strLen - 3) << 24 | str.charCodeAt(strLen - 2) << 16 | str.charCodeAt(strLen - 1) << 8 | 128;
            break;
        }
        wordArray.push(i);
        while (wordArray.length % 16 !== 14) {
          wordArray.push(0);
        }
        wordArray.push(strLen >>> 29);
        wordArray.push(strLen << 3 & 4294967295);
        for (blockstart = 0; blockstart < wordArray.length; blockstart += 16) {
          for (i = 0; i < 16; i++) {
            W[i] = wordArray[blockstart + i];
          }
          for (i = 16; i <= 79; i++) {
            W[i] = _rotLeft(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
          }
          A = H0;
          B = H1;
          C = H2;
          D = H3;
          E = H4;
          for (i = 0; i <= 19; i++) {
            temp = _rotLeft(A, 5) + (B & C | ~B & D) + E + W[i] + 1518500249 & 4294967295;
            E = D;
            D = C;
            C = _rotLeft(B, 30);
            B = A;
            A = temp;
          }
          for (i = 20; i <= 39; i++) {
            temp = _rotLeft(A, 5) + (B ^ C ^ D) + E + W[i] + 1859775393 & 4294967295;
            E = D;
            D = C;
            C = _rotLeft(B, 30);
            B = A;
            A = temp;
          }
          for (i = 40; i <= 59; i++) {
            temp = _rotLeft(A, 5) + (B & C | B & D | C & D) + E + W[i] + 2400959708 & 4294967295;
            E = D;
            D = C;
            C = _rotLeft(B, 30);
            B = A;
            A = temp;
          }
          for (i = 60; i <= 79; i++) {
            temp = _rotLeft(A, 5) + (B ^ C ^ D) + E + W[i] + 3395469782 & 4294967295;
            E = D;
            D = C;
            C = _rotLeft(B, 30);
            B = A;
            A = temp;
          }
          H0 = H0 + A & 4294967295;
          H1 = H1 + B & 4294967295;
          H2 = H2 + C & 4294967295;
          H3 = H3 + D & 4294967295;
          H4 = H4 + E & 4294967295;
        }
        temp = _cvtHex(H0) + _cvtHex(H1) + _cvtHex(H2) + _cvtHex(H3) + _cvtHex(H4);
        return temp.toLowerCase();
      }
    };
    exports2.RandomGenerator = RandomGenerator;
  }
});

// node_modules/typeorm/naming-strategy/DefaultNamingStrategy.js
var require_DefaultNamingStrategy = __commonJS({
  "node_modules/typeorm/naming-strategy/DefaultNamingStrategy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultNamingStrategy = void 0;
    var RandomGenerator_1 = require_RandomGenerator();
    var StringUtils_1 = require_StringUtils();
    var DefaultNamingStrategy2 = class {
      constructor() {
        this.nestedSetColumnNames = { left: "nsleft", right: "nsright" };
        this.materializedPathColumnName = "mpath";
      }
      getTableName(tableOrName) {
        if (typeof tableOrName !== "string") {
          tableOrName = tableOrName.name;
        }
        return tableOrName.split(".").pop();
      }
      /**
       * Normalizes table name.
       *
       * @param targetName Name of the target entity that can be used to generate a table name.
       * @param userSpecifiedName For example if user specified a table name in a decorator, e.g. @Entity("name")
       */
      tableName(targetName, userSpecifiedName) {
        return userSpecifiedName ? userSpecifiedName : (0, StringUtils_1.snakeCase)(targetName);
      }
      /**
       * Creates a table name for a junction table of a closure table.
       *
       * @param originalClosureTableName Name of the closure table which owns this junction table.
       */
      closureJunctionTableName(originalClosureTableName) {
        return originalClosureTableName + "_closure";
      }
      columnName(propertyName, customName, embeddedPrefixes) {
        const name = customName || propertyName;
        if (embeddedPrefixes.length)
          return (0, StringUtils_1.camelCase)(embeddedPrefixes.join("_")) + (0, StringUtils_1.titleCase)(name);
        return name;
      }
      relationName(propertyName) {
        return propertyName;
      }
      primaryKeyName(tableOrName, columnNames) {
        const clonedColumnNames = [...columnNames];
        clonedColumnNames.sort();
        const tableName = this.getTableName(tableOrName);
        const replacedTableName = tableName.replace(".", "_");
        const key = `${replacedTableName}_${clonedColumnNames.join("_")}`;
        return "PK_" + RandomGenerator_1.RandomGenerator.sha1(key).substr(0, 27);
      }
      uniqueConstraintName(tableOrName, columnNames) {
        const clonedColumnNames = [...columnNames];
        clonedColumnNames.sort();
        const tableName = this.getTableName(tableOrName);
        const replacedTableName = tableName.replace(".", "_");
        const key = `${replacedTableName}_${clonedColumnNames.join("_")}`;
        return "UQ_" + RandomGenerator_1.RandomGenerator.sha1(key).substr(0, 27);
      }
      relationConstraintName(tableOrName, columnNames, where) {
        const clonedColumnNames = [...columnNames];
        clonedColumnNames.sort();
        const tableName = this.getTableName(tableOrName);
        const replacedTableName = tableName.replace(".", "_");
        let key = `${replacedTableName}_${clonedColumnNames.join("_")}`;
        if (where)
          key += `_${where}`;
        return "REL_" + RandomGenerator_1.RandomGenerator.sha1(key).substr(0, 26);
      }
      defaultConstraintName(tableOrName, columnName) {
        const tableName = this.getTableName(tableOrName);
        const replacedTableName = tableName.replace(".", "_");
        const key = `${replacedTableName}_${columnName}`;
        return "DF_" + RandomGenerator_1.RandomGenerator.sha1(key).substr(0, 27);
      }
      foreignKeyName(tableOrName, columnNames, _referencedTablePath, _referencedColumnNames) {
        const clonedColumnNames = [...columnNames];
        clonedColumnNames.sort();
        const tableName = this.getTableName(tableOrName);
        const replacedTableName = tableName.replace(".", "_");
        const key = `${replacedTableName}_${clonedColumnNames.join("_")}`;
        return "FK_" + RandomGenerator_1.RandomGenerator.sha1(key).substr(0, 27);
      }
      indexName(tableOrName, columnNames, where) {
        const clonedColumnNames = [...columnNames];
        clonedColumnNames.sort();
        const tableName = this.getTableName(tableOrName);
        const replacedTableName = tableName.replace(".", "_");
        let key = `${replacedTableName}_${clonedColumnNames.join("_")}`;
        if (where)
          key += `_${where}`;
        return "IDX_" + RandomGenerator_1.RandomGenerator.sha1(key).substr(0, 26);
      }
      checkConstraintName(tableOrName, expression, isEnum) {
        const tableName = this.getTableName(tableOrName);
        const replacedTableName = tableName.replace(".", "_");
        const key = `${replacedTableName}_${expression}`;
        const name = "CHK_" + RandomGenerator_1.RandomGenerator.sha1(key).substr(0, 26);
        return isEnum ? `${name}_ENUM` : name;
      }
      exclusionConstraintName(tableOrName, expression) {
        const tableName = this.getTableName(tableOrName);
        const replacedTableName = tableName.replace(".", "_");
        const key = `${replacedTableName}_${expression}`;
        return "XCL_" + RandomGenerator_1.RandomGenerator.sha1(key).substr(0, 26);
      }
      joinColumnName(relationName, referencedColumnName) {
        return (0, StringUtils_1.camelCase)(relationName + "_" + referencedColumnName);
      }
      joinTableName(firstTableName, secondTableName, firstPropertyName, secondPropertyName) {
        return (0, StringUtils_1.snakeCase)(firstTableName + "_" + firstPropertyName.replace(/\./gi, "_") + "_" + secondTableName);
      }
      joinTableColumnDuplicationPrefix(columnName, index) {
        return columnName + "_" + index;
      }
      joinTableColumnName(tableName, propertyName, columnName) {
        return (0, StringUtils_1.camelCase)(tableName + "_" + (columnName ? columnName : propertyName));
      }
      joinTableInverseColumnName(tableName, propertyName, columnName) {
        return this.joinTableColumnName(tableName, propertyName, columnName);
      }
      /**
       * Adds globally set prefix to the table name.
       * This method is executed no matter if prefix was set or not.
       * Table name is either user's given table name, either name generated from entity target.
       * Note that table name comes here already normalized by #tableName method.
       */
      prefixTableName(prefix, tableName) {
        return prefix + tableName;
      }
    };
    exports2.DefaultNamingStrategy = DefaultNamingStrategy2;
  }
});

// node_modules/typeorm/schema-builder/table/TableColumn.js
var require_TableColumn = __commonJS({
  "node_modules/typeorm/schema-builder/table/TableColumn.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TableColumn = void 0;
    var TableColumn2 = class _TableColumn {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(options) {
        this["@instanceof"] = Symbol.for("TableColumn");
        this.isNullable = false;
        this.isGenerated = false;
        this.isPrimary = false;
        this.isUnique = false;
        this.isArray = false;
        this.length = "";
        this.zerofill = false;
        this.unsigned = false;
        if (options) {
          this.name = options.name;
          this.type = options.type || "";
          this.length = options.length || "";
          this.width = options.width;
          this.charset = options.charset;
          this.collation = options.collation;
          this.precision = options.precision;
          this.scale = options.scale;
          this.zerofill = options.zerofill || false;
          this.unsigned = this.zerofill ? true : options.unsigned || false;
          this.default = options.default;
          this.onUpdate = options.onUpdate;
          this.isNullable = options.isNullable || false;
          this.isGenerated = options.isGenerated || false;
          this.generationStrategy = options.generationStrategy;
          this.generatedIdentity = options.generatedIdentity;
          this.isPrimary = options.isPrimary || false;
          this.isUnique = options.isUnique || false;
          this.isArray = options.isArray || false;
          this.comment = options.comment;
          this.enum = options.enum;
          this.enumName = options.enumName;
          this.primaryKeyConstraintName = options.primaryKeyConstraintName;
          this.asExpression = options.asExpression;
          this.generatedType = options.generatedType;
          this.spatialFeatureType = options.spatialFeatureType;
          this.srid = options.srid;
        }
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Clones this column to a new column with exact same properties as this column has.
       */
      clone() {
        return new _TableColumn({
          name: this.name,
          type: this.type,
          length: this.length,
          width: this.width,
          charset: this.charset,
          collation: this.collation,
          precision: this.precision,
          scale: this.scale,
          zerofill: this.zerofill,
          unsigned: this.unsigned,
          enum: this.enum,
          enumName: this.enumName,
          primaryKeyConstraintName: this.primaryKeyConstraintName,
          asExpression: this.asExpression,
          generatedType: this.generatedType,
          default: this.default,
          onUpdate: this.onUpdate,
          isNullable: this.isNullable,
          isGenerated: this.isGenerated,
          generationStrategy: this.generationStrategy,
          generatedIdentity: this.generatedIdentity,
          isPrimary: this.isPrimary,
          isUnique: this.isUnique,
          isArray: this.isArray,
          comment: this.comment,
          spatialFeatureType: this.spatialFeatureType,
          srid: this.srid
        });
      }
    };
    exports2.TableColumn = TableColumn2;
  }
});

// node_modules/typeorm/schema-builder/table/TableIndex.js
var require_TableIndex = __commonJS({
  "node_modules/typeorm/schema-builder/table/TableIndex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TableIndex = void 0;
    var TableIndex2 = class _TableIndex {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(options) {
        this["@instanceof"] = Symbol.for("TableIndex");
        this.columnNames = [];
        this.name = options.name;
        this.columnNames = options.columnNames;
        this.isUnique = !!options.isUnique;
        this.isSpatial = !!options.isSpatial;
        this.isConcurrent = !!options.isConcurrent;
        this.isFulltext = !!options.isFulltext;
        this.isNullFiltered = !!options.isNullFiltered;
        this.parser = options.parser;
        this.where = options.where ? options.where : "";
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Creates a new copy of this index with exactly same properties.
       */
      clone() {
        return new _TableIndex({
          name: this.name,
          columnNames: [...this.columnNames],
          isUnique: this.isUnique,
          isSpatial: this.isSpatial,
          isConcurrent: this.isConcurrent,
          isFulltext: this.isFulltext,
          isNullFiltered: this.isNullFiltered,
          parser: this.parser,
          where: this.where
        });
      }
      // -------------------------------------------------------------------------
      // Static Methods
      // -------------------------------------------------------------------------
      /**
       * Creates index from the index metadata object.
       */
      static create(indexMetadata) {
        return new _TableIndex({
          name: indexMetadata.name,
          columnNames: indexMetadata.columns.map((column) => column.databaseName),
          isUnique: indexMetadata.isUnique,
          isSpatial: indexMetadata.isSpatial,
          isConcurrent: indexMetadata.isConcurrent,
          isFulltext: indexMetadata.isFulltext,
          isNullFiltered: indexMetadata.isNullFiltered,
          parser: indexMetadata.parser,
          where: indexMetadata.where
        });
      }
    };
    exports2.TableIndex = TableIndex2;
  }
});

// node_modules/typeorm/schema-builder/table/TableForeignKey.js
var require_TableForeignKey = __commonJS({
  "node_modules/typeorm/schema-builder/table/TableForeignKey.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TableForeignKey = void 0;
    var TableForeignKey2 = class _TableForeignKey {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(options) {
        this["@instanceof"] = Symbol.for("TableForeignKey");
        this.columnNames = [];
        this.referencedColumnNames = [];
        this.name = options.name;
        this.columnNames = options.columnNames;
        this.referencedColumnNames = options.referencedColumnNames;
        this.referencedDatabase = options.referencedDatabase;
        this.referencedSchema = options.referencedSchema;
        this.referencedTableName = options.referencedTableName;
        this.onDelete = options.onDelete;
        this.onUpdate = options.onUpdate;
        this.deferrable = options.deferrable;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Creates a new copy of this foreign key with exactly same properties.
       */
      clone() {
        return new _TableForeignKey({
          name: this.name,
          columnNames: [...this.columnNames],
          referencedColumnNames: [...this.referencedColumnNames],
          referencedDatabase: this.referencedDatabase,
          referencedSchema: this.referencedSchema,
          referencedTableName: this.referencedTableName,
          onDelete: this.onDelete,
          onUpdate: this.onUpdate,
          deferrable: this.deferrable
        });
      }
      // -------------------------------------------------------------------------
      // Static Methods
      // -------------------------------------------------------------------------
      /**
       * Creates a new table foreign key from the given foreign key metadata.
       */
      static create(metadata, driver) {
        return new _TableForeignKey({
          name: metadata.name,
          columnNames: metadata.columnNames,
          referencedColumnNames: metadata.referencedColumnNames,
          referencedDatabase: metadata.referencedEntityMetadata.database,
          referencedSchema: metadata.referencedEntityMetadata.schema,
          referencedTableName: metadata.referencedTablePath,
          onDelete: metadata.onDelete,
          onUpdate: metadata.onUpdate,
          deferrable: metadata.deferrable
        });
      }
    };
    exports2.TableForeignKey = TableForeignKey2;
  }
});

// node_modules/typeorm/schema-builder/util/TableUtils.js
var require_TableUtils = __commonJS({
  "node_modules/typeorm/schema-builder/util/TableUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TableUtils = void 0;
    var TableUtils = class {
      static createTableColumnOptions(columnMetadata, driver) {
        return {
          name: columnMetadata.databaseName,
          length: driver.getColumnLength(columnMetadata),
          width: columnMetadata.width,
          charset: columnMetadata.charset,
          collation: columnMetadata.collation,
          precision: columnMetadata.precision,
          scale: columnMetadata.scale,
          zerofill: columnMetadata.zerofill,
          unsigned: columnMetadata.unsigned,
          asExpression: columnMetadata.asExpression,
          generatedType: columnMetadata.generatedType,
          default: driver.normalizeDefault(columnMetadata),
          onUpdate: columnMetadata.onUpdate,
          comment: columnMetadata.comment,
          isGenerated: columnMetadata.isGenerated,
          generationStrategy: columnMetadata.generationStrategy,
          generatedIdentity: columnMetadata.generatedIdentity,
          isNullable: columnMetadata.isNullable,
          type: driver.normalizeType(columnMetadata),
          isPrimary: columnMetadata.isPrimary,
          isUnique: driver.normalizeIsUnique(columnMetadata),
          isArray: columnMetadata.isArray || false,
          enum: columnMetadata.enum ? columnMetadata.enum.map((val) => val + "") : columnMetadata.enum,
          enumName: columnMetadata.enumName,
          primaryKeyConstraintName: columnMetadata.primaryKeyConstraintName,
          spatialFeatureType: columnMetadata.spatialFeatureType,
          srid: columnMetadata.srid
        };
      }
    };
    exports2.TableUtils = TableUtils;
  }
});

// node_modules/typeorm/schema-builder/table/TableUnique.js
var require_TableUnique = __commonJS({
  "node_modules/typeorm/schema-builder/table/TableUnique.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TableUnique = void 0;
    var TableUnique2 = class _TableUnique {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(options) {
        this["@instanceof"] = Symbol.for("TableUnique");
        this.columnNames = [];
        this.name = options.name;
        this.columnNames = options.columnNames;
        this.deferrable = options.deferrable;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Creates a new copy of this constraint with exactly same properties.
       */
      clone() {
        return new _TableUnique({
          name: this.name,
          columnNames: [...this.columnNames],
          deferrable: this.deferrable
        });
      }
      // -------------------------------------------------------------------------
      // Static Methods
      // -------------------------------------------------------------------------
      /**
       * Creates unique from the unique metadata object.
       */
      static create(uniqueMetadata) {
        return new _TableUnique({
          name: uniqueMetadata.name,
          columnNames: uniqueMetadata.columns.map((column) => column.databaseName),
          deferrable: uniqueMetadata.deferrable
        });
      }
    };
    exports2.TableUnique = TableUnique2;
  }
});

// node_modules/typeorm/schema-builder/table/TableCheck.js
var require_TableCheck = __commonJS({
  "node_modules/typeorm/schema-builder/table/TableCheck.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TableCheck = void 0;
    var TableCheck2 = class _TableCheck {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(options) {
        this["@instanceof"] = Symbol.for("TableCheck");
        this.columnNames = [];
        this.name = options.name;
        this.columnNames = options.columnNames;
        this.expression = options.expression;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Creates a new copy of this constraint with exactly same properties.
       */
      clone() {
        return new _TableCheck({
          name: this.name,
          columnNames: this.columnNames ? [...this.columnNames] : [],
          expression: this.expression
        });
      }
      // -------------------------------------------------------------------------
      // Static Methods
      // -------------------------------------------------------------------------
      /**
       * Creates checks from the check metadata object.
       */
      static create(checkMetadata) {
        return new _TableCheck({
          name: checkMetadata.name,
          expression: checkMetadata.expression
        });
      }
    };
    exports2.TableCheck = TableCheck2;
  }
});

// node_modules/typeorm/schema-builder/table/TableExclusion.js
var require_TableExclusion = __commonJS({
  "node_modules/typeorm/schema-builder/table/TableExclusion.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TableExclusion = void 0;
    var TableExclusion2 = class _TableExclusion {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(options) {
        this["@instanceof"] = Symbol.for("TableExclusion");
        this.name = options.name;
        this.expression = options.expression;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Creates a new copy of this constraint with exactly same properties.
       */
      clone() {
        return new _TableExclusion({
          name: this.name,
          expression: this.expression
        });
      }
      // -------------------------------------------------------------------------
      // Static Methods
      // -------------------------------------------------------------------------
      /**
       * Creates exclusions from the exclusion metadata object.
       */
      static create(exclusionMetadata) {
        return new _TableExclusion({
          name: exclusionMetadata.name,
          expression: exclusionMetadata.expression
        });
      }
    };
    exports2.TableExclusion = TableExclusion2;
  }
});

// node_modules/typeorm/schema-builder/table/Table.js
var require_Table = __commonJS({
  "node_modules/typeorm/schema-builder/table/Table.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Table = void 0;
    var TableColumn_1 = require_TableColumn();
    var TableIndex_1 = require_TableIndex();
    var TableForeignKey_1 = require_TableForeignKey();
    var TableUtils_1 = require_TableUtils();
    var TableUnique_1 = require_TableUnique();
    var TableCheck_1 = require_TableCheck();
    var TableExclusion_1 = require_TableExclusion();
    var Table2 = class _Table {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(options) {
        this["@instanceof"] = Symbol.for("Table");
        this.columns = [];
        this.indices = [];
        this.foreignKeys = [];
        this.uniques = [];
        this.checks = [];
        this.exclusions = [];
        this.justCreated = false;
        this.withoutRowid = false;
        if (options) {
          this.database = options.database;
          this.schema = options.schema;
          this.name = options.name;
          if (options.columns)
            this.columns = options.columns.map((column) => new TableColumn_1.TableColumn(column));
          if (options.indices)
            this.indices = options.indices.map((index) => new TableIndex_1.TableIndex(index));
          if (options.foreignKeys)
            this.foreignKeys = options.foreignKeys.map((foreignKey) => new TableForeignKey_1.TableForeignKey({
              ...foreignKey,
              referencedDatabase: foreignKey?.referencedDatabase || options.database,
              referencedSchema: foreignKey?.referencedSchema || options.schema
            }));
          if (options.uniques)
            this.uniques = options.uniques.map((unique) => new TableUnique_1.TableUnique(unique));
          if (options.checks)
            this.checks = options.checks.map((check) => new TableCheck_1.TableCheck(check));
          if (options.exclusions)
            this.exclusions = options.exclusions.map((exclusion) => new TableExclusion_1.TableExclusion(exclusion));
          if (options.justCreated !== void 0)
            this.justCreated = options.justCreated;
          if (options.withoutRowid)
            this.withoutRowid = options.withoutRowid;
          this.engine = options.engine;
          this.comment = options.comment;
        }
      }
      // -------------------------------------------------------------------------
      // Accessors
      // -------------------------------------------------------------------------
      get primaryColumns() {
        return this.columns.filter((column) => column.isPrimary);
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Clones this table to a new table with all properties cloned.
       */
      clone() {
        return new _Table({
          schema: this.schema,
          database: this.database,
          name: this.name,
          columns: this.columns.map((column) => column.clone()),
          indices: this.indices.map((constraint) => constraint.clone()),
          foreignKeys: this.foreignKeys.map((constraint) => constraint.clone()),
          uniques: this.uniques.map((constraint) => constraint.clone()),
          checks: this.checks.map((constraint) => constraint.clone()),
          exclusions: this.exclusions.map((constraint) => constraint.clone()),
          justCreated: this.justCreated,
          withoutRowid: this.withoutRowid,
          engine: this.engine,
          comment: this.comment
        });
      }
      /**
       * Add column and creates its constraints.
       */
      addColumn(column) {
        this.columns.push(column);
      }
      /**
       * Remove column and its constraints.
       */
      removeColumn(column) {
        const foundColumn = this.columns.find((c) => c.name === column.name);
        if (foundColumn)
          this.columns.splice(this.columns.indexOf(foundColumn), 1);
      }
      /**
       * Adds unique constraint.
       */
      addUniqueConstraint(uniqueConstraint) {
        this.uniques.push(uniqueConstraint);
        if (uniqueConstraint.columnNames.length === 1) {
          const uniqueColumn = this.columns.find((column) => column.name === uniqueConstraint.columnNames[0]);
          if (uniqueColumn)
            uniqueColumn.isUnique = true;
        }
      }
      /**
       * Removes unique constraint.
       */
      removeUniqueConstraint(removedUnique) {
        const foundUnique = this.uniques.find((unique) => unique.name === removedUnique.name);
        if (foundUnique) {
          this.uniques.splice(this.uniques.indexOf(foundUnique), 1);
          if (foundUnique.columnNames.length === 1) {
            const uniqueColumn = this.columns.find((column) => column.name === foundUnique.columnNames[0]);
            if (uniqueColumn)
              uniqueColumn.isUnique = false;
          }
        }
      }
      /**
       * Adds check constraint.
       */
      addCheckConstraint(checkConstraint) {
        this.checks.push(checkConstraint);
      }
      /**
       * Removes check constraint.
       */
      removeCheckConstraint(removedCheck) {
        const foundCheck = this.checks.find((check) => check.name === removedCheck.name);
        if (foundCheck) {
          this.checks.splice(this.checks.indexOf(foundCheck), 1);
        }
      }
      /**
       * Adds exclusion constraint.
       */
      addExclusionConstraint(exclusionConstraint) {
        this.exclusions.push(exclusionConstraint);
      }
      /**
       * Removes exclusion constraint.
       */
      removeExclusionConstraint(removedExclusion) {
        const foundExclusion = this.exclusions.find((exclusion) => exclusion.name === removedExclusion.name);
        if (foundExclusion) {
          this.exclusions.splice(this.exclusions.indexOf(foundExclusion), 1);
        }
      }
      /**
       * Adds foreign keys.
       */
      addForeignKey(foreignKey) {
        this.foreignKeys.push(foreignKey);
      }
      /**
       * Removes foreign key.
       */
      removeForeignKey(removedForeignKey) {
        const fk = this.foreignKeys.find((foreignKey) => foreignKey.name === removedForeignKey.name);
        if (fk)
          this.foreignKeys.splice(this.foreignKeys.indexOf(fk), 1);
      }
      /**
       * Adds index.
       */
      addIndex(index, isMysql = false) {
        this.indices.push(index);
        if (index.columnNames.length === 1 && index.isUnique && isMysql) {
          const column = this.columns.find((c) => c.name === index.columnNames[0]);
          if (column)
            column.isUnique = true;
        }
      }
      /**
       * Removes index.
       */
      removeIndex(tableIndex, isMysql = false) {
        const index = this.indices.find((index2) => index2.name === tableIndex.name);
        if (index) {
          this.indices.splice(this.indices.indexOf(index), 1);
          if (index.columnNames.length === 1 && index.isUnique && isMysql) {
            const column = this.columns.find((c) => c.name === index.columnNames[0]);
            if (column)
              column.isUnique = this.indices.some((ind) => ind.columnNames.length === 1 && ind.columnNames[0] === column.name && !!index.isUnique);
          }
        }
      }
      findColumnByName(name) {
        return this.columns.find((column) => column.name === name);
      }
      /**
       * Returns all column indices.
       */
      findColumnIndices(column) {
        return this.indices.filter((index) => {
          return !!index.columnNames.find((columnName) => columnName === column.name);
        });
      }
      /**
       * Returns all column foreign keys.
       */
      findColumnForeignKeys(column) {
        return this.foreignKeys.filter((foreignKey) => {
          return !!foreignKey.columnNames.find((columnName) => columnName === column.name);
        });
      }
      /**
       * Returns all column uniques.
       */
      findColumnUniques(column) {
        return this.uniques.filter((unique) => {
          return !!unique.columnNames.find((columnName) => columnName === column.name);
        });
      }
      /**
       * Returns all column checks.
       */
      findColumnChecks(column) {
        return this.checks.filter((check) => {
          return !!check.columnNames.find((columnName) => columnName === column.name);
        });
      }
      // -------------------------------------------------------------------------
      // Static Methods
      // -------------------------------------------------------------------------
      /**
       * Creates table from a given entity metadata.
       */
      static create(entityMetadata, driver) {
        const database = entityMetadata.database === driver.database ? void 0 : entityMetadata.database;
        const schema = entityMetadata.schema === driver.options.schema ? void 0 : entityMetadata.schema;
        const options = {
          database: entityMetadata.database,
          schema: entityMetadata.schema,
          name: driver.buildTableName(entityMetadata.tableName, schema, database),
          withoutRowid: entityMetadata.withoutRowid,
          engine: entityMetadata.engine,
          columns: entityMetadata.columns.filter((column) => column && !column.isVirtualProperty).map((column) => TableUtils_1.TableUtils.createTableColumnOptions(column, driver)),
          indices: entityMetadata.indices.filter((index) => index.synchronize === true).map((index) => TableIndex_1.TableIndex.create(index)),
          uniques: entityMetadata.uniques.map((unique) => TableUnique_1.TableUnique.create(unique)),
          checks: entityMetadata.checks.map((check) => TableCheck_1.TableCheck.create(check)),
          exclusions: entityMetadata.exclusions.map((exclusion) => TableExclusion_1.TableExclusion.create(exclusion)),
          comment: entityMetadata.comment
        };
        return new _Table(options);
      }
    };
    exports2.Table = Table2;
  }
});

// node_modules/typeorm/migration/Migration.js
var require_Migration = __commonJS({
  "node_modules/typeorm/migration/Migration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Migration = void 0;
    var Migration2 = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(id, timestamp, name, instance, transaction) {
        this.id = id;
        this.timestamp = timestamp;
        this.name = name;
        this.instance = instance;
        this.transaction = transaction;
      }
    };
    exports2.Migration = Migration2;
  }
});

// node_modules/typeorm/driver/sqlserver/MssqlParameter.js
var require_MssqlParameter = __commonJS({
  "node_modules/typeorm/driver/sqlserver/MssqlParameter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MssqlParameter = void 0;
    var MssqlParameter2 = class {
      constructor(value, type, ...params) {
        this.value = value;
        this.type = type;
        this["@instanceof"] = Symbol.for("MssqlParameter");
        this.params = [];
        this.params = params || [];
      }
    };
    exports2.MssqlParameter = MssqlParameter2;
  }
});

// node_modules/typeorm/migration/MigrationExecutor.js
var require_MigrationExecutor = __commonJS({
  "node_modules/typeorm/migration/MigrationExecutor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MigrationExecutor = void 0;
    var Table_1 = require_Table();
    var Migration_1 = require_Migration();
    var MssqlParameter_1 = require_MssqlParameter();
    var error_1 = require_error();
    var InstanceChecker_1 = require_InstanceChecker();
    var MigrationExecutor2 = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection, queryRunner) {
        this.connection = connection;
        this.queryRunner = queryRunner;
        this.transaction = "all";
        const { schema } = this.connection.driver.options;
        const database = this.connection.driver.database;
        this.migrationsDatabase = database;
        this.migrationsSchema = schema;
        this.migrationsTableName = connection.options.migrationsTableName || "migrations";
        this.migrationsTable = this.connection.driver.buildTableName(this.migrationsTableName, schema, database);
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Tries to execute a single migration given.
       */
      async executeMigration(migration) {
        return this.withQueryRunner(async (queryRunner) => {
          await this.createMigrationsTableIfNotExist(queryRunner);
          const schemaBuilder = this.connection.driver.createSchemaBuilder();
          if (InstanceChecker_1.InstanceChecker.isRdbmsSchemaBuilder(schemaBuilder)) {
            await schemaBuilder.createMetadataTableIfNecessary(queryRunner);
          }
          await queryRunner.beforeMigration();
          await migration.instance.up(queryRunner);
          await queryRunner.afterMigration();
          await this.insertExecutedMigration(queryRunner, migration);
          return migration;
        });
      }
      /**
       * Returns an array of all migrations.
       */
      async getAllMigrations() {
        return Promise.resolve(this.getMigrations());
      }
      /**
       * Returns an array of all executed migrations.
       */
      async getExecutedMigrations() {
        return this.withQueryRunner(async (queryRunner) => {
          await this.createMigrationsTableIfNotExist(queryRunner);
          return await this.loadExecutedMigrations(queryRunner);
        });
      }
      /**
       * Returns an array of all pending migrations.
       */
      async getPendingMigrations() {
        const allMigrations = await this.getAllMigrations();
        const executedMigrations = await this.getExecutedMigrations();
        return allMigrations.filter((migration) => !executedMigrations.find((executedMigration) => executedMigration.name === migration.name));
      }
      /**
       * Inserts an executed migration.
       */
      insertMigration(migration) {
        return this.withQueryRunner((q) => this.insertExecutedMigration(q, migration));
      }
      /**
       * Deletes an executed migration.
       */
      deleteMigration(migration) {
        return this.withQueryRunner((q) => this.deleteExecutedMigration(q, migration));
      }
      /**
       * Lists all migrations and whether they have been executed or not
       * returns true if there are unapplied migrations
       */
      async showMigrations() {
        let hasUnappliedMigrations = false;
        const queryRunner = this.queryRunner || this.connection.createQueryRunner();
        await this.createMigrationsTableIfNotExist(queryRunner);
        const executedMigrations = await this.loadExecutedMigrations(queryRunner);
        const allMigrations = this.getMigrations();
        for (const migration of allMigrations) {
          const executedMigration = executedMigrations.find((executedMigration2) => executedMigration2.name === migration.name);
          if (executedMigration) {
            this.connection.logger.logSchemaBuild(`[X] ${executedMigration.id} ${migration.name}`);
          } else {
            hasUnappliedMigrations = true;
            this.connection.logger.logSchemaBuild(`[ ] ${migration.name}`);
          }
        }
        if (!this.queryRunner) {
          await queryRunner.release();
        }
        return hasUnappliedMigrations;
      }
      /**
       * Executes all pending migrations. Pending migrations are migrations that are not yet executed,
       * thus not saved in the database.
       */
      async executePendingMigrations() {
        const queryRunner = this.queryRunner || this.connection.createQueryRunner();
        await this.createMigrationsTableIfNotExist(queryRunner);
        const schemaBuilder = this.connection.driver.createSchemaBuilder();
        if (InstanceChecker_1.InstanceChecker.isRdbmsSchemaBuilder(schemaBuilder)) {
          await schemaBuilder.createMetadataTableIfNecessary(queryRunner);
        }
        const executedMigrations = await this.loadExecutedMigrations(queryRunner);
        const lastTimeExecutedMigration = this.getLatestTimestampMigration(executedMigrations);
        const allMigrations = this.getMigrations();
        const successMigrations = [];
        const pendingMigrations = allMigrations.filter((migration) => {
          const executedMigration = executedMigrations.find((executedMigration2) => executedMigration2.name === migration.name);
          if (executedMigration)
            return false;
          return true;
        });
        if (!pendingMigrations.length) {
          this.connection.logger.logSchemaBuild(`No migrations are pending`);
          if (!this.queryRunner)
            await queryRunner.release();
          return [];
        }
        this.connection.logger.logSchemaBuild(`${executedMigrations.length} migrations are already loaded in the database.`);
        this.connection.logger.logSchemaBuild(`${allMigrations.length} migrations were found in the source code.`);
        if (lastTimeExecutedMigration)
          this.connection.logger.logSchemaBuild(`${lastTimeExecutedMigration.name} is the last executed migration. It was executed on ${new Date(lastTimeExecutedMigration.timestamp).toString()}.`);
        this.connection.logger.logSchemaBuild(`${pendingMigrations.length} migrations are new migrations must be executed.`);
        if (this.transaction === "all") {
          const migrationsOverridingTransactionMode = pendingMigrations.filter((migration) => !(migration.instance?.transaction === void 0));
          if (migrationsOverridingTransactionMode.length > 0) {
            const error = new error_1.ForbiddenTransactionModeOverrideError(migrationsOverridingTransactionMode);
            this.connection.logger.logMigration(`Migrations failed, error: ${error.message}`);
            throw error;
          }
        }
        const txModeDefault = {
          each: true,
          none: false,
          all: false
        }[this.transaction];
        for (const migration of pendingMigrations) {
          if (migration.instance) {
            const instanceTx = migration.instance.transaction;
            if (instanceTx === void 0) {
              migration.transaction = txModeDefault;
            } else {
              migration.transaction = instanceTx;
            }
          }
        }
        let transactionStartedByUs = false;
        if (this.transaction === "all" && !queryRunner.isTransactionActive) {
          await queryRunner.beforeMigration();
          await queryRunner.startTransaction();
          transactionStartedByUs = true;
        }
        try {
          for (const migration of pendingMigrations) {
            if (this.fake) {
              await this.insertExecutedMigration(queryRunner, migration);
              continue;
            }
            if (migration.transaction && !queryRunner.isTransactionActive) {
              await queryRunner.beforeMigration();
              await queryRunner.startTransaction();
              transactionStartedByUs = true;
            }
            await migration.instance.up(queryRunner).catch((error) => {
              this.connection.logger.logMigration(`Migration "${migration.name}" failed, error: ${error?.message}`);
              throw error;
            }).then(async () => {
              await this.insertExecutedMigration(queryRunner, migration);
              if (migration.transaction && transactionStartedByUs) {
                await queryRunner.commitTransaction();
                await queryRunner.afterMigration();
              }
            }).then(() => {
              successMigrations.push(migration);
              this.connection.logger.logSchemaBuild(`Migration ${migration.name} has been ${this.fake ? "(fake) " : ""}executed successfully.`);
            });
          }
          if (this.transaction === "all" && transactionStartedByUs) {
            await queryRunner.commitTransaction();
            await queryRunner.afterMigration();
          }
        } catch (err) {
          if (transactionStartedByUs) {
            try {
              await queryRunner.rollbackTransaction();
            } catch (rollbackError) {
            }
          }
          throw err;
        } finally {
          if (!this.queryRunner)
            await queryRunner.release();
        }
        return successMigrations;
      }
      /**
       * Reverts last migration that were run.
       */
      async undoLastMigration() {
        const queryRunner = this.queryRunner || this.connection.createQueryRunner();
        await this.createMigrationsTableIfNotExist(queryRunner);
        const schemaBuilder = this.connection.driver.createSchemaBuilder();
        if (InstanceChecker_1.InstanceChecker.isRdbmsSchemaBuilder(schemaBuilder)) {
          await schemaBuilder.createMetadataTableIfNecessary(queryRunner);
        }
        const executedMigrations = await this.loadExecutedMigrations(queryRunner);
        const lastTimeExecutedMigration = this.getLatestExecutedMigration(executedMigrations);
        if (!lastTimeExecutedMigration) {
          this.connection.logger.logSchemaBuild(`No migrations were found in the database. Nothing to revert!`);
          return;
        }
        const allMigrations = this.getMigrations();
        const migrationToRevert = allMigrations.find((migration) => migration.name === lastTimeExecutedMigration.name);
        if (!migrationToRevert)
          throw new error_1.TypeORMError(`No migration ${lastTimeExecutedMigration.name} was found in the source code. Make sure you have this migration in your codebase and its included in the connection options.`);
        this.connection.logger.logSchemaBuild(`${executedMigrations.length} migrations are already loaded in the database.`);
        this.connection.logger.logSchemaBuild(`${lastTimeExecutedMigration.name} is the last executed migration. It was executed on ${new Date(lastTimeExecutedMigration.timestamp).toString()}.`);
        this.connection.logger.logSchemaBuild(`Now reverting it...`);
        let transactionStartedByUs = false;
        if (this.transaction !== "none" && !queryRunner.isTransactionActive) {
          await queryRunner.startTransaction();
          transactionStartedByUs = true;
        }
        try {
          if (!this.fake) {
            await queryRunner.beforeMigration();
            await migrationToRevert.instance.down(queryRunner);
            await queryRunner.afterMigration();
          }
          await this.deleteExecutedMigration(queryRunner, migrationToRevert);
          this.connection.logger.logSchemaBuild(`Migration ${migrationToRevert.name} has been ${this.fake ? "(fake) " : ""}reverted successfully.`);
          if (transactionStartedByUs)
            await queryRunner.commitTransaction();
        } catch (err) {
          if (transactionStartedByUs) {
            try {
              await queryRunner.rollbackTransaction();
            } catch (rollbackError) {
            }
          }
          throw err;
        } finally {
          if (!this.queryRunner)
            await queryRunner.release();
        }
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Creates table "migrations" that will store information about executed migrations.
       */
      async createMigrationsTableIfNotExist(queryRunner) {
        if (this.connection.driver.options.type === "mongodb") {
          return;
        }
        const tableExist = await queryRunner.hasTable(this.migrationsTable);
        if (!tableExist) {
          await queryRunner.createTable(new Table_1.Table({
            database: this.migrationsDatabase,
            schema: this.migrationsSchema,
            name: this.migrationsTable,
            columns: [
              {
                name: "id",
                type: this.connection.driver.normalizeType({
                  type: this.connection.driver.mappedDataTypes.migrationId
                }),
                isGenerated: true,
                generationStrategy: "increment",
                isPrimary: true,
                isNullable: false
              },
              {
                name: "timestamp",
                type: this.connection.driver.normalizeType({
                  type: this.connection.driver.mappedDataTypes.migrationTimestamp
                }),
                isPrimary: false,
                isNullable: false
              },
              {
                name: "name",
                type: this.connection.driver.normalizeType({
                  type: this.connection.driver.mappedDataTypes.migrationName
                }),
                isNullable: false
              }
            ]
          }));
        }
      }
      /**
       * Loads all migrations that were executed and saved into the database (sorts by id).
       */
      async loadExecutedMigrations(queryRunner) {
        if (this.connection.driver.options.type === "mongodb") {
          const mongoRunner = queryRunner;
          return mongoRunner.cursor(this.migrationsTableName, {}).sort({ _id: -1 }).toArray();
        } else {
          const migrationsRaw = await this.connection.manager.createQueryBuilder(queryRunner).select().orderBy(this.connection.driver.escape("id"), "DESC").from(this.migrationsTable, this.migrationsTableName).getRawMany();
          return migrationsRaw.map((migrationRaw) => {
            return new Migration_1.Migration(parseInt(migrationRaw["id"]), parseInt(migrationRaw["timestamp"]), migrationRaw["name"]);
          });
        }
      }
      /**
       * Gets all migrations that setup for this connection.
       */
      getMigrations() {
        const migrations = this.connection.migrations.map((migration) => {
          const migrationClassName = migration.name || migration.constructor.name;
          const migrationTimestamp = parseInt(migrationClassName.substr(-13), 10);
          if (!migrationTimestamp || isNaN(migrationTimestamp)) {
            throw new error_1.TypeORMError(`${migrationClassName} migration name is wrong. Migration class name should have a JavaScript timestamp appended.`);
          }
          return new Migration_1.Migration(void 0, migrationTimestamp, migrationClassName, migration);
        });
        this.checkForDuplicateMigrations(migrations);
        return migrations.sort((a, b) => a.timestamp - b.timestamp);
      }
      checkForDuplicateMigrations(migrations) {
        const migrationNames = migrations.map((migration) => migration.name);
        const duplicates = Array.from(new Set(migrationNames.filter((migrationName, index) => migrationNames.indexOf(migrationName) < index)));
        if (duplicates.length > 0) {
          throw Error(`Duplicate migrations: ${duplicates.join(", ")}`);
        }
      }
      /**
       * Finds the latest migration (sorts by timestamp) in the given array of migrations.
       */
      getLatestTimestampMigration(migrations) {
        const sortedMigrations = migrations.map((migration) => migration).sort((a, b) => (a.timestamp - b.timestamp) * -1);
        return sortedMigrations.length > 0 ? sortedMigrations[0] : void 0;
      }
      /**
       * Finds the latest migration in the given array of migrations.
       * PRE: Migration array must be sorted by descending id.
       */
      getLatestExecutedMigration(sortedMigrations) {
        return sortedMigrations.length > 0 ? sortedMigrations[0] : void 0;
      }
      /**
       * Inserts new executed migration's data into migrations table.
       */
      async insertExecutedMigration(queryRunner, migration) {
        const values = {};
        if (this.connection.driver.options.type === "mssql") {
          values["timestamp"] = new MssqlParameter_1.MssqlParameter(migration.timestamp, this.connection.driver.normalizeType({
            type: this.connection.driver.mappedDataTypes.migrationTimestamp
          }));
          values["name"] = new MssqlParameter_1.MssqlParameter(migration.name, this.connection.driver.normalizeType({
            type: this.connection.driver.mappedDataTypes.migrationName
          }));
        } else {
          values["timestamp"] = migration.timestamp;
          values["name"] = migration.name;
        }
        if (this.connection.driver.options.type === "mongodb") {
          const mongoRunner = queryRunner;
          await mongoRunner.databaseConnection.db(this.connection.driver.database).collection(this.migrationsTableName).insertOne(values);
        } else {
          const qb = queryRunner.manager.createQueryBuilder();
          await qb.insert().into(this.migrationsTable).values(values).execute();
        }
      }
      /**
       * Delete previously executed migration's data from the migrations table.
       */
      async deleteExecutedMigration(queryRunner, migration) {
        const conditions = {};
        if (this.connection.driver.options.type === "mssql") {
          conditions["timestamp"] = new MssqlParameter_1.MssqlParameter(migration.timestamp, this.connection.driver.normalizeType({
            type: this.connection.driver.mappedDataTypes.migrationTimestamp
          }));
          conditions["name"] = new MssqlParameter_1.MssqlParameter(migration.name, this.connection.driver.normalizeType({
            type: this.connection.driver.mappedDataTypes.migrationName
          }));
        } else {
          conditions["timestamp"] = migration.timestamp;
          conditions["name"] = migration.name;
        }
        if (this.connection.driver.options.type === "mongodb") {
          const mongoRunner = queryRunner;
          await mongoRunner.databaseConnection.db(this.connection.driver.database).collection(this.migrationsTableName).deleteOne(conditions);
        } else {
          const qb = queryRunner.manager.createQueryBuilder();
          await qb.delete().from(this.migrationsTable).where(`${qb.escape("timestamp")} = :timestamp`).andWhere(`${qb.escape("name")} = :name`).setParameters(conditions).execute();
        }
      }
      async withQueryRunner(callback) {
        const queryRunner = this.queryRunner || this.connection.createQueryRunner();
        try {
          return await callback(queryRunner);
        } finally {
          if (!this.queryRunner) {
            await queryRunner.release();
          }
        }
      }
    };
    exports2.MigrationExecutor = MigrationExecutor2;
  }
});

// node_modules/typeorm/util/DepGraph.js
var require_DepGraph = __commonJS({
  "node_modules/typeorm/util/DepGraph.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DepGraph = void 0;
    var error_1 = require_error();
    function createDFS(edges, leavesOnly, result) {
      const currentPath = [];
      const visited = {};
      return function DFS(currentNode) {
        visited[currentNode] = true;
        currentPath.push(currentNode);
        edges[currentNode].forEach(function(node) {
          if (!visited[node]) {
            DFS(node);
          } else if (currentPath.indexOf(node) >= 0) {
            currentPath.push(node);
            throw new error_1.TypeORMError(`Dependency Cycle Found: ${currentPath.join(" -> ")}`);
          }
        });
        currentPath.pop();
        if ((!leavesOnly || edges[currentNode].length === 0) && result.indexOf(currentNode) === -1) {
          result.push(currentNode);
        }
      };
    }
    var DepGraph = class {
      constructor() {
        this.nodes = {};
        this.outgoingEdges = {};
        this.incomingEdges = {};
      }
      /**
       * Add a node to the dependency graph. If a node already exists, this method will do nothing.
       */
      addNode(node, data) {
        if (!this.hasNode(node)) {
          if (arguments.length === 2) {
            this.nodes[node] = data;
          } else {
            this.nodes[node] = node;
          }
          this.outgoingEdges[node] = [];
          this.incomingEdges[node] = [];
        }
      }
      /**
       * Remove a node from the dependency graph. If a node does not exist, this method will do nothing.
       */
      removeNode(node) {
        if (this.hasNode(node)) {
          delete this.nodes[node];
          delete this.outgoingEdges[node];
          delete this.incomingEdges[node];
          [this.incomingEdges, this.outgoingEdges].forEach(function(edgeList) {
            Object.keys(edgeList).forEach(function(key) {
              const idx = edgeList[key].indexOf(node);
              if (idx >= 0) {
                edgeList[key].splice(idx, 1);
              }
            });
          });
        }
      }
      /**
       * Check if a node exists in the graph
       */
      hasNode(node) {
        return this.nodes.hasOwnProperty(node);
      }
      /**
       * Get the data associated with a node name
       */
      getNodeData(node) {
        if (this.hasNode(node)) {
          return this.nodes[node];
        } else {
          throw new error_1.TypeORMError(`Node does not exist: ${node}`);
        }
      }
      /**
       * Set the associated data for a given node name. If the node does not exist, this method will throw an error
       */
      setNodeData(node, data) {
        if (this.hasNode(node)) {
          this.nodes[node] = data;
        } else {
          throw new error_1.TypeORMError(`Node does not exist: ${node}`);
        }
      }
      /**
       * Add a dependency between two nodes. If either of the nodes does not exist,
       * an Error will be thrown.
       */
      addDependency(from, to) {
        if (!this.hasNode(from)) {
          throw new error_1.TypeORMError(`Node does not exist: ${from}`);
        }
        if (!this.hasNode(to)) {
          throw new error_1.TypeORMError(`Node does not exist: ${to}`);
        }
        if (this.outgoingEdges[from].indexOf(to) === -1) {
          this.outgoingEdges[from].push(to);
        }
        if (this.incomingEdges[to].indexOf(from) === -1) {
          this.incomingEdges[to].push(from);
        }
        return true;
      }
      /**
       * Remove a dependency between two nodes.
       */
      removeDependency(from, to) {
        let idx;
        if (this.hasNode(from)) {
          idx = this.outgoingEdges[from].indexOf(to);
          if (idx >= 0) {
            this.outgoingEdges[from].splice(idx, 1);
          }
        }
        if (this.hasNode(to)) {
          idx = this.incomingEdges[to].indexOf(from);
          if (idx >= 0) {
            this.incomingEdges[to].splice(idx, 1);
          }
        }
      }
      /**
       * Get an array containing the nodes that the specified node depends on (transitively).
       *
       * Throws an Error if the graph has a cycle, or the specified node does not exist.
       *
       * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned
       * in the array.
       */
      dependenciesOf(node, leavesOnly) {
        if (this.hasNode(node)) {
          const result = [];
          const DFS = createDFS(this.outgoingEdges, leavesOnly, result);
          DFS(node);
          const idx = result.indexOf(node);
          if (idx >= 0) {
            result.splice(idx, 1);
          }
          return result;
        } else {
          throw new error_1.TypeORMError(`Node does not exist: ${node}`);
        }
      }
      /**
       * get an array containing the nodes that depend on the specified node (transitively).
       *
       * Throws an Error if the graph has a cycle, or the specified node does not exist.
       *
       * If `leavesOnly` is true, only nodes that do not have any dependants will be returned in the array.
       */
      dependantsOf(node, leavesOnly) {
        if (this.hasNode(node)) {
          const result = [];
          const DFS = createDFS(this.incomingEdges, leavesOnly, result);
          DFS(node);
          const idx = result.indexOf(node);
          if (idx >= 0) {
            result.splice(idx, 1);
          }
          return result;
        } else {
          throw new error_1.TypeORMError(`Node does not exist: ${node}`);
        }
      }
      /**
       * Construct the overall processing order for the dependency graph.
       *
       * Throws an Error if the graph has a cycle.
       *
       * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned.
       */
      overallOrder(leavesOnly) {
        const self2 = this;
        const result = [];
        const keys = Object.keys(this.nodes);
        if (keys.length === 0) {
          return result;
        } else {
          const CycleDFS = createDFS(this.outgoingEdges, false, []);
          keys.forEach(function(n) {
            CycleDFS(n);
          });
          const DFS = createDFS(this.outgoingEdges, leavesOnly, result);
          keys.filter(function(node) {
            return self2.incomingEdges[node].length === 0;
          }).forEach(function(n) {
            DFS(n);
          });
          return result;
        }
      }
    };
    exports2.DepGraph = DepGraph;
  }
});

// node_modules/typeorm/metadata-builder/EntityMetadataValidator.js
var require_EntityMetadataValidator = __commonJS({
  "node_modules/typeorm/metadata-builder/EntityMetadataValidator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EntityMetadataValidator = void 0;
    var MissingPrimaryColumnError_1 = require_MissingPrimaryColumnError();
    var CircularRelationsError_1 = require_CircularRelationsError();
    var DepGraph_1 = require_DepGraph();
    var DataTypeNotSupportedError_1 = require_DataTypeNotSupportedError();
    var NoConnectionOptionError_1 = require_NoConnectionOptionError();
    var InitializedRelationError_1 = require_InitializedRelationError();
    var error_1 = require_error();
    var DriverUtils_1 = require_DriverUtils();
    var EntityMetadataValidator = class {
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Validates all given entity metadatas.
       */
      validateMany(entityMetadatas, driver) {
        entityMetadatas.forEach((entityMetadata) => this.validate(entityMetadata, entityMetadatas, driver));
        this.validateDependencies(entityMetadatas);
        this.validateEagerRelations(entityMetadatas);
      }
      /**
       * Validates given entity metadata.
       */
      validate(entityMetadata, allEntityMetadatas, driver) {
        if (!entityMetadata.primaryColumns.length && !entityMetadata.isJunction)
          throw new MissingPrimaryColumnError_1.MissingPrimaryColumnError(entityMetadata);
        if (entityMetadata.primaryColumns.length > 1) {
          const areConstraintNamesEqual = entityMetadata.primaryColumns.every((columnMetadata, i, columnMetadatas) => columnMetadata.primaryKeyConstraintName === columnMetadatas[0].primaryKeyConstraintName);
          if (!areConstraintNamesEqual) {
            throw new error_1.TypeORMError(`Entity ${entityMetadata.name} has multiple primary columns with different constraint names. Constraint names should be the equal.`);
          }
        }
        if (entityMetadata.inheritancePattern === "STI" || entityMetadata.tableType === "entity-child") {
          if (!entityMetadata.discriminatorColumn)
            throw new error_1.TypeORMError(`Entity ${entityMetadata.name} using single-table inheritance, it should also have a discriminator column. Did you forget to put discriminator column options?`);
          if (typeof entityMetadata.discriminatorValue === "undefined")
            throw new error_1.TypeORMError(`Entity ${entityMetadata.name} has an undefined discriminator value. Discriminator value should be defined.`);
          const sameDiscriminatorValueEntityMetadata = allEntityMetadatas.find((metadata) => {
            return metadata !== entityMetadata && (metadata.inheritancePattern === "STI" || metadata.tableType === "entity-child") && metadata.tableName === entityMetadata.tableName && metadata.discriminatorValue === entityMetadata.discriminatorValue && metadata.inheritanceTree.some((parent) => entityMetadata.inheritanceTree.indexOf(parent) !== -1);
          });
          if (sameDiscriminatorValueEntityMetadata)
            throw new error_1.TypeORMError(`Entities ${entityMetadata.name} and ${sameDiscriminatorValueEntityMetadata.name} have the same discriminator values. Make sure they are different while using the @ChildEntity decorator.`);
        }
        entityMetadata.relationCounts.forEach((relationCount) => {
          if (relationCount.relation.isManyToOne || relationCount.relation.isOneToOne)
            throw new error_1.TypeORMError(`Relation count can not be implemented on ManyToOne or OneToOne relations.`);
        });
        if (!(driver.options.type === "mongodb")) {
          entityMetadata.columns.filter((column) => !column.isVirtualProperty).forEach((column) => {
            const normalizedColumn = driver.normalizeType(column);
            if (!driver.supportedDataTypes.includes(normalizedColumn))
              throw new DataTypeNotSupportedError_1.DataTypeNotSupportedError(column, normalizedColumn, driver.options.type);
            if (column.length && !driver.withLengthColumnTypes.includes(normalizedColumn))
              throw new error_1.TypeORMError(`Column ${column.propertyName} of Entity ${entityMetadata.name} does not support length property.`);
            if (column.type === "enum" && !column.enum && !column.enumName)
              throw new error_1.TypeORMError(`Column "${column.propertyName}" of Entity "${entityMetadata.name}" is defined as enum, but missing "enum" or "enumName" properties.`);
          });
        }
        if (DriverUtils_1.DriverUtils.isMySQLFamily(driver) || driver.options.type === "aurora-mysql") {
          const generatedColumns = entityMetadata.columns.filter((column) => column.isGenerated && column.generationStrategy !== "uuid");
          if (generatedColumns.length > 1)
            throw new error_1.TypeORMError(`Error in ${entityMetadata.name} entity. There can be only one auto-increment column in MySql table.`);
        }
        if (DriverUtils_1.DriverUtils.isMySQLFamily(driver)) {
          const metadatasWithDatabase = allEntityMetadatas.filter((metadata) => metadata.database);
          if (metadatasWithDatabase.length === 0 && !driver.database)
            throw new NoConnectionOptionError_1.NoConnectionOptionError("database");
        }
        if (driver.options.type === "mssql") {
          const charsetColumns = entityMetadata.columns.filter((column) => column.charset);
          if (charsetColumns.length > 1)
            throw new error_1.TypeORMError(`Character set specifying is not supported in Sql Server`);
        }
        if (driver.options.type === "postgres") {
          const virtualColumn = entityMetadata.columns.find((column) => column.asExpression && (!column.generatedType || column.generatedType === "VIRTUAL"));
          if (virtualColumn)
            throw new error_1.TypeORMError(`Column "${virtualColumn.propertyName}" of Entity "${entityMetadata.name}" is defined as VIRTUAL, but Postgres supports only STORED generated columns.`);
        }
        const entityInstance = entityMetadata.create(void 0, {
          fromDeserializer: true
        });
        entityMetadata.relations.forEach((relation) => {
          if (relation.isManyToMany || relation.isOneToMany) {
            if (relation.persistenceEnabled === false)
              return;
            const relationInitializedValue = relation.getEntityValue(entityInstance);
            if (Array.isArray(relationInitializedValue))
              throw new InitializedRelationError_1.InitializedRelationError(relation);
          }
        });
        entityMetadata.relations.forEach((relation) => {
          if (driver.supportedOnDeleteTypes && relation.onDelete && !driver.supportedOnDeleteTypes.includes(relation.onDelete)) {
            throw new error_1.TypeORMError(`OnDeleteType "${relation.onDelete}" is not supported for ${driver.options.type}!`);
          }
          if (driver.supportedOnUpdateTypes && relation.onUpdate && !driver.supportedOnUpdateTypes.includes(relation.onUpdate)) {
            throw new error_1.TypeORMError(`OnUpdateType "${relation.onUpdate}" is not valid for ${driver.options.type}!`);
          }
        });
        entityMetadata.relations.forEach((relation) => {
          const isCircularCascadeRemove = relation.isCascadeRemove && relation.inverseRelation && relation.inverseRelation.isCascadeRemove;
          if (isCircularCascadeRemove)
            throw new error_1.TypeORMError(`Relation ${entityMetadata.name}#${relation.propertyName} and ${relation.inverseRelation.entityMetadata.name}#${relation.inverseRelation.propertyName} both has cascade remove set. This may lead to unexpected circular removals. Please set cascade remove only from one side of relationship.`);
        });
      }
      /**
       * Validates dependencies of the entity metadatas.
       */
      validateDependencies(entityMetadatas) {
        const graph = new DepGraph_1.DepGraph();
        entityMetadatas.forEach((entityMetadata) => {
          graph.addNode(entityMetadata.name);
        });
        entityMetadatas.forEach((entityMetadata) => {
          entityMetadata.relationsWithJoinColumns.filter((relation) => !relation.isNullable).forEach((relation) => {
            graph.addDependency(entityMetadata.name, relation.inverseEntityMetadata.name);
          });
        });
        try {
          graph.overallOrder();
        } catch (err) {
          throw new CircularRelationsError_1.CircularRelationsError(err.toString().replace("Error: Dependency Cycle Found: ", ""));
        }
      }
      /**
       * Validates eager relations to prevent circular dependency in them.
       */
      validateEagerRelations(entityMetadatas) {
        entityMetadatas.forEach((entityMetadata) => {
          entityMetadata.eagerRelations.forEach((relation) => {
            if (relation.inverseRelation && relation.inverseRelation.isEager)
              throw new error_1.TypeORMError(`Circular eager relations are disallowed. ${entityMetadata.targetName}#${relation.propertyPath} contains "eager: true", and its inverse side ${relation.inverseEntityMetadata.targetName}#${relation.inverseRelation.propertyPath} contains "eager: true" as well. Remove "eager: true" from one side of the relation.`);
          });
        });
      }
    };
    exports2.EntityMetadataValidator = EntityMetadataValidator;
  }
});

// node_modules/dedent/dist/dedent.js
var require_dedent = __commonJS({
  "node_modules/dedent/dist/dedent.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var dedent = createDedent({});
    var _default = exports2.default = dedent;
    function createDedent(options) {
      dedent2.withOptions = (newOptions) => createDedent({
        ...options,
        ...newOptions
      });
      return dedent2;
      function dedent2(strings, ...values) {
        const raw = typeof strings === "string" ? [strings] : strings.raw;
        const {
          alignValues = false,
          escapeSpecialCharacters = Array.isArray(strings),
          trimWhitespace = true
        } = options;
        let result = "";
        for (let i = 0; i < raw.length; i++) {
          let next = raw[i];
          if (escapeSpecialCharacters) {
            next = next.replace(/\\\n[ \t]*/g, "").replace(/\\`/g, "`").replace(/\\\$/g, "$").replace(/\\\{/g, "{");
          }
          result += next;
          if (i < values.length) {
            const value = alignValues ? alignValue(values[i], result) : values[i];
            result += value;
          }
        }
        const lines = result.split("\n");
        let mindent = null;
        for (const l of lines) {
          const m = l.match(/^(\s+)\S+/);
          if (m) {
            const indent = m[1].length;
            if (!mindent) {
              mindent = indent;
            } else {
              mindent = Math.min(mindent, indent);
            }
          }
        }
        if (mindent !== null) {
          const m = mindent;
          result = lines.map((l) => l[0] === " " || l[0] === "	" ? l.slice(m) : l).join("\n");
        }
        if (trimWhitespace) {
          result = result.trim();
        }
        if (escapeSpecialCharacters) {
          result = result.replace(/\\n/g, "\n");
        }
        return result;
      }
    }
    function alignValue(value, precedingText) {
      if (typeof value !== "string" || !value.includes("\n")) {
        return value;
      }
      const currentLine = precedingText.slice(precedingText.lastIndexOf("\n") + 1);
      const indentMatch = currentLine.match(/^(\s+)/);
      if (indentMatch) {
        const indent = indentMatch[1];
        return value.replace(/\n/g, `
${indent}`);
      }
      return value;
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/typeorm/util/SqlTagUtils.js
var require_SqlTagUtils = __commonJS({
  "node_modules/typeorm/util/SqlTagUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildSqlTag = buildSqlTag;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var dedent_1 = tslib_1.__importDefault(require_dedent());
    function buildSqlTag({ driver, strings, expressions }) {
      let query = "";
      const parameters = [];
      let idx = 0;
      for (const [expressionIdx, expression] of expressions.entries()) {
        query += strings[expressionIdx];
        if (expression === null) {
          query += "NULL";
          continue;
        }
        if (typeof expression === "function") {
          const value = expression();
          if (typeof value === "string") {
            query += value;
            continue;
          }
          if (Array.isArray(value)) {
            if (value.length === 0) {
              throw new Error(`Expression ${expressionIdx} in this sql tagged template is a function which returned an empty array. Empty arrays cannot safely be expanded into parameter lists.`);
            }
            const arrayParams = value.map(() => {
              return driver.createParameter(`param_${idx + 1}`, idx++);
            });
            query += arrayParams.join(", ");
            parameters.push(...value);
            continue;
          }
          throw new Error(`Expression ${expressionIdx} in this sql tagged template is a function which returned a value of type "${value === null ? "null" : typeof value}". Only array and string types are supported as function return values in sql tagged template expressions.`);
        }
        query += driver.createParameter(`param_${idx + 1}`, idx++);
        parameters.push(expression);
      }
      query += strings[strings.length - 1];
      query = (0, dedent_1.default)(query);
      return { query, parameters };
    }
  }
});

// node_modules/typeorm/repository/Repository.js
var require_Repository = __commonJS({
  "node_modules/typeorm/repository/Repository.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Repository = void 0;
    var SqlTagUtils_1 = require_SqlTagUtils();
    var Repository2 = class {
      // -------------------------------------------------------------------------
      // Accessors
      // -------------------------------------------------------------------------
      /**
       * Entity metadata of the entity current repository manages.
       */
      get metadata() {
        return this.manager.connection.getMetadata(this.target);
      }
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(target, manager, queryRunner) {
        this.target = target;
        this.manager = manager;
        this.queryRunner = queryRunner;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Creates a new query builder that can be used to build a SQL query.
       */
      createQueryBuilder(alias, queryRunner) {
        return this.manager.createQueryBuilder(this.metadata.target, alias || this.metadata.targetName, queryRunner || this.queryRunner);
      }
      /**
       * Checks if entity has an id.
       * If entity composite compose ids, it will check them all.
       */
      hasId(entity) {
        return this.manager.hasId(this.metadata.target, entity);
      }
      /**
       * Gets entity mixed id.
       */
      getId(entity) {
        return this.manager.getId(this.metadata.target, entity);
      }
      /**
       * Creates a new entity instance or instances.
       * Can copy properties from the given object into new entities.
       */
      create(plainEntityLikeOrPlainEntityLikes) {
        return this.manager.create(this.metadata.target, plainEntityLikeOrPlainEntityLikes);
      }
      /**
       * Merges multiple entities (or entity-like objects) into a given entity.
       */
      merge(mergeIntoEntity, ...entityLikes) {
        return this.manager.merge(this.metadata.target, mergeIntoEntity, ...entityLikes);
      }
      /**
       * Creates a new entity from the given plain javascript object. If entity already exist in the database, then
       * it loads it (and everything related to it), replaces all values with the new ones from the given object
       * and returns this new entity. This new entity is actually a loaded from the db entity with all properties
       * replaced from the new object.
       *
       * Note that given entity-like object must have an entity id / primary key to find entity by.
       * Returns undefined if entity with given id was not found.
       */
      preload(entityLike) {
        return this.manager.preload(this.metadata.target, entityLike);
      }
      /**
       * Saves one or many given entities.
       */
      save(entityOrEntities, options) {
        return this.manager.save(this.metadata.target, entityOrEntities, options);
      }
      /**
       * Removes one or many given entities.
       */
      remove(entityOrEntities, options) {
        return this.manager.remove(this.metadata.target, entityOrEntities, options);
      }
      /**
       * Records the delete date of one or many given entities.
       */
      softRemove(entityOrEntities, options) {
        return this.manager.softRemove(this.metadata.target, entityOrEntities, options);
      }
      /**
       * Recovers one or many given entities.
       */
      recover(entityOrEntities, options) {
        return this.manager.recover(this.metadata.target, entityOrEntities, options);
      }
      /**
       * Inserts a given entity into the database.
       * Unlike save method executes a primitive operation without cascades, relations and other operations included.
       * Executes fast and efficient INSERT query.
       * Does not check if entity exist in the database, so query will fail if duplicate entity is being inserted.
       */
      insert(entity) {
        return this.manager.insert(this.metadata.target, entity);
      }
      /**
       * Updates entity partially. Entity can be found by a given conditions.
       * Unlike save method executes a primitive operation without cascades, relations and other operations included.
       * Executes fast and efficient UPDATE query.
       * Does not check if entity exist in the database.
       */
      update(criteria, partialEntity) {
        return this.manager.update(this.metadata.target, criteria, partialEntity);
      }
      /**
       * Updates all entities of target type, setting fields from supplied partial entity.
       * This is a primitive operation without cascades, relations or other operations included.
       * Executes fast and efficient UPDATE query without WHERE clause.
       *
       * WARNING! This method updates ALL rows in the target table.
       */
      updateAll(partialEntity) {
        return this.manager.updateAll(this.metadata.target, partialEntity);
      }
      /**
       * Inserts a given entity into the database, unless a unique constraint conflicts then updates the entity
       * Unlike save method executes a primitive operation without cascades, relations and other operations included.
       * Executes fast and efficient INSERT ... ON CONFLICT DO UPDATE/ON DUPLICATE KEY UPDATE query.
       */
      upsert(entityOrEntities, conflictPathsOrOptions) {
        return this.manager.upsert(this.metadata.target, entityOrEntities, conflictPathsOrOptions);
      }
      /**
       * Deletes entities by a given criteria.
       * Unlike save method executes a primitive operation without cascades, relations and other operations included.
       * Executes fast and efficient DELETE query.
       * Does not check if entity exist in the database.
       */
      delete(criteria) {
        return this.manager.delete(this.metadata.target, criteria);
      }
      /**
       * Deletes all entities of target type.
       * This is a primitive operation without cascades, relations or other operations included.
       * Executes fast and efficient DELETE query without WHERE clause.
       *
       * WARNING! This method deletes ALL rows in the target table.
       */
      deleteAll() {
        return this.manager.deleteAll(this.metadata.target);
      }
      /**
       * Records the delete date of entities by a given criteria.
       * Unlike save method executes a primitive operation without cascades, relations and other operations included.
       * Executes fast and efficient UPDATE query.
       * Does not check if entity exist in the database.
       */
      softDelete(criteria) {
        return this.manager.softDelete(this.metadata.target, criteria);
      }
      /**
       * Restores entities by a given criteria.
       * Unlike save method executes a primitive operation without cascades, relations and other operations included.
       * Executes fast and efficient UPDATE query.
       * Does not check if entity exist in the database.
       */
      restore(criteria) {
        return this.manager.restore(this.metadata.target, criteria);
      }
      /**
       * Checks whether any entity exists that matches the given options.
       *
       * @deprecated use `exists` method instead, for example:
       *
       * .exists()
       */
      exist(options) {
        return this.manager.exists(this.metadata.target, options);
      }
      /**
       * Checks whether any entity exists that matches the given options.
       */
      exists(options) {
        return this.manager.exists(this.metadata.target, options);
      }
      /**
       * Checks whether any entity exists that matches the given conditions.
       */
      existsBy(where) {
        return this.manager.existsBy(this.metadata.target, where);
      }
      /**
       * Counts entities that match given options.
       * Useful for pagination.
       */
      count(options) {
        return this.manager.count(this.metadata.target, options);
      }
      /**
       * Counts entities that match given conditions.
       * Useful for pagination.
       */
      countBy(where) {
        return this.manager.countBy(this.metadata.target, where);
      }
      /**
       * Return the SUM of a column
       */
      sum(columnName, where) {
        return this.manager.sum(this.metadata.target, columnName, where);
      }
      /**
       * Return the AVG of a column
       */
      average(columnName, where) {
        return this.manager.average(this.metadata.target, columnName, where);
      }
      /**
       * Return the MIN of a column
       */
      minimum(columnName, where) {
        return this.manager.minimum(this.metadata.target, columnName, where);
      }
      /**
       * Return the MAX of a column
       */
      maximum(columnName, where) {
        return this.manager.maximum(this.metadata.target, columnName, where);
      }
      /**
       * Finds entities that match given find options.
       */
      async find(options) {
        return this.manager.find(this.metadata.target, options);
      }
      /**
       * Finds entities that match given find options.
       */
      async findBy(where) {
        return this.manager.findBy(this.metadata.target, where);
      }
      /**
       * Finds entities that match given find options.
       * Also counts all entities that match given conditions,
       * but ignores pagination settings (from and take options).
       */
      findAndCount(options) {
        return this.manager.findAndCount(this.metadata.target, options);
      }
      /**
       * Finds entities that match given WHERE conditions.
       * Also counts all entities that match given conditions,
       * but ignores pagination settings (from and take options).
       */
      findAndCountBy(where) {
        return this.manager.findAndCountBy(this.metadata.target, where);
      }
      /**
       * Finds entities with ids.
       * Optionally find options or conditions can be applied.
       *
       * @deprecated use `findBy` method instead in conjunction with `In` operator, for example:
       *
       * .findBy({
       *     id: In([1, 2, 3])
       * })
       */
      async findByIds(ids) {
        return this.manager.findByIds(this.metadata.target, ids);
      }
      /**
       * Finds first entity by a given find options.
       * If entity was not found in the database - returns null.
       */
      async findOne(options) {
        return this.manager.findOne(this.metadata.target, options);
      }
      /**
       * Finds first entity that matches given where condition.
       * If entity was not found in the database - returns null.
       */
      async findOneBy(where) {
        return this.manager.findOneBy(this.metadata.target, where);
      }
      /**
       * Finds first entity that matches given id.
       * If entity was not found in the database - returns null.
       *
       * @deprecated use `findOneBy` method instead in conjunction with `In` operator, for example:
       *
       * .findOneBy({
       *     id: 1 // where "id" is your primary column name
       * })
       */
      async findOneById(id) {
        return this.manager.findOneById(this.metadata.target, id);
      }
      /**
       * Finds first entity by a given find options.
       * If entity was not found in the database - rejects with error.
       */
      async findOneOrFail(options) {
        return this.manager.findOneOrFail(this.metadata.target, options);
      }
      /**
       * Finds first entity that matches given where condition.
       * If entity was not found in the database - rejects with error.
       */
      async findOneByOrFail(where) {
        return this.manager.findOneByOrFail(this.metadata.target, where);
      }
      /**
       * Executes a raw SQL query and returns a raw database results.
       * Raw query execution is supported only by relational databases (MongoDB is not supported).
       *
       * @see [Official docs](https://typeorm.io/repository-api) for examples.
       */
      query(query, parameters) {
        return this.manager.query(query, parameters);
      }
      /**
       * Tagged template function that executes raw SQL query and returns raw database results.
       * Template expressions are automatically transformed into database parameters.
       * Raw query execution is supported only by relational databases (MongoDB is not supported).
       * Note: Don't call this as a regular function, it is meant to be used with backticks to tag a template literal.
       * Example: repository.sql`SELECT * FROM table_name WHERE id = ${id}`
       */
      async sql(strings, ...values) {
        const { query, parameters } = (0, SqlTagUtils_1.buildSqlTag)({
          driver: this.manager.connection.driver,
          strings,
          expressions: values
        });
        return await this.query(query, parameters);
      }
      /**
       * Clears all the data from the given table/collection (truncates/drops it).
       *
       * Note: this method uses TRUNCATE and may not work as you expect in transactions on some platforms.
       * @see https://stackoverflow.com/a/5972738/925151
       */
      clear() {
        return this.manager.clear(this.metadata.target);
      }
      /**
       * Increments some column by provided value of the entities matched given conditions.
       */
      increment(conditions, propertyPath, value) {
        return this.manager.increment(this.metadata.target, conditions, propertyPath, value);
      }
      /**
       * Decrements some column by provided value of the entities matched given conditions.
       */
      decrement(conditions, propertyPath, value) {
        return this.manager.decrement(this.metadata.target, conditions, propertyPath, value);
      }
      /**
       * Extends repository with provided functions.
       */
      extend(customs) {
        const thisRepo = this.constructor;
        const { target, manager, queryRunner } = this;
        const ChildClass = class extends thisRepo {
          constructor(target2, manager2, queryRunner2) {
            super(target2, manager2, queryRunner2);
          }
        };
        for (const custom in customs)
          ChildClass.prototype[custom] = customs[custom];
        return new ChildClass(target, manager, queryRunner);
      }
    };
    exports2.Repository = Repository2;
  }
});

// node_modules/typeorm/repository/MongoRepository.js
var require_MongoRepository = __commonJS({
  "node_modules/typeorm/repository/MongoRepository.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MongoRepository = void 0;
    var Repository_1 = require_Repository();
    var TypeORMError_1 = require_TypeORMError();
    var MongoRepository2 = class extends Repository_1.Repository {
      // -------------------------------------------------------------------------
      // Overridden Methods
      // -------------------------------------------------------------------------
      /**
       * Raw SQL query execution is not supported by MongoDB.
       * Calling this method will return an error.
       */
      query(query, parameters) {
        throw new TypeORMError_1.TypeORMError(`Queries aren't supported by MongoDB.`);
      }
      /**
       * Using Query Builder with MongoDB is not supported yet.
       * Calling this method will return an error.
       */
      createQueryBuilder(alias, queryRunner) {
        throw new TypeORMError_1.TypeORMError(`Query Builder is not supported by MongoDB.`);
      }
      /**
       * Finds entities that match given find options or conditions.
       */
      find(options) {
        return this.manager.find(this.metadata.target, options);
      }
      /**
       * Finds entities that match given find options or conditions.
       */
      findBy(where) {
        return this.manager.findBy(this.metadata.target, where);
      }
      /**
       * Finds entities that match given find options or conditions.
       * Also counts all entities that match given conditions,
       * but ignores pagination settings (from and take options).
       */
      findAndCount(options) {
        return this.manager.findAndCount(this.metadata.target, options);
      }
      /**
       * Finds entities that match given find options or conditions.
       * Also counts all entities that match given conditions,
       * but ignores pagination settings (from and take options).
       */
      findAndCountBy(where) {
        return this.manager.findAndCountBy(this.metadata.target, where);
      }
      /**
       * Finds entities by ids.
       * Optionally find options can be applied.
       *
       * @deprecated use `findBy` method instead in conjunction with `In` operator, for example:
       *
       * .findBy({
       *     id: In([1, 2, 3])
       * })
       */
      findByIds(ids, options) {
        return this.manager.findByIds(this.metadata.target, ids, options);
      }
      /**
       * Finds first entity that matches given find options.
       */
      async findOne(options) {
        return this.manager.findOne(this.metadata.target, options);
      }
      /**
       * Finds first entity that matches given WHERE conditions.
       */
      async findOneBy(where) {
        return this.manager.findOneBy(this.metadata.target, where);
      }
      /**
       * Finds entity that matches given id.
       *
       * @deprecated use `findOneBy` method instead in conjunction with `In` operator, for example:
       *
       * .findOneBy({
       *     id: 1 // where "id" is your primary column name
       * })
       */
      async findOneById(id) {
        return this.manager.findOneById(this.metadata.target, id);
      }
      /**
       * Finds first entity by a given find options.
       * If entity was not found in the database - rejects with error.
       */
      async findOneOrFail(options) {
        return this.manager.findOneOrFail(this.metadata.target, options);
      }
      /**
       * Finds first entity that matches given where condition.
       * If entity was not found in the database - rejects with error.
       */
      async findOneByOrFail(where) {
        return this.manager.findOneByOrFail(this.metadata.target, where);
      }
      /**
       * Creates a cursor for a query that can be used to iterate over results from MongoDB.
       */
      createCursor(query) {
        return this.manager.createCursor(this.metadata.target, query);
      }
      /**
       * Creates a cursor for a query that can be used to iterate over results from MongoDB.
       * This returns modified version of cursor that transforms each result into Entity model.
       */
      createEntityCursor(query) {
        return this.manager.createEntityCursor(this.metadata.target, query);
      }
      /**
       * Execute an aggregation framework pipeline against the collection.
       */
      aggregate(pipeline, options) {
        return this.manager.aggregate(this.metadata.target, pipeline, options);
      }
      /**
       * Execute an aggregation framework pipeline against the collection.
       * This returns modified version of cursor that transforms each result into Entity model.
       */
      aggregateEntity(pipeline, options) {
        return this.manager.aggregateEntity(this.metadata.target, pipeline, options);
      }
      /**
       * Perform a bulkWrite operation without a fluent API.
       */
      bulkWrite(operations, options) {
        return this.manager.bulkWrite(this.metadata.target, operations, options);
      }
      /**
       * Count number of matching documents in the db to a query.
       */
      count(query, options) {
        return this.manager.count(this.metadata.target, query || {}, options);
      }
      /**
       * Count number of matching documents in the db to a query.
       */
      countDocuments(query, options) {
        return this.manager.countDocuments(this.metadata.target, query || {}, options);
      }
      /**
       * Count number of matching documents in the db to a query.
       */
      countBy(query, options) {
        return this.manager.countBy(this.metadata.target, query, options);
      }
      /**
       * Creates an index on the db and collection.
       */
      createCollectionIndex(fieldOrSpec, options) {
        return this.manager.createCollectionIndex(this.metadata.target, fieldOrSpec, options);
      }
      /**
       * Creates multiple indexes in the collection, this method is only supported for MongoDB 2.6 or higher.
       * Earlier version of MongoDB will throw a command not supported error.
       * Index specifications are defined at http://docs.mongodb.org/manual/reference/command/createIndexes/.
       */
      createCollectionIndexes(indexSpecs) {
        return this.manager.createCollectionIndexes(this.metadata.target, indexSpecs);
      }
      /**
       * Delete multiple documents on MongoDB.
       */
      deleteMany(query, options) {
        return this.manager.deleteMany(this.metadata.tableName, query, options);
      }
      /**
       * Delete a document on MongoDB.
       */
      deleteOne(query, options) {
        return this.manager.deleteOne(this.metadata.tableName, query, options);
      }
      /**
       * The distinct command returns returns a list of distinct values for the given key across a collection.
       */
      distinct(key, query, options) {
        return this.manager.distinct(this.metadata.tableName, key, query, options);
      }
      /**
       * Drops an index from this collection.
       */
      dropCollectionIndex(indexName, options) {
        return this.manager.dropCollectionIndex(this.metadata.tableName, indexName, options);
      }
      /**
       * Drops all indexes from the collection.
       */
      dropCollectionIndexes() {
        return this.manager.dropCollectionIndexes(this.metadata.tableName);
      }
      /**
       * Find a document and delete it in one atomic operation, requires a write lock for the duration of the operation.
       */
      findOneAndDelete(query, options) {
        return this.manager.findOneAndDelete(this.metadata.tableName, query, options);
      }
      /**
       * Find a document and replace it in one atomic operation, requires a write lock for the duration of the operation.
       */
      findOneAndReplace(query, replacement, options) {
        return this.manager.findOneAndReplace(this.metadata.tableName, query, replacement, options);
      }
      /**
       * Find a document and update it in one atomic operation, requires a write lock for the duration of the operation.
       */
      findOneAndUpdate(query, update, options) {
        return this.manager.findOneAndUpdate(this.metadata.tableName, query, update, options);
      }
      /**
       * Retrieve all the indexes on the collection.
       */
      collectionIndexes() {
        return this.manager.collectionIndexes(this.metadata.tableName);
      }
      /**
       * Retrieve all the indexes on the collection.
       */
      collectionIndexExists(indexes) {
        return this.manager.collectionIndexExists(this.metadata.tableName, indexes);
      }
      /**
       * Retrieves this collections index info.
       */
      collectionIndexInformation(options) {
        return this.manager.collectionIndexInformation(this.metadata.tableName, options);
      }
      /**
       * Initiate an In order bulk write operation, operations will be serially executed in the order they are added, creating a new operation for each switch in types.
       */
      initializeOrderedBulkOp(options) {
        return this.manager.initializeOrderedBulkOp(this.metadata.tableName, options);
      }
      /**
       * Initiate a Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.
       */
      initializeUnorderedBulkOp(options) {
        return this.manager.initializeUnorderedBulkOp(this.metadata.tableName, options);
      }
      /**
       * Inserts an array of documents into MongoDB.
       */
      insertMany(docs, options) {
        return this.manager.insertMany(this.metadata.tableName, docs, options);
      }
      /**
       * Inserts a single document into MongoDB.
       */
      insertOne(doc, options) {
        return this.manager.insertOne(this.metadata.tableName, doc, options);
      }
      /**
       * Returns if the collection is a capped collection.
       */
      isCapped() {
        return this.manager.isCapped(this.metadata.tableName);
      }
      /**
       * Get the list of all indexes information for the collection.
       */
      listCollectionIndexes(options) {
        return this.manager.listCollectionIndexes(this.metadata.tableName, options);
      }
      /**
       * Reindex all indexes on the collection Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.
       */
      rename(newName, options) {
        return this.manager.rename(this.metadata.tableName, newName, options);
      }
      /**
       * Replace a document on MongoDB.
       */
      replaceOne(query, doc, options) {
        return this.manager.replaceOne(this.metadata.tableName, query, doc, options);
      }
      /**
       * Get all the collection statistics.
       */
      stats(options) {
        return this.manager.stats(this.metadata.tableName, options);
      }
      /**
       * Update multiple documents on MongoDB.
       */
      updateMany(query, update, options) {
        return this.manager.updateMany(this.metadata.tableName, query, update, options);
      }
      /**
       * Update a single document on MongoDB.
       */
      updateOne(query, update, options) {
        return this.manager.updateOne(this.metadata.tableName, query, update, options);
      }
    };
    exports2.MongoRepository = MongoRepository2;
  }
});

// node_modules/typeorm/util/TreeRepositoryUtils.js
var require_TreeRepositoryUtils = __commonJS({
  "node_modules/typeorm/util/TreeRepositoryUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TreeRepositoryUtils = void 0;
    var TreeRepositoryUtils2 = class _TreeRepositoryUtils {
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      static createRelationMaps(manager, metadata, alias, rawResults) {
        return rawResults.map((rawResult) => {
          const joinColumn = metadata.treeParentRelation.joinColumns[0];
          const referencedColumn = joinColumn.referencedColumn ?? metadata.primaryColumns[0];
          const joinColumnName = joinColumn.givenDatabaseName || joinColumn.databaseName;
          const referencedColumnName = referencedColumn.givenDatabaseName || referencedColumn.databaseName;
          const id = rawResult[alias + "_" + referencedColumnName];
          const parentId = rawResult[alias + "_" + joinColumnName];
          return {
            id: manager.connection.driver.prepareHydratedValue(id, referencedColumn),
            parentId: manager.connection.driver.prepareHydratedValue(parentId, joinColumn)
          };
        });
      }
      static buildChildrenEntityTree(metadata, entity, entities, relationMaps, options) {
        const childProperty = metadata.treeChildrenRelation.propertyName;
        if (options.depth === 0) {
          entity[childProperty] = [];
          return;
        }
        const joinColumn = metadata.treeParentRelation.joinColumns[0];
        const referencedColumn = joinColumn.referencedColumn ?? metadata.primaryColumns[0];
        const parentEntityId = referencedColumn.getEntityValue(entity);
        const childRelationMaps = relationMaps.filter((relationMap) => relationMap.parentId === parentEntityId);
        const childIds = new Set(childRelationMaps.map((relationMap) => relationMap.id));
        entity[childProperty] = entities.filter((entity2) => childIds.has(referencedColumn.getEntityValue(entity2)));
        entity[childProperty].forEach((childEntity) => {
          _TreeRepositoryUtils.buildChildrenEntityTree(metadata, childEntity, entities, relationMaps, {
            ...options,
            depth: options.depth - 1
          });
        });
      }
      static buildParentEntityTree(metadata, entity, entities, relationMaps) {
        const parentProperty = metadata.treeParentRelation.propertyName;
        const joinColumn = metadata.treeParentRelation.joinColumns[0];
        const referencedColumn = joinColumn.referencedColumn ?? metadata.primaryColumns[0];
        const entityId = referencedColumn.getEntityValue(entity);
        const parentRelationMap = relationMaps.find((relationMap) => relationMap.id === entityId);
        const parentEntity = entities.find((entity2) => {
          if (!parentRelationMap)
            return false;
          return referencedColumn.getEntityValue(entity2) === parentRelationMap.parentId;
        });
        if (parentEntity) {
          entity[parentProperty] = parentEntity;
          _TreeRepositoryUtils.buildParentEntityTree(metadata, entity[parentProperty], entities, relationMaps);
        }
      }
    };
    exports2.TreeRepositoryUtils = TreeRepositoryUtils2;
  }
});

// node_modules/typeorm/repository/TreeRepository.js
var require_TreeRepository = __commonJS({
  "node_modules/typeorm/repository/TreeRepository.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TreeRepository = void 0;
    var DriverUtils_1 = require_DriverUtils();
    var TypeORMError_1 = require_TypeORMError();
    var FindOptionsUtils_1 = require_FindOptionsUtils();
    var TreeRepositoryUtils_1 = require_TreeRepositoryUtils();
    var Repository_1 = require_Repository();
    var TreeRepository2 = class extends Repository_1.Repository {
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Gets complete trees for all roots in the table.
       */
      async findTrees(options) {
        const roots = await this.findRoots(options);
        await Promise.all(roots.map((root) => this.findDescendantsTree(root, options)));
        return roots;
      }
      /**
       * Roots are entities that have no ancestors. Finds them all.
       */
      findRoots(options) {
        const escapeAlias = (alias) => this.manager.connection.driver.escape(alias);
        const escapeColumn = (column) => this.manager.connection.driver.escape(column);
        const joinColumn = this.metadata.treeParentRelation.joinColumns[0];
        const parentPropertyName = joinColumn.givenDatabaseName || joinColumn.databaseName;
        const qb = this.createQueryBuilder("treeEntity");
        FindOptionsUtils_1.FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);
        return qb.where(`${escapeAlias("treeEntity")}.${escapeColumn(parentPropertyName)} IS NULL`).getMany();
      }
      /**
       * Gets all children (descendants) of the given entity. Returns them all in a flat array.
       */
      findDescendants(entity, options) {
        const qb = this.createDescendantsQueryBuilder("treeEntity", "treeClosure", entity);
        FindOptionsUtils_1.FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);
        return qb.getMany();
      }
      /**
       * Gets all children (descendants) of the given entity. Returns them in a tree - nested into each other.
       */
      async findDescendantsTree(entity, options) {
        const qb = this.createDescendantsQueryBuilder("treeEntity", "treeClosure", entity);
        FindOptionsUtils_1.FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);
        const entities = await qb.getRawAndEntities();
        const relationMaps = TreeRepositoryUtils_1.TreeRepositoryUtils.createRelationMaps(this.manager, this.metadata, "treeEntity", entities.raw);
        TreeRepositoryUtils_1.TreeRepositoryUtils.buildChildrenEntityTree(this.metadata, entity, entities.entities, relationMaps, {
          depth: -1,
          ...options
        });
        return entity;
      }
      /**
       * Gets number of descendants of the entity.
       */
      countDescendants(entity) {
        return this.createDescendantsQueryBuilder("treeEntity", "treeClosure", entity).getCount();
      }
      /**
       * Creates a query builder used to get descendants of the entities in a tree.
       */
      createDescendantsQueryBuilder(alias, closureTableAlias, entity) {
        const escape = (alias2) => this.manager.connection.driver.escape(alias2);
        if (this.metadata.treeType === "closure-table") {
          const joinCondition = this.metadata.closureJunctionTable.descendantColumns.map((column) => {
            return escape(closureTableAlias) + "." + escape(column.propertyPath) + " = " + escape(alias) + "." + escape(column.referencedColumn.propertyPath);
          }).join(" AND ");
          const parameters = {};
          const whereCondition = this.metadata.closureJunctionTable.ancestorColumns.map((column) => {
            parameters[column.referencedColumn.propertyName] = column.referencedColumn.getEntityValue(entity);
            return escape(closureTableAlias) + "." + escape(column.propertyPath) + " = :" + column.referencedColumn.propertyName;
          }).join(" AND ");
          return this.createQueryBuilder(alias).innerJoin(this.metadata.closureJunctionTable.tableName, closureTableAlias, joinCondition).where(whereCondition).setParameters(parameters);
        } else if (this.metadata.treeType === "nested-set") {
          const whereCondition = alias + "." + this.metadata.nestedSetLeftColumn.propertyPath + " BETWEEN joined." + this.metadata.nestedSetLeftColumn.propertyPath + " AND joined." + this.metadata.nestedSetRightColumn.propertyPath;
          const parameters = {};
          const joinCondition = this.metadata.treeParentRelation.joinColumns.map((joinColumn) => {
            const parameterName = joinColumn.referencedColumn.propertyPath.replace(".", "_");
            parameters[parameterName] = joinColumn.referencedColumn.getEntityValue(entity);
            return "joined." + joinColumn.referencedColumn.propertyPath + " = :" + parameterName;
          }).join(" AND ");
          return this.createQueryBuilder(alias).innerJoin(this.metadata.targetName, "joined", whereCondition).where(joinCondition, parameters);
        } else if (this.metadata.treeType === "materialized-path") {
          return this.createQueryBuilder(alias).where((qb) => {
            const subQuery = qb.subQuery().select(`${this.metadata.targetName}.${this.metadata.materializedPathColumn.propertyPath}`, "path").from(this.metadata.target, this.metadata.targetName).whereInIds(this.metadata.getEntityIdMap(entity));
            if (DriverUtils_1.DriverUtils.isSQLiteFamily(this.manager.connection.driver)) {
              return `${alias}.${this.metadata.materializedPathColumn.propertyPath} LIKE ${subQuery.getQuery()} || '%'`;
            } else {
              return `${alias}.${this.metadata.materializedPathColumn.propertyPath} LIKE NULLIF(CONCAT(${subQuery.getQuery()}, '%'), '%')`;
            }
          });
        }
        throw new TypeORMError_1.TypeORMError(`Supported only in tree entities`);
      }
      /**
       * Gets all parents (ancestors) of the given entity. Returns them all in a flat array.
       */
      findAncestors(entity, options) {
        const qb = this.createAncestorsQueryBuilder("treeEntity", "treeClosure", entity);
        FindOptionsUtils_1.FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);
        return qb.getMany();
      }
      /**
       * Gets all parents (ancestors) of the given entity. Returns them in a tree - nested into each other.
       */
      async findAncestorsTree(entity, options) {
        const qb = this.createAncestorsQueryBuilder("treeEntity", "treeClosure", entity);
        FindOptionsUtils_1.FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);
        const entities = await qb.getRawAndEntities();
        const relationMaps = TreeRepositoryUtils_1.TreeRepositoryUtils.createRelationMaps(this.manager, this.metadata, "treeEntity", entities.raw);
        TreeRepositoryUtils_1.TreeRepositoryUtils.buildParentEntityTree(this.metadata, entity, entities.entities, relationMaps);
        return entity;
      }
      /**
       * Gets number of ancestors of the entity.
       */
      countAncestors(entity) {
        return this.createAncestorsQueryBuilder("treeEntity", "treeClosure", entity).getCount();
      }
      /**
       * Creates a query builder used to get ancestors of the entities in the tree.
       */
      createAncestorsQueryBuilder(alias, closureTableAlias, entity) {
        if (this.metadata.treeType === "closure-table") {
          const joinCondition = this.metadata.closureJunctionTable.ancestorColumns.map((column) => {
            return closureTableAlias + "." + column.propertyPath + " = " + alias + "." + column.referencedColumn.propertyPath;
          }).join(" AND ");
          const parameters = {};
          const whereCondition = this.metadata.closureJunctionTable.descendantColumns.map((column) => {
            parameters[column.referencedColumn.propertyName] = column.referencedColumn.getEntityValue(entity);
            return closureTableAlias + "." + column.propertyPath + " = :" + column.referencedColumn.propertyName;
          }).join(" AND ");
          return this.createQueryBuilder(alias).innerJoin(this.metadata.closureJunctionTable.tableName, closureTableAlias, joinCondition).where(whereCondition).setParameters(parameters);
        } else if (this.metadata.treeType === "nested-set") {
          const joinCondition = "joined." + this.metadata.nestedSetLeftColumn.propertyPath + " BETWEEN " + alias + "." + this.metadata.nestedSetLeftColumn.propertyPath + " AND " + alias + "." + this.metadata.nestedSetRightColumn.propertyPath;
          const parameters = {};
          const whereCondition = this.metadata.treeParentRelation.joinColumns.map((joinColumn) => {
            const parameterName = joinColumn.referencedColumn.propertyPath.replace(".", "_");
            parameters[parameterName] = joinColumn.referencedColumn.getEntityValue(entity);
            return "joined." + joinColumn.referencedColumn.propertyPath + " = :" + parameterName;
          }).join(" AND ");
          return this.createQueryBuilder(alias).innerJoin(this.metadata.targetName, "joined", joinCondition).where(whereCondition, parameters);
        } else if (this.metadata.treeType === "materialized-path") {
          return this.createQueryBuilder(alias).where((qb) => {
            const subQuery = qb.subQuery().select(`${this.metadata.targetName}.${this.metadata.materializedPathColumn.propertyPath}`, "path").from(this.metadata.target, this.metadata.targetName).whereInIds(this.metadata.getEntityIdMap(entity));
            if (DriverUtils_1.DriverUtils.isSQLiteFamily(this.manager.connection.driver)) {
              return `${subQuery.getQuery()} LIKE ${alias}.${this.metadata.materializedPathColumn.propertyPath} || '%'`;
            } else {
              return `${subQuery.getQuery()} LIKE CONCAT(${alias}.${this.metadata.materializedPathColumn.propertyPath}, '%')`;
            }
          });
        }
        throw new TypeORMError_1.TypeORMError(`Supported only in tree entities`);
      }
    };
    exports2.TreeRepository = TreeRepository2;
  }
});

// node_modules/typeorm/query-builder/transformer/PlainObjectToNewEntityTransformer.js
var require_PlainObjectToNewEntityTransformer = __commonJS({
  "node_modules/typeorm/query-builder/transformer/PlainObjectToNewEntityTransformer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PlainObjectToNewEntityTransformer = void 0;
    var ObjectUtils_1 = require_ObjectUtils();
    var PlainObjectToNewEntityTransformer = class {
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      transform(newEntity, object, metadata, getLazyRelationsPromiseValue = false) {
        this.groupAndTransform(newEntity, object, metadata, getLazyRelationsPromiseValue);
        return newEntity;
      }
      // -------------------------------------------------------------------------
      // Private Methods
      // -------------------------------------------------------------------------
      /**
       * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated
       * we need to group our result and we must have some unique id (primary key in our case)
       */
      groupAndTransform(entity, object, metadata, getLazyRelationsPromiseValue = false) {
        metadata.nonVirtualColumns.forEach((column) => {
          const objectColumnValue = column.getEntityValue(object);
          if (objectColumnValue !== void 0)
            column.setEntityValue(entity, objectColumnValue);
        });
        if (metadata.relations.length) {
          metadata.relations.forEach((relation) => {
            let entityRelatedValue = relation.getEntityValue(entity);
            const objectRelatedValue = relation.getEntityValue(object, getLazyRelationsPromiseValue);
            if (objectRelatedValue === void 0)
              return;
            if (relation.isOneToMany || relation.isManyToMany) {
              if (!Array.isArray(objectRelatedValue))
                return;
              if (!entityRelatedValue) {
                entityRelatedValue = [];
                relation.setEntityValue(entity, entityRelatedValue);
              }
              objectRelatedValue.forEach((objectRelatedValueItem) => {
                let objectRelatedValueEntity = entityRelatedValue.find((entityRelatedValueItem) => {
                  return relation.inverseEntityMetadata.compareEntities(objectRelatedValueItem, entityRelatedValueItem);
                });
                const inverseEntityMetadata = relation.inverseEntityMetadata.findInheritanceMetadata(objectRelatedValueItem);
                if (!objectRelatedValueEntity) {
                  objectRelatedValueEntity = inverseEntityMetadata.create(void 0, {
                    fromDeserializer: true
                  });
                  entityRelatedValue.push(objectRelatedValueEntity);
                }
                this.groupAndTransform(objectRelatedValueEntity, objectRelatedValueItem, inverseEntityMetadata, getLazyRelationsPromiseValue);
              });
            } else {
              if (!ObjectUtils_1.ObjectUtils.isObject(objectRelatedValue)) {
                if (!ObjectUtils_1.ObjectUtils.isObject(entityRelatedValue))
                  relation.setEntityValue(entity, objectRelatedValue);
                return;
              }
              const inverseEntityMetadata = relation.inverseEntityMetadata.findInheritanceMetadata(objectRelatedValue);
              if (!entityRelatedValue) {
                entityRelatedValue = inverseEntityMetadata.create(void 0, {
                  fromDeserializer: true
                });
                relation.setEntityValue(entity, entityRelatedValue);
              }
              this.groupAndTransform(entityRelatedValue, objectRelatedValue, inverseEntityMetadata, getLazyRelationsPromiseValue);
            }
          });
        }
      }
    };
    exports2.PlainObjectToNewEntityTransformer = PlainObjectToNewEntityTransformer;
  }
});

// node_modules/typeorm/query-builder/transformer/PlainObjectToDatabaseEntityTransformer.js
var require_PlainObjectToDatabaseEntityTransformer = __commonJS({
  "node_modules/typeorm/query-builder/transformer/PlainObjectToDatabaseEntityTransformer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PlainObjectToDatabaseEntityTransformer = void 0;
    var LoadMapItem = class {
      constructor(plainEntity, metadata, parentLoadMapItem, relation) {
        this.plainEntity = plainEntity;
        this.metadata = metadata;
        this.parentLoadMapItem = parentLoadMapItem;
        this.relation = relation;
      }
      get target() {
        return this.metadata.target;
      }
      get id() {
        return this.metadata.getEntityIdMixedMap(this.plainEntity);
      }
    };
    var LoadMap = class {
      constructor() {
        this.loadMapItems = [];
      }
      get mainLoadMapItem() {
        return this.loadMapItems.find((item) => !item.relation && !item.parentLoadMapItem);
      }
      addLoadMap(newLoadMap) {
        const item = this.loadMapItems.find((item2) => item2.target === newLoadMap.target && item2.id === newLoadMap.id);
        if (!item)
          this.loadMapItems.push(newLoadMap);
      }
      fillEntities(target, entities) {
        entities.forEach((entity) => {
          const item = this.loadMapItems.find((loadMapItem) => {
            return loadMapItem.target === target && loadMapItem.metadata.compareEntities(entity, loadMapItem.plainEntity);
          });
          if (item)
            item.entity = entity;
        });
      }
      groupByTargetIds() {
        const groups = [];
        this.loadMapItems.forEach((loadMapItem) => {
          let group = groups.find((group2) => group2.target === loadMapItem.target);
          if (!group) {
            group = { target: loadMapItem.target, ids: [] };
            groups.push(group);
          }
          group.ids.push(loadMapItem.id);
        });
        return groups;
      }
    };
    var PlainObjectToDatabaseEntityTransformer = class {
      constructor(manager) {
        this.manager = manager;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      async transform(plainObject, metadata) {
        if (!metadata.hasAllPrimaryKeys(plainObject))
          return Promise.reject("Given object does not have a primary column, cannot transform it to database entity.");
        const loadMap = new LoadMap();
        const fillLoadMap = (entity, entityMetadata, parentLoadMapItem, relation) => {
          const item = new LoadMapItem(entity, entityMetadata, parentLoadMapItem, relation);
          loadMap.addLoadMap(item);
          entityMetadata.extractRelationValuesFromEntity(entity, metadata.relations).filter((value) => value !== null && value !== void 0).forEach(([relation2, value, inverseEntityMetadata]) => fillLoadMap(value, inverseEntityMetadata, item, relation2));
        };
        fillLoadMap(plainObject, metadata);
        await Promise.all(loadMap.groupByTargetIds().map((targetWithIds) => {
          return this.manager.findByIds(targetWithIds.target, targetWithIds.ids).then((entities) => loadMap.fillEntities(targetWithIds.target, entities));
        }));
        loadMap.loadMapItems.forEach((loadMapItem) => {
          if (!loadMapItem.relation || !loadMapItem.entity || !loadMapItem.parentLoadMapItem || !loadMapItem.parentLoadMapItem.entity)
            return;
          if (loadMapItem.relation.isManyToMany || loadMapItem.relation.isOneToMany) {
            if (!loadMapItem.parentLoadMapItem.entity[loadMapItem.relation.propertyName])
              loadMapItem.parentLoadMapItem.entity[loadMapItem.relation.propertyName] = [];
            loadMapItem.parentLoadMapItem.entity[loadMapItem.relation.propertyName].push(loadMapItem.entity);
          } else {
            loadMapItem.parentLoadMapItem.entity[loadMapItem.relation.propertyName] = loadMapItem.entity;
          }
        });
        return loadMap.mainLoadMapItem ? loadMap.mainLoadMapItem.entity : void 0;
      }
    };
    exports2.PlainObjectToDatabaseEntityTransformer = PlainObjectToDatabaseEntityTransformer;
  }
});

// node_modules/typeorm/repository/AbstractRepository.js
var require_AbstractRepository = __commonJS({
  "node_modules/typeorm/repository/AbstractRepository.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractRepository = void 0;
    var CustomRepositoryDoesNotHaveEntityError_1 = require_CustomRepositoryDoesNotHaveEntityError();
    var globals_1 = require_globals();
    var CustomRepositoryNotFoundError_1 = require_CustomRepositoryNotFoundError();
    var AbstractRepository2 = class {
      // -------------------------------------------------------------------------
      // Protected Accessors
      // -------------------------------------------------------------------------
      /**
       * Gets the original ORM repository for the entity that is managed by this repository.
       * If current repository does not manage any entity, then exception will be thrown.
       */
      get repository() {
        const target = this.getCustomRepositoryTarget(this);
        if (!target)
          throw new CustomRepositoryDoesNotHaveEntityError_1.CustomRepositoryDoesNotHaveEntityError(this.constructor);
        return this.manager.getRepository(target);
      }
      /**
       * Gets the original ORM tree repository for the entity that is managed by this repository.
       * If current repository does not manage any entity, then exception will be thrown.
       */
      get treeRepository() {
        const target = this.getCustomRepositoryTarget(this);
        if (!target)
          throw new CustomRepositoryDoesNotHaveEntityError_1.CustomRepositoryDoesNotHaveEntityError(this.constructor);
        return this.manager.getTreeRepository(target);
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Creates a new query builder for the repository's entity that can be used to build a SQL query.
       * If current repository does not manage any entity, then exception will be thrown.
       */
      createQueryBuilder(alias) {
        const target = this.getCustomRepositoryTarget(this.constructor);
        if (!target)
          throw new CustomRepositoryDoesNotHaveEntityError_1.CustomRepositoryDoesNotHaveEntityError(this.constructor);
        return this.manager.getRepository(target).createQueryBuilder(alias);
      }
      /**
       * Creates a new query builder for the given entity that can be used to build a SQL query.
       */
      createQueryBuilderFor(entity, alias) {
        return this.getRepositoryFor(entity).createQueryBuilder(alias);
      }
      /**
       * Gets the original ORM repository for the given entity class.
       */
      getRepositoryFor(entity) {
        return this.manager.getRepository(entity);
      }
      /**
       * Gets the original ORM tree repository for the given entity class.
       */
      getTreeRepositoryFor(entity) {
        return this.manager.getTreeRepository(entity);
      }
      // -------------------------------------------------------------------------
      // Private Methods
      // -------------------------------------------------------------------------
      /**
       * Gets custom repository's managed entity.
       * If given custom repository does not manage any entity then undefined will be returned.
       */
      getCustomRepositoryTarget(customRepository) {
        const entityRepositoryMetadataArgs = (0, globals_1.getMetadataArgsStorage)().entityRepositories.find((repository) => {
          return repository.target === (typeof customRepository === "function" ? customRepository : customRepository.constructor);
        });
        if (!entityRepositoryMetadataArgs)
          throw new CustomRepositoryNotFoundError_1.CustomRepositoryNotFoundError(customRepository);
        return entityRepositoryMetadataArgs.entity;
      }
    };
    exports2.AbstractRepository = AbstractRepository2;
  }
});

// node_modules/typeorm/persistence/SubjectTopologicalSorter.js
var require_SubjectTopologicalSorter = __commonJS({
  "node_modules/typeorm/persistence/SubjectTopologicalSorter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SubjectTopologicalSorter = void 0;
    var error_1 = require_error();
    var SubjectTopologicalSorter = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(subjects) {
        this.subjects = [...subjects];
        this.metadatas = this.getUniqueMetadatas(this.subjects);
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Sorts (orders) subjects in their topological order.
       */
      sort(direction) {
        if (!this.metadatas.length)
          return this.subjects;
        const sortedSubjects = [];
        if (direction === "delete") {
          const junctionSubjects = this.subjects.filter((subject) => !subject.entity && !subject.databaseEntity);
          sortedSubjects.push(...junctionSubjects);
          this.removeAlreadySorted(junctionSubjects);
        }
        const nonNullableDependencies = this.getNonNullableDependencies();
        let sortedNonNullableEntityTargets = this.toposort(nonNullableDependencies);
        if (direction === "insert")
          sortedNonNullableEntityTargets = sortedNonNullableEntityTargets.reverse();
        sortedNonNullableEntityTargets.forEach((sortedEntityTarget) => {
          const entityTargetSubjects = this.subjects.filter((subject) => subject.metadata.targetName === sortedEntityTarget || subject.metadata.inheritanceTree.some((s) => s.name === sortedEntityTarget));
          sortedSubjects.push(...entityTargetSubjects);
          this.removeAlreadySorted(entityTargetSubjects);
        });
        const otherDependencies = this.getDependencies();
        let sortedOtherEntityTargets = this.toposort(otherDependencies);
        if (direction === "insert")
          sortedOtherEntityTargets = sortedOtherEntityTargets.reverse();
        sortedOtherEntityTargets.forEach((sortedEntityTarget) => {
          const entityTargetSubjects = this.subjects.filter((subject) => subject.metadata.targetName === sortedEntityTarget);
          sortedSubjects.push(...entityTargetSubjects);
          this.removeAlreadySorted(entityTargetSubjects);
        });
        sortedSubjects.push(...this.subjects);
        return sortedSubjects;
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Removes already sorted subjects from this.subjects list of subjects.
       */
      removeAlreadySorted(subjects) {
        subjects.forEach((subject) => {
          this.subjects.splice(this.subjects.indexOf(subject), 1);
        });
      }
      /**
       * Extracts all unique metadatas from the given subjects.
       */
      getUniqueMetadatas(subjects) {
        const metadatas = [];
        subjects.forEach((subject) => {
          if (metadatas.indexOf(subject.metadata) === -1)
            metadatas.push(subject.metadata);
        });
        return metadatas;
      }
      /**
       * Gets dependency tree for all entity metadatas with non-nullable relations.
       * We need to execute insertions first for entities which non-nullable relations.
       */
      getNonNullableDependencies() {
        return this.metadatas.reduce((dependencies, metadata) => {
          metadata.relationsWithJoinColumns.forEach((relation) => {
            if (relation.isNullable)
              return;
            dependencies.push([
              metadata.targetName,
              relation.inverseEntityMetadata.targetName
            ]);
          });
          return dependencies;
        }, []);
      }
      /**
       * Gets dependency tree for all entity metadatas with non-nullable relations.
       * We need to execute insertions first for entities which non-nullable relations.
       */
      getDependencies() {
        return this.metadatas.reduce((dependencies, metadata) => {
          metadata.relationsWithJoinColumns.forEach((relation) => {
            if (relation.inverseEntityMetadata === metadata)
              return;
            dependencies.push([
              metadata.targetName,
              relation.inverseEntityMetadata.targetName
            ]);
          });
          return dependencies;
        }, []);
      }
      /**
       * Sorts given graph using topological sorting algorithm.
       *
       * Algorithm is kindly taken from https://github.com/marcelklehr/toposort repository.
       */
      toposort(edges) {
        function uniqueNodes(arr) {
          const res = [];
          for (let i2 = 0, len = arr.length; i2 < len; i2++) {
            const edge = arr[i2];
            if (res.indexOf(edge[0]) < 0)
              res.push(edge[0]);
            if (res.indexOf(edge[1]) < 0)
              res.push(edge[1]);
          }
          return res;
        }
        const nodes = uniqueNodes(edges);
        let cursor = nodes.length, i = cursor;
        const sorted = new Array(cursor), visited = /* @__PURE__ */ new Set();
        while (i--) {
          if (!visited.has(i))
            visit(nodes[i], i, []);
        }
        function visit(node, i2, predecessors) {
          if (predecessors.indexOf(node) >= 0) {
            throw new error_1.TypeORMError("Cyclic dependency: " + JSON.stringify(node));
          }
          if (!~nodes.indexOf(node)) {
            throw new error_1.TypeORMError("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(node));
          }
          if (visited.has(i2))
            return;
          visited.add(i2);
          const outgoing = edges.filter(function(edge) {
            return edge[0] === node;
          });
          if (i2 = outgoing.length) {
            const preds = predecessors.concat(node);
            do {
              const child = outgoing[--i2][1];
              visit(child, nodes.indexOf(child), preds);
            } while (i2);
          }
          sorted[--cursor] = node;
        }
        return sorted;
      }
    };
    exports2.SubjectTopologicalSorter = SubjectTopologicalSorter;
  }
});

// node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "node_modules/dayjs/dayjs.min.js"(exports2, module2) {
    !(function(t, e) {
      "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs = e();
    })(exports2, (function() {
      "use strict";
      var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c = "month", f = "quarter", h = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
        var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
        return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
      } }, m = function(t2, e2, n2) {
        var r2 = String(t2);
        return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
      }, v = { s: m, z: function(t2) {
        var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
        return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
      }, m: function t2(e2, n2) {
        if (e2.date() < n2.date()) return -t2(n2, e2);
        var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), c);
        return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
      }, a: function(t2) {
        return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
      }, p: function(t2) {
        return { M: c, y: h, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: f }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t2) {
        return void 0 === t2;
      } }, g = "en", D = {};
      D[g] = M;
      var p = "$isDayjsObject", S = function(t2) {
        return t2 instanceof _ || !(!t2 || !t2[p]);
      }, w = function t2(e2, n2, r2) {
        var i2;
        if (!e2) return g;
        if ("string" == typeof e2) {
          var s2 = e2.toLowerCase();
          D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
          var u2 = e2.split("-");
          if (!i2 && u2.length > 1) return t2(u2[0]);
        } else {
          var a2 = e2.name;
          D[a2] = e2, i2 = a2;
        }
        return !r2 && i2 && (g = i2), i2 || !r2 && g;
      }, O = function(t2, e2) {
        if (S(t2)) return t2.clone();
        var n2 = "object" == typeof e2 ? e2 : {};
        return n2.date = t2, n2.args = arguments, new _(n2);
      }, b = v;
      b.l = w, b.i = S, b.w = function(t2, e2) {
        return O(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
      };
      var _ = (function() {
        function M2(t2) {
          this.$L = w(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p] = true;
        }
        var m2 = M2.prototype;
        return m2.parse = function(t2) {
          this.$d = (function(t3) {
            var e2 = t3.date, n2 = t3.utc;
            if (null === e2) return /* @__PURE__ */ new Date(NaN);
            if (b.u(e2)) return /* @__PURE__ */ new Date();
            if (e2 instanceof Date) return new Date(e2);
            if ("string" == typeof e2 && !/Z$/i.test(e2)) {
              var r2 = e2.match($);
              if (r2) {
                var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
              }
            }
            return new Date(e2);
          })(t2), this.init();
        }, m2.init = function() {
          var t2 = this.$d;
          this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
        }, m2.$utils = function() {
          return b;
        }, m2.isValid = function() {
          return !(this.$d.toString() === l);
        }, m2.isSame = function(t2, e2) {
          var n2 = O(t2);
          return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
        }, m2.isAfter = function(t2, e2) {
          return O(t2) < this.startOf(e2);
        }, m2.isBefore = function(t2, e2) {
          return this.endOf(e2) < O(t2);
        }, m2.$g = function(t2, e2, n2) {
          return b.u(t2) ? this[e2] : this.set(n2, t2);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t2, e2) {
          var n2 = this, r2 = !!b.u(e2) || e2, f2 = b.p(t2), l2 = function(t3, e3) {
            var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
            return r2 ? i2 : i2.endOf(a);
          }, $2 = function(t3, e3) {
            return b.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
          }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
          switch (f2) {
            case h:
              return r2 ? l2(1, 0) : l2(31, 11);
            case c:
              return r2 ? l2(1, M3) : l2(0, M3 + 1);
            case o:
              var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
              return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
            case a:
            case d:
              return $2(v2 + "Hours", 0);
            case u:
              return $2(v2 + "Minutes", 1);
            case s:
              return $2(v2 + "Seconds", 2);
            case i:
              return $2(v2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t2) {
          return this.startOf(t2, false);
        }, m2.$set = function(t2, e2) {
          var n2, o2 = b.p(t2), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f2 + "Date", n2[d] = f2 + "Date", n2[c] = f2 + "Month", n2[h] = f2 + "FullYear", n2[u] = f2 + "Hours", n2[s] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r] = f2 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
          if (o2 === c || o2 === h) {
            var y2 = this.clone().set(d, 1);
            y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
          } else l2 && this.$d[l2]($2);
          return this.init(), this;
        }, m2.set = function(t2, e2) {
          return this.clone().$set(t2, e2);
        }, m2.get = function(t2) {
          return this[b.p(t2)]();
        }, m2.add = function(r2, f2) {
          var d2, l2 = this;
          r2 = Number(r2);
          var $2 = b.p(f2), y2 = function(t2) {
            var e2 = O(l2);
            return b.w(e2.date(e2.date() + Math.round(t2 * r2)), l2);
          };
          if ($2 === c) return this.set(c, this.$M + r2);
          if ($2 === h) return this.set(h, this.$y + r2);
          if ($2 === a) return y2(1);
          if ($2 === o) return y2(7);
          var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
          return b.w(m3, this);
        }, m2.subtract = function(t2, e2) {
          return this.add(-1 * t2, e2);
        }, m2.format = function(t2) {
          var e2 = this, n2 = this.$locale();
          if (!this.isValid()) return n2.invalidDate || l;
          var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c2 = n2.months, f2 = n2.meridiem, h2 = function(t3, n3, i3, s3) {
            return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
          }, d2 = function(t3) {
            return b.s(s2 % 12 || 12, t3, "0");
          }, $2 = f2 || function(t3, e3, n3) {
            var r3 = t3 < 12 ? "AM" : "PM";
            return n3 ? r3.toLowerCase() : r3;
          };
          return r2.replace(y, (function(t3, r3) {
            return r3 || (function(t4) {
              switch (t4) {
                case "YY":
                  return String(e2.$y).slice(-2);
                case "YYYY":
                  return b.s(e2.$y, 4, "0");
                case "M":
                  return a2 + 1;
                case "MM":
                  return b.s(a2 + 1, 2, "0");
                case "MMM":
                  return h2(n2.monthsShort, a2, c2, 3);
                case "MMMM":
                  return h2(c2, a2);
                case "D":
                  return e2.$D;
                case "DD":
                  return b.s(e2.$D, 2, "0");
                case "d":
                  return String(e2.$W);
                case "dd":
                  return h2(n2.weekdaysMin, e2.$W, o2, 2);
                case "ddd":
                  return h2(n2.weekdaysShort, e2.$W, o2, 3);
                case "dddd":
                  return o2[e2.$W];
                case "H":
                  return String(s2);
                case "HH":
                  return b.s(s2, 2, "0");
                case "h":
                  return d2(1);
                case "hh":
                  return d2(2);
                case "a":
                  return $2(s2, u2, true);
                case "A":
                  return $2(s2, u2, false);
                case "m":
                  return String(u2);
                case "mm":
                  return b.s(u2, 2, "0");
                case "s":
                  return String(e2.$s);
                case "ss":
                  return b.s(e2.$s, 2, "0");
                case "SSS":
                  return b.s(e2.$ms, 3, "0");
                case "Z":
                  return i2;
              }
              return null;
            })(t3) || i2.replace(":", "");
          }));
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r2, d2, l2) {
          var $2, y2 = this, M3 = b.p(d2), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function() {
            return b.m(y2, m3);
          };
          switch (M3) {
            case h:
              $2 = D2() / 12;
              break;
            case c:
              $2 = D2();
              break;
            case f:
              $2 = D2() / 3;
              break;
            case o:
              $2 = (g2 - v2) / 6048e5;
              break;
            case a:
              $2 = (g2 - v2) / 864e5;
              break;
            case u:
              $2 = g2 / n;
              break;
            case s:
              $2 = g2 / e;
              break;
            case i:
              $2 = g2 / t;
              break;
            default:
              $2 = g2;
          }
          return l2 ? $2 : b.a($2);
        }, m2.daysInMonth = function() {
          return this.endOf(c).$D;
        }, m2.$locale = function() {
          return D[this.$L];
        }, m2.locale = function(t2, e2) {
          if (!t2) return this.$L;
          var n2 = this.clone(), r2 = w(t2, e2, true);
          return r2 && (n2.$L = r2), n2;
        }, m2.clone = function() {
          return b.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      })(), k = _.prototype;
      return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h], ["$D", d]].forEach((function(t2) {
        k[t2[1]] = function(e2) {
          return this.$g(e2, t2[0], t2[1]);
        };
      })), O.extend = function(t2, e2) {
        return t2.$i || (t2(e2, _, O), t2.$i = true), O;
      }, O.locale = w, O.isDayjs = S, O.unix = function(t2) {
        return O(1e3 * t2);
      }, O.en = D[g], O.Ls = D, O.p = {}, O;
    }));
  }
});

// node_modules/typeorm/util/DateUtils.js
var require_DateUtils = __commonJS({
  "node_modules/typeorm/util/DateUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DateUtils = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var dayjs_1 = tslib_1.__importDefault(require_dayjs_min());
    var DateUtils = class {
      // -------------------------------------------------------------------------
      // Public Static Methods
      // -------------------------------------------------------------------------
      /**
       * Normalizes date object hydrated from the database.
       */
      static normalizeHydratedDate(mixedDate) {
        if (!mixedDate)
          return mixedDate;
        return typeof mixedDate === "string" ? new Date(mixedDate) : mixedDate;
      }
      /**
       * Converts given value into date string in a "YYYY-MM-DD" format.
       */
      static mixedDateToDateString(value) {
        if (value instanceof Date) {
          return this.formatZerolessValue(value.getFullYear(), 4) + "-" + this.formatZerolessValue(value.getMonth() + 1) + "-" + this.formatZerolessValue(value.getDate());
        }
        return value;
      }
      /**
       * Converts given value into date object.
       */
      static mixedDateToDate(mixedDate, toUtc = false, useMilliseconds = true) {
        let date = typeof mixedDate === "string" ? (0, dayjs_1.default)(mixedDate).toDate() : mixedDate;
        if (toUtc)
          date = new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
        if (!useMilliseconds)
          date.setUTCMilliseconds(0);
        return date;
      }
      /**
       * Converts given value into time string in a "HH:mm:ss" format.
       */
      static mixedDateToTimeString(value, skipSeconds = false) {
        if (value instanceof Date)
          return this.formatZerolessValue(value.getHours()) + ":" + this.formatZerolessValue(value.getMinutes()) + (!skipSeconds ? ":" + this.formatZerolessValue(value.getSeconds()) : "");
        return value;
      }
      /**
       * Converts given value into time string in a "HH:mm:ss" format.
       */
      static mixedTimeToDate(value) {
        if (typeof value === "string") {
          const [hours, minutes, seconds] = value.split(":");
          const date = /* @__PURE__ */ new Date();
          if (hours)
            date.setHours(parseInt(hours));
          if (minutes)
            date.setMinutes(parseInt(minutes));
          if (seconds)
            date.setSeconds(parseInt(seconds));
          return date;
        }
        return value;
      }
      /**
       * Converts given string value with "-" separator into a "HH:mm:ss" format.
       */
      static mixedTimeToString(value, skipSeconds = false) {
        value = value instanceof Date ? value.getHours() + ":" + value.getMinutes() + (!skipSeconds ? ":" + value.getSeconds() : "") : value;
        if (typeof value === "string") {
          return value.split(":").map((v) => v.length === 1 ? "0" + v : v).join(":");
        }
        return value;
      }
      /**
       * Converts given value into datetime string in a "YYYY-MM-DD HH-mm-ss" format.
       */
      static mixedDateToDatetimeString(value, useMilliseconds) {
        if (typeof value === "string") {
          value = new Date(value);
        }
        if (value instanceof Date) {
          let finalValue = this.formatZerolessValue(value.getFullYear(), 4) + "-" + this.formatZerolessValue(value.getMonth() + 1) + "-" + this.formatZerolessValue(value.getDate()) + " " + this.formatZerolessValue(value.getHours()) + ":" + this.formatZerolessValue(value.getMinutes()) + ":" + this.formatZerolessValue(value.getSeconds());
          if (useMilliseconds)
            finalValue += `.${this.formatMilliseconds(value.getMilliseconds())}`;
          value = finalValue;
        }
        return value;
      }
      /**
       * Converts given value into utc datetime string in a "YYYY-MM-DD HH-mm-ss.sss" format.
       */
      static mixedDateToUtcDatetimeString(value) {
        if (typeof value === "string") {
          value = new Date(value);
        }
        if (value instanceof Date) {
          return this.formatZerolessValue(value.getUTCFullYear(), 4) + "-" + this.formatZerolessValue(value.getUTCMonth() + 1) + "-" + this.formatZerolessValue(value.getUTCDate()) + " " + this.formatZerolessValue(value.getUTCHours()) + ":" + this.formatZerolessValue(value.getUTCMinutes()) + ":" + this.formatZerolessValue(value.getUTCSeconds()) + "." + this.formatMilliseconds(value.getUTCMilliseconds());
        }
        return value;
      }
      /**
       * Converts each item in the given array to string joined by "," separator.
       */
      static simpleArrayToString(value) {
        if (Array.isArray(value)) {
          return value.map((i) => String(i)).join(",");
        }
        return value;
      }
      /**
       * Converts given string to simple array split by "," separator.
       */
      static stringToSimpleArray(value) {
        if (typeof value === "string") {
          if (value.length > 0) {
            return value.split(",");
          } else {
            return [];
          }
        }
        return value;
      }
      static simpleJsonToString(value) {
        return JSON.stringify(value);
      }
      static stringToSimpleJson(value) {
        return typeof value === "string" ? JSON.parse(value) : value;
      }
      static simpleEnumToString(value) {
        return "" + value;
      }
      static stringToSimpleEnum(value, columnMetadata) {
        if (columnMetadata.enum && !isNaN(value) && columnMetadata.enum.indexOf(parseInt(value)) >= 0) {
          value = parseInt(value);
        }
        return value;
      }
      // -------------------------------------------------------------------------
      // Private Static Methods
      // -------------------------------------------------------------------------
      /**
       * Formats given number to "0x" format, e.g. if the totalLength = 2 and the value is 1 then it will return "01".
       */
      static formatZerolessValue(value, totalLength = 2) {
        const pad = "0".repeat(totalLength);
        return String(`${pad}${value}`).slice(-totalLength);
      }
      /**
       * Formats given number to "0x" format, e.g. if it is 1 then it will return "01".
       */
      static formatMilliseconds(value) {
        if (value < 10) {
          return "00" + value;
        } else if (value < 100) {
          return "0" + value;
        } else {
          return String(value);
        }
      }
    };
    exports2.DateUtils = DateUtils;
  }
});

// node_modules/typeorm/persistence/SubjectChangedColumnsComputer.js
var require_SubjectChangedColumnsComputer = __commonJS({
  "node_modules/typeorm/persistence/SubjectChangedColumnsComputer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SubjectChangedColumnsComputer = void 0;
    var ApplyValueTransformers_1 = require_ApplyValueTransformers();
    var DateUtils_1 = require_DateUtils();
    var ObjectUtils_1 = require_ObjectUtils();
    var OrmUtils_1 = require_OrmUtils();
    var SubjectChangedColumnsComputer = class {
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Finds what columns are changed in the subject entities.
       */
      compute(subjects) {
        subjects.forEach((subject) => {
          this.computeDiffColumns(subject);
          this.computeDiffRelationalColumns(subjects, subject);
        });
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Differentiate columns from the updated entity and entity stored in the database.
       */
      computeDiffColumns(subject) {
        if (!subject.entity)
          return;
        subject.metadata.columns.forEach((column) => {
          if (column.isVirtual || column.isDiscriminator)
            return;
          const changeMap = subject.changeMaps.find((changeMap2) => changeMap2.column === column);
          if (changeMap) {
            subject.changeMaps.splice(subject.changeMaps.indexOf(changeMap), 1);
          }
          const entityValue = column.getEntityValue(subject.entity);
          if (entityValue === void 0)
            return;
          if (subject.databaseEntity) {
            const shouldTransformDatabaseEntity = column.type !== "json" && column.type !== "jsonb";
            let databaseValue = column.getEntityValue(subject.databaseEntity, shouldTransformDatabaseEntity);
            if (column.relationMetadata) {
              const value = column.relationMetadata.getEntityValue(subject.entity);
              if (value !== null && value !== void 0)
                return;
            }
            let normalizedValue = entityValue;
            if (entityValue !== null && databaseValue !== null) {
              switch (column.type) {
                case "date":
                  normalizedValue = column.isArray ? entityValue.map((date) => DateUtils_1.DateUtils.mixedDateToDateString(date)) : DateUtils_1.DateUtils.mixedDateToDateString(entityValue);
                  databaseValue = column.isArray ? databaseValue.map((date) => DateUtils_1.DateUtils.mixedDateToDateString(date)) : DateUtils_1.DateUtils.mixedDateToDateString(databaseValue);
                  break;
                case "time":
                case "time with time zone":
                case "time without time zone":
                case "timetz":
                  normalizedValue = column.isArray ? entityValue.map((date) => DateUtils_1.DateUtils.mixedDateToTimeString(date)) : DateUtils_1.DateUtils.mixedDateToTimeString(entityValue);
                  databaseValue = column.isArray ? databaseValue.map((date) => DateUtils_1.DateUtils.mixedDateToTimeString(date)) : DateUtils_1.DateUtils.mixedDateToTimeString(databaseValue);
                  break;
                case "datetime":
                case "datetime2":
                case Date:
                case "timestamp":
                case "timestamp without time zone":
                case "timestamp with time zone":
                case "timestamp with local time zone":
                case "timestamptz":
                  normalizedValue = column.isArray ? entityValue.map((date) => DateUtils_1.DateUtils.mixedDateToUtcDatetimeString(date)) : DateUtils_1.DateUtils.mixedDateToUtcDatetimeString(entityValue);
                  databaseValue = column.isArray ? databaseValue.map((date) => DateUtils_1.DateUtils.mixedDateToUtcDatetimeString(date)) : DateUtils_1.DateUtils.mixedDateToUtcDatetimeString(databaseValue);
                  break;
                case "json":
                case "jsonb":
                  if (OrmUtils_1.OrmUtils.deepCompare(entityValue, databaseValue))
                    return;
                  break;
                case "simple-array":
                  normalizedValue = DateUtils_1.DateUtils.simpleArrayToString(entityValue);
                  databaseValue = DateUtils_1.DateUtils.simpleArrayToString(databaseValue);
                  break;
                case "simple-enum":
                  normalizedValue = DateUtils_1.DateUtils.simpleEnumToString(entityValue);
                  databaseValue = DateUtils_1.DateUtils.simpleEnumToString(databaseValue);
                  break;
                case "simple-json":
                  normalizedValue = DateUtils_1.DateUtils.simpleJsonToString(entityValue);
                  databaseValue = DateUtils_1.DateUtils.simpleJsonToString(databaseValue);
                  break;
              }
              if (column.transformer) {
                normalizedValue = ApplyValueTransformers_1.ApplyValueTransformers.transformTo(column.transformer, entityValue);
              }
            }
            if (column.isArray) {
              if (OrmUtils_1.OrmUtils.deepCompare(normalizedValue, databaseValue))
                return;
            } else if (Buffer.isBuffer(normalizedValue) && Buffer.isBuffer(databaseValue)) {
              if (normalizedValue.equals(databaseValue)) {
                return;
              }
            } else {
              if (normalizedValue === databaseValue)
                return;
            }
          }
          if (!subject.diffColumns.includes(column))
            subject.diffColumns.push(column);
          subject.changeMaps.push({
            column,
            value: entityValue
          });
        });
      }
      /**
       * Difference columns of the owning one-to-one and many-to-one columns.
       */
      computeDiffRelationalColumns(allSubjects, subject) {
        if (!subject.entity)
          return;
        subject.metadata.relationsWithJoinColumns.forEach((relation) => {
          let relatedEntity = relation.getEntityValue(subject.entity);
          if (relatedEntity === void 0)
            return;
          if (subject.databaseEntity) {
            let relatedEntityRelationIdMap = relatedEntity;
            if (relatedEntityRelationIdMap !== null && ObjectUtils_1.ObjectUtils.isObject(relatedEntityRelationIdMap))
              relatedEntityRelationIdMap = relation.getRelationIdMap(relatedEntityRelationIdMap);
            const databaseRelatedEntityRelationIdMap = relation.getEntityValue(subject.databaseEntity);
            const areRelatedIdsEqual = OrmUtils_1.OrmUtils.compareIds(relatedEntityRelationIdMap, databaseRelatedEntityRelationIdMap);
            if (areRelatedIdsEqual) {
              return;
            } else {
              subject.diffRelations.push(relation);
            }
          }
          const valueSubject = allSubjects.find((subject2) => subject2.mustBeInserted && subject2.entity === relatedEntity);
          if (valueSubject)
            relatedEntity = valueSubject;
          const changeMap = subject.changeMaps.find((changeMap2) => changeMap2.relation === relation);
          if (changeMap) {
            changeMap.value = relatedEntity;
          } else {
            subject.changeMaps.push({
              relation,
              value: relatedEntity
            });
          }
        });
      }
    };
    exports2.SubjectChangedColumnsComputer = SubjectChangedColumnsComputer;
  }
});

// node_modules/typeorm/error/NestedSetMultipleRootError.js
var require_NestedSetMultipleRootError = __commonJS({
  "node_modules/typeorm/error/NestedSetMultipleRootError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NestedSetMultipleRootError = void 0;
    var TypeORMError_1 = require_TypeORMError();
    var NestedSetMultipleRootError = class extends TypeORMError_1.TypeORMError {
      constructor() {
        super(`Nested sets do not support multiple root entities.`);
      }
    };
    exports2.NestedSetMultipleRootError = NestedSetMultipleRootError;
  }
});

// node_modules/typeorm/persistence/tree/NestedSetSubjectExecutor.js
var require_NestedSetSubjectExecutor = __commonJS({
  "node_modules/typeorm/persistence/tree/NestedSetSubjectExecutor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NestedSetSubjectExecutor = void 0;
    var OrmUtils_1 = require_OrmUtils();
    var NestedSetMultipleRootError_1 = require_NestedSetMultipleRootError();
    var NestedSetSubjectExecutor = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(queryRunner) {
        this.queryRunner = queryRunner;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Executes operations when subject is being inserted.
       */
      async insert(subject) {
        const escape = (alias) => this.queryRunner.connection.driver.escape(alias);
        const tableName = this.getTableName(subject.metadata.tablePath);
        const leftColumnName = escape(subject.metadata.nestedSetLeftColumn.databaseName);
        const rightColumnName = escape(subject.metadata.nestedSetRightColumn.databaseName);
        let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity);
        if (!parent && subject.parentSubject && subject.parentSubject.entity)
          parent = subject.parentSubject.insertedValueSet ? subject.parentSubject.insertedValueSet : subject.parentSubject.entity;
        const parentId = subject.metadata.getEntityIdMap(parent);
        let parentNsRight = void 0;
        if (parentId) {
          parentNsRight = await this.queryRunner.manager.createQueryBuilder().select(subject.metadata.targetName + "." + subject.metadata.nestedSetRightColumn.propertyPath, "right").from(subject.metadata.target, subject.metadata.targetName).whereInIds(parentId).getRawOne().then((result) => {
            const value = result ? result["right"] : void 0;
            return typeof value === "string" ? parseInt(value) : value;
          });
        }
        if (parentNsRight !== void 0) {
          await this.queryRunner.query(`UPDATE ${tableName} SET ${leftColumnName} = CASE WHEN ${leftColumnName} > ${parentNsRight} THEN ${leftColumnName} + 2 ELSE ${leftColumnName} END,${rightColumnName} = ${rightColumnName} + 2 WHERE ${rightColumnName} >= ${parentNsRight}`);
          OrmUtils_1.OrmUtils.mergeDeep(subject.insertedValueSet, subject.metadata.nestedSetLeftColumn.createValueMap(parentNsRight), subject.metadata.nestedSetRightColumn.createValueMap(parentNsRight + 1));
        } else {
          const isUniqueRoot = await this.isUniqueRootEntity(subject, parent);
          if (!isUniqueRoot)
            throw new NestedSetMultipleRootError_1.NestedSetMultipleRootError();
          OrmUtils_1.OrmUtils.mergeDeep(subject.insertedValueSet, subject.metadata.nestedSetLeftColumn.createValueMap(1), subject.metadata.nestedSetRightColumn.createValueMap(2));
        }
      }
      /**
       * Executes operations when subject is being updated.
       */
      async update(subject) {
        let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity);
        if (!parent && subject.parentSubject && subject.parentSubject.entity)
          parent = subject.parentSubject.entity;
        let entity = subject.databaseEntity;
        if (!entity && parent)
          entity = subject.metadata.treeChildrenRelation.getEntityValue(parent).find((child) => {
            return Object.entries(subject.identifier).every(([key, value]) => child[key] === value);
          });
        if (entity === void 0 || parent === void 0) {
          return;
        }
        const oldParent = subject.metadata.treeParentRelation.getEntityValue(entity);
        const oldParentId = subject.metadata.getEntityIdMap(oldParent);
        const parentId = subject.metadata.getEntityIdMap(parent);
        if (OrmUtils_1.OrmUtils.compareIds(oldParentId, parentId)) {
          return;
        }
        if (parent) {
          const escape = (alias) => this.queryRunner.connection.driver.escape(alias);
          const tableName = this.getTableName(subject.metadata.tablePath);
          const leftColumnName = escape(subject.metadata.nestedSetLeftColumn.databaseName);
          const rightColumnName = escape(subject.metadata.nestedSetRightColumn.databaseName);
          const entityId = subject.metadata.getEntityIdMap(entity);
          let entityNs = void 0;
          if (entityId) {
            entityNs = (await this.getNestedSetIds(subject.metadata, entityId))[0];
          }
          let parentNs = void 0;
          if (parentId) {
            parentNs = (await this.getNestedSetIds(subject.metadata, parentId))[0];
          }
          if (entityNs !== void 0 && parentNs !== void 0) {
            const isMovingUp = parentNs.left > entityNs.left;
            const treeSize = entityNs.right - entityNs.left + 1;
            let entitySize;
            if (isMovingUp) {
              entitySize = parentNs.left - entityNs.right;
            } else {
              entitySize = parentNs.right - entityNs.left;
            }
            const updateLeftSide = `WHEN ${leftColumnName} >= ${entityNs.left} AND ${leftColumnName} < ${entityNs.right} THEN ${leftColumnName} + ${entitySize} `;
            const updateRightSide = `WHEN ${rightColumnName} > ${entityNs.left} AND ${rightColumnName} <= ${entityNs.right} THEN ${rightColumnName} + ${entitySize} `;
            if (isMovingUp) {
              await this.queryRunner.query(`UPDATE ${tableName} SET ${leftColumnName} = CASE WHEN ${leftColumnName} > ${entityNs.right} AND ${leftColumnName} <= ${parentNs.left} THEN ${leftColumnName} - ${treeSize} ` + updateLeftSide + `ELSE ${leftColumnName} END, ${rightColumnName} = CASE WHEN ${rightColumnName} > ${entityNs.right} AND ${rightColumnName} < ${parentNs.left} THEN ${rightColumnName} - ${treeSize} ` + updateRightSide + `ELSE ${rightColumnName} END`);
            } else {
              await this.queryRunner.query(`UPDATE ${tableName} SET ${leftColumnName} = CASE WHEN ${leftColumnName} < ${entityNs.left} AND ${leftColumnName} > ${parentNs.right} THEN ${leftColumnName} + ${treeSize} ` + updateLeftSide + `ELSE ${leftColumnName} END, ${rightColumnName} = CASE WHEN ${rightColumnName} < ${entityNs.left} AND ${rightColumnName} >= ${parentNs.right} THEN ${rightColumnName} + ${treeSize} ` + updateRightSide + `ELSE ${rightColumnName} END`);
            }
          }
        } else {
          const isUniqueRoot = await this.isUniqueRootEntity(subject, parent);
          if (!isUniqueRoot)
            throw new NestedSetMultipleRootError_1.NestedSetMultipleRootError();
        }
      }
      /**
       * Executes operations when subject is being removed.
       */
      async remove(subjects) {
        if (!Array.isArray(subjects))
          subjects = [subjects];
        const metadata = subjects[0].metadata;
        const escape = (alias) => this.queryRunner.connection.driver.escape(alias);
        const tableName = this.getTableName(metadata.tablePath);
        const leftColumnName = escape(metadata.nestedSetLeftColumn.databaseName);
        const rightColumnName = escape(metadata.nestedSetRightColumn.databaseName);
        const entitiesIds = [];
        for (const subject of subjects) {
          const entityId = metadata.getEntityIdMap(subject.entity);
          if (entityId) {
            entitiesIds.push(entityId);
          }
        }
        const entitiesNs = await this.getNestedSetIds(metadata, entitiesIds);
        for (const entity of entitiesNs) {
          const treeSize = entity.right - entity.left + 1;
          await this.queryRunner.query(`UPDATE ${tableName} SET ${leftColumnName} = CASE WHEN ${leftColumnName} > ${entity.left} THEN ${leftColumnName} - ${treeSize} ELSE ${leftColumnName} END, ${rightColumnName} = CASE WHEN ${rightColumnName} > ${entity.right} THEN ${rightColumnName} - ${treeSize} ELSE ${rightColumnName} END`);
        }
      }
      /**
       * Get the nested set ids for a given entity
       */
      getNestedSetIds(metadata, ids) {
        const select = {
          left: `${metadata.targetName}.${metadata.nestedSetLeftColumn.propertyPath}`,
          right: `${metadata.targetName}.${metadata.nestedSetRightColumn.propertyPath}`
        };
        const queryBuilder = this.queryRunner.manager.createQueryBuilder();
        Object.entries(select).forEach(([key, value]) => {
          queryBuilder.addSelect(value, key);
        });
        return queryBuilder.from(metadata.target, metadata.targetName).whereInIds(ids).orderBy(select.right, "DESC").getRawMany().then((results) => {
          const data = [];
          for (const result of results) {
            const entry = {};
            for (const key of Object.keys(select)) {
              const value = result ? result[key] : void 0;
              entry[key] = typeof value === "string" ? parseInt(value) : value;
            }
            data.push(entry);
          }
          return data;
        });
      }
      async isUniqueRootEntity(subject, parent) {
        const escape = (alias) => this.queryRunner.connection.driver.escape(alias);
        const tableName = this.getTableName(subject.metadata.tablePath);
        const parameters = [];
        const whereCondition = subject.metadata.treeParentRelation.joinColumns.map((column) => {
          const columnName = escape(column.databaseName);
          const parameter = column.getEntityValue(parent);
          if (parameter == null) {
            return `${columnName} IS NULL`;
          }
          parameters.push(parameter);
          const parameterName = this.queryRunner.connection.driver.createParameter("entity_" + column.databaseName, parameters.length - 1);
          return `${columnName} = ${parameterName}`;
        }).join(" AND ");
        const countAlias = "count";
        const result = await this.queryRunner.query(`SELECT COUNT(1) AS ${escape(countAlias)} FROM ${tableName} WHERE ${whereCondition}`, parameters, true);
        return parseInt(result.records[0][countAlias]) === 0;
      }
      /**
       * Gets escaped table name with schema name if SqlServer or Postgres driver used with custom
       * schema name, otherwise returns escaped table name.
       */
      getTableName(tablePath) {
        return tablePath.split(".").map((i) => {
          return i === "" ? i : this.queryRunner.connection.driver.escape(i);
        }).join(".");
      }
    };
    exports2.NestedSetSubjectExecutor = NestedSetSubjectExecutor;
  }
});

// node_modules/typeorm/persistence/tree/ClosureSubjectExecutor.js
var require_ClosureSubjectExecutor = __commonJS({
  "node_modules/typeorm/persistence/tree/ClosureSubjectExecutor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ClosureSubjectExecutor = void 0;
    var CannotAttachTreeChildrenEntityError_1 = require_CannotAttachTreeChildrenEntityError();
    var OrmUtils_1 = require_OrmUtils();
    var ClosureSubjectExecutor = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(queryRunner) {
        this.queryRunner = queryRunner;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Executes operations when subject is being inserted.
       */
      async insert(subject) {
        const closureJunctionInsertMap = {};
        subject.metadata.closureJunctionTable.ancestorColumns.forEach((column) => {
          closureJunctionInsertMap[column.databaseName] = subject.identifier;
        });
        subject.metadata.closureJunctionTable.descendantColumns.forEach((column) => {
          closureJunctionInsertMap[column.databaseName] = subject.identifier;
        });
        await this.queryRunner.manager.createQueryBuilder().insert().into(subject.metadata.closureJunctionTable.tablePath).values(closureJunctionInsertMap).updateEntity(false).callListeners(false).execute();
        let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity);
        if (!parent && subject.parentSubject && subject.parentSubject.entity)
          parent = subject.parentSubject.insertedValueSet ? subject.parentSubject.insertedValueSet : subject.parentSubject.entity;
        if (parent) {
          const escape = (alias) => this.queryRunner.connection.driver.escape(alias);
          const tableName = this.getTableName(subject.metadata.closureJunctionTable.tablePath);
          const queryParams = [];
          const ancestorColumnNames = subject.metadata.closureJunctionTable.ancestorColumns.map((column) => {
            return escape(column.databaseName);
          });
          const descendantColumnNames = subject.metadata.closureJunctionTable.descendantColumns.map((column) => {
            return escape(column.databaseName);
          });
          const childEntityIds1 = subject.metadata.primaryColumns.map((column) => {
            queryParams.push(column.getEntityValue(subject.insertedValueSet ? subject.insertedValueSet : subject.entity));
            return this.queryRunner.connection.driver.createParameter("child_entity_" + column.databaseName, queryParams.length - 1);
          });
          const whereCondition = subject.metadata.closureJunctionTable.descendantColumns.map((column) => {
            const columnName = escape(column.databaseName);
            const parentId = column.referencedColumn.getEntityValue(parent);
            if (!parentId)
              throw new CannotAttachTreeChildrenEntityError_1.CannotAttachTreeChildrenEntityError(subject.metadata.name);
            queryParams.push(parentId);
            const parameterName = this.queryRunner.connection.driver.createParameter("parent_entity_" + column.referencedColumn.databaseName, queryParams.length - 1);
            return `${columnName} = ${parameterName}`;
          });
          await this.queryRunner.query(`INSERT INTO ${tableName} (${[
            ...ancestorColumnNames,
            ...descendantColumnNames
          ].join(", ")}) SELECT ${ancestorColumnNames.join(", ")}, ${childEntityIds1.join(", ")} FROM ${tableName} WHERE ${whereCondition.join(" AND ")}`, queryParams);
        }
      }
      /**
       * Executes operations when subject is being updated.
       */
      async update(subject) {
        let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity);
        if (!parent && subject.parentSubject && subject.parentSubject.entity)
          parent = subject.parentSubject.entity;
        let entity = subject.databaseEntity;
        if (!entity && parent)
          entity = subject.metadata.treeChildrenRelation.getEntityValue(parent).find((child) => {
            return Object.entries(subject.identifier).every(([key, value]) => child[key] === value);
          });
        if (entity === void 0 || parent === void 0) {
          return;
        }
        const oldParent = subject.metadata.treeParentRelation.getEntityValue(entity);
        const oldParentId = subject.metadata.getEntityIdMap(oldParent);
        const parentId = subject.metadata.getEntityIdMap(parent);
        if (OrmUtils_1.OrmUtils.compareIds(oldParentId, parentId)) {
          return;
        }
        const escape = (alias) => this.queryRunner.connection.driver.escape(alias);
        const closureTable = subject.metadata.closureJunctionTable;
        const ancestorColumnNames = closureTable.ancestorColumns.map((column) => {
          return escape(column.databaseName);
        });
        const descendantColumnNames = closureTable.descendantColumns.map((column) => {
          return escape(column.databaseName);
        });
        const createSubQuery = (qb, alias) => {
          const subAlias = `sub${alias}`;
          const subSelect = qb.createQueryBuilder().select(descendantColumnNames.join(", ")).from(closureTable.tablePath, subAlias);
          for (const column of closureTable.ancestorColumns) {
            subSelect.andWhere(`${escape(subAlias)}.${escape(column.databaseName)} = :value_${column.referencedColumn.databaseName}`);
          }
          return qb.createQueryBuilder().select(descendantColumnNames.join(", ")).from(`(${subSelect.getQuery()})`, alias).setParameters(subSelect.getParameters()).getQuery();
        };
        const parameters = {};
        for (const column of subject.metadata.primaryColumns) {
          parameters[`value_${column.databaseName}`] = entity[column.databaseName];
        }
        await this.queryRunner.manager.createQueryBuilder().delete().from(closureTable.tablePath).where((qb) => `(${descendantColumnNames.join(", ")}) IN (${createSubQuery(qb, "descendant")})`).andWhere((qb) => `(${ancestorColumnNames.join(", ")}) NOT IN (${createSubQuery(qb, "ancestor")})`).setParameters(parameters).execute();
        if (parent) {
          const queryParams = [];
          const tableName = this.getTableName(closureTable.tablePath);
          const superAlias = escape("supertree");
          const subAlias = escape("subtree");
          const select = [
            ...ancestorColumnNames.map((columnName) => `${superAlias}.${columnName}`),
            ...descendantColumnNames.map((columnName) => `${subAlias}.${columnName}`)
          ];
          const entityWhereCondition = subject.metadata.closureJunctionTable.ancestorColumns.map((column) => {
            const columnName = escape(column.databaseName);
            const entityId = column.referencedColumn.getEntityValue(entity);
            queryParams.push(entityId);
            const parameterName = this.queryRunner.connection.driver.createParameter("entity_" + column.referencedColumn.databaseName, queryParams.length - 1);
            return `${subAlias}.${columnName} = ${parameterName}`;
          });
          const parentWhereCondition = subject.metadata.closureJunctionTable.descendantColumns.map((column) => {
            const columnName = escape(column.databaseName);
            const parentId2 = column.referencedColumn.getEntityValue(parent);
            if (!parentId2)
              throw new CannotAttachTreeChildrenEntityError_1.CannotAttachTreeChildrenEntityError(subject.metadata.name);
            queryParams.push(parentId2);
            const parameterName = this.queryRunner.connection.driver.createParameter("parent_entity_" + column.referencedColumn.databaseName, queryParams.length - 1);
            return `${superAlias}.${columnName} = ${parameterName}`;
          });
          await this.queryRunner.query(`INSERT INTO ${tableName} (${[
            ...ancestorColumnNames,
            ...descendantColumnNames
          ].join(", ")}) SELECT ${select.join(", ")} FROM ${tableName} AS ${superAlias}, ${tableName} AS ${subAlias} WHERE ${[
            ...entityWhereCondition,
            ...parentWhereCondition
          ].join(" AND ")}`, queryParams);
        }
      }
      /**
       * Executes operations when subject is being removed.
       */
      async remove(subjects) {
        if (!(this.queryRunner.connection.driver.options.type === "mssql")) {
          return;
        }
        if (!Array.isArray(subjects))
          subjects = [subjects];
        const escape = (alias) => this.queryRunner.connection.driver.escape(alias);
        const identifiers = subjects.map((subject) => subject.identifier);
        const closureTable = subjects[0].metadata.closureJunctionTable;
        const generateWheres = (columns) => {
          return columns.map((column) => {
            const data = identifiers.map((identifier) => identifier[column.referencedColumn.databaseName]);
            return `${escape(column.databaseName)} IN (${data.join(", ")})`;
          }).join(" AND ");
        };
        const ancestorWhere = generateWheres(closureTable.ancestorColumns);
        const descendantWhere = generateWheres(closureTable.descendantColumns);
        await this.queryRunner.manager.createQueryBuilder().delete().from(closureTable.tablePath).where(ancestorWhere).orWhere(descendantWhere).execute();
      }
      /**
       * Gets escaped table name with schema name if SqlServer or Postgres driver used with custom
       * schema name, otherwise returns escaped table name.
       */
      getTableName(tablePath) {
        return tablePath.split(".").map((i) => {
          return i === "" ? i : this.queryRunner.connection.driver.escape(i);
        }).join(".");
      }
    };
    exports2.ClosureSubjectExecutor = ClosureSubjectExecutor;
  }
});

// node_modules/typeorm/metadata/EntityMetadata.js
var require_EntityMetadata = __commonJS({
  "node_modules/typeorm/metadata/EntityMetadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EntityMetadata = void 0;
    var CannotCreateEntityIdMapError_1 = require_CannotCreateEntityIdMapError();
    var OrmUtils_1 = require_OrmUtils();
    var EntityPropertyNotFoundError_1 = require_EntityPropertyNotFoundError();
    var ObjectUtils_1 = require_ObjectUtils();
    var StringUtils_1 = require_StringUtils();
    var EntityMetadata2 = class _EntityMetadata {
      // ---------------------------------------------------------------------
      // Constructor
      // ---------------------------------------------------------------------
      constructor(options) {
        this["@instanceof"] = Symbol.for("EntityMetadata");
        this.childEntityMetadatas = [];
        this.inheritanceTree = [];
        this.tableType = "regular";
        this.withoutRowid = false;
        this.synchronize = true;
        this.hasNonNullableRelations = false;
        this.isJunction = false;
        this.isAlwaysUsingConstructor = true;
        this.isClosureJunction = false;
        this.hasMultiplePrimaryKeys = false;
        this.hasUUIDGeneratedColumns = false;
        this.ownColumns = [];
        this.columns = [];
        this.ancestorColumns = [];
        this.descendantColumns = [];
        this.nonVirtualColumns = [];
        this.ownerColumns = [];
        this.inverseColumns = [];
        this.generatedColumns = [];
        this.primaryColumns = [];
        this.ownRelations = [];
        this.relations = [];
        this.eagerRelations = [];
        this.lazyRelations = [];
        this.oneToOneRelations = [];
        this.ownerOneToOneRelations = [];
        this.oneToManyRelations = [];
        this.manyToOneRelations = [];
        this.manyToManyRelations = [];
        this.ownerManyToManyRelations = [];
        this.relationsWithJoinColumns = [];
        this.relationIds = [];
        this.relationCounts = [];
        this.foreignKeys = [];
        this.embeddeds = [];
        this.allEmbeddeds = [];
        this.ownIndices = [];
        this.indices = [];
        this.uniques = [];
        this.ownUniques = [];
        this.checks = [];
        this.exclusions = [];
        this.ownListeners = [];
        this.listeners = [];
        this.afterLoadListeners = [];
        this.beforeInsertListeners = [];
        this.afterInsertListeners = [];
        this.beforeUpdateListeners = [];
        this.afterUpdateListeners = [];
        this.beforeRemoveListeners = [];
        this.beforeSoftRemoveListeners = [];
        this.beforeRecoverListeners = [];
        this.afterRemoveListeners = [];
        this.afterSoftRemoveListeners = [];
        this.afterRecoverListeners = [];
        this.connection = options.connection;
        this.inheritanceTree = options.inheritanceTree || [];
        this.inheritancePattern = options.inheritancePattern;
        this.treeType = options.tableTree ? options.tableTree.type : void 0;
        this.treeOptions = options.tableTree ? options.tableTree.options : void 0;
        this.parentClosureEntityMetadata = options.parentClosureEntityMetadata;
        this.tableMetadataArgs = options.args;
        this.target = this.tableMetadataArgs.target;
        this.tableType = this.tableMetadataArgs.type;
        this.expression = this.tableMetadataArgs.expression;
        this.withoutRowid = this.tableMetadataArgs.withoutRowid;
        this.dependsOn = this.tableMetadataArgs.dependsOn;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Creates a new entity.
       */
      create(queryRunner, options) {
        const pojo = options && options.pojo === true ? true : false;
        let ret;
        if (typeof this.target === "function" && !pojo) {
          if (!options?.fromDeserializer || this.isAlwaysUsingConstructor) {
            ret = new this.target();
          } else {
            ret = Object.create(this.target.prototype);
          }
        } else {
          ret = {};
        }
        if (this.connection.options.typename) {
          ret[this.connection.options.typename] = this.targetName;
        }
        this.lazyRelations.forEach((relation) => this.connection.relationLoader.enableLazyLoad(relation, ret, queryRunner));
        return ret;
      }
      /**
       * Checks if given entity has an id.
       */
      hasId(entity) {
        if (!entity)
          return false;
        return this.primaryColumns.every((primaryColumn) => {
          const value = primaryColumn.getEntityValue(entity);
          return value !== null && value !== void 0 && value !== "";
        });
      }
      /**
       * Checks if given entity / object contains ALL primary keys entity must have.
       * Returns true if it contains all of them, false if at least one of them is not defined.
       */
      hasAllPrimaryKeys(entity) {
        return this.primaryColumns.every((primaryColumn) => {
          const value = primaryColumn.getEntityValue(entity);
          return value !== null && value !== void 0;
        });
      }
      /**
       * Ensures that given object is an entity id map.
       * If given id is an object then it means its already id map.
       * If given id isn't an object then it means its a value of the id column
       * and it creates a new id map with this value and name of the primary column.
       */
      ensureEntityIdMap(id) {
        if (ObjectUtils_1.ObjectUtils.isObject(id))
          return id;
        if (this.hasMultiplePrimaryKeys)
          throw new CannotCreateEntityIdMapError_1.CannotCreateEntityIdMapError(this, id);
        return this.primaryColumns[0].createValueMap(id);
      }
      /**
       * Gets primary keys of the entity and returns them in a literal object.
       * For example, for Post{ id: 1, title: "hello" } where id is primary it will return { id: 1 }
       * For multiple primary keys it returns multiple keys in object.
       * For primary keys inside embeds it returns complex object literal with keys in them.
       */
      getEntityIdMap(entity) {
        if (!entity)
          return void 0;
        return _EntityMetadata.getValueMap(entity, this.primaryColumns, {
          skipNulls: true
        });
      }
      /**
       * Creates a "mixed id map".
       * If entity has multiple primary keys (ids) then it will return just regular id map, like what getEntityIdMap returns.
       * But if entity has a single primary key then it will return just value of the id column of the entity, just value.
       * This is called mixed id map.
       */
      getEntityIdMixedMap(entity) {
        if (!entity)
          return entity;
        const idMap = this.getEntityIdMap(entity);
        if (this.hasMultiplePrimaryKeys) {
          return idMap;
        } else if (idMap) {
          return this.primaryColumns[0].getEntityValue(idMap);
        }
        return idMap;
      }
      /**
       * Compares two different entities by their ids.
       * Returns true if they match, false otherwise.
       */
      compareEntities(firstEntity, secondEntity) {
        const firstEntityIdMap = this.getEntityIdMap(firstEntity);
        if (!firstEntityIdMap)
          return false;
        const secondEntityIdMap = this.getEntityIdMap(secondEntity);
        if (!secondEntityIdMap)
          return false;
        return OrmUtils_1.OrmUtils.compareIds(firstEntityIdMap, secondEntityIdMap);
      }
      /**
       * Finds column with a given property name.
       */
      findColumnWithPropertyName(propertyName) {
        return this.columns.find((column) => column.propertyName === propertyName);
      }
      /**
       * Finds column with a given database name.
       */
      findColumnWithDatabaseName(databaseName) {
        return this.columns.find((column) => column.databaseName === databaseName);
      }
      /**
       * Checks if there is a column or relationship with a given property path.
       */
      hasColumnWithPropertyPath(propertyPath) {
        const hasColumn = this.columns.some((column) => column.propertyPath === propertyPath);
        return hasColumn || this.hasRelationWithPropertyPath(propertyPath);
      }
      /**
       * Finds column with a given property path.
       */
      findColumnWithPropertyPath(propertyPath) {
        const column = this.columns.find((column2) => column2.propertyPath === propertyPath);
        if (column)
          return column;
        const relation = this.relations.find((relation2) => relation2.propertyPath === propertyPath);
        if (relation && relation.joinColumns.length === 1)
          return relation.joinColumns[0];
        return void 0;
      }
      /**
       * Finds column with a given property path.
       * Does not search in relation unlike findColumnWithPropertyPath.
       */
      findColumnWithPropertyPathStrict(propertyPath) {
        return this.columns.find((column) => column.propertyPath === propertyPath);
      }
      /**
       * Finds columns with a given property path.
       * Property path can match a relation, and relations can contain multiple columns.
       */
      findColumnsWithPropertyPath(propertyPath) {
        const column = this.columns.find((column2) => column2.propertyPath === propertyPath);
        if (column)
          return [column];
        const relation = this.findRelationWithPropertyPath(propertyPath);
        if (relation && relation.joinColumns)
          return relation.joinColumns;
        return [];
      }
      /**
       * Checks if there is a relation with the given property path.
       */
      hasRelationWithPropertyPath(propertyPath) {
        return this.relations.some((relation) => relation.propertyPath === propertyPath);
      }
      /**
       * Finds relation with the given property path.
       */
      findRelationWithPropertyPath(propertyPath) {
        return this.relations.find((relation) => relation.propertyPath === propertyPath);
      }
      /**
       * Checks if there is an embedded with a given property path.
       */
      hasEmbeddedWithPropertyPath(propertyPath) {
        return this.allEmbeddeds.some((embedded) => embedded.propertyPath === propertyPath);
      }
      /**
       * Finds embedded with a given property path.
       */
      findEmbeddedWithPropertyPath(propertyPath) {
        return this.allEmbeddeds.find((embedded) => embedded.propertyPath === propertyPath);
      }
      /**
       * Returns an array of databaseNames mapped from provided propertyPaths
       */
      mapPropertyPathsToColumns(propertyPaths) {
        return propertyPaths.map((propertyPath) => {
          const column = this.findColumnWithPropertyPath(propertyPath);
          if (column == null) {
            throw new EntityPropertyNotFoundError_1.EntityPropertyNotFoundError(propertyPath, this);
          }
          return column;
        });
      }
      /**
       * Iterates through entity and finds and extracts all values from relations in the entity.
       * If relation value is an array its being flattened.
       */
      extractRelationValuesFromEntity(entity, relations) {
        const relationsAndValues = [];
        relations.forEach((relation) => {
          const value = relation.getEntityValue(entity);
          if (Array.isArray(value)) {
            value.forEach((subValue) => relationsAndValues.push([
              relation,
              subValue,
              _EntityMetadata.getInverseEntityMetadata(subValue, relation)
            ]));
          } else if (value) {
            relationsAndValues.push([
              relation,
              value,
              _EntityMetadata.getInverseEntityMetadata(value, relation)
            ]);
          }
        });
        return relationsAndValues;
      }
      /**
       * In the case of SingleTableInheritance, find the correct metadata
       * for a given value.
       *
       * @param value The value to find the metadata for.
       * @returns The found metadata for the entity or the base metadata if no matching metadata
       *          was found in the whole inheritance tree.
       */
      findInheritanceMetadata(value) {
        if (this.inheritancePattern === "STI" && this.childEntityMetadatas.length > 0) {
          let manuallySetDiscriminatorValue;
          if (this.discriminatorColumn) {
            manuallySetDiscriminatorValue = value[this.discriminatorColumn.propertyName];
          }
          return this.childEntityMetadatas.find((meta) => manuallySetDiscriminatorValue === meta.discriminatorValue || value.constructor === meta.target) || this;
        }
        return this;
      }
      // -------------------------------------------------------------------------
      // Private Static Methods
      // -------------------------------------------------------------------------
      static getInverseEntityMetadata(value, relation) {
        return relation.inverseEntityMetadata.findInheritanceMetadata(value);
      }
      // -------------------------------------------------------------------------
      // Public Static Methods
      // -------------------------------------------------------------------------
      /**
       * Creates a property paths for a given entity.
       *
       * @deprecated
       */
      static createPropertyPath(metadata, entity, prefix = "") {
        const paths = [];
        Object.keys(entity).forEach((key) => {
          const parentPath = prefix ? prefix + "." + key : key;
          if (metadata.hasEmbeddedWithPropertyPath(parentPath)) {
            const subPaths = this.createPropertyPath(metadata, entity[key], parentPath);
            paths.push(...subPaths);
          } else {
            const path = prefix ? prefix + "." + key : key;
            paths.push(path);
          }
        });
        return paths;
      }
      /**
       * Finds difference between two entity id maps.
       * Returns items that exist in the first array and absent in the second array.
       */
      static difference(firstIdMaps, secondIdMaps) {
        return firstIdMaps.filter((firstIdMap) => {
          return !secondIdMaps.find((secondIdMap) => OrmUtils_1.OrmUtils.compareIds(firstIdMap, secondIdMap));
        });
      }
      /**
       * Creates value map from the given values and columns.
       * Examples of usages are primary columns map and join columns map.
       */
      static getValueMap(entity, columns, options) {
        return columns.reduce((map, column) => {
          const value = column.getEntityValueMap(entity, options);
          if (map === void 0 || value === null || value === void 0)
            return void 0;
          return OrmUtils_1.OrmUtils.mergeDeep(map, value);
        }, {});
      }
      // ---------------------------------------------------------------------
      // Public Builder Methods
      // ---------------------------------------------------------------------
      build() {
        const namingStrategy = this.connection.namingStrategy;
        const entityPrefix = this.connection.options.entityPrefix;
        const entitySkipConstructor = this.connection.options.entitySkipConstructor;
        this.engine = this.tableMetadataArgs.engine;
        this.database = this.tableMetadataArgs.type === "entity-child" && this.parentEntityMetadata ? this.parentEntityMetadata.database : this.tableMetadataArgs.database;
        if (this.tableMetadataArgs.schema) {
          this.schema = this.tableMetadataArgs.schema;
        } else if (this.tableMetadataArgs.type === "entity-child" && this.parentEntityMetadata) {
          this.schema = this.parentEntityMetadata.schema;
        } else if (this.connection.options?.hasOwnProperty("schema")) {
          this.schema = this.connection.options.schema;
        }
        this.givenTableName = this.tableMetadataArgs.type === "entity-child" && this.parentEntityMetadata ? this.parentEntityMetadata.givenTableName : this.tableMetadataArgs.name;
        this.synchronize = this.tableMetadataArgs.synchronize === false ? false : true;
        this.targetName = typeof this.tableMetadataArgs.target === "function" ? this.tableMetadataArgs.target.name : this.tableMetadataArgs.target;
        if (this.tableMetadataArgs.type === "closure-junction") {
          this.tableNameWithoutPrefix = namingStrategy.closureJunctionTableName(this.givenTableName);
        } else if (this.tableMetadataArgs.type === "entity-child" && this.parentEntityMetadata) {
          this.tableNameWithoutPrefix = namingStrategy.tableName(this.parentEntityMetadata.targetName, this.parentEntityMetadata.givenTableName);
        } else {
          this.tableNameWithoutPrefix = namingStrategy.tableName(this.targetName, this.givenTableName);
          if (this.tableMetadataArgs.type === "junction" && this.connection.driver.maxAliasLength && this.connection.driver.maxAliasLength > 0 && this.tableNameWithoutPrefix.length > this.connection.driver.maxAliasLength) {
            this.tableNameWithoutPrefix = (0, StringUtils_1.shorten)(this.tableNameWithoutPrefix, { separator: "_", segmentLength: 3 });
          }
        }
        this.tableName = entityPrefix ? namingStrategy.prefixTableName(entityPrefix, this.tableNameWithoutPrefix) : this.tableNameWithoutPrefix;
        this.target = this.target ? this.target : this.tableName;
        this.name = this.targetName ? this.targetName : this.tableName;
        this.expression = this.tableMetadataArgs.expression;
        this.withoutRowid = this.tableMetadataArgs.withoutRowid === true ? true : false;
        this.tablePath = this.connection.driver.buildTableName(this.tableName, this.schema, this.database);
        this.orderBy = typeof this.tableMetadataArgs.orderBy === "function" ? this.tableMetadataArgs.orderBy(this.propertiesMap) : this.tableMetadataArgs.orderBy;
        if (entitySkipConstructor !== void 0) {
          this.isAlwaysUsingConstructor = !entitySkipConstructor;
        }
        this.isJunction = this.tableMetadataArgs.type === "closure-junction" || this.tableMetadataArgs.type === "junction";
        this.isClosureJunction = this.tableMetadataArgs.type === "closure-junction";
        this.comment = this.tableMetadataArgs.comment;
      }
      /**
       * Registers a new column in the entity and recomputes all depend properties.
       */
      registerColumn(column) {
        if (this.ownColumns.indexOf(column) !== -1)
          return;
        this.ownColumns.push(column);
        this.columns = this.embeddeds.reduce((columns, embedded) => columns.concat(embedded.columnsFromTree), this.ownColumns);
        this.primaryColumns = this.columns.filter((column2) => column2.isPrimary);
        this.hasMultiplePrimaryKeys = this.primaryColumns.length > 1;
        this.hasUUIDGeneratedColumns = this.columns.filter((column2) => column2.isGenerated || column2.generationStrategy === "uuid").length > 0;
        this.propertiesMap = this.createPropertiesMap();
        if (this.childEntityMetadatas)
          this.childEntityMetadatas.forEach((entityMetadata) => entityMetadata.registerColumn(column));
      }
      /**
       * Creates a special object - all columns and relations of the object (plus columns and relations from embeds)
       * in a special format - { propertyName: propertyName }.
       *
       * example: Post{ id: number, name: string, counterEmbed: { count: number }, category: Category }.
       * This method will create following object:
       * { id: "id", counterEmbed: { count: "counterEmbed.count" }, category: "category" }
       */
      createPropertiesMap() {
        const map = {};
        this.columns.forEach((column) => OrmUtils_1.OrmUtils.mergeDeep(map, column.createValueMap(column.propertyPath)));
        this.relations.forEach((relation) => OrmUtils_1.OrmUtils.mergeDeep(map, relation.createValueMap(relation.propertyPath)));
        return map;
      }
      /**
       * Checks if entity has any column which rely on returning data,
       * e.g. columns with auto generated value, DEFAULT values considered as dependant of returning data.
       * For example, if we need to have RETURNING after INSERT (or we need returned id for DBs not supporting RETURNING),
       * it means we cannot execute bulk inserts in some cases.
       */
      getInsertionReturningColumns() {
        return this.columns.filter((column) => {
          return column.default !== void 0 || column.asExpression !== void 0 || column.isGenerated || column.isCreateDate || column.isUpdateDate || column.isDeleteDate || column.isVersion;
        });
      }
    };
    exports2.EntityMetadata = EntityMetadata2;
  }
});

// node_modules/typeorm/persistence/tree/MaterializedPathSubjectExecutor.js
var require_MaterializedPathSubjectExecutor = __commonJS({
  "node_modules/typeorm/persistence/tree/MaterializedPathSubjectExecutor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MaterializedPathSubjectExecutor = void 0;
    var OrmUtils_1 = require_OrmUtils();
    var EntityMetadata_1 = require_EntityMetadata();
    var Brackets_1 = require_Brackets();
    var MaterializedPathSubjectExecutor = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(queryRunner) {
        this.queryRunner = queryRunner;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Executes operations when subject is being inserted.
       */
      async insert(subject) {
        let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity);
        if (!parent && subject.parentSubject && subject.parentSubject.entity)
          parent = subject.parentSubject.insertedValueSet ? subject.parentSubject.insertedValueSet : subject.parentSubject.entity;
        const parentId = subject.metadata.getEntityIdMap(parent);
        let parentPath = "";
        if (parentId) {
          parentPath = await this.getEntityPath(subject, parentId);
        }
        const insertedEntityId = subject.metadata.treeParentRelation.joinColumns.map((joinColumn) => {
          return joinColumn.referencedColumn.getEntityValue(subject.insertedValueSet);
        }).join("_");
        await this.queryRunner.manager.createQueryBuilder().update(subject.metadata.target).set({
          [subject.metadata.materializedPathColumn.propertyPath]: parentPath + insertedEntityId + "."
        }).where(subject.identifier).execute();
      }
      /**
       * Executes operations when subject is being updated.
       */
      async update(subject) {
        let newParent = subject.metadata.treeParentRelation.getEntityValue(subject.entity);
        if (!newParent && subject.parentSubject && subject.parentSubject.entity)
          newParent = subject.parentSubject.entity;
        let entity = subject.databaseEntity;
        if (!entity && newParent)
          entity = subject.metadata.treeChildrenRelation.getEntityValue(newParent).find((child) => {
            return Object.entries(subject.identifier).every(([key, value]) => child[key] === value);
          });
        const oldParent = subject.metadata.treeParentRelation.getEntityValue(entity);
        const oldParentId = this.getEntityParentReferencedColumnMap(subject, oldParent);
        const newParentId = this.getEntityParentReferencedColumnMap(subject, newParent);
        if (OrmUtils_1.OrmUtils.compareIds(oldParentId, newParentId)) {
          return;
        }
        let newParentPath = "";
        if (newParentId) {
          newParentPath = await this.getEntityPath(subject, newParentId);
        }
        let oldParentPath = "";
        if (oldParentId) {
          oldParentPath = await this.getEntityPath(subject, oldParentId) || "";
        }
        const entityPath = subject.metadata.treeParentRelation.joinColumns.map((joinColumn) => {
          return joinColumn.referencedColumn.getEntityValue(entity);
        }).join("_");
        const propertyPath = subject.metadata.materializedPathColumn.propertyPath;
        await this.queryRunner.manager.createQueryBuilder().update(subject.metadata.target).set({
          [propertyPath]: () => `REPLACE(${this.queryRunner.connection.driver.escape(propertyPath)}, '${oldParentPath}${entityPath}.', '${newParentPath}${entityPath}.')`
        }).where(`${propertyPath} LIKE :path`, {
          path: `${oldParentPath}${entityPath}.%`
        }).execute();
      }
      getEntityParentReferencedColumnMap(subject, entity) {
        if (!entity)
          return void 0;
        return EntityMetadata_1.EntityMetadata.getValueMap(entity, subject.metadata.treeParentRelation.joinColumns.map((column) => column.referencedColumn).filter((v) => v != null), { skipNulls: true });
      }
      getEntityPath(subject, id) {
        const metadata = subject.metadata;
        const normalized = (Array.isArray(id) ? id : [id]).map((id2) => metadata.ensureEntityIdMap(id2));
        return this.queryRunner.manager.createQueryBuilder().select(subject.metadata.targetName + "." + subject.metadata.materializedPathColumn.propertyPath, "path").from(subject.metadata.target, subject.metadata.targetName).where(new Brackets_1.Brackets((qb) => {
          for (const data of normalized) {
            qb.orWhere(new Brackets_1.Brackets((qb2) => qb2.where(data)));
          }
        })).getRawOne().then((result) => result ? result["path"] : "");
      }
    };
    exports2.MaterializedPathSubjectExecutor = MaterializedPathSubjectExecutor;
  }
});

// node_modules/typeorm/persistence/SubjectExecutor.js
var require_SubjectExecutor = __commonJS({
  "node_modules/typeorm/persistence/SubjectExecutor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SubjectExecutor = void 0;
    var SubjectTopologicalSorter_1 = require_SubjectTopologicalSorter();
    var SubjectChangedColumnsComputer_1 = require_SubjectChangedColumnsComputer();
    var SubjectWithoutIdentifierError_1 = require_SubjectWithoutIdentifierError();
    var SubjectRemovedAndUpdatedError_1 = require_SubjectRemovedAndUpdatedError();
    var BroadcasterResult_1 = require_BroadcasterResult();
    var NestedSetSubjectExecutor_1 = require_NestedSetSubjectExecutor();
    var ClosureSubjectExecutor_1 = require_ClosureSubjectExecutor();
    var MaterializedPathSubjectExecutor_1 = require_MaterializedPathSubjectExecutor();
    var OrmUtils_1 = require_OrmUtils();
    var ObjectUtils_1 = require_ObjectUtils();
    var InstanceChecker_1 = require_InstanceChecker();
    var SubjectExecutor = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(queryRunner, subjects, options) {
        this.hasExecutableOperations = false;
        this.insertSubjects = [];
        this.updateSubjects = [];
        this.removeSubjects = [];
        this.softRemoveSubjects = [];
        this.recoverSubjects = [];
        this.queryRunner = queryRunner;
        this.allSubjects = subjects;
        this.options = options;
        this.validate();
        this.recompute();
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Executes all operations over given array of subjects.
       * Executes queries using given query runner.
       */
      async execute() {
        let broadcasterResult = void 0;
        if (!this.options || this.options.listeners !== false) {
          broadcasterResult = this.broadcastBeforeEventsForAll();
          if (broadcasterResult.promises.length > 0)
            await Promise.all(broadcasterResult.promises);
        }
        if (broadcasterResult && broadcasterResult.count > 0) {
          this.insertSubjects.forEach((subject) => subject.recompute());
          this.updateSubjects.forEach((subject) => subject.recompute());
          this.removeSubjects.forEach((subject) => subject.recompute());
          this.softRemoveSubjects.forEach((subject) => subject.recompute());
          this.recoverSubjects.forEach((subject) => subject.recompute());
          this.recompute();
        }
        this.insertSubjects = new SubjectTopologicalSorter_1.SubjectTopologicalSorter(this.insertSubjects).sort("insert");
        await this.executeInsertOperations();
        this.updateSubjects = this.allSubjects.filter((subject) => subject.mustBeUpdated);
        await this.executeUpdateOperations();
        this.removeSubjects = new SubjectTopologicalSorter_1.SubjectTopologicalSorter(this.removeSubjects).sort("delete");
        await this.executeRemoveOperations();
        this.softRemoveSubjects = this.allSubjects.filter((subject) => subject.mustBeSoftRemoved);
        await this.executeSoftRemoveOperations();
        this.recoverSubjects = this.allSubjects.filter((subject) => subject.mustBeRecovered);
        await this.executeRecoverOperations();
        this.updateSpecialColumnsInPersistedEntities();
        if (!this.options || this.options.listeners !== false) {
          broadcasterResult = this.broadcastAfterEventsForAll();
          if (broadcasterResult.promises.length > 0)
            await Promise.all(broadcasterResult.promises);
        }
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Validates all given subjects.
       */
      validate() {
        this.allSubjects.forEach((subject) => {
          if (subject.mustBeUpdated && subject.mustBeRemoved)
            throw new SubjectRemovedAndUpdatedError_1.SubjectRemovedAndUpdatedError(subject);
        });
      }
      /**
       * Performs entity re-computations - finds changed columns, re-builds insert/update/remove subjects.
       */
      recompute() {
        new SubjectChangedColumnsComputer_1.SubjectChangedColumnsComputer().compute(this.allSubjects);
        this.insertSubjects = this.allSubjects.filter((subject) => subject.mustBeInserted);
        this.updateSubjects = this.allSubjects.filter((subject) => subject.mustBeUpdated);
        this.removeSubjects = this.allSubjects.filter((subject) => subject.mustBeRemoved);
        this.softRemoveSubjects = this.allSubjects.filter((subject) => subject.mustBeSoftRemoved);
        this.recoverSubjects = this.allSubjects.filter((subject) => subject.mustBeRecovered);
        this.hasExecutableOperations = this.insertSubjects.length > 0 || this.updateSubjects.length > 0 || this.removeSubjects.length > 0 || this.softRemoveSubjects.length > 0 || this.recoverSubjects.length > 0;
      }
      /**
       * Broadcasts "BEFORE_INSERT", "BEFORE_UPDATE", "BEFORE_REMOVE", "BEFORE_SOFT_REMOVE", "BEFORE_RECOVER" events for all given subjects.
       */
      broadcastBeforeEventsForAll() {
        const result = new BroadcasterResult_1.BroadcasterResult();
        if (this.insertSubjects.length)
          this.insertSubjects.forEach((subject) => this.queryRunner.broadcaster.broadcastBeforeInsertEvent(result, subject.metadata, subject.entity));
        if (this.updateSubjects.length)
          this.updateSubjects.forEach((subject) => this.queryRunner.broadcaster.broadcastBeforeUpdateEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.diffColumns, subject.diffRelations));
        if (this.removeSubjects.length)
          this.removeSubjects.forEach((subject) => this.queryRunner.broadcaster.broadcastBeforeRemoveEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));
        if (this.softRemoveSubjects.length)
          this.softRemoveSubjects.forEach((subject) => this.queryRunner.broadcaster.broadcastBeforeSoftRemoveEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));
        if (this.recoverSubjects.length)
          this.recoverSubjects.forEach((subject) => this.queryRunner.broadcaster.broadcastBeforeRecoverEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));
        return result;
      }
      /**
       * Broadcasts "AFTER_INSERT", "AFTER_UPDATE", "AFTER_REMOVE", "AFTER_SOFT_REMOVE", "AFTER_RECOVER" events for all given subjects.
       * Returns void if there wasn't any listener or subscriber executed.
       * Note: this method has a performance-optimized code organization.
       */
      broadcastAfterEventsForAll() {
        const result = new BroadcasterResult_1.BroadcasterResult();
        if (this.insertSubjects.length)
          this.insertSubjects.forEach((subject) => this.queryRunner.broadcaster.broadcastAfterInsertEvent(result, subject.metadata, subject.entity, subject.identifier));
        if (this.updateSubjects.length)
          this.updateSubjects.forEach((subject) => this.queryRunner.broadcaster.broadcastAfterUpdateEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.diffColumns, subject.diffRelations));
        if (this.removeSubjects.length)
          this.removeSubjects.forEach((subject) => this.queryRunner.broadcaster.broadcastAfterRemoveEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));
        if (this.softRemoveSubjects.length)
          this.softRemoveSubjects.forEach((subject) => this.queryRunner.broadcaster.broadcastAfterSoftRemoveEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));
        if (this.recoverSubjects.length)
          this.recoverSubjects.forEach((subject) => this.queryRunner.broadcaster.broadcastAfterRecoverEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));
        return result;
      }
      /**
       * Executes insert operations.
       */
      async executeInsertOperations() {
        const [groupedInsertSubjects, groupedInsertSubjectKeys] = this.groupBulkSubjects(this.insertSubjects, "insert");
        for (const groupName of groupedInsertSubjectKeys) {
          const subjects = groupedInsertSubjects[groupName];
          const bulkInsertMaps = [];
          const bulkInsertSubjects = [];
          const singleInsertSubjects = [];
          if (this.queryRunner.connection.driver.options.type === "mongodb") {
            subjects.forEach((subject) => {
              if (subject.metadata.createDateColumn && subject.entity) {
                subject.entity[subject.metadata.createDateColumn.databaseName] = /* @__PURE__ */ new Date();
              }
              if (subject.metadata.updateDateColumn && subject.entity) {
                subject.entity[subject.metadata.updateDateColumn.databaseName] = /* @__PURE__ */ new Date();
              }
              subject.createValueSetAndPopChangeMap();
              bulkInsertSubjects.push(subject);
              bulkInsertMaps.push(subject.entity);
            });
          } else if (this.queryRunner.connection.driver.options.type === "oracle") {
            subjects.forEach((subject) => {
              singleInsertSubjects.push(subject);
            });
          } else {
            subjects.forEach((subject) => {
              if (subject.changeMaps.length === 0 || subject.metadata.treeType || this.queryRunner.connection.driver.options.type === "oracle" || this.queryRunner.connection.driver.options.type === "sap") {
                singleInsertSubjects.push(subject);
              } else {
                bulkInsertSubjects.push(subject);
                bulkInsertMaps.push(subject.createValueSetAndPopChangeMap());
              }
            });
          }
          if (InstanceChecker_1.InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {
            const insertResult = await this.queryRunner.manager.insert(subjects[0].metadata.target, bulkInsertMaps);
            subjects.forEach((subject, index) => {
              subject.identifier = insertResult.identifiers[index];
              subject.generatedMap = insertResult.generatedMaps[index];
              subject.insertedValueSet = bulkInsertMaps[index];
            });
          } else {
            if (bulkInsertMaps.length > 0) {
              const insertResult = await this.queryRunner.manager.createQueryBuilder().insert().into(subjects[0].metadata.target).values(bulkInsertMaps).updateEntity(this.options && this.options.reload === false ? false : true).callListeners(false).execute();
              bulkInsertSubjects.forEach((subject, index) => {
                subject.identifier = insertResult.identifiers[index];
                subject.generatedMap = insertResult.generatedMaps[index];
                subject.insertedValueSet = bulkInsertMaps[index];
              });
            }
            if (singleInsertSubjects.length > 0) {
              for (const subject of singleInsertSubjects) {
                subject.insertedValueSet = subject.createValueSetAndPopChangeMap();
                if (subject.metadata.treeType === "nested-set")
                  await new NestedSetSubjectExecutor_1.NestedSetSubjectExecutor(this.queryRunner).insert(subject);
                await this.queryRunner.manager.createQueryBuilder().insert().into(subject.metadata.target).values(subject.insertedValueSet).updateEntity(this.options && this.options.reload === false ? false : true).callListeners(false).execute().then((insertResult) => {
                  subject.identifier = insertResult.identifiers[0];
                  subject.generatedMap = insertResult.generatedMaps[0];
                });
                if (subject.metadata.treeType === "closure-table") {
                  await new ClosureSubjectExecutor_1.ClosureSubjectExecutor(this.queryRunner).insert(subject);
                } else if (subject.metadata.treeType === "materialized-path") {
                  await new MaterializedPathSubjectExecutor_1.MaterializedPathSubjectExecutor(this.queryRunner).insert(subject);
                }
              }
            }
          }
          subjects.forEach((subject) => {
            if (subject.generatedMap) {
              subject.metadata.columns.forEach((column) => {
                const value = column.getEntityValue(subject.generatedMap);
                if (value !== void 0 && value !== null) {
                  const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);
                  column.setEntityValue(subject.generatedMap, preparedValue);
                }
              });
            }
          });
        }
      }
      /**
       * Updates all given subjects in the database.
       */
      async executeUpdateOperations() {
        const updateSubject = async (subject) => {
          if (!subject.identifier)
            throw new SubjectWithoutIdentifierError_1.SubjectWithoutIdentifierError(subject);
          if (InstanceChecker_1.InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {
            const partialEntity = this.cloneMongoSubjectEntity(subject);
            if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.propertyName) {
              delete partialEntity[subject.metadata.objectIdColumn.propertyName];
            }
            if (subject.metadata.createDateColumn && subject.metadata.createDateColumn.propertyName) {
              delete partialEntity[subject.metadata.createDateColumn.propertyName];
            }
            if (subject.metadata.updateDateColumn && subject.metadata.updateDateColumn.propertyName) {
              partialEntity[subject.metadata.updateDateColumn.propertyName] = /* @__PURE__ */ new Date();
            }
            const manager = this.queryRunner.manager;
            await manager.update(subject.metadata.target, subject.identifier, partialEntity);
          } else {
            const updateMap = subject.createValueSetAndPopChangeMap();
            switch (subject.metadata.treeType) {
              case "nested-set":
                await new NestedSetSubjectExecutor_1.NestedSetSubjectExecutor(this.queryRunner).update(subject);
                break;
              case "closure-table":
                await new ClosureSubjectExecutor_1.ClosureSubjectExecutor(this.queryRunner).update(subject);
                break;
              case "materialized-path":
                await new MaterializedPathSubjectExecutor_1.MaterializedPathSubjectExecutor(this.queryRunner).update(subject);
                break;
            }
            const updateQueryBuilder = this.queryRunner.manager.createQueryBuilder().update(subject.metadata.target).set(updateMap).updateEntity(this.options && this.options.reload === false ? false : true).callListeners(false);
            if (subject.entity) {
              updateQueryBuilder.whereEntity(subject.identifier);
            } else {
              updateQueryBuilder.where(subject.identifier);
            }
            const updateResult = await updateQueryBuilder.execute();
            const updateGeneratedMap = updateResult.generatedMaps[0];
            if (updateGeneratedMap) {
              subject.metadata.columns.forEach((column) => {
                const value = column.getEntityValue(updateGeneratedMap);
                if (value !== void 0 && value !== null) {
                  const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);
                  column.setEntityValue(updateGeneratedMap, preparedValue);
                }
              });
              if (!subject.generatedMap) {
                subject.generatedMap = {};
              }
              Object.assign(subject.generatedMap, updateGeneratedMap);
            }
          }
        };
        const nestedSetSubjects = [];
        const remainingSubjects = [];
        for (const subject of this.updateSubjects) {
          if (subject.metadata.treeType === "nested-set") {
            nestedSetSubjects.push(subject);
          } else {
            remainingSubjects.push(subject);
          }
        }
        const updateNestSetSubjects = async () => {
          for (const subject of nestedSetSubjects) {
            await updateSubject(subject);
          }
        };
        await Promise.all([
          ...remainingSubjects.map(updateSubject),
          updateNestSetSubjects()
        ]);
      }
      /**
       * Removes all given subjects from the database.
       *
       * todo: we need to apply topological sort here as well
       */
      async executeRemoveOperations() {
        const [groupedRemoveSubjects, groupedRemoveSubjectKeys] = this.groupBulkSubjects(this.removeSubjects, "delete");
        for (const groupName of groupedRemoveSubjectKeys) {
          const subjects = groupedRemoveSubjects[groupName];
          const deleteMaps = subjects.map((subject) => {
            if (!subject.identifier)
              throw new SubjectWithoutIdentifierError_1.SubjectWithoutIdentifierError(subject);
            return subject.identifier;
          });
          if (InstanceChecker_1.InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {
            const manager = this.queryRunner.manager;
            await manager.delete(subjects[0].metadata.target, deleteMaps);
          } else {
            switch (subjects[0].metadata.treeType) {
              case "nested-set":
                await new NestedSetSubjectExecutor_1.NestedSetSubjectExecutor(this.queryRunner).remove(subjects);
                break;
              case "closure-table":
                await new ClosureSubjectExecutor_1.ClosureSubjectExecutor(this.queryRunner).remove(subjects);
                break;
            }
            await this.queryRunner.manager.createQueryBuilder().delete().from(subjects[0].metadata.target).where(deleteMaps).callListeners(false).execute();
          }
        }
      }
      cloneMongoSubjectEntity(subject) {
        const target = {};
        if (subject.entity) {
          for (const column of subject.metadata.columns) {
            OrmUtils_1.OrmUtils.mergeDeep(target, column.getEntityValueMap(subject.entity));
          }
        }
        return target;
      }
      /**
       * Soft-removes all given subjects in the database.
       */
      async executeSoftRemoveOperations() {
        await Promise.all(this.softRemoveSubjects.map(async (subject) => {
          if (!subject.identifier)
            throw new SubjectWithoutIdentifierError_1.SubjectWithoutIdentifierError(subject);
          let updateResult;
          if (InstanceChecker_1.InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {
            const partialEntity = this.cloneMongoSubjectEntity(subject);
            if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.propertyName) {
              delete partialEntity[subject.metadata.objectIdColumn.propertyName];
            }
            if (subject.metadata.createDateColumn && subject.metadata.createDateColumn.propertyName) {
              delete partialEntity[subject.metadata.createDateColumn.propertyName];
            }
            if (subject.metadata.updateDateColumn && subject.metadata.updateDateColumn.propertyName) {
              partialEntity[subject.metadata.updateDateColumn.propertyName] = /* @__PURE__ */ new Date();
            }
            if (subject.metadata.deleteDateColumn && subject.metadata.deleteDateColumn.propertyName) {
              partialEntity[subject.metadata.deleteDateColumn.propertyName] = /* @__PURE__ */ new Date();
            }
            const manager = this.queryRunner.manager;
            updateResult = await manager.update(subject.metadata.target, subject.identifier, partialEntity);
          } else {
            const softDeleteQueryBuilder = this.queryRunner.manager.createQueryBuilder().softDelete().from(subject.metadata.target).updateEntity(this.options && this.options.reload === false ? false : true).callListeners(false);
            if (subject.entity) {
              softDeleteQueryBuilder.whereEntity(subject.identifier);
            } else {
              softDeleteQueryBuilder.where(subject.identifier);
            }
            updateResult = await softDeleteQueryBuilder.execute();
          }
          subject.generatedMap = updateResult.generatedMaps[0];
          if (subject.generatedMap) {
            subject.metadata.columns.forEach((column) => {
              const value = column.getEntityValue(subject.generatedMap);
              if (value !== void 0 && value !== null) {
                const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);
                column.setEntityValue(subject.generatedMap, preparedValue);
              }
            });
          }
        }));
      }
      /**
       * Recovers all given subjects in the database.
       */
      async executeRecoverOperations() {
        await Promise.all(this.recoverSubjects.map(async (subject) => {
          if (!subject.identifier)
            throw new SubjectWithoutIdentifierError_1.SubjectWithoutIdentifierError(subject);
          let updateResult;
          if (InstanceChecker_1.InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {
            const partialEntity = this.cloneMongoSubjectEntity(subject);
            if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.propertyName) {
              delete partialEntity[subject.metadata.objectIdColumn.propertyName];
            }
            if (subject.metadata.createDateColumn && subject.metadata.createDateColumn.propertyName) {
              delete partialEntity[subject.metadata.createDateColumn.propertyName];
            }
            if (subject.metadata.updateDateColumn && subject.metadata.updateDateColumn.propertyName) {
              partialEntity[subject.metadata.updateDateColumn.propertyName] = /* @__PURE__ */ new Date();
            }
            if (subject.metadata.deleteDateColumn && subject.metadata.deleteDateColumn.propertyName) {
              partialEntity[subject.metadata.deleteDateColumn.propertyName] = null;
            }
            const manager = this.queryRunner.manager;
            updateResult = await manager.update(subject.metadata.target, subject.identifier, partialEntity);
          } else {
            const softDeleteQueryBuilder = this.queryRunner.manager.createQueryBuilder().restore().from(subject.metadata.target).updateEntity(this.options && this.options.reload === false ? false : true).callListeners(false);
            if (subject.entity) {
              softDeleteQueryBuilder.whereEntity(subject.identifier);
            } else {
              softDeleteQueryBuilder.where(subject.identifier);
            }
            updateResult = await softDeleteQueryBuilder.execute();
          }
          subject.generatedMap = updateResult.generatedMaps[0];
          if (subject.generatedMap) {
            subject.metadata.columns.forEach((column) => {
              const value = column.getEntityValue(subject.generatedMap);
              if (value !== void 0 && value !== null) {
                const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);
                column.setEntityValue(subject.generatedMap, preparedValue);
              }
            });
          }
        }));
      }
      /**
       * Updates all special columns of the saving entities (create date, update date, version, etc.).
       * Also updates nullable columns and columns with default values.
       */
      updateSpecialColumnsInPersistedEntities() {
        if (this.insertSubjects.length)
          this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.insertSubjects);
        if (this.updateSubjects.length)
          this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.updateSubjects);
        if (this.softRemoveSubjects.length)
          this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.softRemoveSubjects);
        if (this.recoverSubjects.length)
          this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.recoverSubjects);
        if (this.removeSubjects.length) {
          this.removeSubjects.forEach((subject) => {
            if (!subject.entity)
              return;
            subject.metadata.primaryColumns.forEach((primaryColumn) => {
              primaryColumn.setEntityValue(subject.entity, void 0);
            });
          });
        }
        this.allSubjects.forEach((subject) => {
          if (!subject.entity)
            return;
          subject.metadata.relationIds.forEach((relationId) => {
            relationId.setValue(subject.entity);
          });
          if (InstanceChecker_1.InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {
            if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.databaseName && subject.metadata.objectIdColumn.databaseName !== subject.metadata.objectIdColumn.propertyName) {
              delete subject.entity[subject.metadata.objectIdColumn.databaseName];
            }
          }
        });
      }
      /**
       * Updates all special columns of the saving entities (create date, update date, version, etc.).
       * Also updates nullable columns and columns with default values.
       */
      updateSpecialColumnsInInsertedAndUpdatedEntities(subjects) {
        subjects.forEach((subject) => {
          if (!subject.entity)
            return;
          subject.metadata.columns.forEach((column) => {
            if (subject.metadata.childEntityMetadatas.length > 0 && subject.metadata.childEntityMetadatas.map((metadata) => metadata.target).indexOf(column.target) !== -1)
              return;
            if (column.isVirtual)
              return;
            if (column.isDeleteDate)
              return;
            if (column.isNullable) {
              const columnValue = column.getEntityValue(subject.entity);
              if (columnValue === void 0)
                column.setEntityValue(subject.entity, null);
            }
            if (subject.updatedRelationMaps.length > 0) {
              subject.updatedRelationMaps.forEach((updatedRelationMap) => {
                updatedRelationMap.relation.joinColumns.forEach((column2) => {
                  if (column2.isVirtual === true)
                    return;
                  column2.setEntityValue(subject.entity, ObjectUtils_1.ObjectUtils.isObject(updatedRelationMap.value) ? column2.referencedColumn.getEntityValue(updatedRelationMap.value) : updatedRelationMap.value);
                });
              });
            }
          });
          if (subject.generatedMap)
            this.queryRunner.manager.merge(subject.metadata.target, subject.entity, subject.generatedMap);
        });
      }
      /**
       * Groups subjects by metadata names (by tables) to make bulk insertions and deletions possible.
       * However there are some limitations with bulk insertions of data into tables with generated (increment) columns
       * in some drivers. Some drivers like mysql and sqlite does not support returning multiple generated columns
       * after insertion and can only return a single generated column value, that's why its not possible to do bulk insertion,
       * because it breaks insertion result's generatedMap and leads to problems when this subject is used in other subjects saves.
       * That's why we only support bulking in junction tables for those drivers.
       *
       * Other drivers like postgres and sql server support RETURNING / OUTPUT statement which allows to return generated
       * id for each inserted row, that's why bulk insertion is not limited to junction tables in there.
       */
      groupBulkSubjects(subjects, type) {
        const group = {};
        const keys = [];
        const hasReturningDependColumns = subjects.some((subject) => {
          return subject.metadata.getInsertionReturningColumns().length > 0;
        });
        const groupingAllowed = type === "delete" || this.queryRunner.connection.driver.isReturningSqlSupported("insert") || hasReturningDependColumns === false;
        subjects.forEach((subject, index) => {
          const key = groupingAllowed || subject.metadata.isJunction ? subject.metadata.name : subject.metadata.name + "_" + index;
          if (!group[key]) {
            group[key] = [subject];
            keys.push(key);
          } else {
            group[key].push(subject);
          }
        });
        return [group, keys];
      }
    };
    exports2.SubjectExecutor = SubjectExecutor;
  }
});

// node_modules/typeorm/persistence/Subject.js
var require_Subject = __commonJS({
  "node_modules/typeorm/persistence/Subject.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Subject = void 0;
    var OrmUtils_1 = require_OrmUtils();
    var ObjectUtils_1 = require_ObjectUtils();
    var InstanceChecker_1 = require_InstanceChecker();
    var Subject = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(options) {
        this["@instanceof"] = Symbol.for("Subject");
        this.identifier = void 0;
        this.entityWithFulfilledIds = void 0;
        this.databaseEntityLoaded = false;
        this.changeMaps = [];
        this.canBeInserted = false;
        this.canBeUpdated = false;
        this.mustBeRemoved = false;
        this.canBeSoftRemoved = false;
        this.canBeRecovered = false;
        this.updatedRelationMaps = [];
        this.diffColumns = [];
        this.diffRelations = [];
        this.metadata = options.metadata;
        this.entity = options.entity;
        this.parentSubject = options.parentSubject;
        if (options.canBeInserted !== void 0)
          this.canBeInserted = options.canBeInserted;
        if (options.canBeUpdated !== void 0)
          this.canBeUpdated = options.canBeUpdated;
        if (options.mustBeRemoved !== void 0)
          this.mustBeRemoved = options.mustBeRemoved;
        if (options.canBeSoftRemoved !== void 0)
          this.canBeSoftRemoved = options.canBeSoftRemoved;
        if (options.canBeRecovered !== void 0)
          this.canBeRecovered = options.canBeRecovered;
        if (options.identifier !== void 0)
          this.identifier = options.identifier;
        if (options.changeMaps !== void 0)
          this.changeMaps.push(...options.changeMaps);
        this.recompute();
      }
      // -------------------------------------------------------------------------
      // Accessors
      // -------------------------------------------------------------------------
      /**
       * Checks if this subject must be inserted into the database.
       * Subject can be inserted into the database if it is allowed to be inserted (explicitly persisted or by cascades)
       * and if it does not have database entity set.
       */
      get mustBeInserted() {
        return this.canBeInserted && !this.databaseEntity;
      }
      /**
       * Checks if this subject must be updated into the database.
       * Subject can be updated in the database if it is allowed to be updated (explicitly persisted or by cascades)
       * and if it does have differentiated columns or relations.
       */
      get mustBeUpdated() {
        return this.canBeUpdated && this.identifier && (this.databaseEntityLoaded === false || this.databaseEntityLoaded && this.databaseEntity) && // ((this.entity && this.databaseEntity) || (!this.entity && !this.databaseEntity)) &&
        // ensure there are one or more changes for updatable columns
        this.changeMaps.some((change) => !change.column || change.column.isUpdate);
      }
      /**
       * Checks if this subject must be soft-removed into the database.
       * Subject can be updated in the database if it is allowed to be soft-removed (explicitly persisted or by cascades)
       * and if it does have differentiated columns or relations.
       */
      get mustBeSoftRemoved() {
        return this.canBeSoftRemoved && this.identifier && (this.databaseEntityLoaded === false || this.databaseEntityLoaded && this.databaseEntity);
      }
      /**
       * Checks if this subject must be recovered into the database.
       * Subject can be updated in the database if it is allowed to be recovered (explicitly persisted or by cascades)
       * and if it does have differentiated columns or relations.
       */
      get mustBeRecovered() {
        return this.canBeRecovered && this.identifier && (this.databaseEntityLoaded === false || this.databaseEntityLoaded && this.databaseEntity);
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Creates a value set needs to be inserted / updated in the database.
       * Value set is based on the entity and change maps of the subject.
       * Important note: this method pops data from this subject's change maps.
       */
      createValueSetAndPopChangeMap() {
        const changeMapsWithoutValues = [];
        const changeSet = this.changeMaps.reduce((updateMap, changeMap) => {
          let value = changeMap.value;
          if (InstanceChecker_1.InstanceChecker.isSubject(value)) {
            value = value.insertedValueSet ? value.insertedValueSet : value.entity;
          }
          let valueMap;
          if (this.metadata.isJunction && changeMap.column) {
            valueMap = changeMap.column.createValueMap(changeMap.column.referencedColumn.getEntityValue(value));
          } else if (changeMap.column) {
            valueMap = changeMap.column.createValueMap(value);
          } else if (changeMap.relation) {
            if (ObjectUtils_1.ObjectUtils.isObject(value) && !Buffer.isBuffer(value)) {
              const relationId = changeMap.relation.getRelationIdMap(value);
              if (relationId === void 0) {
                changeMapsWithoutValues.push(changeMap);
                this.canBeUpdated = true;
                return updateMap;
              }
              valueMap = changeMap.relation.createValueMap(relationId);
              this.updatedRelationMaps.push({
                relation: changeMap.relation,
                value: relationId
              });
            } else {
              valueMap = changeMap.relation.createValueMap(value);
              this.updatedRelationMaps.push({
                relation: changeMap.relation,
                value
              });
            }
          }
          OrmUtils_1.OrmUtils.mergeDeep(updateMap, valueMap);
          return updateMap;
        }, {});
        this.changeMaps = changeMapsWithoutValues;
        return changeSet;
      }
      /**
       * Recomputes entityWithFulfilledIds and identifier when entity changes.
       */
      recompute() {
        if (this.entity) {
          this.entityWithFulfilledIds = Object.assign({}, this.entity);
          if (this.parentSubject) {
            this.metadata.primaryColumns.forEach((primaryColumn) => {
              if (primaryColumn.relationMetadata && primaryColumn.relationMetadata.inverseEntityMetadata === this.parentSubject.metadata) {
                const value = primaryColumn.referencedColumn.getEntityValue(this.parentSubject.entity);
                primaryColumn.setEntityValue(this.entityWithFulfilledIds, value);
              }
            });
          }
          this.identifier = this.metadata.getEntityIdMap(this.entityWithFulfilledIds);
        } else if (this.databaseEntity) {
          this.identifier = this.metadata.getEntityIdMap(this.databaseEntity);
        }
      }
    };
    exports2.Subject = Subject;
  }
});

// node_modules/typeorm/persistence/subject-builder/OneToManySubjectBuilder.js
var require_OneToManySubjectBuilder = __commonJS({
  "node_modules/typeorm/persistence/subject-builder/OneToManySubjectBuilder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OneToManySubjectBuilder = void 0;
    var Subject_1 = require_Subject();
    var OrmUtils_1 = require_OrmUtils();
    var EntityMetadata_1 = require_EntityMetadata();
    var OneToManySubjectBuilder = class {
      // ---------------------------------------------------------------------
      // Constructor
      // ---------------------------------------------------------------------
      constructor(subjects) {
        this.subjects = subjects;
      }
      // ---------------------------------------------------------------------
      // Public Methods
      // ---------------------------------------------------------------------
      /**
       * Builds all required operations.
       */
      build() {
        this.subjects.forEach((subject) => {
          subject.metadata.oneToManyRelations.forEach((relation) => {
            if (relation.persistenceEnabled === false)
              return;
            this.buildForSubjectRelation(subject, relation);
          });
        });
      }
      // ---------------------------------------------------------------------
      // Protected Methods
      // ---------------------------------------------------------------------
      /**
       * Builds operations for a given subject and relation.
       *
       * by example: subject is "post" entity we are saving here and relation is "categories" inside it here.
       */
      buildForSubjectRelation(subject, relation) {
        let relatedEntityDatabaseRelationIds = [];
        if (subject.databaseEntity) {
          const relatedEntityDatabaseRelation = relation.getEntityValue(subject.databaseEntity);
          if (relatedEntityDatabaseRelation) {
            relatedEntityDatabaseRelationIds = relatedEntityDatabaseRelation.map((entity) => relation.inverseEntityMetadata.getEntityIdMap(entity));
          }
        }
        let relatedEntities = relation.getEntityValue(subject.entity);
        if (relatedEntities === null)
          relatedEntities = [];
        if (relatedEntities === void 0)
          return;
        const relatedPersistedEntityRelationIds = [];
        relatedEntities.forEach((relatedEntity) => {
          let relationIdMap = relation.inverseEntityMetadata.getEntityIdMap(relatedEntity);
          let relatedEntitySubject = this.subjects.find((subject2) => {
            return subject2.entity === relatedEntity;
          });
          if (relatedEntitySubject)
            relationIdMap = relatedEntitySubject.identifier;
          if (!relationIdMap) {
            if (!relatedEntitySubject)
              return;
            relatedEntitySubject.changeMaps.push({
              relation: relation.inverseRelation,
              value: subject
            });
            return;
          }
          const relationIdInDatabaseSubjectRelation = relatedEntityDatabaseRelationIds.find((relatedDatabaseEntityRelationId) => {
            return OrmUtils_1.OrmUtils.compareIds(relationIdMap, relatedDatabaseEntityRelationId);
          });
          if (!relationIdInDatabaseSubjectRelation) {
            if (!relatedEntitySubject) {
              relatedEntitySubject = new Subject_1.Subject({
                metadata: relation.inverseEntityMetadata,
                parentSubject: subject,
                canBeUpdated: true,
                identifier: relationIdMap
              });
              this.subjects.push(relatedEntitySubject);
            }
            relatedEntitySubject.changeMaps.push({
              relation: relation.inverseRelation,
              value: subject
            });
          }
          relatedPersistedEntityRelationIds.push(relationIdMap);
        });
        if (relation.inverseRelation?.orphanedRowAction !== "disable") {
          EntityMetadata_1.EntityMetadata.difference(relatedEntityDatabaseRelationIds, relatedPersistedEntityRelationIds).forEach((removedRelatedEntityRelationId) => {
            const removedRelatedEntitySubject = new Subject_1.Subject({
              metadata: relation.inverseEntityMetadata,
              parentSubject: subject,
              identifier: removedRelatedEntityRelationId
            });
            if (!relation.inverseRelation || relation.inverseRelation.orphanedRowAction === "nullify") {
              removedRelatedEntitySubject.canBeUpdated = true;
              removedRelatedEntitySubject.changeMaps = [
                {
                  relation: relation.inverseRelation,
                  value: null
                }
              ];
            } else if (relation.inverseRelation.orphanedRowAction === "delete") {
              removedRelatedEntitySubject.mustBeRemoved = true;
            } else if (relation.inverseRelation.orphanedRowAction === "soft-delete") {
              removedRelatedEntitySubject.canBeSoftRemoved = true;
            }
            this.subjects.push(removedRelatedEntitySubject);
          });
        }
      }
    };
    exports2.OneToManySubjectBuilder = OneToManySubjectBuilder;
  }
});

// node_modules/typeorm/persistence/subject-builder/OneToOneInverseSideSubjectBuilder.js
var require_OneToOneInverseSideSubjectBuilder = __commonJS({
  "node_modules/typeorm/persistence/subject-builder/OneToOneInverseSideSubjectBuilder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OneToOneInverseSideSubjectBuilder = void 0;
    var Subject_1 = require_Subject();
    var OrmUtils_1 = require_OrmUtils();
    var OneToOneInverseSideSubjectBuilder = class {
      // ---------------------------------------------------------------------
      // Constructor
      // ---------------------------------------------------------------------
      constructor(subjects) {
        this.subjects = subjects;
      }
      // ---------------------------------------------------------------------
      // Public Methods
      // ---------------------------------------------------------------------
      /**
       * Builds all required operations.
       */
      build() {
        this.subjects.forEach((subject) => {
          subject.metadata.oneToOneRelations.forEach((relation) => {
            if (relation.isOwning || relation.persistenceEnabled === false)
              return;
            this.buildForSubjectRelation(subject, relation);
          });
        });
      }
      // ---------------------------------------------------------------------
      // Protected Methods
      // ---------------------------------------------------------------------
      /**
       * Builds operations for a given subject and relation.
       *
       * by example: subject is "post" entity we are saving here and relation is "category" inside it here.
       */
      buildForSubjectRelation(subject, relation) {
        let relatedEntityDatabaseRelationId = void 0;
        if (subject.databaseEntity)
          relatedEntityDatabaseRelationId = relation.getEntityValue(subject.databaseEntity);
        const relatedEntity = relation.getEntityValue(subject.entity);
        if (relatedEntity === void 0)
          return;
        if (relatedEntity === null) {
          if (relatedEntityDatabaseRelationId) {
            const removedRelatedEntitySubject = new Subject_1.Subject({
              metadata: relation.inverseEntityMetadata,
              parentSubject: subject,
              canBeUpdated: true,
              identifier: relatedEntityDatabaseRelationId,
              changeMaps: [
                {
                  relation: relation.inverseRelation,
                  value: null
                }
              ]
            });
            this.subjects.push(removedRelatedEntitySubject);
          }
          return;
        }
        let relationIdMap = relation.inverseEntityMetadata.getEntityIdMap(relatedEntity);
        let relatedEntitySubject = this.subjects.find((operateSubject) => {
          return !!operateSubject.entity && operateSubject.entity === relatedEntity;
        });
        if (relatedEntitySubject)
          relationIdMap = relatedEntitySubject.identifier;
        if (!relationIdMap) {
          if (!relatedEntitySubject)
            return;
          relatedEntitySubject.changeMaps.push({
            relation: relation.inverseRelation,
            value: subject
          });
        }
        const areRelatedIdEqualWithDatabase = relatedEntityDatabaseRelationId && OrmUtils_1.OrmUtils.compareIds(relationIdMap, relatedEntityDatabaseRelationId);
        if (!areRelatedIdEqualWithDatabase) {
          if (!relatedEntitySubject) {
            relatedEntitySubject = new Subject_1.Subject({
              metadata: relation.inverseEntityMetadata,
              canBeUpdated: true,
              identifier: relationIdMap
            });
            this.subjects.push(relatedEntitySubject);
          }
          relatedEntitySubject.changeMaps.push({
            relation: relation.inverseRelation,
            value: subject
          });
        }
      }
    };
    exports2.OneToOneInverseSideSubjectBuilder = OneToOneInverseSideSubjectBuilder;
  }
});

// node_modules/typeorm/persistence/subject-builder/ManyToManySubjectBuilder.js
var require_ManyToManySubjectBuilder = __commonJS({
  "node_modules/typeorm/persistence/subject-builder/ManyToManySubjectBuilder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ManyToManySubjectBuilder = void 0;
    var Subject_1 = require_Subject();
    var OrmUtils_1 = require_OrmUtils();
    var ManyToManySubjectBuilder = class {
      // ---------------------------------------------------------------------
      // Constructor
      // ---------------------------------------------------------------------
      constructor(subjects) {
        this.subjects = subjects;
      }
      // ---------------------------------------------------------------------
      // Public Methods
      // ---------------------------------------------------------------------
      /**
       * Builds operations for any changes in the many-to-many relations of the subjects.
       */
      build() {
        this.subjects.forEach((subject) => {
          if (!subject.entity)
            return;
          subject.metadata.manyToManyRelations.forEach((relation) => {
            if (relation.persistenceEnabled === false)
              return;
            this.buildForSubjectRelation(subject, relation);
          });
        });
      }
      /**
       * Builds operations for removal of all many-to-many records of all many-to-many relations of the given subject.
       */
      buildForAllRemoval(subject) {
        if (!subject.databaseEntity)
          return;
        subject.metadata.manyToManyRelations.forEach((relation) => {
          if (relation.persistenceEnabled === false)
            return;
          const relatedEntityRelationIdsInDatabase = relation.getEntityValue(subject.databaseEntity);
          relatedEntityRelationIdsInDatabase.forEach((relationId) => {
            const junctionSubject = new Subject_1.Subject({
              metadata: relation.junctionEntityMetadata,
              parentSubject: subject,
              mustBeRemoved: true,
              identifier: this.buildJunctionIdentifier(subject, relation, relationId)
            });
            this.subjects.push(junctionSubject);
          });
        });
      }
      // ---------------------------------------------------------------------
      // Protected Methods
      // ---------------------------------------------------------------------
      /**
       * Builds operations for a given subject and relation.
       *
       * by example: subject is "post" entity we are saving here and relation is "categories" inside it here.
       */
      buildForSubjectRelation(subject, relation) {
        let databaseRelatedEntityIds = [];
        if (subject.databaseEntity) {
          const databaseRelatedEntityValue = relation.getEntityValue(subject.databaseEntity);
          if (databaseRelatedEntityValue) {
            databaseRelatedEntityIds = databaseRelatedEntityValue.map((e) => relation.inverseEntityMetadata.getEntityIdMap(e));
          }
        }
        let relatedEntities = relation.getEntityValue(subject.entity);
        if (relatedEntities === null)
          relatedEntities = [];
        if (!Array.isArray(relatedEntities))
          return;
        relatedEntities.forEach((relatedEntity) => {
          let relatedEntityRelationIdMap = relation.inverseEntityMetadata.getEntityIdMap(relatedEntity);
          const relatedEntitySubject = this.subjects.find((subject2) => {
            return subject2.entity === relatedEntity;
          });
          if (relatedEntitySubject)
            relatedEntityRelationIdMap = relatedEntitySubject.identifier;
          if (!relatedEntityRelationIdMap) {
            if (!relatedEntitySubject)
              return;
          }
          const relatedEntityExistInDatabase = databaseRelatedEntityIds.find((databaseRelatedEntityRelationId) => {
            return OrmUtils_1.OrmUtils.compareIds(databaseRelatedEntityRelationId, relatedEntityRelationIdMap);
          });
          if (relatedEntityExistInDatabase)
            return;
          const ownerValue = relation.isOwning ? subject : relatedEntitySubject || relatedEntity;
          const inverseValue = relation.isOwning ? relatedEntitySubject || relatedEntity : subject;
          const junctionSubject = new Subject_1.Subject({
            metadata: relation.junctionEntityMetadata,
            parentSubject: subject,
            canBeInserted: true
          });
          this.subjects.push(junctionSubject);
          relation.junctionEntityMetadata.ownerColumns.forEach((column) => {
            junctionSubject.changeMaps.push({
              column,
              value: ownerValue
              // valueFactory: (value) => column.referencedColumn!.getEntityValue(value) // column.referencedColumn!.getEntityValue(ownerEntityMap),
            });
          });
          relation.junctionEntityMetadata.inverseColumns.forEach((column) => {
            junctionSubject.changeMaps.push({
              column,
              value: inverseValue
              // valueFactory: (value) => column.referencedColumn!.getEntityValue(value) // column.referencedColumn!.getEntityValue(inverseEntityMap),
            });
          });
        });
        const changedInverseEntityRelationIds = [];
        relatedEntities.forEach((relatedEntity) => {
          let relatedEntityRelationIdMap = relation.inverseEntityMetadata.getEntityIdMap(relatedEntity);
          const relatedEntitySubject = this.subjects.find((subject2) => {
            return subject2.entity === relatedEntity;
          });
          if (relatedEntitySubject)
            relatedEntityRelationIdMap = relatedEntitySubject.identifier;
          if (relatedEntityRelationIdMap !== void 0 && relatedEntityRelationIdMap !== null)
            changedInverseEntityRelationIds.push(relatedEntityRelationIdMap);
        });
        const removedJunctionEntityIds = databaseRelatedEntityIds.filter((existRelationId) => {
          return !changedInverseEntityRelationIds.find((changedRelationId) => {
            return OrmUtils_1.OrmUtils.compareIds(changedRelationId, existRelationId);
          });
        });
        removedJunctionEntityIds.forEach((removedEntityRelationId) => {
          const junctionSubject = new Subject_1.Subject({
            metadata: relation.junctionEntityMetadata,
            parentSubject: subject,
            mustBeRemoved: true,
            identifier: this.buildJunctionIdentifier(subject, relation, removedEntityRelationId)
          });
          this.subjects.push(junctionSubject);
        });
      }
      /**
       * Creates identifiers for junction table.
       * Example: { postId: 1, categoryId: 2 }
       */
      buildJunctionIdentifier(subject, relation, relationId) {
        const ownerEntityMap = relation.isOwning ? subject.entity : relationId;
        const inverseEntityMap = relation.isOwning ? relationId : subject.entity;
        const identifier = {};
        relation.junctionEntityMetadata.ownerColumns.forEach((column) => {
          OrmUtils_1.OrmUtils.mergeDeep(identifier, column.createValueMap(column.referencedColumn.getEntityValue(ownerEntityMap)));
        });
        relation.junctionEntityMetadata.inverseColumns.forEach((column) => {
          OrmUtils_1.OrmUtils.mergeDeep(identifier, column.createValueMap(column.referencedColumn.getEntityValue(inverseEntityMap)));
        });
        return identifier;
      }
    };
    exports2.ManyToManySubjectBuilder = ManyToManySubjectBuilder;
  }
});

// node_modules/typeorm/persistence/SubjectDatabaseEntityLoader.js
var require_SubjectDatabaseEntityLoader = __commonJS({
  "node_modules/typeorm/persistence/SubjectDatabaseEntityLoader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SubjectDatabaseEntityLoader = void 0;
    var OrmUtils_1 = require_OrmUtils();
    var SubjectDatabaseEntityLoader = class {
      // ---------------------------------------------------------------------
      // Constructor
      // ---------------------------------------------------------------------
      constructor(queryRunner, subjects) {
        this.queryRunner = queryRunner;
        this.subjects = subjects;
      }
      // ---------------------------------------------------------------------
      // Public Methods
      // ---------------------------------------------------------------------
      /**
       * Loads database entities for all subjects.
       *
       * loadAllRelations flag is used to load all relation ids of the object, no matter if they present in subject entity or not.
       * This option is used for deletion.
       */
      async load(operationType) {
        const promises = this.groupByEntityTargets().map(async (subjectGroup) => {
          const allIds = [];
          const allSubjects = [];
          subjectGroup.subjects.forEach((subject) => {
            if (subject.databaseEntity || !subject.identifier)
              return;
            allIds.push(subject.identifier);
            allSubjects.push(subject);
          });
          if (!allIds.length)
            return;
          const loadRelationPropertyPaths = [];
          if (operationType === "save" || operationType === "soft-remove" || operationType === "recover") {
            subjectGroup.subjects.forEach((subject) => {
              subject.metadata.relations.forEach((relation) => {
                const value = relation.getEntityValue(subject.entityWithFulfilledIds);
                if (value === void 0)
                  return;
                if (loadRelationPropertyPaths.indexOf(relation.propertyPath) === -1)
                  loadRelationPropertyPaths.push(relation.propertyPath);
              });
            });
          } else {
            loadRelationPropertyPaths.push(...subjectGroup.subjects[0].metadata.manyToManyRelations.map((relation) => relation.propertyPath));
          }
          const findOptions = {
            loadEagerRelations: false,
            loadRelationIds: {
              relations: loadRelationPropertyPaths,
              disableMixedMap: true
            },
            // the soft-deleted entities should be included in the loaded entities for recover operation
            withDeleted: true
          };
          let entities = [];
          if (this.queryRunner.connection.driver.options.type === "mongodb") {
            const mongoRepo = this.queryRunner.manager.getRepository(subjectGroup.target);
            entities = await mongoRepo.findByIds(allIds, findOptions);
          } else {
            entities = await this.queryRunner.manager.getRepository(subjectGroup.target).createQueryBuilder().setFindOptions(findOptions).whereInIds(allIds).getMany();
          }
          entities.forEach((entity) => {
            const entityId = allSubjects[0].metadata.getEntityIdMap(entity);
            allSubjects.forEach((subject) => {
              if (subject.databaseEntity)
                return;
              if (OrmUtils_1.OrmUtils.compareIds(subject.identifier, entityId))
                subject.databaseEntity = entity;
            });
          });
          for (const subject of allSubjects) {
            subject.databaseEntityLoaded = true;
          }
        });
        await Promise.all(promises);
      }
      // ---------------------------------------------------------------------
      // Protected Methods
      // ---------------------------------------------------------------------
      /**
       * Groups given Subject objects into groups separated by entity targets.
       */
      groupByEntityTargets() {
        return this.subjects.reduce((groups, operatedEntity) => {
          let group = groups.find((group2) => group2.target === operatedEntity.metadata.target);
          if (!group) {
            group = { target: operatedEntity.metadata.target, subjects: [] };
            groups.push(group);
          }
          group.subjects.push(operatedEntity);
          return groups;
        }, []);
      }
    };
    exports2.SubjectDatabaseEntityLoader = SubjectDatabaseEntityLoader;
  }
});

// node_modules/typeorm/persistence/subject-builder/CascadesSubjectBuilder.js
var require_CascadesSubjectBuilder = __commonJS({
  "node_modules/typeorm/persistence/subject-builder/CascadesSubjectBuilder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CascadesSubjectBuilder = void 0;
    var Subject_1 = require_Subject();
    var ObjectUtils_1 = require_ObjectUtils();
    var CascadesSubjectBuilder = class {
      // ---------------------------------------------------------------------
      // Constructor
      // ---------------------------------------------------------------------
      constructor(allSubjects) {
        this.allSubjects = allSubjects;
      }
      // ---------------------------------------------------------------------
      // Public Methods
      // ---------------------------------------------------------------------
      /**
       * Builds a cascade subjects tree and pushes them in into the given array of subjects.
       */
      build(subject, operationType) {
        subject.metadata.extractRelationValuesFromEntity(subject.entity, subject.metadata.relations).forEach(([relation, relationEntity, relationEntityMetadata]) => {
          if (relationEntity === void 0 || relationEntity === null || !relation.isCascadeInsert && !relation.isCascadeUpdate && !relation.isCascadeSoftRemove && !relation.isCascadeRecover)
            return;
          if (!ObjectUtils_1.ObjectUtils.isObject(relationEntity))
            return;
          const alreadyExistRelationEntitySubject = this.findByPersistEntityLike(relationEntityMetadata.target, relationEntity);
          if (alreadyExistRelationEntitySubject) {
            if (alreadyExistRelationEntitySubject.canBeInserted === false)
              alreadyExistRelationEntitySubject.canBeInserted = relation.isCascadeInsert === true && operationType === "save";
            if (alreadyExistRelationEntitySubject.canBeUpdated === false)
              alreadyExistRelationEntitySubject.canBeUpdated = relation.isCascadeUpdate === true && operationType === "save";
            if (alreadyExistRelationEntitySubject.canBeSoftRemoved === false)
              alreadyExistRelationEntitySubject.canBeSoftRemoved = relation.isCascadeSoftRemove === true && operationType === "soft-remove";
            if (alreadyExistRelationEntitySubject.canBeRecovered === false)
              alreadyExistRelationEntitySubject.canBeRecovered = relation.isCascadeRecover === true && operationType === "recover";
            return;
          }
          const relationEntitySubject = new Subject_1.Subject({
            metadata: relationEntityMetadata,
            parentSubject: subject,
            entity: relationEntity,
            canBeInserted: relation.isCascadeInsert === true && operationType === "save",
            canBeUpdated: relation.isCascadeUpdate === true && operationType === "save",
            canBeSoftRemoved: relation.isCascadeSoftRemove === true && operationType === "soft-remove",
            canBeRecovered: relation.isCascadeRecover === true && operationType === "recover"
          });
          this.allSubjects.push(relationEntitySubject);
          this.build(relationEntitySubject, operationType);
        });
      }
      // ---------------------------------------------------------------------
      // Protected Methods
      // ---------------------------------------------------------------------
      /**
       * Finds subject where entity like given subject's entity.
       * Comparison made by entity id.
       */
      findByPersistEntityLike(entityTarget, entity) {
        return this.allSubjects.find((subject) => {
          if (!subject.entity)
            return false;
          if (subject.entity === entity)
            return true;
          return subject.metadata.target === entityTarget && subject.metadata.compareEntities(subject.entityWithFulfilledIds, entity);
        });
      }
    };
    exports2.CascadesSubjectBuilder = CascadesSubjectBuilder;
  }
});

// node_modules/typeorm/persistence/EntityPersistExecutor.js
var require_EntityPersistExecutor = __commonJS({
  "node_modules/typeorm/persistence/EntityPersistExecutor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EntityPersistExecutor = void 0;
    var MustBeEntityError_1 = require_MustBeEntityError();
    var SubjectExecutor_1 = require_SubjectExecutor();
    var CannotDetermineEntityError_1 = require_CannotDetermineEntityError();
    var Subject_1 = require_Subject();
    var OneToManySubjectBuilder_1 = require_OneToManySubjectBuilder();
    var OneToOneInverseSideSubjectBuilder_1 = require_OneToOneInverseSideSubjectBuilder();
    var ManyToManySubjectBuilder_1 = require_ManyToManySubjectBuilder();
    var SubjectDatabaseEntityLoader_1 = require_SubjectDatabaseEntityLoader();
    var CascadesSubjectBuilder_1 = require_CascadesSubjectBuilder();
    var OrmUtils_1 = require_OrmUtils();
    var EntityPersistExecutor = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection, queryRunner, mode, target, entity, options) {
        this.connection = connection;
        this.queryRunner = queryRunner;
        this.mode = mode;
        this.target = target;
        this.entity = entity;
        this.options = options;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Executes persistence operation ob given entity or entities.
       */
      async execute() {
        if (!this.entity || typeof this.entity !== "object")
          return Promise.reject(new MustBeEntityError_1.MustBeEntityError(this.mode, this.entity));
        await Promise.resolve();
        const queryRunner = this.queryRunner || this.connection.createQueryRunner();
        const oldQueryRunnerData = queryRunner.data;
        if (this.options && this.options.data) {
          queryRunner.data = this.options.data;
        }
        try {
          const entities = Array.isArray(this.entity) ? this.entity : [this.entity];
          const entitiesInChunks = this.options && this.options.chunk && this.options.chunk > 0 ? OrmUtils_1.OrmUtils.chunk(entities, this.options.chunk) : [entities];
          const executors = await Promise.all(entitiesInChunks.map(async (entities2) => {
            const subjects = [];
            entities2.forEach((entity) => {
              const entityTarget = this.target ? this.target : entity.constructor;
              if (entityTarget === Object)
                throw new CannotDetermineEntityError_1.CannotDetermineEntityError(this.mode);
              const metadata = this.connection.getMetadata(entityTarget).findInheritanceMetadata(entity);
              subjects.push(new Subject_1.Subject({
                metadata,
                entity,
                canBeInserted: this.mode === "save",
                canBeUpdated: this.mode === "save",
                mustBeRemoved: this.mode === "remove",
                canBeSoftRemoved: this.mode === "soft-remove",
                canBeRecovered: this.mode === "recover"
              }));
            });
            const cascadesSubjectBuilder = new CascadesSubjectBuilder_1.CascadesSubjectBuilder(subjects);
            subjects.forEach((subject) => {
              cascadesSubjectBuilder.build(subject, this.mode);
            });
            await new SubjectDatabaseEntityLoader_1.SubjectDatabaseEntityLoader(queryRunner, subjects).load(this.mode);
            if (this.mode === "save" || this.mode === "soft-remove" || this.mode === "recover") {
              new OneToManySubjectBuilder_1.OneToManySubjectBuilder(subjects).build();
              new OneToOneInverseSideSubjectBuilder_1.OneToOneInverseSideSubjectBuilder(subjects).build();
              new ManyToManySubjectBuilder_1.ManyToManySubjectBuilder(subjects).build();
            } else {
              subjects.forEach((subject) => {
                if (subject.mustBeRemoved) {
                  new ManyToManySubjectBuilder_1.ManyToManySubjectBuilder(subjects).buildForAllRemoval(subject);
                }
              });
            }
            return new SubjectExecutor_1.SubjectExecutor(queryRunner, subjects, this.options);
          }));
          const executorsWithExecutableOperations = executors.filter((executor) => executor.hasExecutableOperations);
          if (executorsWithExecutableOperations.length === 0)
            return;
          let isTransactionStartedByUs = false;
          try {
            if (!queryRunner.isTransactionActive) {
              if (this.connection.driver.transactionSupport !== "none" && (!this.options || this.options.transaction !== false)) {
                isTransactionStartedByUs = true;
                await queryRunner.startTransaction();
              }
            }
            for (const executor of executorsWithExecutableOperations) {
              await executor.execute();
            }
            if (isTransactionStartedByUs === true)
              await queryRunner.commitTransaction();
          } catch (error) {
            if (isTransactionStartedByUs) {
              try {
                await queryRunner.rollbackTransaction();
              } catch (rollbackError) {
              }
            }
            throw error;
          }
        } finally {
          queryRunner.data = oldQueryRunnerData;
          if (!this.queryRunner)
            await queryRunner.release();
        }
      }
    };
    exports2.EntityPersistExecutor = EntityPersistExecutor;
  }
});

// node_modules/typeorm/entity-manager/EntityManager.js
var require_EntityManager = __commonJS({
  "node_modules/typeorm/entity-manager/EntityManager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EntityManager = void 0;
    var EntityNotFoundError_1 = require_EntityNotFoundError();
    var QueryRunnerProviderAlreadyReleasedError_1 = require_QueryRunnerProviderAlreadyReleasedError();
    var NoNeedToReleaseEntityManagerError_1 = require_NoNeedToReleaseEntityManagerError();
    var MongoRepository_1 = require_MongoRepository();
    var TreeRepository_1 = require_TreeRepository();
    var Repository_1 = require_Repository();
    var FindOptionsUtils_1 = require_FindOptionsUtils();
    var PlainObjectToNewEntityTransformer_1 = require_PlainObjectToNewEntityTransformer();
    var PlainObjectToDatabaseEntityTransformer_1 = require_PlainObjectToDatabaseEntityTransformer();
    var error_1 = require_error();
    var AbstractRepository_1 = require_AbstractRepository();
    var EntityPersistExecutor_1 = require_EntityPersistExecutor();
    var ObjectUtils_1 = require_ObjectUtils();
    var globals_1 = require_globals();
    var InstanceChecker_1 = require_InstanceChecker();
    var SqlTagUtils_1 = require_SqlTagUtils();
    var OrmUtils_1 = require_OrmUtils();
    var EntityManager2 = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection, queryRunner) {
        this["@instanceof"] = Symbol.for("EntityManager");
        this.repositories = /* @__PURE__ */ new Map();
        this.treeRepositories = [];
        this.plainObjectToEntityTransformer = new PlainObjectToNewEntityTransformer_1.PlainObjectToNewEntityTransformer();
        this.connection = connection;
        if (queryRunner) {
          this.queryRunner = queryRunner;
          ObjectUtils_1.ObjectUtils.assign(this.queryRunner, { manager: this });
        }
      }
      /**
       * Wraps given function execution (and all operations made there) in a transaction.
       * All database operations must be executed using provided entity manager.
       */
      async transaction(isolationOrRunInTransaction, runInTransactionParam) {
        const isolation = typeof isolationOrRunInTransaction === "string" ? isolationOrRunInTransaction : void 0;
        const runInTransaction = typeof isolationOrRunInTransaction === "function" ? isolationOrRunInTransaction : runInTransactionParam;
        if (!runInTransaction) {
          throw new error_1.TypeORMError(`Transaction method requires callback in second parameter if isolation level is supplied.`);
        }
        if (this.queryRunner && this.queryRunner.isReleased)
          throw new QueryRunnerProviderAlreadyReleasedError_1.QueryRunnerProviderAlreadyReleasedError();
        const queryRunner = this.queryRunner || this.connection.createQueryRunner();
        try {
          await queryRunner.startTransaction(isolation);
          const result = await runInTransaction(queryRunner.manager);
          await queryRunner.commitTransaction();
          return result;
        } catch (err) {
          try {
            await queryRunner.rollbackTransaction();
          } catch (rollbackError) {
          }
          throw err;
        } finally {
          if (!this.queryRunner)
            await queryRunner.release();
        }
      }
      /**
       * Executes raw SQL query and returns raw database results.
       *
       * @see [Official docs](https://typeorm.io/docs/Working%20with%20Entity%20Manager/entity-manager-api/) for examples.
       */
      async query(query, parameters) {
        return this.connection.query(query, parameters, this.queryRunner);
      }
      /**
       * Tagged template function that executes raw SQL query and returns raw database results.
       * Template expressions are automatically transformed into database parameters.
       * Raw query execution is supported only by relational databases (MongoDB is not supported).
       * Note: Don't call this as a regular function, it is meant to be used with backticks to tag a template literal.
       * Example: entityManager.sql`SELECT * FROM table_name WHERE id = ${id}`
       */
      async sql(strings, ...values) {
        const { query, parameters } = (0, SqlTagUtils_1.buildSqlTag)({
          driver: this.connection.driver,
          strings,
          expressions: values
        });
        return await this.query(query, parameters);
      }
      /**
       * Creates a new query builder that can be used to build a SQL query.
       */
      createQueryBuilder(entityClass, alias, queryRunner) {
        if (alias) {
          return this.connection.createQueryBuilder(entityClass, alias, queryRunner || this.queryRunner);
        } else {
          return this.connection.createQueryBuilder(entityClass || queryRunner || this.queryRunner);
        }
      }
      /**
       * Checks if entity has an id by its Function type or schema name.
       */
      hasId(targetOrEntity, maybeEntity) {
        const target = arguments.length === 2 ? targetOrEntity : targetOrEntity.constructor;
        const entity = arguments.length === 2 ? maybeEntity : targetOrEntity;
        const metadata = this.connection.getMetadata(target);
        return metadata.hasId(entity);
      }
      /**
       * Gets entity mixed id.
       */
      getId(targetOrEntity, maybeEntity) {
        const target = arguments.length === 2 ? targetOrEntity : targetOrEntity.constructor;
        const entity = arguments.length === 2 ? maybeEntity : targetOrEntity;
        const metadata = this.connection.getMetadata(target);
        return metadata.getEntityIdMixedMap(entity);
      }
      /**
       * Creates a new entity instance or instances.
       * Can copy properties from the given object into new entities.
       */
      create(entityClass, plainObjectOrObjects) {
        const metadata = this.connection.getMetadata(entityClass);
        if (!plainObjectOrObjects)
          return metadata.create(this.queryRunner);
        if (Array.isArray(plainObjectOrObjects))
          return plainObjectOrObjects.map((plainEntityLike) => this.create(entityClass, plainEntityLike));
        const mergeIntoEntity = metadata.create(this.queryRunner);
        this.plainObjectToEntityTransformer.transform(mergeIntoEntity, plainObjectOrObjects, metadata, true);
        return mergeIntoEntity;
      }
      /**
       * Merges two entities into one new entity.
       */
      merge(entityClass, mergeIntoEntity, ...entityLikes) {
        const metadata = this.connection.getMetadata(entityClass);
        entityLikes.forEach((object) => this.plainObjectToEntityTransformer.transform(mergeIntoEntity, object, metadata));
        return mergeIntoEntity;
      }
      /**
       * Creates a new entity from the given plain javascript object. If entity already exist in the database, then
       * it loads it (and everything related to it), replaces all values with the new ones from the given object
       * and returns this new entity. This new entity is actually a loaded from the db entity with all properties
       * replaced from the new object.
       */
      async preload(entityClass, entityLike) {
        const metadata = this.connection.getMetadata(entityClass);
        const plainObjectToDatabaseEntityTransformer = new PlainObjectToDatabaseEntityTransformer_1.PlainObjectToDatabaseEntityTransformer(this.connection.manager);
        const transformedEntity = await plainObjectToDatabaseEntityTransformer.transform(entityLike, metadata);
        if (transformedEntity)
          return this.merge(entityClass, transformedEntity, entityLike);
        return void 0;
      }
      /**
       * Saves a given entity in the database.
       */
      save(targetOrEntity, maybeEntityOrOptions, maybeOptions) {
        let target = arguments.length > 1 && (typeof targetOrEntity === "function" || InstanceChecker_1.InstanceChecker.isEntitySchema(targetOrEntity) || typeof targetOrEntity === "string") ? targetOrEntity : void 0;
        const entity = target ? maybeEntityOrOptions : targetOrEntity;
        const options = target ? maybeOptions : maybeEntityOrOptions;
        if (InstanceChecker_1.InstanceChecker.isEntitySchema(target))
          target = target.options.name;
        if (Array.isArray(entity) && entity.length === 0)
          return Promise.resolve(entity);
        return new EntityPersistExecutor_1.EntityPersistExecutor(this.connection, this.queryRunner, "save", target, entity, options).execute().then(() => entity);
      }
      /**
       * Removes a given entity from the database.
       */
      remove(targetOrEntity, maybeEntityOrOptions, maybeOptions) {
        const target = arguments.length > 1 && (typeof targetOrEntity === "function" || InstanceChecker_1.InstanceChecker.isEntitySchema(targetOrEntity) || typeof targetOrEntity === "string") ? targetOrEntity : void 0;
        const entity = target ? maybeEntityOrOptions : targetOrEntity;
        const options = target ? maybeOptions : maybeEntityOrOptions;
        if (Array.isArray(entity) && entity.length === 0)
          return Promise.resolve(entity);
        return new EntityPersistExecutor_1.EntityPersistExecutor(this.connection, this.queryRunner, "remove", target, entity, options).execute().then(() => entity);
      }
      /**
       * Records the delete date of one or many given entities.
       */
      softRemove(targetOrEntity, maybeEntityOrOptions, maybeOptions) {
        let target = arguments.length > 1 && (typeof targetOrEntity === "function" || InstanceChecker_1.InstanceChecker.isEntitySchema(targetOrEntity) || typeof targetOrEntity === "string") ? targetOrEntity : void 0;
        const entity = target ? maybeEntityOrOptions : targetOrEntity;
        const options = target ? maybeOptions : maybeEntityOrOptions;
        if (InstanceChecker_1.InstanceChecker.isEntitySchema(target))
          target = target.options.name;
        if (Array.isArray(entity) && entity.length === 0)
          return Promise.resolve(entity);
        return new EntityPersistExecutor_1.EntityPersistExecutor(this.connection, this.queryRunner, "soft-remove", target, entity, options).execute().then(() => entity);
      }
      /**
       * Recovers one or many given entities.
       */
      recover(targetOrEntity, maybeEntityOrOptions, maybeOptions) {
        let target = arguments.length > 1 && (typeof targetOrEntity === "function" || InstanceChecker_1.InstanceChecker.isEntitySchema(targetOrEntity) || typeof targetOrEntity === "string") ? targetOrEntity : void 0;
        const entity = target ? maybeEntityOrOptions : targetOrEntity;
        const options = target ? maybeOptions : maybeEntityOrOptions;
        if (InstanceChecker_1.InstanceChecker.isEntitySchema(target))
          target = target.options.name;
        if (Array.isArray(entity) && entity.length === 0)
          return Promise.resolve(entity);
        return new EntityPersistExecutor_1.EntityPersistExecutor(this.connection, this.queryRunner, "recover", target, entity, options).execute().then(() => entity);
      }
      /**
       * Inserts a given entity into the database.
       * Unlike save method executes a primitive operation without cascades, relations and other operations included.
       * Executes fast and efficient INSERT query.
       * Does not check if entity exist in the database, so query will fail if duplicate entity is being inserted.
       * You can execute bulk inserts using this method.
       */
      async insert(target, entity) {
        return this.createQueryBuilder().insert().into(target).values(entity).execute();
      }
      async upsert(target, entityOrEntities, conflictPathsOrOptions) {
        const metadata = this.connection.getMetadata(target);
        let options;
        if (Array.isArray(conflictPathsOrOptions)) {
          options = {
            conflictPaths: conflictPathsOrOptions
          };
        } else {
          options = conflictPathsOrOptions;
        }
        let entities;
        if (!Array.isArray(entityOrEntities)) {
          entities = [entityOrEntities];
        } else {
          entities = entityOrEntities;
        }
        const conflictColumns = metadata.mapPropertyPathsToColumns(Array.isArray(options.conflictPaths) ? options.conflictPaths : Object.keys(options.conflictPaths));
        const overwriteColumns = metadata.columns.filter((col) => !conflictColumns.includes(col) && entities.some((entity) => typeof col.getEntityValue(entity) !== "undefined"));
        return this.createQueryBuilder().insert().into(target).values(entities).orUpdate([...conflictColumns, ...overwriteColumns].map((col) => col.databaseName), conflictColumns.map((col) => col.databaseName), {
          skipUpdateIfNoValuesChanged: options.skipUpdateIfNoValuesChanged,
          indexPredicate: options.indexPredicate,
          upsertType: options.upsertType || this.connection.driver.supportedUpsertTypes[0]
        }).execute();
      }
      /**
       * Updates entity partially. Entity can be found by a given condition(s).
       * Unlike save method executes a primitive operation without cascades, relations and other operations included.
       * Executes fast and efficient UPDATE query.
       * Does not check if entity exist in the database.
       * Condition(s) cannot be empty.
       */
      update(target, criteria, partialEntity) {
        if (OrmUtils_1.OrmUtils.isCriteriaNullOrEmpty(criteria)) {
          return Promise.reject(new error_1.TypeORMError(`Empty criteria(s) are not allowed for the update method.`));
        }
        if (OrmUtils_1.OrmUtils.isPrimitiveCriteria(criteria)) {
          return this.createQueryBuilder().update(target).set(partialEntity).whereInIds(criteria).execute();
        } else {
          return this.createQueryBuilder().update(target).set(partialEntity).where(criteria).execute();
        }
      }
      /**
       * Updates all entities of target type, setting fields from supplied partial entity.
       * This is a primitive operation without cascades, relations or other operations included.
       * Executes fast and efficient UPDATE query without WHERE clause.
       *
       * WARNING! This method updates ALL rows in the target table.
       */
      updateAll(target, partialEntity) {
        return this.createQueryBuilder().update(target).set(partialEntity).execute();
      }
      /**
       * Deletes entities by a given condition(s).
       * Unlike save method executes a primitive operation without cascades, relations and other operations included.
       * Executes fast and efficient DELETE query.
       * Does not check if entity exist in the database.
       * Condition(s) cannot be empty.
       */
      delete(targetOrEntity, criteria) {
        if (OrmUtils_1.OrmUtils.isCriteriaNullOrEmpty(criteria)) {
          return Promise.reject(new error_1.TypeORMError(`Empty criteria(s) are not allowed for the delete method.`));
        }
        if (OrmUtils_1.OrmUtils.isPrimitiveCriteria(criteria)) {
          return this.createQueryBuilder().delete().from(targetOrEntity).whereInIds(criteria).execute();
        } else {
          return this.createQueryBuilder().delete().from(targetOrEntity).where(criteria).execute();
        }
      }
      /**
       * Deletes all entities of target type.
       * This is a primitive operation without cascades, relations or other operations included.
       * Executes fast and efficient DELETE query without WHERE clause.
       *
       * WARNING! This method deletes ALL rows in the target table.
       */
      deleteAll(targetOrEntity) {
        return this.createQueryBuilder().delete().from(targetOrEntity).execute();
      }
      /**
       * Records the delete date of entities by a given condition(s).
       * Unlike save method executes a primitive operation without cascades, relations and other operations included.
       * Executes fast and efficient UPDATE query.
       * Does not check if entity exist in the database.
       * Condition(s) cannot be empty.
       */
      softDelete(targetOrEntity, criteria) {
        if (OrmUtils_1.OrmUtils.isCriteriaNullOrEmpty(criteria)) {
          return Promise.reject(new error_1.TypeORMError(`Empty criteria(s) are not allowed for the softDelete method.`));
        }
        if (OrmUtils_1.OrmUtils.isPrimitiveCriteria(criteria)) {
          return this.createQueryBuilder().softDelete().from(targetOrEntity).whereInIds(criteria).execute();
        } else {
          return this.createQueryBuilder().softDelete().from(targetOrEntity).where(criteria).execute();
        }
      }
      /**
       * Restores entities by a given condition(s).
       * Unlike save method executes a primitive operation without cascades, relations and other operations included.
       * Executes fast and efficient UPDATE query.
       * Does not check if entity exist in the database.
       * Condition(s) cannot be empty.
       */
      restore(targetOrEntity, criteria) {
        if (OrmUtils_1.OrmUtils.isCriteriaNullOrEmpty(criteria)) {
          return Promise.reject(new error_1.TypeORMError(`Empty criteria(s) are not allowed for the restore method.`));
        }
        if (OrmUtils_1.OrmUtils.isPrimitiveCriteria(criteria)) {
          return this.createQueryBuilder().restore().from(targetOrEntity).whereInIds(criteria).execute();
        } else {
          return this.createQueryBuilder().restore().from(targetOrEntity).where(criteria).execute();
        }
      }
      /**
       * Checks whether any entity exists with the given options.
       */
      exists(entityClass, options) {
        const metadata = this.connection.getMetadata(entityClass);
        return this.createQueryBuilder(entityClass, FindOptionsUtils_1.FindOptionsUtils.extractFindManyOptionsAlias(options) || metadata.name).setFindOptions(options || {}).getExists();
      }
      /**
       * Checks whether any entity exists with the given conditions.
       */
      async existsBy(entityClass, where) {
        const metadata = this.connection.getMetadata(entityClass);
        return this.createQueryBuilder(entityClass, metadata.name).setFindOptions({ where }).getExists();
      }
      /**
       * Counts entities that match given options.
       * Useful for pagination.
       */
      count(entityClass, options) {
        const metadata = this.connection.getMetadata(entityClass);
        return this.createQueryBuilder(entityClass, FindOptionsUtils_1.FindOptionsUtils.extractFindManyOptionsAlias(options) || metadata.name).setFindOptions(options || {}).getCount();
      }
      /**
       * Counts entities that match given conditions.
       * Useful for pagination.
       */
      countBy(entityClass, where) {
        const metadata = this.connection.getMetadata(entityClass);
        return this.createQueryBuilder(entityClass, metadata.name).setFindOptions({ where }).getCount();
      }
      /**
       * Return the SUM of a column
       */
      sum(entityClass, columnName, where) {
        return this.callAggregateFun(entityClass, "SUM", columnName, where);
      }
      /**
       * Return the AVG of a column
       */
      average(entityClass, columnName, where) {
        return this.callAggregateFun(entityClass, "AVG", columnName, where);
      }
      /**
       * Return the MIN of a column
       */
      minimum(entityClass, columnName, where) {
        return this.callAggregateFun(entityClass, "MIN", columnName, where);
      }
      /**
       * Return the MAX of a column
       */
      maximum(entityClass, columnName, where) {
        return this.callAggregateFun(entityClass, "MAX", columnName, where);
      }
      async callAggregateFun(entityClass, fnName, columnName, where = {}) {
        const metadata = this.connection.getMetadata(entityClass);
        const column = metadata.columns.find((item) => item.propertyPath === columnName);
        if (!column) {
          throw new error_1.TypeORMError(`Column "${columnName}" was not found in table "${metadata.name}"`);
        }
        const result = await this.createQueryBuilder(entityClass, metadata.name).setFindOptions({ where }).select(`${fnName}(${this.connection.driver.escape(column.databaseName)})`, fnName).getRawOne();
        return result[fnName] === null ? null : parseFloat(result[fnName]);
      }
      /**
       * Finds entities that match given find options.
       */
      async find(entityClass, options) {
        const metadata = this.connection.getMetadata(entityClass);
        return this.createQueryBuilder(entityClass, FindOptionsUtils_1.FindOptionsUtils.extractFindManyOptionsAlias(options) || metadata.name).setFindOptions(options || {}).getMany();
      }
      /**
       * Finds entities that match given find options.
       */
      async findBy(entityClass, where) {
        const metadata = this.connection.getMetadata(entityClass);
        return this.createQueryBuilder(entityClass, metadata.name).setFindOptions({ where }).getMany();
      }
      /**
       * Finds entities that match given find options.
       * Also counts all entities that match given conditions,
       * but ignores pagination settings (from and take options).
       */
      findAndCount(entityClass, options) {
        const metadata = this.connection.getMetadata(entityClass);
        return this.createQueryBuilder(entityClass, FindOptionsUtils_1.FindOptionsUtils.extractFindManyOptionsAlias(options) || metadata.name).setFindOptions(options || {}).getManyAndCount();
      }
      /**
       * Finds entities that match given WHERE conditions.
       * Also counts all entities that match given conditions,
       * but ignores pagination settings (from and take options).
       */
      findAndCountBy(entityClass, where) {
        const metadata = this.connection.getMetadata(entityClass);
        return this.createQueryBuilder(entityClass, metadata.name).setFindOptions({ where }).getManyAndCount();
      }
      /**
       * Finds entities with ids.
       * Optionally find options or conditions can be applied.
       *
       * @deprecated use `findBy` method instead in conjunction with `In` operator, for example:
       *
       * .findBy({
       *     id: In([1, 2, 3])
       * })
       */
      async findByIds(entityClass, ids) {
        if (!ids.length)
          return Promise.resolve([]);
        const metadata = this.connection.getMetadata(entityClass);
        return this.createQueryBuilder(entityClass, metadata.name).andWhereInIds(ids).getMany();
      }
      /**
       * Finds first entity by a given find options.
       * If entity was not found in the database - returns null.
       */
      async findOne(entityClass, options) {
        const metadata = this.connection.getMetadata(entityClass);
        let alias = metadata.name;
        if (options && options.join) {
          alias = options.join.alias;
        }
        if (!options.where) {
          throw new Error(`You must provide selection conditions in order to find a single row.`);
        }
        return this.createQueryBuilder(entityClass, alias).setFindOptions({
          ...options,
          take: 1
        }).getOne();
      }
      /**
       * Finds first entity that matches given where condition.
       * If entity was not found in the database - returns null.
       */
      async findOneBy(entityClass, where) {
        const metadata = this.connection.getMetadata(entityClass);
        return this.createQueryBuilder(entityClass, metadata.name).setFindOptions({
          where,
          take: 1
        }).getOne();
      }
      /**
       * Finds first entity that matches given id.
       * If entity was not found in the database - returns null.
       *
       * @deprecated use `findOneBy` method instead in conjunction with `In` operator, for example:
       *
       * .findOneBy({
       *     id: 1 // where "id" is your primary column name
       * })
       */
      async findOneById(entityClass, id) {
        const metadata = this.connection.getMetadata(entityClass);
        return this.createQueryBuilder(entityClass, metadata.name).setFindOptions({
          take: 1
        }).whereInIds(metadata.ensureEntityIdMap(id)).getOne();
      }
      /**
       * Finds first entity by a given find options.
       * If entity was not found in the database - rejects with error.
       */
      async findOneOrFail(entityClass, options) {
        return this.findOne(entityClass, options).then((value) => {
          if (value === null) {
            return Promise.reject(new EntityNotFoundError_1.EntityNotFoundError(entityClass, options));
          }
          return Promise.resolve(value);
        });
      }
      /**
       * Finds first entity that matches given where condition.
       * If entity was not found in the database - rejects with error.
       */
      async findOneByOrFail(entityClass, where) {
        return this.findOneBy(entityClass, where).then((value) => {
          if (value === null) {
            return Promise.reject(new EntityNotFoundError_1.EntityNotFoundError(entityClass, where));
          }
          return Promise.resolve(value);
        });
      }
      /**
       * Clears all the data from the given table (truncates/drops it).
       *
       * Note: this method uses TRUNCATE and may not work as you expect in transactions on some platforms.
       * @see https://stackoverflow.com/a/5972738/925151
       */
      async clear(entityClass) {
        const metadata = this.connection.getMetadata(entityClass);
        const queryRunner = this.queryRunner || this.connection.createQueryRunner();
        try {
          return await queryRunner.clearTable(metadata.tablePath);
        } finally {
          if (!this.queryRunner)
            await queryRunner.release();
        }
      }
      /**
       * Increments some column by provided value of the entities matched given conditions.
       */
      async increment(entityClass, conditions, propertyPath, value) {
        const metadata = this.connection.getMetadata(entityClass);
        const column = metadata.findColumnWithPropertyPath(propertyPath);
        if (!column)
          throw new error_1.TypeORMError(`Column ${propertyPath} was not found in ${metadata.targetName} entity.`);
        if (isNaN(Number(value)))
          throw new error_1.TypeORMError(`Value "${value}" is not a number.`);
        const values = propertyPath.split(".").reduceRight((value2, key) => ({ [key]: value2 }), () => this.connection.driver.escape(column.databaseName) + " + " + value);
        return this.createQueryBuilder(entityClass, "entity").update(entityClass).set(values).where(conditions).execute();
      }
      /**
       * Decrements some column by provided value of the entities matched given conditions.
       */
      async decrement(entityClass, conditions, propertyPath, value) {
        const metadata = this.connection.getMetadata(entityClass);
        const column = metadata.findColumnWithPropertyPath(propertyPath);
        if (!column)
          throw new error_1.TypeORMError(`Column ${propertyPath} was not found in ${metadata.targetName} entity.`);
        if (isNaN(Number(value)))
          throw new error_1.TypeORMError(`Value "${value}" is not a number.`);
        const values = propertyPath.split(".").reduceRight((value2, key) => ({ [key]: value2 }), () => this.connection.driver.escape(column.databaseName) + " - " + value);
        return this.createQueryBuilder(entityClass, "entity").update(entityClass).set(values).where(conditions).execute();
      }
      /**
       * Gets repository for the given entity class or name.
       * If single database connection mode is used, then repository is obtained from the
       * repository aggregator, where each repository is individually created for this entity manager.
       * When single database connection is not used, repository is being obtained from the connection.
       */
      getRepository(target) {
        const repoFromMap = this.repositories.get(target);
        if (repoFromMap)
          return repoFromMap;
        if (this.connection.driver.options.type === "mongodb") {
          const newRepository = new MongoRepository_1.MongoRepository(target, this, this.queryRunner);
          this.repositories.set(target, newRepository);
          return newRepository;
        } else {
          const newRepository = new Repository_1.Repository(target, this, this.queryRunner);
          this.repositories.set(target, newRepository);
          return newRepository;
        }
      }
      /**
       * Gets tree repository for the given entity class or name.
       * If single database connection mode is used, then repository is obtained from the
       * repository aggregator, where each repository is individually created for this entity manager.
       * When single database connection is not used, repository is being obtained from the connection.
       */
      getTreeRepository(target) {
        if (this.connection.driver.treeSupport === false)
          throw new error_1.TreeRepositoryNotSupportedError(this.connection.driver);
        const repository = this.treeRepositories.find((repository2) => repository2.target === target);
        if (repository)
          return repository;
        const newRepository = new TreeRepository_1.TreeRepository(target, this, this.queryRunner);
        this.treeRepositories.push(newRepository);
        return newRepository;
      }
      /**
       * Gets mongodb repository for the given entity class.
       */
      getMongoRepository(target) {
        return this.connection.getMongoRepository(target);
      }
      /**
       * Creates a new repository instance out of a given Repository and
       * sets current EntityManager instance to it. Used to work with custom repositories
       * in transactions.
       */
      withRepository(repository) {
        const repositoryConstructor = repository.constructor;
        const { target, manager, queryRunner, ...otherRepositoryProperties } = repository;
        return Object.assign(new repositoryConstructor(repository.target, this), {
          ...otherRepositoryProperties
        });
      }
      /**
       * Gets custom entity repository marked with @EntityRepository decorator.
       *
       * @deprecated use Repository.extend to create custom repositories
       */
      getCustomRepository(customRepository) {
        const entityRepositoryMetadataArgs = (0, globals_1.getMetadataArgsStorage)().entityRepositories.find((repository) => {
          return repository.target === (typeof customRepository === "function" ? customRepository : customRepository.constructor);
        });
        if (!entityRepositoryMetadataArgs)
          throw new error_1.CustomRepositoryNotFoundError(customRepository);
        const entityMetadata = entityRepositoryMetadataArgs.entity ? this.connection.getMetadata(entityRepositoryMetadataArgs.entity) : void 0;
        const entityRepositoryInstance = new entityRepositoryMetadataArgs.target(this, entityMetadata);
        if (entityRepositoryInstance instanceof AbstractRepository_1.AbstractRepository) {
          if (!entityRepositoryInstance["manager"])
            entityRepositoryInstance["manager"] = this;
        } else {
          if (!entityMetadata)
            throw new error_1.CustomRepositoryCannotInheritRepositoryError(customRepository);
          entityRepositoryInstance["manager"] = this;
          entityRepositoryInstance["metadata"] = entityMetadata;
        }
        return entityRepositoryInstance;
      }
      /**
       * Releases all resources used by entity manager.
       * This is used when entity manager is created with a single query runner,
       * and this single query runner needs to be released after job with entity manager is done.
       */
      async release() {
        if (!this.queryRunner)
          throw new NoNeedToReleaseEntityManagerError_1.NoNeedToReleaseEntityManagerError();
        return this.queryRunner.release();
      }
    };
    exports2.EntityManager = EntityManager2;
  }
});

// node_modules/typeorm/query-builder/transformer/DocumentToEntityTransformer.js
var require_DocumentToEntityTransformer = __commonJS({
  "node_modules/typeorm/query-builder/transformer/DocumentToEntityTransformer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DocumentToEntityTransformer = void 0;
    var DocumentToEntityTransformer = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(enableRelationIdValues = false) {
        this.enableRelationIdValues = enableRelationIdValues;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      transformAll(documents, metadata) {
        return documents.map((document2) => this.transform(document2, metadata));
      }
      transform(document2, metadata) {
        const entity = metadata.create(void 0, {
          fromDeserializer: true
        });
        let hasData = false;
        if (metadata.objectIdColumn) {
          const { databaseNameWithoutPrefixes, propertyName } = metadata.objectIdColumn;
          const documentIdWithoutPrefixes = document2[databaseNameWithoutPrefixes];
          const documentIdWithPropertyName = document2[propertyName];
          if (documentIdWithoutPrefixes) {
            entity[propertyName] = documentIdWithoutPrefixes;
            hasData = true;
          } else if (documentIdWithPropertyName) {
            entity[propertyName] = documentIdWithPropertyName;
            hasData = true;
          }
        }
        if (this.enableRelationIdValues) {
          metadata.columns.filter((column) => !!column.relationMetadata).forEach((column) => {
            const valueInObject = document2[column.databaseNameWithoutPrefixes];
            if (valueInObject !== void 0 && valueInObject !== null && column.propertyName) {
              entity[column.propertyName] = valueInObject;
              hasData = true;
            }
          });
        }
        metadata.ownColumns.forEach((column) => {
          const valueInObject = document2[column.databaseNameWithoutPrefixes];
          if (valueInObject !== void 0 && column.propertyName && !column.isVirtual) {
            entity[column.propertyName] = valueInObject;
            hasData = true;
          }
        });
        const addEmbeddedValuesRecursively = (entity2, document3, embeddeds) => {
          embeddeds.forEach((embedded) => {
            if (!document3[embedded.prefix])
              return;
            if (embedded.isArray) {
              entity2[embedded.propertyName] = document3[embedded.prefix].map((subValue, index) => {
                const newItem = embedded.create({
                  fromDeserializer: true
                });
                embedded.columns.forEach((column) => {
                  newItem[column.propertyName] = subValue[column.databaseNameWithoutPrefixes];
                });
                addEmbeddedValuesRecursively(newItem, document3[embedded.prefix][index], embedded.embeddeds);
                return newItem;
              });
            } else {
              if (embedded.embeddeds.length && !entity2[embedded.propertyName])
                entity2[embedded.propertyName] = embedded.create({
                  fromDeserializer: true
                });
              embedded.columns.forEach((column) => {
                const value = document3[embedded.prefix][column.databaseNameWithoutPrefixes];
                if (value === void 0)
                  return;
                if (!entity2[embedded.propertyName])
                  entity2[embedded.propertyName] = embedded.create({
                    fromDeserializer: true
                  });
                entity2[embedded.propertyName][column.propertyName] = value;
              });
              addEmbeddedValuesRecursively(entity2[embedded.propertyName], document3[embedded.prefix], embedded.embeddeds);
            }
          });
        };
        addEmbeddedValuesRecursively(entity, document2, metadata.embeddeds);
        return hasData ? entity : null;
      }
    };
    exports2.DocumentToEntityTransformer = DocumentToEntityTransformer;
  }
});

// node_modules/typeorm/entity-manager/MongoEntityManager.js
var require_MongoEntityManager = __commonJS({
  "node_modules/typeorm/entity-manager/MongoEntityManager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MongoEntityManager = void 0;
    var EntityManager_1 = require_EntityManager();
    var DocumentToEntityTransformer_1 = require_DocumentToEntityTransformer();
    var FindOptionsUtils_1 = require_FindOptionsUtils();
    var PlatformTools_1 = require_PlatformTools();
    var InsertResult_1 = require_InsertResult();
    var UpdateResult_1 = require_UpdateResult();
    var DeleteResult_1 = require_DeleteResult();
    var ObjectUtils_1 = require_ObjectUtils();
    var MongoEntityManager2 = class extends EntityManager_1.EntityManager {
      get mongoQueryRunner() {
        return this.connection.driver.queryRunner;
      }
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection) {
        super(connection);
        this["@instanceof"] = Symbol.for("MongoEntityManager");
      }
      // -------------------------------------------------------------------------
      // Overridden Methods
      // -------------------------------------------------------------------------
      /**
       * Finds entities that match given find options.
       */
      /**
       * Finds entities that match given find options or conditions.
       */
      async find(entityClassOrName, optionsOrConditions) {
        const query = this.convertFindManyOptionsOrConditionsToMongodbQuery(optionsOrConditions);
        const cursor = this.createEntityCursor(entityClassOrName, query);
        const deleteDateColumn = this.connection.getMetadata(entityClassOrName).deleteDateColumn;
        if (FindOptionsUtils_1.FindOptionsUtils.isFindManyOptions(optionsOrConditions)) {
          if (optionsOrConditions.select)
            cursor.project(this.convertFindOptionsSelectToProjectCriteria(optionsOrConditions.select));
          if (optionsOrConditions.skip)
            cursor.skip(optionsOrConditions.skip);
          if (optionsOrConditions.take)
            cursor.limit(optionsOrConditions.take);
          if (optionsOrConditions.order)
            cursor.sort(this.convertFindOptionsOrderToOrderCriteria(optionsOrConditions.order));
          if (deleteDateColumn && !optionsOrConditions.withDeleted) {
            this.filterSoftDeleted(cursor, deleteDateColumn, query);
          }
        } else if (deleteDateColumn) {
          this.filterSoftDeleted(cursor, deleteDateColumn, query);
        }
        return cursor.toArray();
      }
      /**
       * Finds entities that match given find options or conditions.
       * Also counts all entities that match given conditions,
       * but ignores pagination settings (from and take options).
       */
      async findAndCount(entityClassOrName, options) {
        return this.executeFindAndCount(entityClassOrName, options);
      }
      /**
       * Finds entities that match given where conditions.
       */
      async findAndCountBy(entityClassOrName, where) {
        return this.executeFindAndCount(entityClassOrName, where);
      }
      /**
       * Finds entities by ids.
       * Optionally find options can be applied.
       *
       * @deprecated use `findBy` method instead.
       */
      async findByIds(entityClassOrName, ids, optionsOrConditions) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        const query = this.convertFindManyOptionsOrConditionsToMongodbQuery(optionsOrConditions) || {};
        const objectIdInstance = PlatformTools_1.PlatformTools.load("mongodb").ObjectId;
        query["_id"] = {
          $in: ids.map((id) => {
            if (typeof id === "string") {
              return new objectIdInstance(id);
            }
            if (typeof id === "object") {
              if (id instanceof objectIdInstance) {
                return id;
              }
              const propertyName = metadata.objectIdColumn.propertyName;
              if (id[propertyName] instanceof objectIdInstance) {
                return id[propertyName];
              }
            }
          })
        };
        const cursor = this.createEntityCursor(entityClassOrName, query);
        if (FindOptionsUtils_1.FindOptionsUtils.isFindManyOptions(optionsOrConditions)) {
          if (optionsOrConditions.select)
            cursor.project(this.convertFindOptionsSelectToProjectCriteria(optionsOrConditions.select));
          if (optionsOrConditions.skip)
            cursor.skip(optionsOrConditions.skip);
          if (optionsOrConditions.take)
            cursor.limit(optionsOrConditions.take);
          if (optionsOrConditions.order)
            cursor.sort(this.convertFindOptionsOrderToOrderCriteria(optionsOrConditions.order));
        }
        return cursor.toArray();
      }
      /**
       * Finds first entity that matches given conditions and/or find options.
       */
      async findOne(entityClassOrName, options) {
        return this.executeFindOne(entityClassOrName, options);
      }
      /**
       * Finds first entity that matches given WHERE conditions.
       */
      async findOneBy(entityClassOrName, where) {
        return this.executeFindOne(entityClassOrName, where);
      }
      /**
       * Finds entity that matches given id.
       *
       * @deprecated use `findOneBy` method instead in conjunction with `In` operator, for example:
       *
       * .findOneBy({
       *     id: 1 // where "id" is your primary column name
       * })
       */
      async findOneById(entityClassOrName, id) {
        return this.executeFindOne(entityClassOrName, id);
      }
      /**
       * Inserts a given entity into the database.
       * Unlike save method executes a primitive operation without cascades, relations and other operations included.
       * Executes fast and efficient INSERT query.
       * Does not check if entity exist in the database, so query will fail if duplicate entity is being inserted.
       * You can execute bulk inserts using this method.
       */
      async insert(target, entity) {
        const result = new InsertResult_1.InsertResult();
        if (Array.isArray(entity)) {
          result.raw = await this.insertMany(target, entity);
          Object.keys(result.raw.insertedIds).forEach((key) => {
            const insertedId = result.raw.insertedIds[key];
            result.generatedMaps.push(this.connection.driver.createGeneratedMap(this.connection.getMetadata(target), insertedId));
            result.identifiers.push(this.connection.driver.createGeneratedMap(this.connection.getMetadata(target), insertedId));
          });
        } else {
          result.raw = await this.insertOne(target, entity);
          result.generatedMaps.push(this.connection.driver.createGeneratedMap(this.connection.getMetadata(target), result.raw.insertedId));
          result.identifiers.push(this.connection.driver.createGeneratedMap(this.connection.getMetadata(target), result.raw.insertedId));
        }
        return result;
      }
      /**
       * Updates entity partially. Entity can be found by a given conditions.
       * Unlike save method executes a primitive operation without cascades, relations and other operations included.
       * Executes fast and efficient UPDATE query.
       * Does not check if entity exist in the database.
       */
      async update(target, criteria, partialEntity) {
        const result = new UpdateResult_1.UpdateResult();
        if (Array.isArray(criteria)) {
          const updateResults = await Promise.all(criteria.map((criteriaItem) => {
            return this.update(target, criteriaItem, partialEntity);
          }));
          result.raw = updateResults.map((r) => r.raw);
          result.affected = updateResults.map((r) => r.affected || 0).reduce((c, r) => c + r, 0);
          result.generatedMaps = updateResults.reduce((c, r) => c.concat(r.generatedMaps), []);
        } else {
          const metadata = this.connection.getMetadata(target);
          const mongoResult = await this.updateMany(target, this.convertMixedCriteria(metadata, criteria), { $set: partialEntity });
          result.raw = mongoResult;
          result.affected = mongoResult.modifiedCount;
        }
        return result;
      }
      /**
       * Deletes entities by a given conditions.
       * Unlike save method executes a primitive operation without cascades, relations and other operations included.
       * Executes fast and efficient DELETE query.
       * Does not check if entity exist in the database.
       */
      async delete(target, criteria) {
        const result = new DeleteResult_1.DeleteResult();
        if (Array.isArray(criteria)) {
          const deleteResults = await Promise.all(criteria.map((criteriaItem) => {
            return this.delete(target, criteriaItem);
          }));
          result.raw = deleteResults.map((r) => r.raw);
          result.affected = deleteResults.map((r) => r.affected || 0).reduce((c, r) => c + r, 0);
        } else {
          const mongoResult = await this.deleteMany(target, this.convertMixedCriteria(this.connection.getMetadata(target), criteria));
          result.raw = mongoResult;
          result.affected = mongoResult.deletedCount;
        }
        return result;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Creates a cursor for a query that can be used to iterate over results from MongoDB.
       */
      createCursor(entityClassOrName, query = {}) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.cursor(metadata.tableName, query);
      }
      /**
       * Creates a cursor for a query that can be used to iterate over results from MongoDB.
       * This returns modified version of cursor that transforms each result into Entity model.
       */
      createEntityCursor(entityClassOrName, query = {}) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        const cursor = this.createCursor(entityClassOrName, query);
        this.applyEntityTransformationToCursor(metadata, cursor);
        return cursor;
      }
      /**
       * Execute an aggregation framework pipeline against the collection.
       */
      aggregate(entityClassOrName, pipeline, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.aggregate(metadata.tableName, pipeline, options);
      }
      /**
       * Execute an aggregation framework pipeline against the collection.
       * This returns modified version of cursor that transforms each result into Entity model.
       */
      aggregateEntity(entityClassOrName, pipeline, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        const cursor = this.mongoQueryRunner.aggregate(metadata.tableName, pipeline, options);
        this.applyEntityTransformationToCursor(metadata, cursor);
        return cursor;
      }
      /**
       * Perform a bulkWrite operation without a fluent API.
       */
      bulkWrite(entityClassOrName, operations, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.bulkWrite(metadata.tableName, operations, options);
      }
      /**
       * Count number of matching documents in the db to a query.
       */
      count(entityClassOrName, query = {}, options = {}) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.count(metadata.tableName, query, options);
      }
      /**
       * Count number of matching documents in the db to a query.
       */
      countDocuments(entityClassOrName, query = {}, options = {}) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.countDocuments(metadata.tableName, query, options);
      }
      /**
       * Count number of matching documents in the db to a query.
       */
      countBy(entityClassOrName, query, options) {
        return this.count(entityClassOrName, query, options);
      }
      /**
       * Creates an index on the db and collection.
       */
      createCollectionIndex(entityClassOrName, fieldOrSpec, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.createCollectionIndex(metadata.tableName, fieldOrSpec, options);
      }
      /**
       * Creates multiple indexes in the collection, this method is only supported for MongoDB 2.6 or higher.
       * Earlier version of MongoDB will throw a command not supported error.
       * Index specifications are defined at http://docs.mongodb.org/manual/reference/command/createIndexes/.
       */
      createCollectionIndexes(entityClassOrName, indexSpecs) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.createCollectionIndexes(metadata.tableName, indexSpecs);
      }
      /**
       * Delete multiple documents on MongoDB.
       */
      deleteMany(entityClassOrName, query, options = {}) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.deleteMany(metadata.tableName, query, options);
      }
      /**
       * Delete a document on MongoDB.
       */
      deleteOne(entityClassOrName, query, options = {}) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.deleteOne(metadata.tableName, query, options);
      }
      /**
       * The distinct command returns returns a list of distinct values for the given key across a collection.
       */
      distinct(entityClassOrName, key, query, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.distinct(metadata.tableName, key, query, options);
      }
      /**
       * Drops an index from this collection.
       */
      dropCollectionIndex(entityClassOrName, indexName, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.dropCollectionIndex(metadata.tableName, indexName, options);
      }
      /**
       * Drops all indexes from the collection.
       */
      dropCollectionIndexes(entityClassOrName) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.dropCollectionIndexes(metadata.tableName);
      }
      /**
       * Find a document and delete it in one atomic operation, requires a write lock for the duration of the operation.
       */
      findOneAndDelete(entityClassOrName, query, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.findOneAndDelete(metadata.tableName, query, options);
      }
      /**
       * Find a document and replace it in one atomic operation, requires a write lock for the duration of the operation.
       */
      findOneAndReplace(entityClassOrName, query, replacement, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.findOneAndReplace(metadata.tableName, query, replacement, options);
      }
      /**
       * Find a document and update it in one atomic operation, requires a write lock for the duration of the operation.
       */
      findOneAndUpdate(entityClassOrName, query, update, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.findOneAndUpdate(metadata.tableName, query, update, options);
      }
      /**
       * Retrieve all the indexes on the collection.
       */
      collectionIndexes(entityClassOrName) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.collectionIndexes(metadata.tableName);
      }
      /**
       * Retrieve all the indexes on the collection.
       */
      collectionIndexExists(entityClassOrName, indexes) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.collectionIndexExists(metadata.tableName, indexes);
      }
      /**
       * Retrieves this collections index info.
       */
      collectionIndexInformation(entityClassOrName, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.collectionIndexInformation(metadata.tableName, options);
      }
      /**
       * Initiate an In order bulk write operation, operations will be serially executed in the order they are added, creating a new operation for each switch in types.
       */
      initializeOrderedBulkOp(entityClassOrName, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.initializeOrderedBulkOp(metadata.tableName, options);
      }
      /**
       * Initiate a Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.
       */
      initializeUnorderedBulkOp(entityClassOrName, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.initializeUnorderedBulkOp(metadata.tableName, options);
      }
      /**
       * Inserts an array of documents into MongoDB.
       */
      insertMany(entityClassOrName, docs, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.insertMany(metadata.tableName, docs, options);
      }
      /**
       * Inserts a single document into MongoDB.
       */
      insertOne(entityClassOrName, doc, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.insertOne(metadata.tableName, doc, options);
      }
      /**
       * Returns if the collection is a capped collection.
       */
      isCapped(entityClassOrName) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.isCapped(metadata.tableName);
      }
      /**
       * Get the list of all indexes information for the collection.
       */
      listCollectionIndexes(entityClassOrName, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.listCollectionIndexes(metadata.tableName, options);
      }
      /**
       * Reindex all indexes on the collection Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.
       */
      rename(entityClassOrName, newName, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.rename(metadata.tableName, newName, options);
      }
      /**
       * Replace a document on MongoDB.
       */
      replaceOne(entityClassOrName, query, doc, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.replaceOne(metadata.tableName, query, doc, options);
      }
      /**
       * Get all the collection statistics.
       */
      stats(entityClassOrName, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.stats(metadata.tableName, options);
      }
      watch(entityClassOrName, pipeline, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.watch(metadata.tableName, pipeline, options);
      }
      /**
       * Update multiple documents on MongoDB.
       */
      updateMany(entityClassOrName, query, update, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.updateMany(metadata.tableName, query, update, options);
      }
      /**
       * Update a single document on MongoDB.
       */
      updateOne(entityClassOrName, query, update, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.updateOne(metadata.tableName, query, update, options);
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Converts FindManyOptions to mongodb query.
       */
      convertFindManyOptionsOrConditionsToMongodbQuery(optionsOrConditions) {
        if (!optionsOrConditions)
          return void 0;
        if (FindOptionsUtils_1.FindOptionsUtils.isFindManyOptions(optionsOrConditions))
          return typeof optionsOrConditions.where === "string" ? {} : optionsOrConditions.where;
        return optionsOrConditions;
      }
      /**
       * Converts FindOneOptions to mongodb query.
       */
      convertFindOneOptionsOrConditionsToMongodbQuery(optionsOrConditions) {
        if (!optionsOrConditions)
          return void 0;
        if (FindOptionsUtils_1.FindOptionsUtils.isFindOneOptions(optionsOrConditions))
          return typeof optionsOrConditions.where === "string" ? {} : optionsOrConditions.where;
        return optionsOrConditions;
      }
      /**
       * Converts FindOptions into mongodb order by criteria.
       */
      convertFindOptionsOrderToOrderCriteria(order) {
        return Object.keys(order).reduce((orderCriteria, key) => {
          switch (order[key]) {
            case "DESC":
              orderCriteria[key] = -1;
              break;
            case "ASC":
              orderCriteria[key] = 1;
              break;
            default:
              orderCriteria[key] = order[key];
          }
          return orderCriteria;
        }, {});
      }
      /**
       * Converts FindOptions into mongodb select by criteria.
       */
      convertFindOptionsSelectToProjectCriteria(selects) {
        if (Array.isArray(selects)) {
          return selects.reduce((projectCriteria, key) => {
            projectCriteria[key] = 1;
            return projectCriteria;
          }, {});
        } else {
          return {};
        }
      }
      /**
       * Ensures given id is an id for query.
       */
      convertMixedCriteria(metadata, idMap) {
        const objectIdInstance = PlatformTools_1.PlatformTools.load("mongodb").ObjectId;
        if (objectIdInstance.isValid(idMap)) {
          return {
            _id: new objectIdInstance(idMap)
          };
        }
        if (ObjectUtils_1.ObjectUtils.isObject(idMap)) {
          return metadata.columns.reduce((query, column) => {
            const columnValue = column.getEntityValue(idMap);
            if (columnValue !== void 0)
              query[column.databasePath] = columnValue;
            return query;
          }, {});
        }
        return {
          _id: new objectIdInstance(idMap)
        };
      }
      /**
       * Overrides cursor's toArray and next methods to convert results to entity automatically.
       */
      applyEntityTransformationToCursor(metadata, cursor) {
        const queryRunner = this.mongoQueryRunner;
        cursor["__to_array_func"] = cursor.toArray;
        cursor.toArray = () => cursor["__to_array_func"]().then(async (results) => {
          const transformer = new DocumentToEntityTransformer_1.DocumentToEntityTransformer();
          const entities = transformer.transformAll(results, metadata);
          await queryRunner.broadcaster.broadcast("Load", metadata, entities);
          return entities;
        });
        cursor["__next_func"] = cursor.next;
        cursor.next = () => cursor["__next_func"]().then(async (result) => {
          if (!result) {
            return result;
          }
          const transformer = new DocumentToEntityTransformer_1.DocumentToEntityTransformer();
          const entity = transformer.transform(result, metadata);
          await queryRunner.broadcaster.broadcast("Load", metadata, [
            entity
          ]);
          return entity;
        });
      }
      filterSoftDeleted(cursor, deleteDateColumn, query) {
        const { $or, ...restQuery } = query ?? {};
        cursor.filter({
          $or: [
            { [deleteDateColumn.propertyName]: { $eq: null } },
            ...Array.isArray($or) ? $or : []
          ],
          ...restQuery
        });
      }
      /**
       * Finds first entity that matches given conditions and/or find options.
       */
      async executeFindOne(entityClassOrName, optionsOrConditions, maybeOptions) {
        const objectIdInstance = PlatformTools_1.PlatformTools.load("mongodb").ObjectId;
        const id = optionsOrConditions instanceof objectIdInstance || typeof optionsOrConditions === "string" ? optionsOrConditions : void 0;
        const findOneOptionsOrConditions = id ? maybeOptions : optionsOrConditions;
        const query = this.convertFindOneOptionsOrConditionsToMongodbQuery(findOneOptionsOrConditions) || {};
        if (id) {
          query["_id"] = id instanceof objectIdInstance ? id : new objectIdInstance(id);
        }
        const cursor = this.createEntityCursor(entityClassOrName, query);
        const deleteDateColumn = this.connection.getMetadata(entityClassOrName).deleteDateColumn;
        if (FindOptionsUtils_1.FindOptionsUtils.isFindOneOptions(findOneOptionsOrConditions)) {
          if (findOneOptionsOrConditions.select)
            cursor.project(this.convertFindOptionsSelectToProjectCriteria(findOneOptionsOrConditions.select));
          if (findOneOptionsOrConditions.order)
            cursor.sort(this.convertFindOptionsOrderToOrderCriteria(findOneOptionsOrConditions.order));
          if (deleteDateColumn && !findOneOptionsOrConditions.withDeleted) {
            this.filterSoftDeleted(cursor, deleteDateColumn, query);
          }
        } else if (deleteDateColumn) {
          this.filterSoftDeleted(cursor, deleteDateColumn, query);
        }
        const result = await cursor.limit(1).toArray();
        return result.length > 0 ? result[0] : null;
      }
      async executeFind(entityClassOrName, optionsOrConditions) {
        const query = this.convertFindManyOptionsOrConditionsToMongodbQuery(optionsOrConditions);
        const cursor = this.createEntityCursor(entityClassOrName, query);
        const deleteDateColumn = this.connection.getMetadata(entityClassOrName).deleteDateColumn;
        if (FindOptionsUtils_1.FindOptionsUtils.isFindManyOptions(optionsOrConditions)) {
          if (optionsOrConditions.select)
            cursor.project(this.convertFindOptionsSelectToProjectCriteria(optionsOrConditions.select));
          if (optionsOrConditions.skip)
            cursor.skip(optionsOrConditions.skip);
          if (optionsOrConditions.take)
            cursor.limit(optionsOrConditions.take);
          if (optionsOrConditions.order)
            cursor.sort(this.convertFindOptionsOrderToOrderCriteria(optionsOrConditions.order));
          if (deleteDateColumn && !optionsOrConditions.withDeleted) {
            this.filterSoftDeleted(cursor, deleteDateColumn, query);
          }
        } else if (deleteDateColumn) {
          this.filterSoftDeleted(cursor, deleteDateColumn, query);
        }
        return cursor.toArray();
      }
      /**
       * Finds entities that match given find options or conditions.
       */
      async executeFindAndCount(entityClassOrName, optionsOrConditions) {
        const query = this.convertFindManyOptionsOrConditionsToMongodbQuery(optionsOrConditions);
        const cursor = this.createEntityCursor(entityClassOrName, query);
        const deleteDateColumn = this.connection.getMetadata(entityClassOrName).deleteDateColumn;
        if (FindOptionsUtils_1.FindOptionsUtils.isFindManyOptions(optionsOrConditions)) {
          if (optionsOrConditions.select)
            cursor.project(this.convertFindOptionsSelectToProjectCriteria(optionsOrConditions.select));
          if (optionsOrConditions.skip)
            cursor.skip(optionsOrConditions.skip);
          if (optionsOrConditions.take)
            cursor.limit(optionsOrConditions.take);
          if (optionsOrConditions.order)
            cursor.sort(this.convertFindOptionsOrderToOrderCriteria(optionsOrConditions.order));
          if (deleteDateColumn && !optionsOrConditions.withDeleted) {
            this.filterSoftDeleted(cursor, deleteDateColumn, query);
          }
        } else if (deleteDateColumn) {
          this.filterSoftDeleted(cursor, deleteDateColumn, query);
        }
        const [results, count] = await Promise.all([
          cursor.toArray(),
          this.count(entityClassOrName, query)
        ]);
        return [results, parseInt(count)];
      }
    };
    exports2.MongoEntityManager = MongoEntityManager2;
  }
});

// node_modules/typeorm/entity-manager/SqljsEntityManager.js
var require_SqljsEntityManager = __commonJS({
  "node_modules/typeorm/entity-manager/SqljsEntityManager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SqljsEntityManager = void 0;
    var EntityManager_1 = require_EntityManager();
    var SqljsEntityManager = class extends EntityManager_1.EntityManager {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection, queryRunner) {
        super(connection, queryRunner);
        this["@instanceof"] = Symbol.for("SqljsEntityManager");
        this.driver = connection.driver;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Loads either the definition from a file (Node.js) or localstorage (browser)
       * or uses the given definition to open a new database.
       */
      async loadDatabase(fileNameOrLocalStorageOrData) {
        await this.driver.load(fileNameOrLocalStorageOrData);
      }
      /**
       * Saves the current database to a file (Node.js) or localstorage (browser)
       * if fileNameOrLocalStorage is not set options.location is used.
       */
      async saveDatabase(fileNameOrLocalStorage) {
        await this.driver.save(fileNameOrLocalStorage);
      }
      /**
       * Returns the current database definition.
       */
      exportDatabase() {
        return this.driver.export();
      }
    };
    exports2.SqljsEntityManager = SqljsEntityManager;
  }
});

// node_modules/typeorm/entity-manager/EntityManagerFactory.js
var require_EntityManagerFactory = __commonJS({
  "node_modules/typeorm/entity-manager/EntityManagerFactory.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EntityManagerFactory = void 0;
    var EntityManager_1 = require_EntityManager();
    var MongoEntityManager_1 = require_MongoEntityManager();
    var SqljsEntityManager_1 = require_SqljsEntityManager();
    var EntityManagerFactory = class {
      /**
       * Creates a new entity manager depend on a given connection's driver.
       */
      create(connection, queryRunner) {
        if (connection.driver.options.type === "mongodb")
          return new MongoEntityManager_1.MongoEntityManager(connection);
        if (connection.driver.options.type === "sqljs")
          return new SqljsEntityManager_1.SqljsEntityManager(connection, queryRunner);
        return new EntityManager_1.EntityManager(connection, queryRunner);
      }
    };
    exports2.EntityManagerFactory = EntityManagerFactory;
  }
});

// node_modules/typeorm/schema-builder/view/View.js
var require_View = __commonJS({
  "node_modules/typeorm/schema-builder/view/View.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.View = void 0;
    var View2 = class _View {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(options) {
        this["@instanceof"] = Symbol.for("View");
        this.indices = [];
        if (options) {
          this.database = options.database;
          this.schema = options.schema;
          this.name = options.name;
          this.expression = options.expression;
          this.materialized = !!options.materialized;
        }
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Clones this table to a new table with all properties cloned.
       */
      clone() {
        return new _View({
          database: this.database,
          schema: this.schema,
          name: this.name,
          expression: this.expression,
          materialized: this.materialized
        });
      }
      /**
       * Add index
       */
      addIndex(index) {
        this.indices.push(index);
      }
      /**
       * Remove index
       */
      removeIndex(viewIndex) {
        const index = this.indices.find((index2) => index2.name === viewIndex.name);
        if (index) {
          this.indices.splice(this.indices.indexOf(index), 1);
        }
      }
      // -------------------------------------------------------------------------
      // Static Methods
      // -------------------------------------------------------------------------
      /**
       * Creates view from a given entity metadata.
       */
      static create(entityMetadata, driver) {
        const options = {
          database: entityMetadata.database,
          schema: entityMetadata.schema,
          name: driver.buildTableName(entityMetadata.tableName, entityMetadata.schema, entityMetadata.database),
          expression: entityMetadata.expression,
          materialized: entityMetadata.tableMetadataArgs.materialized
        };
        return new _View(options);
      }
    };
    exports2.View = View2;
  }
});

// node_modules/typeorm/schema-builder/util/ViewUtils.js
var require_ViewUtils = __commonJS({
  "node_modules/typeorm/schema-builder/util/ViewUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ViewUtils = void 0;
    var ViewUtils = class {
      /**
       * Comparator for .sort() that will order views bases on dependencies in creation order
       */
      static viewMetadataCmp(metadataA, metadataB) {
        if (!metadataA || !metadataB) {
          return 0;
        }
        if (metadataA.dependsOn && (metadataA.dependsOn.has(metadataB.target) || metadataA.dependsOn.has(metadataB.name))) {
          return 1;
        }
        if (metadataB.dependsOn && (metadataB.dependsOn.has(metadataA.target) || metadataB.dependsOn.has(metadataA.name))) {
          return -1;
        }
        return 0;
      }
    };
    exports2.ViewUtils = ViewUtils;
  }
});

// node_modules/typeorm/schema-builder/RdbmsSchemaBuilder.js
var require_RdbmsSchemaBuilder = __commonJS({
  "node_modules/typeorm/schema-builder/RdbmsSchemaBuilder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RdbmsSchemaBuilder = void 0;
    var Table_1 = require_Table();
    var TableColumn_1 = require_TableColumn();
    var TableForeignKey_1 = require_TableForeignKey();
    var TableIndex_1 = require_TableIndex();
    var TableUtils_1 = require_TableUtils();
    var TableUnique_1 = require_TableUnique();
    var TableCheck_1 = require_TableCheck();
    var TableExclusion_1 = require_TableExclusion();
    var View_1 = require_View();
    var ViewUtils_1 = require_ViewUtils();
    var DriverUtils_1 = require_DriverUtils();
    var RdbmsSchemaBuilder = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection) {
        this.connection = connection;
        this["@instanceof"] = Symbol.for("RdbmsSchemaBuilder");
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Creates complete schemas for the given entity metadatas.
       */
      async build() {
        this.queryRunner = this.connection.createQueryRunner();
        this.currentDatabase = this.connection.driver.database;
        this.currentSchema = this.connection.driver.schema;
        const isUsingTransactions = !(this.connection.driver.options.type === "cockroachdb") && !(this.connection.driver.options.type === "spanner") && this.connection.options.migrationsTransactionMode !== "none";
        await this.queryRunner.beforeMigration();
        if (isUsingTransactions) {
          await this.queryRunner.startTransaction();
        }
        try {
          await this.createMetadataTableIfNecessary(this.queryRunner);
          const tablePaths = this.entityToSyncMetadatas.map((metadata) => this.getTablePath(metadata));
          const viewPaths = this.viewEntityToSyncMetadatas.map((metadata) => this.getTablePath(metadata));
          await this.queryRunner.getTables(tablePaths);
          await this.queryRunner.getViews(viewPaths);
          await this.executeSchemaSyncOperationsInProperOrder();
          if (this.connection.queryResultCache)
            await this.connection.queryResultCache.synchronize(this.queryRunner);
          if (isUsingTransactions) {
            await this.queryRunner.commitTransaction();
          }
        } catch (error) {
          try {
            if (isUsingTransactions) {
              await this.queryRunner.rollbackTransaction();
            }
          } catch (rollbackError) {
          }
          throw error;
        } finally {
          await this.queryRunner.afterMigration();
          await this.queryRunner.release();
        }
      }
      /**
       * Create the typeorm_metadata table if necessary.
       */
      async createMetadataTableIfNecessary(queryRunner) {
        if (this.viewEntityToSyncMetadatas.length > 0 || this.hasGeneratedColumns()) {
          await this.createTypeormMetadataTable(queryRunner);
        }
      }
      /**
       * Returns sql queries to be executed by schema builder.
       */
      async log() {
        this.queryRunner = this.connection.createQueryRunner();
        try {
          const tablePaths = this.entityToSyncMetadatas.map((metadata) => this.getTablePath(metadata));
          const viewPaths = this.viewEntityToSyncMetadatas.map((metadata) => this.getTablePath(metadata));
          await this.queryRunner.getTables(tablePaths);
          await this.queryRunner.getViews(viewPaths);
          this.queryRunner.enableSqlMemory();
          await this.executeSchemaSyncOperationsInProperOrder();
          if (this.connection.queryResultCache)
            await this.connection.queryResultCache.synchronize(this.queryRunner);
          return this.queryRunner.getMemorySql();
        } finally {
          this.queryRunner.disableSqlMemory();
          await this.queryRunner.release();
        }
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Returns only entities that should be synced in the database.
       */
      get entityToSyncMetadatas() {
        return this.connection.entityMetadatas.filter((metadata) => metadata.synchronize && metadata.tableType !== "entity-child" && metadata.tableType !== "view");
      }
      /**
       * Returns only entities that should be synced in the database.
       */
      get viewEntityToSyncMetadatas() {
        return this.connection.entityMetadatas.filter((metadata) => metadata.tableType === "view" && metadata.synchronize).sort(ViewUtils_1.ViewUtils.viewMetadataCmp);
      }
      /**
       * Checks if there are at least one generated column.
       */
      hasGeneratedColumns() {
        return this.connection.entityMetadatas.some((entityMetadata) => {
          return entityMetadata.columns.some((column) => column.generatedType);
        });
      }
      /**
       * Executes schema sync operations in a proper order.
       * Order of operations matter here.
       */
      async executeSchemaSyncOperationsInProperOrder() {
        await this.dropOldViews();
        await this.dropOldForeignKeys();
        await this.dropOldIndices();
        await this.dropOldChecks();
        await this.dropOldExclusions();
        await this.dropCompositeUniqueConstraints();
        await this.renameColumns();
        await this.changeTableComment();
        await this.createNewTables();
        await this.dropRemovedColumns();
        await this.addNewColumns();
        await this.updatePrimaryKeys();
        await this.updateExistColumns();
        await this.createNewIndices();
        await this.createNewChecks();
        await this.createNewExclusions();
        await this.createCompositeUniqueConstraints();
        await this.createForeignKeys();
        await this.createViews();
        await this.createNewViewIndices();
      }
      getTablePath(target) {
        const parsed = this.connection.driver.parseTableName(target);
        return this.connection.driver.buildTableName(parsed.tableName, parsed.schema || this.currentSchema, parsed.database || this.currentDatabase);
      }
      /**
       * Drops all (old) foreign keys that exist in the tables, but do not exist in the entity metadata.
       */
      async dropOldForeignKeys() {
        for (const metadata of this.entityToSyncMetadatas) {
          const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === this.getTablePath(metadata));
          if (!table)
            continue;
          const tableForeignKeysToDrop = table.foreignKeys.filter((tableForeignKey) => {
            const metadataFK = metadata.foreignKeys.find((metadataForeignKey) => tableForeignKey.name === metadataForeignKey.name && this.getTablePath(tableForeignKey) === this.getTablePath(metadataForeignKey.referencedEntityMetadata));
            return !metadataFK || metadataFK.onDelete && metadataFK.onDelete !== tableForeignKey.onDelete || metadataFK.onUpdate && metadataFK.onUpdate !== tableForeignKey.onUpdate;
          });
          if (tableForeignKeysToDrop.length === 0)
            continue;
          this.connection.logger.logSchemaBuild(`dropping old foreign keys of ${table.name}: ${tableForeignKeysToDrop.map((dbForeignKey) => dbForeignKey.name).join(", ")}`);
          await this.queryRunner.dropForeignKeys(table, tableForeignKeysToDrop);
        }
      }
      /**
       * Rename tables
       */
      async renameTables() {
      }
      /**
       * Renames columns.
       * Works if only one column per table was changed.
       * Changes only column name. If something besides name was changed, these changes will be ignored.
       */
      async renameColumns() {
        for (const metadata of this.entityToSyncMetadatas) {
          const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === this.getTablePath(metadata));
          if (!table)
            continue;
          if (metadata.columns.length !== table.columns.length)
            continue;
          const renamedMetadataColumns = metadata.columns.filter((c) => !c.isVirtualProperty).filter((column) => {
            return !table.columns.find((tableColumn) => {
              return tableColumn.name === column.databaseName && tableColumn.type === this.connection.driver.normalizeType(column) && tableColumn.isNullable === column.isNullable && tableColumn.isUnique === this.connection.driver.normalizeIsUnique(column);
            });
          });
          if (renamedMetadataColumns.length === 0 || renamedMetadataColumns.length > 1)
            continue;
          const renamedTableColumns = table.columns.filter((tableColumn) => {
            return !metadata.columns.find((column) => {
              return !column.isVirtualProperty && column.databaseName === tableColumn.name && this.connection.driver.normalizeType(column) === tableColumn.type && column.isNullable === tableColumn.isNullable && this.connection.driver.normalizeIsUnique(column) === tableColumn.isUnique;
            });
          });
          if (renamedTableColumns.length === 0 || renamedTableColumns.length > 1)
            continue;
          const renamedColumn = renamedTableColumns[0].clone();
          renamedColumn.name = renamedMetadataColumns[0].databaseName;
          this.connection.logger.logSchemaBuild(`renaming column "${renamedTableColumns[0].name}" in "${table.name}" to "${renamedColumn.name}"`);
          await this.queryRunner.renameColumn(table, renamedTableColumns[0], renamedColumn);
        }
      }
      async dropOldIndices() {
        for (const metadata of this.entityToSyncMetadatas) {
          const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === this.getTablePath(metadata));
          if (!table)
            continue;
          const dropQueries = table.indices.filter((tableIndex) => {
            const indexMetadata = metadata.indices.find((index) => index.name === tableIndex.name);
            if (indexMetadata) {
              if (indexMetadata.synchronize === false)
                return false;
              if (indexMetadata.isUnique !== tableIndex.isUnique)
                return true;
              if (indexMetadata.isSpatial !== tableIndex.isSpatial)
                return true;
              if (this.connection.driver.isFullTextColumnTypeSupported() && indexMetadata.isFulltext !== tableIndex.isFulltext)
                return true;
              if (indexMetadata.columns.length !== tableIndex.columnNames.length)
                return true;
              return !indexMetadata.columns.every((column) => tableIndex.columnNames.indexOf(column.databaseName) !== -1);
            }
            return true;
          }).map(async (tableIndex) => {
            this.connection.logger.logSchemaBuild(`dropping an index: "${tableIndex.name}" from table ${table.name}`);
            await this.queryRunner.dropIndex(table, tableIndex);
          });
          await Promise.all(dropQueries);
        }
        if (this.connection.options.type === "postgres") {
          const postgresQueryRunner = this.queryRunner;
          for (const metadata of this.viewEntityToSyncMetadatas) {
            const view = this.queryRunner.loadedViews.find((view2) => this.getTablePath(view2) === this.getTablePath(metadata));
            if (!view)
              continue;
            const dropQueries = view.indices.filter((tableIndex) => {
              const indexMetadata = metadata.indices.find((index) => index.name === tableIndex.name);
              if (indexMetadata) {
                if (indexMetadata.synchronize === false)
                  return false;
                if (indexMetadata.isUnique !== tableIndex.isUnique)
                  return true;
                if (indexMetadata.isSpatial !== tableIndex.isSpatial)
                  return true;
                if (this.connection.driver.isFullTextColumnTypeSupported() && indexMetadata.isFulltext !== tableIndex.isFulltext)
                  return true;
                if (indexMetadata.columns.length !== tableIndex.columnNames.length)
                  return true;
                return !indexMetadata.columns.every((column) => tableIndex.columnNames.indexOf(column.databaseName) !== -1);
              }
              return true;
            }).map(async (tableIndex) => {
              this.connection.logger.logSchemaBuild(`dropping an index: "${tableIndex.name}" from view ${view.name}`);
              await postgresQueryRunner.dropViewIndex(view, tableIndex);
            });
            await Promise.all(dropQueries);
          }
        }
      }
      async dropOldChecks() {
        if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql")
          return;
        for (const metadata of this.entityToSyncMetadatas) {
          const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === this.getTablePath(metadata));
          if (!table)
            continue;
          const oldChecks = table.checks.filter((tableCheck) => {
            return !metadata.checks.find((checkMetadata) => checkMetadata.name === tableCheck.name);
          });
          if (oldChecks.length === 0)
            continue;
          this.connection.logger.logSchemaBuild(`dropping old check constraint: ${oldChecks.map((check) => `"${check.name}"`).join(", ")} from table "${table.name}"`);
          await this.queryRunner.dropCheckConstraints(table, oldChecks);
        }
      }
      async dropCompositeUniqueConstraints() {
        for (const metadata of this.entityToSyncMetadatas) {
          const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === this.getTablePath(metadata));
          if (!table)
            continue;
          const compositeUniques = table.uniques.filter((tableUnique) => {
            return tableUnique.columnNames.length > 1 && !metadata.uniques.find((uniqueMetadata) => uniqueMetadata.name === tableUnique.name);
          });
          if (compositeUniques.length === 0)
            continue;
          this.connection.logger.logSchemaBuild(`dropping old unique constraint: ${compositeUniques.map((unique) => `"${unique.name}"`).join(", ")} from table "${table.name}"`);
          await this.queryRunner.dropUniqueConstraints(table, compositeUniques);
        }
      }
      async dropOldExclusions() {
        if (!(this.connection.driver.options.type === "postgres"))
          return;
        for (const metadata of this.entityToSyncMetadatas) {
          const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === this.getTablePath(metadata));
          if (!table)
            continue;
          const oldExclusions = table.exclusions.filter((tableExclusion) => {
            return !metadata.exclusions.find((exclusionMetadata) => exclusionMetadata.name === tableExclusion.name);
          });
          if (oldExclusions.length === 0)
            continue;
          this.connection.logger.logSchemaBuild(`dropping old exclusion constraint: ${oldExclusions.map((exclusion) => `"${exclusion.name}"`).join(", ")} from table "${table.name}"`);
          await this.queryRunner.dropExclusionConstraints(table, oldExclusions);
        }
      }
      /**
       * change table comment
       */
      async changeTableComment() {
        for (const metadata of this.entityToSyncMetadatas) {
          const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === this.getTablePath(metadata));
          if (!table)
            continue;
          if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "postgres") {
            const newComment = metadata.comment;
            await this.queryRunner.changeTableComment(table, newComment);
          }
        }
      }
      /**
       * Creates tables that do not exist in the database yet.
       * New tables are created without foreign and primary keys.
       * Primary key only can be created in conclusion with auto generated column.
       */
      async createNewTables() {
        for (const metadata of this.entityToSyncMetadatas) {
          const existTable = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === this.getTablePath(metadata));
          if (existTable)
            continue;
          this.connection.logger.logSchemaBuild(`creating a new table: ${this.getTablePath(metadata)}`);
          const table = Table_1.Table.create(metadata, this.connection.driver);
          await this.queryRunner.createTable(table, false, false);
          this.queryRunner.loadedTables.push(table);
        }
      }
      async createViews() {
        for (const metadata of this.viewEntityToSyncMetadatas) {
          const existView = this.queryRunner.loadedViews.find((view2) => {
            const viewExpression = typeof view2.expression === "string" ? view2.expression.trim() : view2.expression(this.connection).getQuery();
            const metadataExpression = typeof metadata.expression === "string" ? metadata.expression.trim() : metadata.expression(this.connection).getQuery();
            return this.getTablePath(view2) === this.getTablePath(metadata) && viewExpression === metadataExpression;
          });
          if (existView)
            continue;
          this.connection.logger.logSchemaBuild(`creating a new view: ${this.getTablePath(metadata)}`);
          const view = View_1.View.create(metadata, this.connection.driver);
          await this.queryRunner.createView(view, true);
          this.queryRunner.loadedViews.push(view);
        }
      }
      async dropOldViews() {
        const droppedViews = [];
        const viewEntityToSyncMetadatas = this.viewEntityToSyncMetadatas;
        const viewToMetadata = /* @__PURE__ */ new Map();
        for (const view of this.queryRunner.loadedViews) {
          const viewMetadata = viewEntityToSyncMetadatas.find((metadata) => {
            return this.getTablePath(view) === this.getTablePath(metadata);
          });
          if (viewMetadata) {
            viewToMetadata.set(view, viewMetadata);
          }
        }
        for (const view of this.queryRunner.loadedViews) {
          const viewMetadata = viewToMetadata.get(view);
          if (!viewMetadata) {
            continue;
          }
          const viewExpression = typeof view.expression === "string" ? view.expression.trim() : view.expression(this.connection).getQuery();
          const metadataExpression = typeof viewMetadata.expression === "string" ? viewMetadata.expression.trim() : viewMetadata.expression(this.connection).getQuery();
          if (viewExpression === metadataExpression)
            continue;
          this.connection.logger.logSchemaBuild(`dropping an old view: ${view.name}`);
          droppedViews.push(view);
        }
        const viewDependencyChain = (view) => {
          const viewMetadata = viewToMetadata.get(view);
          let viewWithDependencies = [view];
          if (!viewMetadata) {
            return viewWithDependencies;
          }
          for (const [currentView, currentMetadata] of viewToMetadata.entries()) {
            if (currentView === view) {
              continue;
            }
            if (currentMetadata.dependsOn && (currentMetadata.dependsOn.has(viewMetadata.target) || currentMetadata.dependsOn.has(viewMetadata.name))) {
              viewWithDependencies = viewWithDependencies.concat(viewDependencyChain(currentView));
            }
          }
          return viewWithDependencies;
        };
        const droppedViewsWithDependencies = new Set(
          // Collect all dropped views, and their dependencies
          droppedViews.map((view) => viewDependencyChain(view)).reduce((all, segment) => {
            return all.concat(segment);
          }, []).sort((a, b) => {
            return ViewUtils_1.ViewUtils.viewMetadataCmp(viewToMetadata.get(a), viewToMetadata.get(b));
          }).reverse()
        );
        for (const view of droppedViewsWithDependencies) {
          await this.queryRunner.dropView(view);
        }
        this.queryRunner.loadedViews = this.queryRunner.loadedViews.filter((view) => !droppedViewsWithDependencies.has(view));
      }
      /**
       * Drops all columns that exist in the table, but does not exist in the metadata (left old).
       * We drop their keys too, since it should be safe.
       */
      async dropRemovedColumns() {
        for (const metadata of this.entityToSyncMetadatas) {
          const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === this.getTablePath(metadata));
          if (!table)
            continue;
          const droppedTableColumns = table.columns.filter((tableColumn) => {
            return !metadata.columns.find((columnMetadata) => columnMetadata.isVirtualProperty || columnMetadata.databaseName === tableColumn.name);
          });
          if (droppedTableColumns.length === 0)
            continue;
          this.connection.logger.logSchemaBuild(`columns dropped in ${table.name}: ` + droppedTableColumns.map((column) => column.name).join(", "));
          await this.queryRunner.dropColumns(table, droppedTableColumns);
        }
      }
      /**
       * Adds columns from metadata which does not exist in the table.
       * Columns are created without keys.
       */
      async addNewColumns() {
        for (const metadata of this.entityToSyncMetadatas) {
          const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === this.getTablePath(metadata));
          if (!table)
            continue;
          const newColumnMetadatas = metadata.columns.filter((columnMetadata) => {
            return !columnMetadata.isVirtualProperty && !table.columns.find((tableColumn) => tableColumn.name === columnMetadata.databaseName);
          });
          if (newColumnMetadatas.length === 0)
            continue;
          const newTableColumnOptions = this.metadataColumnsToTableColumnOptions(newColumnMetadatas);
          const newTableColumns = newTableColumnOptions.map((option) => new TableColumn_1.TableColumn(option));
          if (newTableColumns.length === 0)
            continue;
          this.connection.logger.logSchemaBuild(`new columns added: ` + newColumnMetadatas.map((column) => column.databaseName).join(", "));
          await this.queryRunner.addColumns(table, newTableColumns);
        }
      }
      /**
       * Updates composite primary keys.
       */
      async updatePrimaryKeys() {
        for (const metadata of this.entityToSyncMetadatas) {
          const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === this.getTablePath(metadata));
          if (!table)
            continue;
          const primaryMetadataColumns = metadata.columns.filter((column) => column.isPrimary);
          const primaryTableColumns = table.columns.filter((column) => column.isPrimary);
          if (primaryTableColumns.length !== primaryMetadataColumns.length && primaryMetadataColumns.length > 1) {
            const changedPrimaryColumns = primaryMetadataColumns.map((primaryMetadataColumn) => {
              return new TableColumn_1.TableColumn(TableUtils_1.TableUtils.createTableColumnOptions(primaryMetadataColumn, this.connection.driver));
            });
            await this.queryRunner.updatePrimaryKeys(table, changedPrimaryColumns);
          }
        }
      }
      /**
       * Update all exist columns which metadata has changed.
       * Still don't create keys. Also we don't touch foreign keys of the changed columns.
       */
      async updateExistColumns() {
        for (const metadata of this.entityToSyncMetadatas) {
          const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === this.getTablePath(metadata));
          if (!table)
            continue;
          const changedColumns = this.connection.driver.findChangedColumns(table.columns, metadata.columns);
          if (changedColumns.length === 0)
            continue;
          for (const changedColumn of changedColumns) {
            await this.dropColumnReferencedForeignKeys(this.getTablePath(metadata), changedColumn.databaseName);
          }
          for (const changedColumn of changedColumns) {
            await this.dropColumnCompositeIndices(this.getTablePath(metadata), changedColumn.databaseName);
          }
          if (!(DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql" || this.connection.driver.options.type === "spanner")) {
            for (const changedColumn of changedColumns) {
              await this.dropColumnCompositeUniques(this.getTablePath(metadata), changedColumn.databaseName);
            }
          }
          const newAndOldTableColumns = changedColumns.map((changedColumn) => {
            const oldTableColumn = table.columns.find((column) => column.name === changedColumn.databaseName);
            const newTableColumnOptions = TableUtils_1.TableUtils.createTableColumnOptions(changedColumn, this.connection.driver);
            const newTableColumn = new TableColumn_1.TableColumn(newTableColumnOptions);
            return {
              oldColumn: oldTableColumn,
              newColumn: newTableColumn
            };
          });
          if (newAndOldTableColumns.length === 0)
            continue;
          this.connection.logger.logSchemaBuild(`columns changed in "${table.name}". updating: ` + changedColumns.map((column) => column.databaseName).join(", "));
          await this.queryRunner.changeColumns(table, newAndOldTableColumns);
        }
      }
      /**
       * Creates composite indices which are missing in db yet.
       */
      async createNewIndices() {
        for (const metadata of this.entityToSyncMetadatas) {
          const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === this.getTablePath(metadata));
          if (!table)
            continue;
          const newIndices = metadata.indices.filter((indexMetadata) => !table.indices.find((tableIndex) => tableIndex.name === indexMetadata.name) && indexMetadata.synchronize === true).map((indexMetadata) => TableIndex_1.TableIndex.create(indexMetadata));
          if (newIndices.length === 0)
            continue;
          this.connection.logger.logSchemaBuild(`adding new indices ${newIndices.map((index) => `"${index.name}"`).join(", ")} in table "${table.name}"`);
          await this.queryRunner.createIndices(table, newIndices);
        }
      }
      /**
       * Creates indices for materialized views.
       */
      async createNewViewIndices() {
        if (this.connection.options.type !== "postgres" || !DriverUtils_1.DriverUtils.isPostgresFamily(this.connection.driver)) {
          return;
        }
        const postgresQueryRunner = this.queryRunner;
        for (const metadata of this.viewEntityToSyncMetadatas) {
          const view = this.queryRunner.loadedViews.find((view2) => {
            const viewExpression = typeof view2.expression === "string" ? view2.expression.trim() : view2.expression(this.connection).getQuery();
            const metadataExpression = typeof metadata.expression === "string" ? metadata.expression.trim() : metadata.expression(this.connection).getQuery();
            return this.getTablePath(view2) === this.getTablePath(metadata) && viewExpression === metadataExpression;
          });
          if (!view || !view.materialized)
            continue;
          const newIndices = metadata.indices.filter((indexMetadata) => !view.indices.find((tableIndex) => tableIndex.name === indexMetadata.name) && indexMetadata.synchronize === true).map((indexMetadata) => TableIndex_1.TableIndex.create(indexMetadata));
          if (newIndices.length === 0)
            continue;
          this.connection.logger.logSchemaBuild(`adding new indices ${newIndices.map((index) => `"${index.name}"`).join(", ")} in view "${view.name}"`);
          await postgresQueryRunner.createViewIndices(view, newIndices);
        }
      }
      async createNewChecks() {
        if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql")
          return;
        for (const metadata of this.entityToSyncMetadatas) {
          const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === this.getTablePath(metadata));
          if (!table)
            continue;
          const newChecks = metadata.checks.filter((checkMetadata) => !table.checks.find((tableCheck) => tableCheck.name === checkMetadata.name)).map((checkMetadata) => TableCheck_1.TableCheck.create(checkMetadata));
          if (newChecks.length === 0)
            continue;
          this.connection.logger.logSchemaBuild(`adding new check constraints: ${newChecks.map((index) => `"${index.name}"`).join(", ")} in table "${table.name}"`);
          await this.queryRunner.createCheckConstraints(table, newChecks);
        }
      }
      /**
       * Creates composite uniques which are missing in db yet.
       */
      async createCompositeUniqueConstraints() {
        for (const metadata of this.entityToSyncMetadatas) {
          const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === this.getTablePath(metadata));
          if (!table)
            continue;
          const compositeUniques = metadata.uniques.filter((uniqueMetadata) => uniqueMetadata.columns.length > 1 && !table.uniques.find((tableUnique) => tableUnique.name === uniqueMetadata.name)).map((uniqueMetadata) => TableUnique_1.TableUnique.create(uniqueMetadata));
          if (compositeUniques.length === 0)
            continue;
          this.connection.logger.logSchemaBuild(`adding new unique constraints: ${compositeUniques.map((unique) => `"${unique.name}"`).join(", ")} in table "${table.name}"`);
          await this.queryRunner.createUniqueConstraints(table, compositeUniques);
        }
      }
      /**
       * Creates exclusions which are missing in db yet.
       */
      async createNewExclusions() {
        if (!(this.connection.driver.options.type === "postgres"))
          return;
        for (const metadata of this.entityToSyncMetadatas) {
          const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === this.getTablePath(metadata));
          if (!table)
            continue;
          const newExclusions = metadata.exclusions.filter((exclusionMetadata) => !table.exclusions.find((tableExclusion) => tableExclusion.name === exclusionMetadata.name)).map((exclusionMetadata) => TableExclusion_1.TableExclusion.create(exclusionMetadata));
          if (newExclusions.length === 0)
            continue;
          this.connection.logger.logSchemaBuild(`adding new exclusion constraints: ${newExclusions.map((exclusion) => `"${exclusion.name}"`).join(", ")} in table "${table.name}"`);
          await this.queryRunner.createExclusionConstraints(table, newExclusions);
        }
      }
      /**
       * Creates foreign keys which does not exist in the table yet.
       */
      async createForeignKeys() {
        for (const metadata of this.entityToSyncMetadatas) {
          const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === this.getTablePath(metadata));
          if (!table)
            continue;
          const newKeys = metadata.foreignKeys.filter((foreignKey) => {
            return !table.foreignKeys.find((dbForeignKey) => dbForeignKey.name === foreignKey.name && this.getTablePath(dbForeignKey) === this.getTablePath(foreignKey.referencedEntityMetadata));
          });
          if (newKeys.length === 0)
            continue;
          const dbForeignKeys = newKeys.map((foreignKeyMetadata) => TableForeignKey_1.TableForeignKey.create(foreignKeyMetadata, this.connection.driver));
          this.connection.logger.logSchemaBuild(`creating a foreign keys: ${newKeys.map((key) => key.name).join(", ")} on table "${table.name}"`);
          await this.queryRunner.createForeignKeys(table, dbForeignKeys);
        }
      }
      /**
       * Drops all foreign keys where given column of the given table is being used.
       */
      async dropColumnReferencedForeignKeys(tablePath, columnName) {
        const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === tablePath);
        if (!table)
          return;
        const tablesWithFK = [];
        const columnForeignKey = table.foreignKeys.find((foreignKey) => foreignKey.columnNames.indexOf(columnName) !== -1);
        if (columnForeignKey) {
          const clonedTable = table.clone();
          clonedTable.foreignKeys = [columnForeignKey];
          tablesWithFK.push(clonedTable);
          table.removeForeignKey(columnForeignKey);
        }
        for (const loadedTable of this.queryRunner.loadedTables) {
          const dependForeignKeys = loadedTable.foreignKeys.filter((foreignKey) => {
            return this.getTablePath(foreignKey) === tablePath && foreignKey.referencedColumnNames.indexOf(columnName) !== -1;
          });
          if (dependForeignKeys.length > 0) {
            const clonedTable = loadedTable.clone();
            clonedTable.foreignKeys = dependForeignKeys;
            tablesWithFK.push(clonedTable);
            dependForeignKeys.forEach((dependForeignKey) => loadedTable.removeForeignKey(dependForeignKey));
          }
        }
        if (tablesWithFK.length > 0) {
          for (const tableWithFK of tablesWithFK) {
            this.connection.logger.logSchemaBuild(`dropping related foreign keys of ${tableWithFK.name}: ${tableWithFK.foreignKeys.map((foreignKey) => foreignKey.name).join(", ")}`);
            await this.queryRunner.dropForeignKeys(tableWithFK, tableWithFK.foreignKeys);
          }
        }
      }
      /**
       * Drops all composite indices, related to given column.
       */
      async dropColumnCompositeIndices(tablePath, columnName) {
        const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === tablePath);
        if (!table)
          return;
        const relatedIndices = table.indices.filter((index) => index.columnNames.length > 1 && index.columnNames.indexOf(columnName) !== -1);
        if (relatedIndices.length === 0)
          return;
        this.connection.logger.logSchemaBuild(`dropping related indices of "${tablePath}"."${columnName}": ${relatedIndices.map((index) => index.name).join(", ")}`);
        await this.queryRunner.dropIndices(table, relatedIndices);
      }
      /**
       * Drops all composite uniques, related to given column.
       */
      async dropColumnCompositeUniques(tablePath, columnName) {
        const table = this.queryRunner.loadedTables.find((table2) => this.getTablePath(table2) === tablePath);
        if (!table)
          return;
        const relatedUniques = table.uniques.filter((unique) => unique.columnNames.length > 1 && unique.columnNames.indexOf(columnName) !== -1);
        if (relatedUniques.length === 0)
          return;
        this.connection.logger.logSchemaBuild(`dropping related unique constraints of "${tablePath}"."${columnName}": ${relatedUniques.map((unique) => unique.name).join(", ")}`);
        await this.queryRunner.dropUniqueConstraints(table, relatedUniques);
      }
      /**
       * Creates new columns from the given column metadatas.
       */
      metadataColumnsToTableColumnOptions(columns) {
        return columns.map((columnMetadata) => TableUtils_1.TableUtils.createTableColumnOptions(columnMetadata, this.connection.driver));
      }
      /**
       * Creates typeorm service table for storing user defined Views and generate columns.
       */
      async createTypeormMetadataTable(queryRunner) {
        const schema = this.currentSchema;
        const database = this.currentDatabase;
        const typeormMetadataTable = this.connection.driver.buildTableName(this.connection.metadataTableName, schema, database);
        const isPrimary = this.connection.driver.options.type === "spanner";
        await queryRunner.createTable(new Table_1.Table({
          database,
          schema,
          name: typeormMetadataTable,
          columns: [
            {
              name: "type",
              type: this.connection.driver.normalizeType({
                type: this.connection.driver.mappedDataTypes.metadataType
              }),
              isNullable: false,
              isPrimary
            },
            {
              name: "database",
              type: this.connection.driver.normalizeType({
                type: this.connection.driver.mappedDataTypes.metadataDatabase
              }),
              isNullable: true,
              isPrimary
            },
            {
              name: "schema",
              type: this.connection.driver.normalizeType({
                type: this.connection.driver.mappedDataTypes.metadataSchema
              }),
              isNullable: true,
              isPrimary
            },
            {
              name: "table",
              type: this.connection.driver.normalizeType({
                type: this.connection.driver.mappedDataTypes.metadataTable
              }),
              isNullable: true,
              isPrimary
            },
            {
              name: "name",
              type: this.connection.driver.normalizeType({
                type: this.connection.driver.mappedDataTypes.metadataName
              }),
              isNullable: true,
              isPrimary
            },
            {
              name: "value",
              type: this.connection.driver.normalizeType({
                type: this.connection.driver.mappedDataTypes.metadataValue
              }),
              isNullable: true,
              isPrimary
            }
          ]
        }), true);
      }
    };
    exports2.RdbmsSchemaBuilder = RdbmsSchemaBuilder;
  }
});

// node_modules/typeorm/driver/Query.js
var require_Query = __commonJS({
  "node_modules/typeorm/driver/Query.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Query = void 0;
    var Query = class {
      constructor(query, parameters) {
        this.query = query;
        this.parameters = parameters;
        this["@instanceof"] = Symbol.for("Query");
      }
    };
    exports2.Query = Query;
  }
});

// node_modules/typeorm/driver/SqlInMemory.js
var require_SqlInMemory = __commonJS({
  "node_modules/typeorm/driver/SqlInMemory.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SqlInMemory = void 0;
    var SqlInMemory = class {
      constructor() {
        this.upQueries = [];
        this.downQueries = [];
      }
    };
    exports2.SqlInMemory = SqlInMemory;
  }
});

// node_modules/typeorm/query-runner/BaseQueryRunner.js
var require_BaseQueryRunner = __commonJS({
  "node_modules/typeorm/query-runner/BaseQueryRunner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseQueryRunner = void 0;
    var Query_1 = require_Query();
    var SqlInMemory_1 = require_SqlInMemory();
    var TypeORMError_1 = require_TypeORMError();
    var OrmUtils_1 = require_OrmUtils();
    var InstanceChecker_1 = require_InstanceChecker();
    var SqlTagUtils_1 = require_SqlTagUtils();
    var BaseQueryRunner = class {
      constructor() {
        this.isReleased = false;
        this.isTransactionActive = false;
        this.data = {};
        this.loadedTables = [];
        this.loadedViews = [];
        this.sqlMemoryMode = false;
        this.sqlInMemory = new SqlInMemory_1.SqlInMemory();
        this.transactionDepth = 0;
        this.cachedTablePaths = {};
      }
      /**
       * Tagged template function that executes raw SQL query and returns raw database results.
       * Template expressions are automatically transformed into database parameters.
       * Raw query execution is supported only by relational databases (MongoDB is not supported).
       * Note: Don't call this as a regular function, it is meant to be used with backticks to tag a template literal.
       * Example: queryRunner.sql`SELECT * FROM table_name WHERE id = ${id}`
       */
      async sql(strings, ...values) {
        const { query, parameters } = (0, SqlTagUtils_1.buildSqlTag)({
          driver: this.connection.driver,
          strings,
          expressions: values
        });
        return await this.query(query, parameters);
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Called before migrations are run.
       */
      async beforeMigration() {
      }
      /**
       * Called after migrations are run.
       */
      async afterMigration() {
      }
      /**
       * Loads given table's data from the database.
       */
      async getTable(tablePath) {
        this.loadedTables = await this.loadTables([tablePath]);
        return this.loadedTables.length > 0 ? this.loadedTables[0] : void 0;
      }
      /**
       * Loads all tables (with given names) from the database.
       */
      async getTables(tableNames) {
        if (!tableNames) {
          return await this.loadTables(tableNames);
        }
        this.loadedTables = await this.loadTables(tableNames);
        return this.loadedTables;
      }
      /**
       * Loads given view's data from the database.
       */
      async getView(viewPath) {
        this.loadedViews = await this.loadViews([viewPath]);
        return this.loadedViews.length > 0 ? this.loadedViews[0] : void 0;
      }
      /**
       * Loads given view's data from the database.
       */
      async getViews(viewPaths) {
        this.loadedViews = await this.loadViews(viewPaths);
        return this.loadedViews;
      }
      /**
       * Enables special query runner mode in which sql queries won't be executed,
       * instead they will be memorized into a special variable inside query runner.
       * You can get memorized sql using getMemorySql() method.
       */
      enableSqlMemory() {
        this.sqlInMemory = new SqlInMemory_1.SqlInMemory();
        this.sqlMemoryMode = true;
      }
      /**
       * Disables special query runner mode in which sql queries won't be executed
       * started by calling enableSqlMemory() method.
       *
       * Previously memorized sql will be flushed.
       */
      disableSqlMemory() {
        this.sqlInMemory = new SqlInMemory_1.SqlInMemory();
        this.sqlMemoryMode = false;
      }
      /**
       * Flushes all memorized sqls.
       */
      clearSqlMemory() {
        this.sqlInMemory = new SqlInMemory_1.SqlInMemory();
      }
      /**
       * Gets sql stored in the memory. Parameters in the sql are already replaced.
       */
      getMemorySql() {
        return this.sqlInMemory;
      }
      /**
       * Executes up sql queries.
       */
      async executeMemoryUpSql() {
        for (const { query, parameters } of this.sqlInMemory.upQueries) {
          await this.query(query, parameters);
        }
      }
      /**
       * Executes down sql queries.
       */
      async executeMemoryDownSql() {
        for (const { query, parameters } of this.sqlInMemory.downQueries.reverse()) {
          await this.query(query, parameters);
        }
      }
      getReplicationMode() {
        return this.mode;
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Gets view from previously loaded views, otherwise loads it from database.
       */
      async getCachedView(viewName) {
        const view = this.loadedViews.find((view2) => view2.name === viewName);
        if (view)
          return view;
        const foundViews = await this.loadViews([viewName]);
        if (foundViews.length > 0) {
          this.loadedViews.push(foundViews[0]);
          return foundViews[0];
        } else {
          throw new TypeORMError_1.TypeORMError(`View "${viewName}" does not exist.`);
        }
      }
      /**
       * Gets table from previously loaded tables, otherwise loads it from database.
       */
      async getCachedTable(tableName) {
        if (tableName in this.cachedTablePaths) {
          const tablePath = this.cachedTablePaths[tableName];
          const table = this.loadedTables.find((table2) => this.getTablePath(table2) === tablePath);
          if (table) {
            return table;
          }
        }
        const foundTables = await this.loadTables([tableName]);
        if (foundTables.length > 0) {
          const foundTablePath = this.getTablePath(foundTables[0]);
          const cachedTable = this.loadedTables.find((table) => this.getTablePath(table) === foundTablePath);
          if (!cachedTable) {
            this.cachedTablePaths[tableName] = this.getTablePath(foundTables[0]);
            this.loadedTables.push(foundTables[0]);
            return foundTables[0];
          } else {
            return cachedTable;
          }
        } else {
          throw new TypeORMError_1.TypeORMError(`Table "${tableName}" does not exist.`);
        }
      }
      /**
       * Replaces loaded table with given changed table.
       */
      replaceCachedTable(table, changedTable) {
        const oldTablePath = this.getTablePath(table);
        const foundTable = this.loadedTables.find((loadedTable) => this.getTablePath(loadedTable) === oldTablePath);
        for (const [key, cachedPath] of Object.entries(this.cachedTablePaths)) {
          if (cachedPath === oldTablePath) {
            this.cachedTablePaths[key] = this.getTablePath(changedTable);
          }
        }
        if (foundTable) {
          foundTable.database = changedTable.database;
          foundTable.schema = changedTable.schema;
          foundTable.name = changedTable.name;
          foundTable.columns = changedTable.columns;
          foundTable.indices = changedTable.indices;
          foundTable.foreignKeys = changedTable.foreignKeys;
          foundTable.uniques = changedTable.uniques;
          foundTable.checks = changedTable.checks;
          foundTable.justCreated = changedTable.justCreated;
          foundTable.engine = changedTable.engine;
          foundTable.comment = changedTable.comment;
        }
      }
      getTablePath(target) {
        const parsed = this.connection.driver.parseTableName(target);
        return this.connection.driver.buildTableName(parsed.tableName, parsed.schema, parsed.database);
      }
      getTypeormMetadataTableName() {
        const options = this.connection.driver.options;
        return this.connection.driver.buildTableName(this.connection.metadataTableName, options.schema, options.database);
      }
      /**
       * Generates SQL query to select record from typeorm metadata table.
       */
      selectTypeormMetadataSql({ database, schema, table, type, name }) {
        const qb = this.connection.createQueryBuilder();
        const selectQb = qb.select().from(this.getTypeormMetadataTableName(), "t").where(`${qb.escape("type")} = :type`, { type }).andWhere(`${qb.escape("name")} = :name`, { name });
        if (database) {
          selectQb.andWhere(`${qb.escape("database")} = :database`, {
            database
          });
        }
        if (schema) {
          selectQb.andWhere(`${qb.escape("schema")} = :schema`, { schema });
        }
        if (table) {
          selectQb.andWhere(`${qb.escape("table")} = :table`, { table });
        }
        const [query, parameters] = selectQb.getQueryAndParameters();
        return new Query_1.Query(query, parameters);
      }
      /**
       * Generates SQL query to insert a record into typeorm metadata table.
       */
      insertTypeormMetadataSql({ database, schema, table, type, name, value }) {
        const [query, parameters] = this.connection.createQueryBuilder().insert().into(this.getTypeormMetadataTableName()).values({
          database,
          schema,
          table,
          type,
          name,
          value
        }).getQueryAndParameters();
        return new Query_1.Query(query, parameters);
      }
      /**
       * Generates SQL query to delete a record from typeorm metadata table.
       */
      deleteTypeormMetadataSql({ database, schema, table, type, name }) {
        const qb = this.connection.createQueryBuilder();
        const deleteQb = qb.delete().from(this.getTypeormMetadataTableName()).where(`${qb.escape("type")} = :type`, { type }).andWhere(`${qb.escape("name")} = :name`, { name });
        if (database) {
          deleteQb.andWhere(`${qb.escape("database")} = :database`, {
            database
          });
        }
        if (schema) {
          deleteQb.andWhere(`${qb.escape("schema")} = :schema`, { schema });
        }
        if (table) {
          deleteQb.andWhere(`${qb.escape("table")} = :table`, { table });
        }
        const [query, parameters] = deleteQb.getQueryAndParameters();
        return new Query_1.Query(query, parameters);
      }
      /**
       * Checks if at least one of column properties was changed.
       * Does not checks column type, length and autoincrement, because these properties changes separately.
       */
      isColumnChanged(oldColumn, newColumn, checkDefault, checkComment, checkEnum = true) {
        return oldColumn.charset !== newColumn.charset || oldColumn.collation !== newColumn.collation || oldColumn.precision !== newColumn.precision || oldColumn.scale !== newColumn.scale || oldColumn.width !== newColumn.width || // MySQL only
        oldColumn.zerofill !== newColumn.zerofill || // MySQL only
        oldColumn.unsigned !== newColumn.unsigned || // MySQL only
        oldColumn.asExpression !== newColumn.asExpression || checkDefault && oldColumn.default !== newColumn.default || oldColumn.onUpdate !== newColumn.onUpdate || // MySQL only
        oldColumn.isNullable !== newColumn.isNullable || checkComment && oldColumn.comment !== newColumn.comment || checkEnum && this.isEnumChanged(oldColumn, newColumn);
      }
      isEnumChanged(oldColumn, newColumn) {
        return !OrmUtils_1.OrmUtils.isArraysEqual(oldColumn.enum || [], newColumn.enum || []);
      }
      /**
       * Checks if column length is by default.
       */
      isDefaultColumnLength(table, column, length) {
        if (this.connection.hasMetadata(table.name)) {
          const metadata = this.connection.getMetadata(table.name);
          const columnMetadata = metadata.findColumnWithDatabaseName(column.name);
          if (columnMetadata) {
            const columnMetadataLength = this.connection.driver.getColumnLength(columnMetadata);
            if (columnMetadataLength)
              return false;
          }
        }
        if (this.connection.driver.dataTypeDefaults && this.connection.driver.dataTypeDefaults[column.type] && this.connection.driver.dataTypeDefaults[column.type].length) {
          return this.connection.driver.dataTypeDefaults[column.type].length.toString() === length.toString();
        }
        return false;
      }
      /**
       * Checks if column precision is by default.
       */
      isDefaultColumnPrecision(table, column, precision) {
        if (this.connection.hasMetadata(table.name)) {
          const metadata = this.connection.getMetadata(table.name);
          const columnMetadata = metadata.findColumnWithDatabaseName(column.name);
          if (columnMetadata && columnMetadata.precision !== null && columnMetadata.precision !== void 0)
            return false;
        }
        if (this.connection.driver.dataTypeDefaults && this.connection.driver.dataTypeDefaults[column.type] && this.connection.driver.dataTypeDefaults[column.type].precision !== null && this.connection.driver.dataTypeDefaults[column.type].precision !== void 0)
          return this.connection.driver.dataTypeDefaults[column.type].precision === precision;
        return false;
      }
      /**
       * Checks if column scale is by default.
       */
      isDefaultColumnScale(table, column, scale) {
        if (this.connection.hasMetadata(table.name)) {
          const metadata = this.connection.getMetadata(table.name);
          const columnMetadata = metadata.findColumnWithDatabaseName(column.name);
          if (columnMetadata && columnMetadata.scale !== null && columnMetadata.scale !== void 0)
            return false;
        }
        if (this.connection.driver.dataTypeDefaults && this.connection.driver.dataTypeDefaults[column.type] && this.connection.driver.dataTypeDefaults[column.type].scale !== null && this.connection.driver.dataTypeDefaults[column.type].scale !== void 0)
          return this.connection.driver.dataTypeDefaults[column.type].scale === scale;
        return false;
      }
      /**
       * Executes sql used special for schema build.
       */
      async executeQueries(upQueries, downQueries) {
        if (InstanceChecker_1.InstanceChecker.isQuery(upQueries))
          upQueries = [upQueries];
        if (InstanceChecker_1.InstanceChecker.isQuery(downQueries))
          downQueries = [downQueries];
        this.sqlInMemory.upQueries.push(...upQueries);
        this.sqlInMemory.downQueries.push(...downQueries);
        if (this.sqlMemoryMode === true)
          return Promise.resolve();
        for (const { query, parameters } of upQueries) {
          await this.query(query, parameters);
        }
      }
      /**
       * Generated an index name for a table and index
       */
      generateIndexName(table, index) {
        return this.connection.namingStrategy.indexName(table, index.columnNames, index.where);
      }
    };
    exports2.BaseQueryRunner = BaseQueryRunner;
  }
});

// node_modules/typeorm/query-runner/QueryResult.js
var require_QueryResult = __commonJS({
  "node_modules/typeorm/query-runner/QueryResult.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryResult = void 0;
    var QueryResult2 = class {
      constructor() {
        this.records = [];
      }
    };
    exports2.QueryResult = QueryResult2;
  }
});

// node_modules/typeorm/subscriber/Broadcaster.js
var require_Broadcaster = __commonJS({
  "node_modules/typeorm/subscriber/Broadcaster.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Broadcaster = void 0;
    var ObjectUtils_1 = require_ObjectUtils();
    var BroadcasterResult_1 = require_BroadcasterResult();
    var Broadcaster = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(queryRunner) {
        this.queryRunner = queryRunner;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      async broadcast(event, ...args) {
        const result = new BroadcasterResult_1.BroadcasterResult();
        const broadcastFunction = this[`broadcast${event}Event`];
        if (typeof broadcastFunction === "function") {
          ;
          broadcastFunction.call(this, result, ...args);
        }
        await result.wait();
      }
      /**
       * Broadcasts "BEFORE_INSERT" event.
       * Before insert event is executed before entity is being inserted to the database for the first time.
       * All subscribers and entity listeners who listened to this event will be executed at this point.
       * Subscribers and entity listeners can return promises, it will wait until they are resolved.
       *
       * Note: this method has a performance-optimized code organization, do not change code structure.
       */
      broadcastBeforeInsertEvent(result, metadata, entity) {
        if (entity && metadata.beforeInsertListeners.length) {
          metadata.beforeInsertListeners.forEach((listener) => {
            if (listener.isAllowed(entity)) {
              const executionResult = listener.execute(entity);
              if (executionResult instanceof Promise)
                result.promises.push(executionResult);
              result.count++;
            }
          });
        }
        if (this.queryRunner.connection.subscribers.length) {
          this.queryRunner.connection.subscribers.forEach((subscriber) => {
            if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeInsert) {
              const executionResult = subscriber.beforeInsert({
                connection: this.queryRunner.connection,
                queryRunner: this.queryRunner,
                manager: this.queryRunner.manager,
                entity,
                metadata
              });
              if (executionResult instanceof Promise)
                result.promises.push(executionResult);
              result.count++;
            }
          });
        }
      }
      /**
       * Broadcasts "BEFORE_UPDATE" event.
       * Before update event is executed before entity is being updated in the database.
       * All subscribers and entity listeners who listened to this event will be executed at this point.
       * Subscribers and entity listeners can return promises, it will wait until they are resolved.
       *
       * Note: this method has a performance-optimized code organization, do not change code structure.
       */
      broadcastBeforeUpdateEvent(result, metadata, entity, databaseEntity, updatedColumns, updatedRelations) {
        if (entity && metadata.beforeUpdateListeners.length) {
          metadata.beforeUpdateListeners.forEach((listener) => {
            if (listener.isAllowed(entity)) {
              const executionResult = listener.execute(entity);
              if (executionResult instanceof Promise)
                result.promises.push(executionResult);
              result.count++;
            }
          });
        }
        if (this.queryRunner.connection.subscribers.length) {
          this.queryRunner.connection.subscribers.forEach((subscriber) => {
            if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeUpdate) {
              const executionResult = subscriber.beforeUpdate({
                connection: this.queryRunner.connection,
                queryRunner: this.queryRunner,
                manager: this.queryRunner.manager,
                entity,
                metadata,
                databaseEntity,
                updatedColumns: updatedColumns || [],
                updatedRelations: updatedRelations || []
              });
              if (executionResult instanceof Promise)
                result.promises.push(executionResult);
              result.count++;
            }
          });
        }
      }
      /**
       * Broadcasts "BEFORE_REMOVE" event.
       * Before remove event is executed before entity is being removed from the database.
       * All subscribers and entity listeners who listened to this event will be executed at this point.
       * Subscribers and entity listeners can return promises, it will wait until they are resolved.
       *
       * Note: this method has a performance-optimized code organization, do not change code structure.
       */
      broadcastBeforeRemoveEvent(result, metadata, entity, databaseEntity, identifier) {
        if (entity && metadata.beforeRemoveListeners.length) {
          metadata.beforeRemoveListeners.forEach((listener) => {
            if (listener.isAllowed(entity)) {
              const executionResult = listener.execute(entity);
              if (executionResult instanceof Promise)
                result.promises.push(executionResult);
              result.count++;
            }
          });
        }
        if (this.queryRunner.connection.subscribers.length) {
          this.queryRunner.connection.subscribers.forEach((subscriber) => {
            if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeRemove) {
              const executionResult = subscriber.beforeRemove({
                connection: this.queryRunner.connection,
                queryRunner: this.queryRunner,
                manager: this.queryRunner.manager,
                entity,
                metadata,
                databaseEntity,
                entityId: metadata.getEntityIdMixedMap(databaseEntity ?? identifier)
              });
              if (executionResult instanceof Promise)
                result.promises.push(executionResult);
              result.count++;
            }
          });
        }
      }
      /**
       * Broadcasts "BEFORE_SOFT_REMOVE" event.
       * Before soft remove event is executed before entity is being soft removed from the database.
       * All subscribers and entity listeners who listened to this event will be executed at this point.
       * Subscribers and entity listeners can return promises, it will wait until they are resolved.
       *
       * Note: this method has a performance-optimized code organization, do not change code structure.
       */
      broadcastBeforeSoftRemoveEvent(result, metadata, entity, databaseEntity, identifier) {
        if (entity && metadata.beforeSoftRemoveListeners.length) {
          metadata.beforeSoftRemoveListeners.forEach((listener) => {
            if (listener.isAllowed(entity)) {
              const executionResult = listener.execute(entity);
              if (executionResult instanceof Promise)
                result.promises.push(executionResult);
              result.count++;
            }
          });
        }
        if (this.queryRunner.connection.subscribers.length) {
          this.queryRunner.connection.subscribers.forEach((subscriber) => {
            if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeSoftRemove) {
              const executionResult = subscriber.beforeSoftRemove({
                connection: this.queryRunner.connection,
                queryRunner: this.queryRunner,
                manager: this.queryRunner.manager,
                entity,
                metadata,
                databaseEntity,
                entityId: metadata.getEntityIdMixedMap(databaseEntity ?? identifier)
              });
              if (executionResult instanceof Promise)
                result.promises.push(executionResult);
              result.count++;
            }
          });
        }
      }
      /**
       * Broadcasts "BEFORE_RECOVER" event.
       * Before recover event is executed before entity is being recovered in the database.
       * All subscribers and entity listeners who listened to this event will be executed at this point.
       * Subscribers and entity listeners can return promises, it will wait until they are resolved.
       *
       * Note: this method has a performance-optimized code organization, do not change code structure.
       */
      broadcastBeforeRecoverEvent(result, metadata, entity, databaseEntity, identifier) {
        if (entity && metadata.beforeRecoverListeners.length) {
          metadata.beforeRecoverListeners.forEach((listener) => {
            if (listener.isAllowed(entity)) {
              const executionResult = listener.execute(entity);
              if (executionResult instanceof Promise)
                result.promises.push(executionResult);
              result.count++;
            }
          });
        }
        if (this.queryRunner.connection.subscribers.length) {
          this.queryRunner.connection.subscribers.forEach((subscriber) => {
            if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeRecover) {
              const executionResult = subscriber.beforeRecover({
                connection: this.queryRunner.connection,
                queryRunner: this.queryRunner,
                manager: this.queryRunner.manager,
                entity,
                metadata,
                databaseEntity,
                entityId: metadata.getEntityIdMixedMap(databaseEntity ?? identifier)
              });
              if (executionResult instanceof Promise)
                result.promises.push(executionResult);
              result.count++;
            }
          });
        }
      }
      /**
       * Broadcasts "AFTER_INSERT" event.
       * After insert event is executed after entity is being persisted to the database for the first time.
       * All subscribers and entity listeners who listened to this event will be executed at this point.
       * Subscribers and entity listeners can return promises, it will wait until they are resolved.
       *
       * Note: this method has a performance-optimized code organization, do not change code structure.
       */
      broadcastAfterInsertEvent(result, metadata, entity, identifier) {
        if (entity && metadata.afterInsertListeners.length) {
          metadata.afterInsertListeners.forEach((listener) => {
            if (listener.isAllowed(entity)) {
              const executionResult = listener.execute(entity);
              if (executionResult instanceof Promise)
                result.promises.push(executionResult);
              result.count++;
            }
          });
        }
        if (this.queryRunner.connection.subscribers.length) {
          this.queryRunner.connection.subscribers.forEach((subscriber) => {
            if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterInsert) {
              const executionResult = subscriber.afterInsert({
                connection: this.queryRunner.connection,
                queryRunner: this.queryRunner,
                manager: this.queryRunner.manager,
                entity,
                metadata,
                entityId: metadata.getEntityIdMixedMap(identifier)
              });
              if (executionResult instanceof Promise)
                result.promises.push(executionResult);
              result.count++;
            }
          });
        }
      }
      /**
       * Broadcasts "BEFORE_QUERY" event.
       */
      broadcastBeforeQueryEvent(result, query, parameters) {
        if (this.queryRunner.connection.subscribers.length) {
          this.queryRunner.connection.subscribers.forEach((subscriber) => {
            if (subscriber.beforeQuery) {
              const executionResult = subscriber.beforeQuery({
                connection: this.queryRunner.connection,
                queryRunner: this.queryRunner,
                manager: this.queryRunner.manager,
                query,
                parameters
              });
              if (executionResult instanceof Promise)
                result.promises.push(executionResult);
              result.count++;
            }
          });
        }
      }
      /**
       * Broadcasts "AFTER_QUERY" event.
       */
      broadcastAfterQueryEvent(result, query, parameters, success, executionTime, rawResults, error) {
        if (this.queryRunner.connection.subscribers.length) {
          this.queryRunner.connection.subscribers.forEach((subscriber) => {
            if (subscriber.afterQuery) {
              const executionResult = subscriber.afterQuery({
                connection: this.queryRunner.connection,
                queryRunner: this.queryRunner,
                manager: this.queryRunner.manager,
                query,
                parameters,
                success,
                executionTime,
                rawResults,
                error
              });
              if (executionResult instanceof Promise)
                result.promises.push(executionResult);
              result.count++;
            }
          });
        }
      }
      /**
       * Broadcasts "BEFORE_TRANSACTION_START" event.
       */
      broadcastBeforeTransactionStartEvent(result) {
        if (this.queryRunner.connection.subscribers.length) {
          this.queryRunner.connection.subscribers.forEach((subscriber) => {
            if (subscriber.beforeTransactionStart) {
              const executionResult = subscriber.beforeTransactionStart({
                connection: this.queryRunner.connection,
                queryRunner: this.queryRunner,
                manager: this.queryRunner.manager
              });
              if (executionResult instanceof Promise)
                result.promises.push(executionResult);
              result.count++;
            }
          });
        }
      }
      /**
       * Broadcasts "AFTER_TRANSACTION_START" event.
       */
      broadcastAfterTransactionStartEvent(result) {
        if (this.queryRunner.connection.subscribers.length) {
          this.queryRunner.connection.subscribers.forEach((subscriber) => {
            if (subscriber.afterTransactionStart) {
              const executionResult = subscriber.afterTransactionStart({
                connection: this.queryRunner.connection,
                queryRunner: this.queryRunner,
                manager: this.queryRunner.manager
              });
              if (executionResult instanceof Promise)
                result.promises.push(executionResult);
              result.count++;
            }
          });
        }
      }
      /**
       * Broadcasts "BEFORE_TRANSACTION_COMMIT" event.
       */
      broadcastBeforeTransactionCommitEvent(result) {
        if (this.queryRunner.connection.subscribers.length) {
          this.queryRunner.connection.subscribers.forEach((subscriber) => {
            if (subscriber.beforeTransactionCommit) {
              const executionResult = subscriber.beforeTransactionCommit({
                connection: this.queryRunner.connection,
                queryRunner: this.queryRunner,
                manager: this.queryRunner.manager
              });
              if (executionResult instanceof Promise)
                result.promises.push(executionResult);
              result.count++;
            }
          });
        }
      }
      /**
       * Broadcasts "AFTER_TRANSACTION_COMMIT" event.
       */
      broadcastAfterTransactionCommitEvent(result) {
        if (this.queryRunner.connection.subscribers.length) {
          this.queryRunner.connection.subscribers.forEach((subscriber) => {
            if (subscriber.afterTransactionCommit) {
              const executionResult = subscriber.afterTransactionCommit({
                connection: this.queryRunner.connection,
                queryRunner: this.queryRunner,
                manager: this.queryRunner.manager
              });
              if (executionResult instanceof Promise)
                result.promises.push(executionResult);
              result.count++;
            }
          });
        }
      }
      /**
       * Broadcasts "BEFORE_TRANSACTION_ROLLBACK" event.
       */
      broadcastBeforeTransactionRollbackEvent(result) {
        if (this.queryRunner.connection.subscribers.length) {
          this.queryRunner.connection.subscribers.forEach((subscriber) => {
            if (subscriber.beforeTransactionRollback) {
              const executionResult = subscriber.beforeTransactionRollback({
                connection: this.queryRunner.connection,
                queryRunner: this.queryRunner,
                manager: this.queryRunner.manager
              });
              if (executionResult instanceof Promise)
                result.promises.push(executionResult);
              result.count++;
            }
          });
        }
      }
      /**
       * Broadcasts "AFTER_TRANSACTION_ROLLBACK" event.
       */
      broadcastAfterTransactionRollbackEvent(result) {
        if (this.queryRunner.connection.subscribers.length) {
          this.queryRunner.connection.subscribers.forEach((subscriber) => {
            if (subscriber.afterTransactionRollback) {
              const executionResult = subscriber.afterTransactionRollback({
                connection: this.queryRunner.connection,
                queryRunner: this.queryRunner,
                manager: this.queryRunner.manager
              });
              if (executionResult instanceof Promise)
                result.promises.push(executionResult);
              result.count++;
            }
          });
        }
      }
      /**
       * Broadcasts "AFTER_UPDATE" event.
       * After update event is executed after entity is being updated in the database.
       * All subscribers and entity listeners who listened to this event will be executed at this point.
       * Subscribers and entity listeners can return promises, it will wait until they are resolved.
       *
       * Note: this method has a performance-optimized code organization, do not change code structure.
       */
      broadcastAfterUpdateEvent(result, metadata, entity, databaseEntity, updatedColumns, updatedRelations) {
        if (entity && metadata.afterUpdateListeners.length) {
          metadata.afterUpdateListeners.forEach((listener) => {
            if (listener.isAllowed(entity)) {
              const executionResult = listener.execute(entity);
              if (executionResult instanceof Promise)
                result.promises.push(executionResult);
              result.count++;
            }
          });
        }
        if (this.queryRunner.connection.subscribers.length) {
          this.queryRunner.connection.subscribers.forEach((subscriber) => {
            if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterUpdate) {
              const executionResult = subscriber.afterUpdate({
                connection: this.queryRunner.connection,
                queryRunner: this.queryRunner,
                manager: this.queryRunner.manager,
                entity,
                metadata,
                databaseEntity,
                updatedColumns: updatedColumns || [],
                updatedRelations: updatedRelations || []
              });
              if (executionResult instanceof Promise)
                result.promises.push(executionResult);
              result.count++;
            }
          });
        }
      }
      /**
       * Broadcasts "AFTER_REMOVE" event.
       * After remove event is executed after entity is being removed from the database.
       * All subscribers and entity listeners who listened to this event will be executed at this point.
       * Subscribers and entity listeners can return promises, it will wait until they are resolved.
       *
       * Note: this method has a performance-optimized code organization, do not change code structure.
       */
      broadcastAfterRemoveEvent(result, metadata, entity, databaseEntity, identifier) {
        if (entity && metadata.afterRemoveListeners.length) {
          metadata.afterRemoveListeners.forEach((listener) => {
            if (listener.isAllowed(entity)) {
              const executionResult = listener.execute(entity);
              if (executionResult instanceof Promise)
                result.promises.push(executionResult);
              result.count++;
            }
          });
        }
        if (this.queryRunner.connection.subscribers.length) {
          this.queryRunner.connection.subscribers.forEach((subscriber) => {
            if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterRemove) {
              const executionResult = subscriber.afterRemove({
                connection: this.queryRunner.connection,
                queryRunner: this.queryRunner,
                manager: this.queryRunner.manager,
                entity,
                metadata,
                databaseEntity,
                entityId: metadata.getEntityIdMixedMap(databaseEntity ?? identifier)
              });
              if (executionResult instanceof Promise)
                result.promises.push(executionResult);
              result.count++;
            }
          });
        }
      }
      /**
       * Broadcasts "AFTER_SOFT_REMOVE" event.
       * After soft remove event is executed after entity is being soft removed from the database.
       * All subscribers and entity listeners who listened to this event will be executed at this point.
       * Subscribers and entity listeners can return promises, it will wait until they are resolved.
       *
       * Note: this method has a performance-optimized code organization, do not change code structure.
       */
      broadcastAfterSoftRemoveEvent(result, metadata, entity, databaseEntity, identifier) {
        if (entity && metadata.afterSoftRemoveListeners.length) {
          metadata.afterSoftRemoveListeners.forEach((listener) => {
            if (listener.isAllowed(entity)) {
              const executionResult = listener.execute(entity);
              if (executionResult instanceof Promise)
                result.promises.push(executionResult);
              result.count++;
            }
          });
        }
        if (this.queryRunner.connection.subscribers.length) {
          this.queryRunner.connection.subscribers.forEach((subscriber) => {
            if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterSoftRemove) {
              const executionResult = subscriber.afterSoftRemove({
                connection: this.queryRunner.connection,
                queryRunner: this.queryRunner,
                manager: this.queryRunner.manager,
                entity,
                metadata,
                databaseEntity,
                entityId: metadata.getEntityIdMixedMap(databaseEntity ?? identifier)
              });
              if (executionResult instanceof Promise)
                result.promises.push(executionResult);
              result.count++;
            }
          });
        }
      }
      /**
       * Broadcasts "AFTER_RECOVER" event.
       * After recover event is executed after entity is being recovered in the database.
       * All subscribers and entity listeners who listened to this event will be executed at this point.
       * Subscribers and entity listeners can return promises, it will wait until they are resolved.
       *
       * Note: this method has a performance-optimized code organization, do not change code structure.
       */
      broadcastAfterRecoverEvent(result, metadata, entity, databaseEntity, identifier) {
        if (entity && metadata.afterRecoverListeners.length) {
          metadata.afterRecoverListeners.forEach((listener) => {
            if (listener.isAllowed(entity)) {
              const executionResult = listener.execute(entity);
              if (executionResult instanceof Promise)
                result.promises.push(executionResult);
              result.count++;
            }
          });
        }
        if (this.queryRunner.connection.subscribers.length) {
          this.queryRunner.connection.subscribers.forEach((subscriber) => {
            if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterRecover) {
              const executionResult = subscriber.afterRecover({
                connection: this.queryRunner.connection,
                queryRunner: this.queryRunner,
                manager: this.queryRunner.manager,
                entity,
                metadata,
                databaseEntity,
                entityId: metadata.getEntityIdMixedMap(databaseEntity ?? identifier)
              });
              if (executionResult instanceof Promise)
                result.promises.push(executionResult);
              result.count++;
            }
          });
        }
      }
      /**
       * @deprecated Use `broadcastLoadForAllEvent`
       */
      broadcastLoadEventsForAll(result, metadata, entities) {
        return this.broadcastLoadEvent(result, metadata, entities);
      }
      /**
       * Broadcasts "AFTER_LOAD" event for all given entities, and their sub-entities.
       * After load event is executed after entity has been loaded from the database.
       * All subscribers and entity listeners who listened to this event will be executed at this point.
       * Subscribers and entity listeners can return promises, it will wait until they are resolved.
       *
       * Note: this method has a performance-optimized code organization, do not change code structure.
       */
      broadcastLoadEvent(result, metadata, entities) {
        const fittingSubscribers = this.queryRunner.connection.subscribers.filter((subscriber) => this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterLoad);
        if (metadata.relations.length || metadata.afterLoadListeners.length || fittingSubscribers.length) {
          const nonPromiseEntities = entities.filter((entity) => !(entity instanceof Promise));
          if (metadata.relations.length) {
            metadata.relations.forEach((relation) => {
              nonPromiseEntities.forEach((entity) => {
                if (relation.isLazy && !entity.hasOwnProperty(relation.propertyName))
                  return;
                const value = relation.getEntityValue(entity);
                if (ObjectUtils_1.ObjectUtils.isObject(value))
                  this.broadcastLoadEvent(result, relation.inverseEntityMetadata, Array.isArray(value) ? value : [value]);
              });
            });
          }
          if (metadata.afterLoadListeners.length) {
            metadata.afterLoadListeners.forEach((listener) => {
              nonPromiseEntities.forEach((entity) => {
                if (listener.isAllowed(entity)) {
                  const executionResult = listener.execute(entity);
                  if (executionResult instanceof Promise)
                    result.promises.push(executionResult);
                  result.count++;
                }
              });
            });
          }
          fittingSubscribers.forEach((subscriber) => {
            nonPromiseEntities.forEach((entity) => {
              const executionResult = subscriber.afterLoad(entity, {
                entity,
                metadata,
                connection: this.queryRunner.connection,
                queryRunner: this.queryRunner,
                manager: this.queryRunner.manager
              });
              if (executionResult instanceof Promise)
                result.promises.push(executionResult);
              result.count++;
            });
          });
        }
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Checks if subscriber's methods can be executed by checking if its don't listen to the particular entity,
       * or listens our entity.
       */
      isAllowedSubscriber(subscriber, target) {
        return !subscriber.listenTo || !subscriber.listenTo() || subscriber.listenTo() === Object || subscriber.listenTo() === target || subscriber.listenTo().isPrototypeOf(target);
      }
    };
    exports2.Broadcaster = Broadcaster;
  }
});

// node_modules/typeorm/driver/types/MetadataTableType.js
var require_MetadataTableType = __commonJS({
  "node_modules/typeorm/driver/types/MetadataTableType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MetadataTableType = void 0;
    var MetadataTableType;
    (function(MetadataTableType2) {
      MetadataTableType2["VIEW"] = "VIEW";
      MetadataTableType2["MATERIALIZED_VIEW"] = "MATERIALIZED_VIEW";
      MetadataTableType2["GENERATED_COLUMN"] = "GENERATED_COLUMN";
    })(MetadataTableType || (exports2.MetadataTableType = MetadataTableType = {}));
  }
});

// node_modules/typeorm/driver/cockroachdb/CockroachQueryRunner.js
var require_CockroachQueryRunner = __commonJS({
  "node_modules/typeorm/driver/cockroachdb/CockroachQueryRunner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CockroachQueryRunner = void 0;
    var error_1 = require_error();
    var QueryFailedError_1 = require_QueryFailedError();
    var QueryRunnerAlreadyReleasedError_1 = require_QueryRunnerAlreadyReleasedError();
    var TransactionNotStartedError_1 = require_TransactionNotStartedError();
    var BaseQueryRunner_1 = require_BaseQueryRunner();
    var QueryResult_1 = require_QueryResult();
    var Table_1 = require_Table();
    var TableCheck_1 = require_TableCheck();
    var TableColumn_1 = require_TableColumn();
    var TableExclusion_1 = require_TableExclusion();
    var TableForeignKey_1 = require_TableForeignKey();
    var TableIndex_1 = require_TableIndex();
    var TableUnique_1 = require_TableUnique();
    var View_1 = require_View();
    var Broadcaster_1 = require_Broadcaster();
    var BroadcasterResult_1 = require_BroadcasterResult();
    var InstanceChecker_1 = require_InstanceChecker();
    var OrmUtils_1 = require_OrmUtils();
    var VersionUtils_1 = require_VersionUtils();
    var Query_1 = require_Query();
    var MetadataTableType_1 = require_MetadataTableType();
    var CockroachQueryRunner = class extends BaseQueryRunner_1.BaseQueryRunner {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(driver, mode) {
        super();
        this.queries = [];
        this.storeQueries = false;
        this.transactionRetries = 0;
        this.driver = driver;
        this.connection = driver.connection;
        this.mode = mode;
        this.broadcaster = new Broadcaster_1.Broadcaster(this);
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Creates/uses database connection from the connection pool to perform further operations.
       * Returns obtained database connection.
       */
      connect() {
        if (this.databaseConnection)
          return Promise.resolve(this.databaseConnection);
        if (this.databaseConnectionPromise)
          return this.databaseConnectionPromise;
        if (this.mode === "slave" && this.driver.isReplicated) {
          this.databaseConnectionPromise = this.driver.obtainSlaveConnection().then(([connection, release]) => {
            this.driver.connectedQueryRunners.push(this);
            this.databaseConnection = connection;
            const onErrorCallback = (err) => this.releaseConnection(err);
            this.releaseCallback = (err) => {
              this.databaseConnection.removeListener("error", onErrorCallback);
              release(err);
            };
            this.databaseConnection.on("error", onErrorCallback);
            return this.databaseConnection;
          });
        } else {
          this.databaseConnectionPromise = this.driver.obtainMasterConnection().then(([connection, release]) => {
            this.driver.connectedQueryRunners.push(this);
            this.databaseConnection = connection;
            const onErrorCallback = (err) => this.releaseConnection(err);
            this.releaseCallback = (err) => {
              this.databaseConnection.removeListener("error", onErrorCallback);
              release(err);
            };
            this.databaseConnection.on("error", onErrorCallback);
            return this.databaseConnection;
          });
        }
        return this.databaseConnectionPromise;
      }
      /**
       * Release a connection back to the pool, optionally specifying an Error to release with.
       * Per pg-pool documentation this will prevent the pool from re-using the broken connection.
       */
      async releaseConnection(err) {
        if (this.isReleased) {
          return;
        }
        this.isReleased = true;
        if (this.releaseCallback) {
          this.releaseCallback(err);
          this.releaseCallback = void 0;
        }
        const index = this.driver.connectedQueryRunners.indexOf(this);
        if (index !== -1) {
          this.driver.connectedQueryRunners.splice(index, 1);
        }
      }
      /**
       * Releases used database connection.
       * You cannot use query runner methods once its released.
       */
      release() {
        return this.releaseConnection();
      }
      /**
       * Starts transaction.
       */
      async startTransaction(isolationLevel) {
        this.isTransactionActive = true;
        this.transactionRetries = 0;
        try {
          await this.broadcaster.broadcast("BeforeTransactionStart");
        } catch (err) {
          this.isTransactionActive = false;
          throw err;
        }
        if (this.transactionDepth === 0) {
          await this.query("START TRANSACTION");
          await this.query("SAVEPOINT cockroach_restart");
          if (isolationLevel) {
            await this.query("SET TRANSACTION ISOLATION LEVEL " + isolationLevel);
          }
        } else {
          await this.query(`SAVEPOINT typeorm_${this.transactionDepth}`);
        }
        this.transactionDepth += 1;
        this.storeQueries = true;
        await this.broadcaster.broadcast("AfterTransactionStart");
      }
      /**
       * Commits transaction.
       * Error will be thrown if transaction was not started.
       */
      async commitTransaction() {
        if (!this.isTransactionActive)
          throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionCommit");
        if (this.transactionDepth > 1) {
          await this.query(`RELEASE SAVEPOINT typeorm_${this.transactionDepth - 1}`);
          this.transactionDepth -= 1;
        } else {
          this.storeQueries = false;
          await this.query("RELEASE SAVEPOINT cockroach_restart");
          await this.query("COMMIT");
          this.queries = [];
          this.isTransactionActive = false;
          this.transactionRetries = 0;
          this.transactionDepth -= 1;
        }
        await this.broadcaster.broadcast("AfterTransactionCommit");
      }
      /**
       * Rollbacks transaction.
       * Error will be thrown if transaction was not started.
       */
      async rollbackTransaction() {
        if (!this.isTransactionActive)
          throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionRollback");
        if (this.transactionDepth > 1) {
          await this.query(`ROLLBACK TO SAVEPOINT typeorm_${this.transactionDepth - 1}`);
        } else {
          this.storeQueries = false;
          await this.query("ROLLBACK");
          this.queries = [];
          this.isTransactionActive = false;
          this.transactionRetries = 0;
        }
        this.transactionDepth -= 1;
        await this.broadcaster.broadcast("AfterTransactionRollback");
      }
      /**
       * Executes a given SQL query.
       */
      async query(query, parameters, useStructuredResult = false) {
        if (this.isReleased)
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        const databaseConnection = await this.connect();
        this.driver.connection.logger.logQuery(query, parameters, this);
        await this.broadcaster.broadcast("BeforeQuery", query, parameters);
        const broadcasterResult = new BroadcasterResult_1.BroadcasterResult();
        const queryStartTime = Date.now();
        if (this.isTransactionActive && this.storeQueries) {
          this.queries.push({ query, parameters });
        }
        try {
          const raw = await new Promise((ok, fail) => {
            databaseConnection.query(query, parameters, (err, raw2) => err ? fail(err) : ok(raw2));
          });
          const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
          const queryEndTime = Date.now();
          const queryExecutionTime = queryEndTime - queryStartTime;
          if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) {
            this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
          }
          const result = new QueryResult_1.QueryResult();
          if (raw.hasOwnProperty("rowCount")) {
            result.affected = raw.rowCount;
          }
          if (raw.hasOwnProperty("rows")) {
            result.records = raw.rows;
          }
          switch (raw.command) {
            case "DELETE":
              result.raw = [raw.rows, raw.rowCount];
              break;
            default:
              result.raw = raw.rows;
          }
          this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, raw, void 0);
          if (useStructuredResult) {
            return result;
          } else {
            return result.raw;
          }
        } catch (err) {
          if (err.code === "40001" && this.isTransactionActive && this.transactionRetries < (this.driver.options.maxTransactionRetries || 5)) {
            this.transactionRetries += 1;
            this.storeQueries = false;
            await this.query("ROLLBACK TO SAVEPOINT cockroach_restart");
            const sleepTime = 2 ** this.transactionRetries * 0.1 * (Math.random() + 0.5) * 1e3;
            await new Promise((resolve) => setTimeout(resolve, sleepTime));
            let result = void 0;
            for (const q of this.queries) {
              this.driver.connection.logger.logQuery(`Retrying transaction for query "${q.query}"`, q.parameters, this);
              result = await this.query(q.query, q.parameters);
            }
            this.transactionRetries = 0;
            this.storeQueries = true;
            return result;
          } else {
            this.driver.connection.logger.logQueryError(err, query, parameters, this);
            this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, void 0, void 0, err);
            throw new QueryFailedError_1.QueryFailedError(query, parameters, err);
          }
        } finally {
          await broadcasterResult.wait();
        }
      }
      /**
       * Returns raw data stream.
       */
      async stream(query, parameters, onEnd, onError) {
        const QueryStream = this.driver.loadStreamDependency();
        if (this.isReleased) {
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        }
        const databaseConnection = await this.connect();
        this.driver.connection.logger.logQuery(query, parameters, this);
        const stream = databaseConnection.query(new QueryStream(query, parameters));
        if (onEnd) {
          stream.on("end", onEnd);
        }
        if (onError) {
          stream.on("error", onError);
        }
        return stream;
      }
      /**
       * Returns all available database names including system databases.
       */
      async getDatabases() {
        return Promise.resolve([]);
      }
      /**
       * Returns all available schema names including system schemas.
       * If database parameter specified, returns schemas of that database.
       */
      async getSchemas(database) {
        return Promise.resolve([]);
      }
      /**
       * Checks if database with the given name exist.
       */
      async hasDatabase(database) {
        const result = await this.query(`SELECT * FROM "pg_database" WHERE "datname" = '${database}'`);
        return result.length ? true : false;
      }
      /**
       * Loads currently using database
       */
      async getCurrentDatabase() {
        const query = await this.query(`SELECT * FROM current_database()`);
        return query[0]["current_database"];
      }
      /**
       * Checks if schema with the given name exist.
       */
      async hasSchema(schema) {
        const result = await this.query(`SELECT * FROM "information_schema"."schemata" WHERE "schema_name" = '${schema}'`);
        return result.length ? true : false;
      }
      /**
       * Loads currently using database schema
       */
      async getCurrentSchema() {
        const query = await this.query(`SELECT * FROM current_schema()`);
        return query[0]["current_schema"];
      }
      /**
       * Checks if table with the given name exist in the database.
       */
      async hasTable(tableOrName) {
        const parsedTableName = this.driver.parseTableName(tableOrName);
        if (!parsedTableName.schema) {
          parsedTableName.schema = await this.getCurrentSchema();
        }
        const sql = `SELECT * FROM "information_schema"."tables" WHERE "table_schema" = '${parsedTableName.schema}' AND "table_name" = '${parsedTableName.tableName}'`;
        const result = await this.query(sql);
        return result.length ? true : false;
      }
      /**
       * Checks if column with the given name exist in the given table.
       */
      async hasColumn(tableOrName, columnName) {
        const parsedTableName = this.driver.parseTableName(tableOrName);
        if (!parsedTableName.schema) {
          parsedTableName.schema = await this.getCurrentSchema();
        }
        const sql = `SELECT * FROM "information_schema"."columns" WHERE "table_schema" = '${parsedTableName.schema}' AND "table_name" = '${parsedTableName.tableName}' AND "column_name" = '${columnName}'`;
        const result = await this.query(sql);
        return result.length ? true : false;
      }
      /**
       * Creates a new database.
       */
      async createDatabase(database, ifNotExist) {
        const up = `CREATE DATABASE ${ifNotExist ? "IF NOT EXISTS " : ""} "${database}"`;
        const down = `DROP DATABASE "${database}"`;
        await this.executeQueries(new Query_1.Query(up), new Query_1.Query(down));
      }
      /**
       * Drops database.
       */
      async dropDatabase(database, ifExist) {
        const up = `DROP DATABASE ${ifExist ? "IF EXISTS " : ""} "${database}"`;
        const down = `CREATE DATABASE "${database}"`;
        await this.executeQueries(new Query_1.Query(up), new Query_1.Query(down));
      }
      /**
       * Creates a new table schema.
       */
      async createSchema(schemaPath, ifNotExist) {
        const schema = schemaPath.indexOf(".") === -1 ? schemaPath : schemaPath.split(".")[1];
        const up = ifNotExist ? `CREATE SCHEMA IF NOT EXISTS "${schema}"` : `CREATE SCHEMA "${schema}"`;
        const down = `DROP SCHEMA "${schema}" CASCADE`;
        await this.executeQueries(new Query_1.Query(up), new Query_1.Query(down));
      }
      /**
       * Drops table schema.
       */
      async dropSchema(schemaPath, ifExist, isCascade) {
        const schema = schemaPath.indexOf(".") === -1 ? schemaPath : schemaPath.split(".")[1];
        const up = ifExist ? `DROP SCHEMA IF EXISTS "${schema}" ${isCascade ? "CASCADE" : ""}` : `DROP SCHEMA "${schema}" ${isCascade ? "CASCADE" : ""}`;
        const down = `CREATE SCHEMA "${schema}"`;
        await this.executeQueries(new Query_1.Query(up), new Query_1.Query(down));
      }
      /**
       * Creates a new table.
       */
      async createTable(table, ifNotExist = false, createForeignKeys = true, createIndices = true) {
        if (ifNotExist) {
          const isTableExist = await this.hasTable(table);
          if (isTableExist)
            return Promise.resolve();
        }
        const upQueries = [];
        const downQueries = [];
        const enumColumns = table.columns.filter((column) => column.type === "enum" || column.type === "simple-enum");
        const createdEnumTypes = [];
        for (const column of enumColumns) {
          const hasEnum = await this.hasEnumType(table, column);
          const enumName = this.buildEnumName(table, column);
          if (!hasEnum && createdEnumTypes.indexOf(enumName) === -1) {
            createdEnumTypes.push(enumName);
            upQueries.push(this.createEnumTypeSql(table, column, enumName));
            downQueries.push(this.dropEnumTypeSql(table, column, enumName));
          }
        }
        table.columns.filter((column) => column.isGenerated && column.generationStrategy === "increment").forEach((column) => {
          upQueries.push(new Query_1.Query(`CREATE SEQUENCE ${this.escapePath(this.buildSequencePath(table, column))}`));
          downQueries.push(new Query_1.Query(`DROP SEQUENCE ${this.escapePath(this.buildSequencePath(table, column))}`));
        });
        upQueries.push(this.createTableSql(table, createForeignKeys));
        downQueries.push(this.dropTableSql(table));
        if (createForeignKeys)
          table.foreignKeys.forEach((foreignKey) => downQueries.push(this.dropForeignKeySql(table, foreignKey)));
        if (createIndices) {
          table.indices.filter((index) => !index.isUnique).forEach((index) => {
            if (!index.name)
              index.name = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);
            upQueries.push(this.createIndexSql(table, index));
            downQueries.push(this.dropIndexSql(table, index));
          });
        }
        const generatedColumns = table.columns.filter((column) => column.generatedType && column.asExpression);
        for (const column of generatedColumns) {
          const currentSchema = await this.getCurrentSchema();
          let { schema } = this.driver.parseTableName(table);
          if (!schema) {
            schema = currentSchema;
          }
          const insertQuery = this.insertTypeormMetadataSql({
            schema,
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name,
            value: column.asExpression
          });
          const deleteQuery = this.deleteTypeormMetadataSql({
            schema,
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name
          });
          upQueries.push(insertQuery);
          downQueries.push(deleteQuery);
        }
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Drops the table.
       */
      async dropTable(target, ifExist, dropForeignKeys = true, dropIndices = true) {
        if (ifExist) {
          const isTableExist = await this.hasTable(target);
          if (!isTableExist)
            return Promise.resolve();
        }
        const createForeignKeys = dropForeignKeys;
        const tablePath = this.getTablePath(target);
        const table = await this.getCachedTable(tablePath);
        const upQueries = [];
        const downQueries = [];
        if (dropForeignKeys)
          table.foreignKeys.forEach((foreignKey) => upQueries.push(this.dropForeignKeySql(table, foreignKey)));
        if (dropIndices) {
          table.indices.forEach((index) => {
            upQueries.push(this.dropIndexSql(table, index));
            downQueries.push(this.createIndexSql(table, index));
          });
        }
        upQueries.push(this.dropTableSql(table));
        downQueries.push(this.createTableSql(table, createForeignKeys));
        table.columns.filter((column) => column.isGenerated && column.generationStrategy === "increment").forEach((column) => {
          upQueries.push(new Query_1.Query(`DROP SEQUENCE ${this.escapePath(this.buildSequencePath(table, column))}`));
          downQueries.push(new Query_1.Query(`CREATE SEQUENCE ${this.escapePath(this.buildSequencePath(table, column))}`));
        });
        const generatedColumns = table.columns.filter((column) => column.generatedType && column.asExpression);
        for (const column of generatedColumns) {
          const currentSchema = await this.getCurrentSchema();
          let { schema } = this.driver.parseTableName(table);
          if (!schema) {
            schema = currentSchema;
          }
          const deleteQuery = this.deleteTypeormMetadataSql({
            schema,
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name
          });
          const insertQuery = this.insertTypeormMetadataSql({
            schema,
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name,
            value: column.asExpression
          });
          upQueries.push(deleteQuery);
          downQueries.push(insertQuery);
        }
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Creates a new view.
       */
      async createView(view, syncWithMetadata = false) {
        const upQueries = [];
        const downQueries = [];
        upQueries.push(this.createViewSql(view));
        if (syncWithMetadata)
          upQueries.push(await this.insertViewDefinitionSql(view));
        downQueries.push(this.dropViewSql(view));
        if (syncWithMetadata)
          downQueries.push(await this.deleteViewDefinitionSql(view));
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Drops the view.
       */
      async dropView(target) {
        const viewName = InstanceChecker_1.InstanceChecker.isView(target) ? target.name : target;
        const view = await this.getCachedView(viewName);
        const upQueries = [];
        const downQueries = [];
        upQueries.push(await this.deleteViewDefinitionSql(view));
        upQueries.push(this.dropViewSql(view));
        downQueries.push(await this.insertViewDefinitionSql(view));
        downQueries.push(this.createViewSql(view));
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Renames the given table.
       */
      async renameTable(oldTableOrName, newTableName) {
        const upQueries = [];
        const downQueries = [];
        const oldTable = InstanceChecker_1.InstanceChecker.isTable(oldTableOrName) ? oldTableOrName : await this.getCachedTable(oldTableOrName);
        const newTable = oldTable.clone();
        const { schema: schemaName, tableName: oldTableName } = this.driver.parseTableName(oldTable);
        newTable.name = schemaName ? `${schemaName}.${newTableName}` : newTableName;
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(oldTable)} RENAME TO "${newTableName}"`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME TO "${oldTableName}"`));
        if (newTable.primaryColumns.length > 0 && !newTable.primaryColumns[0].primaryKeyConstraintName) {
          const columnNames = newTable.primaryColumns.map((column) => column.name);
          const oldPkName = this.connection.namingStrategy.primaryKeyName(oldTable, columnNames);
          const newPkName = this.connection.namingStrategy.primaryKeyName(newTable, columnNames);
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${oldPkName}" TO "${newPkName}"`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${newPkName}" TO "${oldPkName}"`));
        }
        newTable.uniques.forEach((unique) => {
          const oldUniqueName = this.connection.namingStrategy.uniqueConstraintName(oldTable, unique.columnNames);
          if (unique.name !== oldUniqueName)
            return;
          const newUniqueName = this.connection.namingStrategy.uniqueConstraintName(newTable, unique.columnNames);
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${unique.name}" TO "${newUniqueName}"`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${newUniqueName}" TO "${unique.name}"`));
          unique.name = newUniqueName;
        });
        newTable.indices.forEach((index) => {
          const oldIndexName = this.connection.namingStrategy.indexName(oldTable, index.columnNames, index.where);
          if (index.name !== oldIndexName)
            return;
          const { schema } = this.driver.parseTableName(newTable);
          const newIndexName = this.connection.namingStrategy.indexName(newTable, index.columnNames, index.where);
          const up = schema ? `ALTER INDEX "${schema}"."${index.name}" RENAME TO "${newIndexName}"` : `ALTER INDEX "${index.name}" RENAME TO "${newIndexName}"`;
          const down = schema ? `ALTER INDEX "${schema}"."${newIndexName}" RENAME TO "${index.name}"` : `ALTER INDEX "${newIndexName}" RENAME TO "${index.name}"`;
          upQueries.push(new Query_1.Query(up));
          downQueries.push(new Query_1.Query(down));
          index.name = newIndexName;
        });
        newTable.foreignKeys.forEach((foreignKey) => {
          const oldForeignKeyName = this.connection.namingStrategy.foreignKeyName(oldTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
          if (foreignKey.name !== oldForeignKeyName)
            return;
          const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(newTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${foreignKey.name}" TO "${newForeignKeyName}"`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${newForeignKeyName}" TO "${foreignKey.name}"`));
          foreignKey.name = newForeignKeyName;
        });
        const enumColumns = newTable.columns.filter((column) => column.type === "enum" || column.type === "simple-enum");
        for (const column of enumColumns) {
          if (column.enumName)
            continue;
          const oldEnumType = await this.getUserDefinedTypeName(oldTable, column);
          upQueries.push(new Query_1.Query(`ALTER TYPE "${oldEnumType.schema}"."${oldEnumType.name}" RENAME TO ${this.buildEnumName(newTable, column, false)}`));
          downQueries.push(new Query_1.Query(`ALTER TYPE ${this.buildEnumName(newTable, column)} RENAME TO "${oldEnumType.name}"`));
        }
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Creates a new column from the column in the table.
       */
      async addColumn(tableOrName, column) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        if (column.generationStrategy === "increment") {
          throw new error_1.TypeORMError(`Adding sequential generated columns into existing table is not supported`);
        }
        if (column.type === "enum" || column.type === "simple-enum") {
          const hasEnum = await this.hasEnumType(table, column);
          if (!hasEnum) {
            upQueries.push(this.createEnumTypeSql(table, column));
            downQueries.push(this.dropEnumTypeSql(table, column));
          }
        }
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(table, column)}`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN "${column.name}"`));
        if (column.isPrimary) {
          const primaryColumns = clonedTable.primaryColumns;
          if (primaryColumns.length > 0) {
            const pkName2 = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column2) => column2.name));
            const columnNames2 = primaryColumns.map((column2) => `"${column2.name}"`).join(", ");
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName2}"`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName2}" PRIMARY KEY (${columnNames2})`));
          }
          primaryColumns.push(column);
          const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column2) => column2.name));
          const columnNames = primaryColumns.map((column2) => `"${column2.name}"`).join(", ");
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
        }
        if (column.generatedType && column.asExpression) {
          const currentSchema = await this.getCurrentSchema();
          let { schema } = this.driver.parseTableName(table);
          if (!schema) {
            schema = currentSchema;
          }
          const insertQuery = this.insertTypeormMetadataSql({
            schema,
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name,
            value: column.asExpression
          });
          const deleteQuery = this.deleteTypeormMetadataSql({
            schema,
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name
          });
          upQueries.push(insertQuery);
          downQueries.push(deleteQuery);
        }
        const columnIndex = clonedTable.indices.find((index) => index.columnNames.length === 1 && index.columnNames[0] === column.name);
        if (columnIndex) {
          if (columnIndex.isUnique) {
            const unique = new TableUnique_1.TableUnique({
              name: this.connection.namingStrategy.uniqueConstraintName(table, columnIndex.columnNames),
              columnNames: columnIndex.columnNames
            });
            upQueries.push(this.createUniqueConstraintSql(table, unique));
            downQueries.push(this.dropIndexSql(table, unique));
            clonedTable.uniques.push(unique);
          } else {
            upQueries.push(this.createIndexSql(table, columnIndex));
            downQueries.push(this.dropIndexSql(table, columnIndex));
          }
        }
        if (column.isUnique) {
          const uniqueConstraint = new TableUnique_1.TableUnique({
            name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),
            columnNames: [column.name]
          });
          clonedTable.uniques.push(uniqueConstraint);
          upQueries.push(this.createUniqueConstraintSql(table, uniqueConstraint));
          downQueries.push(this.dropIndexSql(table, uniqueConstraint.name));
        }
        if (column.comment) {
          upQueries.push(new Query_1.Query(`COMMENT ON COLUMN ${this.escapePath(table)}."${column.name}" IS ${this.escapeComment(column.comment)}`));
          downQueries.push(new Query_1.Query(`COMMENT ON COLUMN ${this.escapePath(table)}."${column.name}" IS ${this.escapeComment(column.comment)}`));
        }
        await this.executeQueries(upQueries, downQueries);
        clonedTable.addColumn(column);
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Creates a new columns from the column in the table.
       */
      async addColumns(tableOrName, columns) {
        for (const column of columns) {
          await this.addColumn(tableOrName, column);
        }
      }
      /**
       * Renames column in the given table.
       */
      async renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const oldColumn = InstanceChecker_1.InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find((c) => c.name === oldTableColumnOrName);
        if (!oldColumn)
          throw new error_1.TypeORMError(`Column "${oldTableColumnOrName}" was not found in the "${table.name}" table.`);
        let newColumn;
        if (InstanceChecker_1.InstanceChecker.isTableColumn(newTableColumnOrName)) {
          newColumn = newTableColumnOrName;
        } else {
          newColumn = oldColumn.clone();
          newColumn.name = newTableColumnOrName;
        }
        return this.changeColumn(table, oldColumn, newColumn);
      }
      /**
       * Changes a column in the table.
       */
      async changeColumn(tableOrName, oldTableColumnOrName, newColumn) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        let clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        let defaultValueChanged = false;
        const oldColumn = InstanceChecker_1.InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find((column) => column.name === oldTableColumnOrName);
        if (!oldColumn)
          throw new error_1.TypeORMError(`Column "${oldTableColumnOrName}" was not found in the "${table.name}" table.`);
        if (oldColumn.type !== newColumn.type || oldColumn.length !== newColumn.length || newColumn.isArray !== oldColumn.isArray || oldColumn.generatedType !== newColumn.generatedType || oldColumn.asExpression !== newColumn.asExpression) {
          await this.dropColumn(table, oldColumn);
          await this.addColumn(table, newColumn);
          clonedTable = table.clone();
        } else {
          if (oldColumn.name !== newColumn.name) {
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME COLUMN "${oldColumn.name}" TO "${newColumn.name}"`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME COLUMN "${newColumn.name}" TO "${oldColumn.name}"`));
            if (oldColumn.type === "enum" || oldColumn.type === "simple-enum") {
              const oldEnumType = await this.getUserDefinedTypeName(table, oldColumn);
              upQueries.push(new Query_1.Query(`ALTER TYPE "${oldEnumType.schema}"."${oldEnumType.name}" RENAME TO ${this.buildEnumName(table, newColumn, false)}`));
              downQueries.push(new Query_1.Query(`ALTER TYPE ${this.buildEnumName(table, newColumn)} RENAME TO "${oldEnumType.name}"`));
            }
            if (oldColumn.isPrimary === true && !oldColumn.primaryKeyConstraintName) {
              const primaryColumns = clonedTable.primaryColumns;
              const columnNames = primaryColumns.map((column) => column.name);
              const oldPkName = this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);
              columnNames.splice(columnNames.indexOf(oldColumn.name), 1);
              columnNames.push(newColumn.name);
              const newPkName = this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${oldPkName}" TO "${newPkName}"`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${newPkName}" TO "${oldPkName}"`));
            }
            clonedTable.findColumnUniques(oldColumn).forEach((unique) => {
              const oldUniqueName = this.connection.namingStrategy.uniqueConstraintName(clonedTable, unique.columnNames);
              if (unique.name !== oldUniqueName)
                return;
              unique.columnNames.splice(unique.columnNames.indexOf(oldColumn.name), 1);
              unique.columnNames.push(newColumn.name);
              const newUniqueName = this.connection.namingStrategy.uniqueConstraintName(clonedTable, unique.columnNames);
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${unique.name}" TO "${newUniqueName}"`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${newUniqueName}" TO "${unique.name}"`));
              unique.name = newUniqueName;
            });
            clonedTable.findColumnIndices(oldColumn).forEach((index) => {
              const oldIndexName = this.connection.namingStrategy.indexName(clonedTable, index.columnNames, index.where);
              if (index.name !== oldIndexName)
                return;
              index.columnNames.splice(index.columnNames.indexOf(oldColumn.name), 1);
              index.columnNames.push(newColumn.name);
              const { schema } = this.driver.parseTableName(table);
              const newIndexName = this.connection.namingStrategy.indexName(clonedTable, index.columnNames, index.where);
              const up = schema ? `ALTER INDEX "${schema}"."${index.name}" RENAME TO "${newIndexName}"` : `ALTER INDEX "${index.name}" RENAME TO "${newIndexName}"`;
              const down = schema ? `ALTER INDEX "${schema}"."${newIndexName}" RENAME TO "${index.name}"` : `ALTER INDEX "${newIndexName}" RENAME TO "${index.name}"`;
              upQueries.push(new Query_1.Query(up));
              downQueries.push(new Query_1.Query(down));
              index.name = newIndexName;
            });
            clonedTable.findColumnForeignKeys(oldColumn).forEach((foreignKey) => {
              const foreignKeyName = this.connection.namingStrategy.foreignKeyName(clonedTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
              if (foreignKey.name !== foreignKeyName)
                return;
              foreignKey.columnNames.splice(foreignKey.columnNames.indexOf(oldColumn.name), 1);
              foreignKey.columnNames.push(newColumn.name);
              const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(clonedTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${foreignKey.name}" TO "${newForeignKeyName}"`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${newForeignKeyName}" TO "${foreignKey.name}"`));
              foreignKey.name = newForeignKeyName;
            });
            const oldTableColumn = clonedTable.columns.find((column) => column.name === oldColumn.name);
            clonedTable.columns[clonedTable.columns.indexOf(oldTableColumn)].name = newColumn.name;
            oldColumn.name = newColumn.name;
          }
          if (newColumn.precision !== oldColumn.precision || newColumn.scale !== oldColumn.scale) {
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" TYPE ${this.driver.createFullType(newColumn)}`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" TYPE ${this.driver.createFullType(oldColumn)}`));
          }
          if (oldColumn.isNullable !== newColumn.isNullable) {
            if (newColumn.isNullable) {
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" DROP NOT NULL`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" SET NOT NULL`));
            } else {
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" SET NOT NULL`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" DROP NOT NULL`));
            }
          }
          if (oldColumn.comment !== newColumn.comment) {
            upQueries.push(new Query_1.Query(`COMMENT ON COLUMN ${this.escapePath(table)}."${oldColumn.name}" IS ${this.escapeComment(newColumn.comment)}`));
            downQueries.push(new Query_1.Query(`COMMENT ON COLUMN ${this.escapePath(table)}."${newColumn.name}" IS ${this.escapeComment(oldColumn.comment)}`));
          }
          if (newColumn.isPrimary !== oldColumn.isPrimary) {
            const primaryColumns = clonedTable.primaryColumns;
            if (primaryColumns.length > 0) {
              const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column) => column.name));
              const columnNames = primaryColumns.map((column) => `"${column.name}"`).join(", ");
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
            }
            if (newColumn.isPrimary === true) {
              primaryColumns.push(newColumn);
              const column = clonedTable.columns.find((column2) => column2.name === newColumn.name);
              column.isPrimary = true;
              const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column2) => column2.name));
              const columnNames = primaryColumns.map((column2) => `"${column2.name}"`).join(", ");
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
            } else {
              const primaryColumn = primaryColumns.find((c) => c.name === newColumn.name);
              primaryColumns.splice(primaryColumns.indexOf(primaryColumn), 1);
              const column = clonedTable.columns.find((column2) => column2.name === newColumn.name);
              column.isPrimary = false;
              if (primaryColumns.length > 0) {
                const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column2) => column2.name));
                const columnNames = primaryColumns.map((column2) => `"${column2.name}"`).join(", ");
                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
              }
            }
          }
          if (newColumn.isUnique !== oldColumn.isUnique) {
            if (newColumn.isUnique) {
              const uniqueConstraint = new TableUnique_1.TableUnique({
                name: this.connection.namingStrategy.uniqueConstraintName(table, [newColumn.name]),
                columnNames: [newColumn.name]
              });
              clonedTable.uniques.push(uniqueConstraint);
              upQueries.push(this.createUniqueConstraintSql(table, uniqueConstraint));
              downQueries.push(this.dropIndexSql(table, uniqueConstraint));
            } else {
              const uniqueConstraint = clonedTable.uniques.find((unique) => {
                return unique.columnNames.length === 1 && !!unique.columnNames.find((columnName) => columnName === newColumn.name);
              });
              clonedTable.uniques.splice(clonedTable.uniques.indexOf(uniqueConstraint), 1);
              upQueries.push(this.dropIndexSql(table, uniqueConstraint));
              downQueries.push(this.createUniqueConstraintSql(table, uniqueConstraint));
            }
          }
          if ((newColumn.type === "enum" || newColumn.type === "simple-enum") && (oldColumn.type === "enum" || oldColumn.type === "simple-enum") && (!OrmUtils_1.OrmUtils.isArraysEqual(newColumn.enum, oldColumn.enum) || newColumn.enumName !== oldColumn.enumName)) {
            const arraySuffix = newColumn.isArray ? "[]" : "";
            const newEnumName = this.buildEnumName(table, newColumn);
            const oldEnumName = this.buildEnumName(table, oldColumn);
            const oldEnumNameWithoutSchema = this.buildEnumName(table, oldColumn, false);
            const oldEnumNameWithSchema_old = this.buildEnumName(table, oldColumn, true, false, true);
            const oldEnumNameWithoutSchema_old = this.buildEnumName(table, oldColumn, false, false, true);
            upQueries.push(new Query_1.Query(`ALTER TYPE ${oldEnumName} RENAME TO ${oldEnumNameWithoutSchema_old}`));
            downQueries.push(new Query_1.Query(`ALTER TYPE ${oldEnumNameWithSchema_old} RENAME TO ${oldEnumNameWithoutSchema}`));
            upQueries.push(this.createEnumTypeSql(table, newColumn, newEnumName));
            downQueries.push(this.dropEnumTypeSql(table, newColumn, newEnumName));
            if (oldColumn.default !== null && oldColumn.default !== void 0) {
              defaultValueChanged = true;
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" DROP DEFAULT`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" SET DEFAULT ${oldColumn.default}`));
            }
            const upType = `${newEnumName}${arraySuffix} USING "${newColumn.name}"::"text"::${newEnumName}${arraySuffix}`;
            const downType = `${oldEnumNameWithSchema_old}${arraySuffix} USING "${newColumn.name}"::"text"::${oldEnumNameWithSchema_old}${arraySuffix}`;
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" TYPE ${upType}`));
            upQueries.push(new Query_1.Query(`SELECT pg_sleep(0.1)`));
            downQueries.push(new Query_1.Query(`SELECT pg_sleep(0.1)`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" TYPE ${downType}`));
            if (newColumn.default !== null && newColumn.default !== void 0) {
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" SET DEFAULT ${newColumn.default}`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" DROP DEFAULT`));
            }
            upQueries.push(this.dropEnumTypeSql(table, oldColumn, oldEnumNameWithSchema_old));
            downQueries.push(this.createEnumTypeSql(table, oldColumn, oldEnumNameWithSchema_old));
          }
          if (oldColumn.isGenerated !== newColumn.isGenerated && newColumn.generationStrategy !== "uuid") {
            if (newColumn.isGenerated) {
              if (newColumn.generationStrategy === "increment") {
                throw new error_1.TypeORMError(`Adding sequential generated columns into existing table is not supported`);
              } else if (newColumn.generationStrategy === "rowid") {
                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" SET DEFAULT unique_rowid()`));
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" DROP DEFAULT`));
              }
            } else {
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" DROP DEFAULT`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" SET DEFAULT unique_rowid()`));
            }
          }
          if (newColumn.default !== oldColumn.default && !defaultValueChanged) {
            if (newColumn.default !== null && newColumn.default !== void 0) {
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" SET DEFAULT ${newColumn.default}`));
              if (oldColumn.default !== null && oldColumn.default !== void 0) {
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" SET DEFAULT ${oldColumn.default}`));
              } else {
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" DROP DEFAULT`));
              }
            } else if (oldColumn.default !== null && oldColumn.default !== void 0) {
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" DROP DEFAULT`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" SET DEFAULT ${oldColumn.default}`));
            }
          }
        }
        if ((newColumn.spatialFeatureType || "").toLowerCase() !== (oldColumn.spatialFeatureType || "").toLowerCase() || newColumn.srid !== oldColumn.srid) {
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" TYPE ${this.driver.createFullType(newColumn)}`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" TYPE ${this.driver.createFullType(oldColumn)}`));
        }
        await this.executeQueries(upQueries, downQueries);
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Changes a column in the table.
       */
      async changeColumns(tableOrName, changedColumns) {
        for (const { oldColumn, newColumn } of changedColumns) {
          await this.changeColumn(tableOrName, oldColumn, newColumn);
        }
      }
      /**
       * Drops column in the table.
       */
      async dropColumn(tableOrName, columnOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const column = InstanceChecker_1.InstanceChecker.isTableColumn(columnOrName) ? columnOrName : table.findColumnByName(columnOrName);
        if (!column)
          throw new error_1.TypeORMError(`Column "${columnOrName}" was not found in table "${table.name}"`);
        const clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        if (column.isPrimary) {
          const pkName = column.primaryKeyConstraintName ? column.primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, clonedTable.primaryColumns.map((column2) => column2.name));
          const columnNames = clonedTable.primaryColumns.map((primaryColumn) => `"${primaryColumn.name}"`).join(", ");
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP CONSTRAINT "${pkName}"`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
          const tableColumn = clonedTable.findColumnByName(column.name);
          tableColumn.isPrimary = false;
          if (clonedTable.primaryColumns.length > 0) {
            const pkName2 = clonedTable.primaryColumns[0].primaryKeyConstraintName ? clonedTable.primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, clonedTable.primaryColumns.map((column2) => column2.name));
            const columnNames2 = clonedTable.primaryColumns.map((primaryColumn) => `"${primaryColumn.name}"`).join(", ");
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD CONSTRAINT "${pkName2}" PRIMARY KEY (${columnNames2})`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP CONSTRAINT "${pkName2}"`));
          }
        }
        const columnIndex = clonedTable.indices.find((index) => index.columnNames.length === 1 && index.columnNames[0] === column.name);
        if (columnIndex) {
          clonedTable.indices.splice(clonedTable.indices.indexOf(columnIndex), 1);
          upQueries.push(this.dropIndexSql(table, columnIndex));
          downQueries.push(this.createIndexSql(table, columnIndex));
        }
        const columnCheck = clonedTable.checks.find((check) => !!check.columnNames && check.columnNames.length === 1 && check.columnNames[0] === column.name);
        if (columnCheck) {
          clonedTable.checks.splice(clonedTable.checks.indexOf(columnCheck), 1);
          upQueries.push(this.dropCheckConstraintSql(table, columnCheck));
          downQueries.push(this.createCheckConstraintSql(table, columnCheck));
        }
        const columnUnique = clonedTable.uniques.find((unique) => unique.columnNames.length === 1 && unique.columnNames[0] === column.name);
        if (columnUnique) {
          clonedTable.uniques.splice(clonedTable.uniques.indexOf(columnUnique), 1);
          upQueries.push(this.dropIndexSql(table, columnUnique.name));
          downQueries.push(this.createUniqueConstraintSql(table, columnUnique));
        }
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN "${column.name}"`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(table, column)}`));
        if (column.generationStrategy === "increment") {
          upQueries.push(new Query_1.Query(`DROP SEQUENCE ${this.escapePath(this.buildSequencePath(table, column))}`));
          downQueries.push(new Query_1.Query(`CREATE SEQUENCE ${this.escapePath(this.buildSequencePath(table, column))}`));
        }
        if (column.generatedType && column.asExpression) {
          const currentSchema = await this.getCurrentSchema();
          let { schema } = this.driver.parseTableName(table);
          if (!schema) {
            schema = currentSchema;
          }
          const deleteQuery = this.deleteTypeormMetadataSql({
            schema,
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name
          });
          const insertQuery = this.insertTypeormMetadataSql({
            schema,
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name,
            value: column.asExpression
          });
          upQueries.push(deleteQuery);
          downQueries.push(insertQuery);
        }
        if (column.type === "enum" || column.type === "simple-enum") {
          const hasEnum = await this.hasEnumType(table, column);
          if (hasEnum) {
            const enumType = await this.getUserDefinedTypeName(table, column);
            const escapedEnumName = `"${enumType.schema}"."${enumType.name}"`;
            upQueries.push(this.dropEnumTypeSql(table, column, escapedEnumName));
            downQueries.push(this.createEnumTypeSql(table, column, escapedEnumName));
          }
        }
        await this.executeQueries(upQueries, downQueries);
        clonedTable.removeColumn(column);
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Drops the columns in the table.
       */
      async dropColumns(tableOrName, columns) {
        for (const column of [...columns]) {
          await this.dropColumn(tableOrName, column);
        }
      }
      /**
       * Creates a new primary key.
       */
      async createPrimaryKey(tableOrName, columnNames, constraintName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const clonedTable = table.clone();
        const up = this.createPrimaryKeySql(table, columnNames, constraintName);
        clonedTable.columns.forEach((column) => {
          if (columnNames.find((columnName) => columnName === column.name))
            column.isPrimary = true;
        });
        const down = this.dropPrimaryKeySql(clonedTable);
        await this.executeQueries(up, down);
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Updates composite primary keys.
       */
      async updatePrimaryKeys(tableOrName, columns) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const clonedTable = table.clone();
        const columnNames = columns.map((column) => column.name);
        const upQueries = [];
        const downQueries = [];
        const primaryColumns = clonedTable.primaryColumns;
        if (primaryColumns.length > 0) {
          const pkName2 = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column) => column.name));
          const columnNamesString2 = primaryColumns.map((column) => `"${column.name}"`).join(", ");
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName2}"`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName2}" PRIMARY KEY (${columnNamesString2})`));
        }
        clonedTable.columns.filter((column) => columnNames.indexOf(column.name) !== -1).forEach((column) => column.isPrimary = true);
        const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);
        const columnNamesString = columnNames.map((columnName) => `"${columnName}"`).join(", ");
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNamesString})`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
        await this.executeQueries(upQueries, downQueries);
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Drops a primary key.
       */
      async dropPrimaryKey(tableOrName, constraintName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const up = this.dropPrimaryKeySql(table);
        const down = this.createPrimaryKeySql(table, table.primaryColumns.map((column) => column.name), constraintName);
        await this.executeQueries(up, down);
        table.primaryColumns.forEach((column) => {
          column.isPrimary = false;
        });
      }
      /**
       * Creates new unique constraint.
       */
      async createUniqueConstraint(tableOrName, uniqueConstraint) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        if (!uniqueConstraint.name)
          uniqueConstraint.name = this.connection.namingStrategy.uniqueConstraintName(table, uniqueConstraint.columnNames);
        const up = this.createUniqueConstraintSql(table, uniqueConstraint);
        const down = this.dropIndexSql(table, uniqueConstraint);
        await this.executeQueries(up, down);
        table.addUniqueConstraint(uniqueConstraint);
      }
      /**
       * Creates new unique constraints.
       */
      async createUniqueConstraints(tableOrName, uniqueConstraints) {
        for (const uniqueConstraint of uniqueConstraints) {
          await this.createUniqueConstraint(tableOrName, uniqueConstraint);
        }
      }
      /**
       * Drops unique constraint.
       */
      async dropUniqueConstraint(tableOrName, uniqueOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const uniqueConstraint = InstanceChecker_1.InstanceChecker.isTableUnique(uniqueOrName) ? uniqueOrName : table.uniques.find((u) => u.name === uniqueOrName);
        if (!uniqueConstraint)
          throw new error_1.TypeORMError(`Supplied unique constraint was not found in table ${table.name}`);
        const up = this.dropIndexSql(table, uniqueConstraint);
        const down = this.createUniqueConstraintSql(table, uniqueConstraint);
        await this.executeQueries(up, down);
        table.removeUniqueConstraint(uniqueConstraint);
      }
      /**
       * Drops unique constraints.
       */
      async dropUniqueConstraints(tableOrName, uniqueConstraints) {
        for (const uniqueConstraint of [...uniqueConstraints]) {
          await this.dropUniqueConstraint(tableOrName, uniqueConstraint);
        }
      }
      /**
       * Creates new check constraint.
       */
      async createCheckConstraint(tableOrName, checkConstraint) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        if (!checkConstraint.name)
          checkConstraint.name = this.connection.namingStrategy.checkConstraintName(table, checkConstraint.expression);
        const up = this.createCheckConstraintSql(table, checkConstraint);
        const down = this.dropCheckConstraintSql(table, checkConstraint);
        await this.executeQueries(up, down);
        table.addCheckConstraint(checkConstraint);
      }
      /**
       * Creates new check constraints.
       */
      async createCheckConstraints(tableOrName, checkConstraints) {
        const promises = checkConstraints.map((checkConstraint) => this.createCheckConstraint(tableOrName, checkConstraint));
        await Promise.all(promises);
      }
      /**
       * Drops check constraint.
       */
      async dropCheckConstraint(tableOrName, checkOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const checkConstraint = InstanceChecker_1.InstanceChecker.isTableCheck(checkOrName) ? checkOrName : table.checks.find((c) => c.name === checkOrName);
        if (!checkConstraint)
          throw new error_1.TypeORMError(`Supplied check constraint was not found in table ${table.name}`);
        const up = this.dropCheckConstraintSql(table, checkConstraint);
        const down = this.createCheckConstraintSql(table, checkConstraint);
        await this.executeQueries(up, down);
        table.removeCheckConstraint(checkConstraint);
      }
      /**
       * Drops check constraints.
       */
      async dropCheckConstraints(tableOrName, checkConstraints) {
        const promises = checkConstraints.map((checkConstraint) => this.dropCheckConstraint(tableOrName, checkConstraint));
        await Promise.all(promises);
      }
      /**
       * Creates new exclusion constraint.
       */
      async createExclusionConstraint(tableOrName, exclusionConstraint) {
        throw new error_1.TypeORMError(`CockroachDB does not support exclusion constraints.`);
      }
      /**
       * Creates new exclusion constraints.
       */
      async createExclusionConstraints(tableOrName, exclusionConstraints) {
        throw new error_1.TypeORMError(`CockroachDB does not support exclusion constraints.`);
      }
      /**
       * Drops exclusion constraint.
       */
      async dropExclusionConstraint(tableOrName, exclusionOrName) {
        throw new error_1.TypeORMError(`CockroachDB does not support exclusion constraints.`);
      }
      /**
       * Drops exclusion constraints.
       */
      async dropExclusionConstraints(tableOrName, exclusionConstraints) {
        throw new error_1.TypeORMError(`CockroachDB does not support exclusion constraints.`);
      }
      /**
       * Creates a new foreign key.
       */
      async createForeignKey(tableOrName, foreignKey) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        if (!foreignKey.name)
          foreignKey.name = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
        const up = this.createForeignKeySql(table, foreignKey);
        const down = this.dropForeignKeySql(table, foreignKey);
        await this.executeQueries(up, down);
        table.addForeignKey(foreignKey);
      }
      /**
       * Creates a new foreign keys.
       */
      async createForeignKeys(tableOrName, foreignKeys) {
        for (const foreignKey of foreignKeys) {
          await this.createForeignKey(tableOrName, foreignKey);
        }
      }
      /**
       * Drops a foreign key from the table.
       */
      async dropForeignKey(tableOrName, foreignKeyOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const foreignKey = InstanceChecker_1.InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName : table.foreignKeys.find((fk) => fk.name === foreignKeyOrName);
        if (!foreignKey)
          throw new error_1.TypeORMError(`Supplied foreign key was not found in table ${table.name}`);
        const up = this.dropForeignKeySql(table, foreignKey);
        const down = this.createForeignKeySql(table, foreignKey);
        await this.executeQueries(up, down);
        table.removeForeignKey(foreignKey);
      }
      /**
       * Drops a foreign keys from the table.
       */
      async dropForeignKeys(tableOrName, foreignKeys) {
        for (const foreignKey of [...foreignKeys]) {
          await this.dropForeignKey(tableOrName, foreignKey);
        }
      }
      /**
       * Creates a new index.
       */
      async createIndex(tableOrName, index) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        if (!index.name)
          index.name = this.generateIndexName(table, index);
        if (index.isUnique) {
          const unique = new TableUnique_1.TableUnique({
            name: index.name,
            columnNames: index.columnNames
          });
          const up = this.createUniqueConstraintSql(table, unique);
          const down = this.dropIndexSql(table, unique);
          await this.executeQueries(up, down);
          table.addUniqueConstraint(unique);
        } else {
          const up = this.createIndexSql(table, index);
          const down = this.dropIndexSql(table, index);
          await this.executeQueries(up, down);
          table.addIndex(index);
        }
      }
      /**
       * Creates a new indices
       */
      async createIndices(tableOrName, indices) {
        for (const index of indices) {
          await this.createIndex(tableOrName, index);
        }
      }
      /**
       * Drops an index from the table.
       */
      async dropIndex(tableOrName, indexOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const index = InstanceChecker_1.InstanceChecker.isTableIndex(indexOrName) ? indexOrName : table.indices.find((i) => i.name === indexOrName);
        if (!index)
          throw new error_1.TypeORMError(`Supplied index ${indexOrName} was not found in table ${table.name}`);
        if (!index.name)
          index.name = this.generateIndexName(table, index);
        const up = this.dropIndexSql(table, index);
        const down = this.createIndexSql(table, index);
        await this.executeQueries(up, down);
        table.removeIndex(index);
      }
      /**
       * Drops an indices from the table.
       */
      async dropIndices(tableOrName, indices) {
        for (const index of [...indices]) {
          await this.dropIndex(tableOrName, index);
        }
      }
      /**
       * Clears all table contents.
       * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.
       */
      async clearTable(tableName) {
        await this.query(`TRUNCATE TABLE ${this.escapePath(tableName)}`);
      }
      /**
       * Removes all tables from the currently connected database.
       */
      async clearDatabase() {
        const schemas = [];
        this.connection.entityMetadatas.filter((metadata) => metadata.schema).forEach((metadata) => {
          const isSchemaExist = !!schemas.find((schema) => schema === metadata.schema);
          if (!isSchemaExist)
            schemas.push(metadata.schema);
        });
        schemas.push(this.driver.options.schema || "current_schema()");
        const schemaNamesString = schemas.map((name) => {
          return name === "current_schema()" ? name : "'" + name + "'";
        }).join(", ");
        const isAnotherTransactionActive = this.isTransactionActive;
        if (!isAnotherTransactionActive)
          await this.startTransaction();
        try {
          const version = await this.getVersion();
          const selectViewDropsQuery = `SELECT 'DROP VIEW IF EXISTS "' || schemaname || '"."' || viewname || '" CASCADE;' as "query" FROM "pg_views" WHERE "schemaname" IN (${schemaNamesString})`;
          const dropViewQueries = await this.query(selectViewDropsQuery);
          await Promise.all(dropViewQueries.map((q) => this.query(q["query"])));
          const selectDropsQuery = `SELECT 'DROP TABLE IF EXISTS "' || table_schema || '"."' || table_name || '" CASCADE;' as "query" FROM "information_schema"."tables" WHERE "table_schema" IN (${schemaNamesString})`;
          const dropQueries = await this.query(selectDropsQuery);
          await Promise.all(dropQueries.map((q) => this.query(q["query"])));
          const selectSequenceDropsQuery = `SELECT 'DROP SEQUENCE "' || sequence_schema || '"."' || sequence_name || '";' as "query" FROM "information_schema"."sequences" WHERE "sequence_schema" IN (${schemaNamesString})`;
          const sequenceDropQueries = await this.query(selectSequenceDropsQuery);
          await Promise.all(sequenceDropQueries.map((q) => this.query(q["query"])));
          if (VersionUtils_1.VersionUtils.isGreaterOrEqual(version, "20.2.19")) {
            await this.dropEnumTypes(schemaNamesString);
          }
          if (!isAnotherTransactionActive)
            await this.commitTransaction();
        } catch (error) {
          try {
            if (!isAnotherTransactionActive)
              await this.rollbackTransaction();
          } catch {
          }
          throw error;
        }
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      async loadViews(viewNames) {
        const hasTable = await this.hasTable(this.getTypeormMetadataTableName());
        if (!hasTable) {
          return [];
        }
        if (!viewNames) {
          viewNames = [];
        }
        const currentDatabase = await this.getCurrentDatabase();
        const currentSchema = await this.getCurrentSchema();
        const viewsCondition = viewNames.map((viewName) => {
          const { schema, tableName } = this.driver.parseTableName(viewName);
          return `("t"."schema" = '${schema || currentSchema}' AND "t"."name" = '${tableName}')`;
        }).join(" OR ");
        const query = `SELECT "t".*, "v"."check_option" FROM ${this.escapePath(this.getTypeormMetadataTableName())} "t" INNER JOIN "information_schema"."views" "v" ON "v"."table_schema" = "t"."schema" AND "v"."table_name" = "t"."name" WHERE "t"."type" = '${MetadataTableType_1.MetadataTableType.VIEW}' ${viewsCondition ? `AND (${viewsCondition})` : ""}`;
        const dbViews = await this.query(query);
        return dbViews.map((dbView) => {
          const view = new View_1.View();
          const schema = dbView["schema"] === currentSchema && !this.driver.options.schema ? void 0 : dbView["schema"];
          view.database = currentDatabase;
          view.schema = dbView["schema"];
          view.name = this.driver.buildTableName(dbView["name"], schema);
          view.expression = dbView["value"];
          return view;
        });
      }
      /**
       * Loads all tables (with given names) from the database and creates a Table from them.
       */
      async loadTables(tableNames) {
        if (tableNames && tableNames.length === 0) {
          return [];
        }
        const currentSchema = await this.getCurrentSchema();
        const currentDatabase = await this.getCurrentDatabase();
        const dbTables = [];
        if (!tableNames) {
          const tablesSql = `SELECT "table_schema", "table_name" FROM "information_schema"."tables"`;
          dbTables.push(...await this.query(tablesSql));
        } else {
          const tablesCondition = tableNames.map((tableName) => this.driver.parseTableName(tableName)).map(({ schema, tableName }) => {
            return `("table_schema" = '${schema || currentSchema}' AND "table_name" = '${tableName}')`;
          }).join(" OR ");
          const tablesSql = `SELECT "table_schema", "table_name" FROM "information_schema"."tables" WHERE ` + tablesCondition;
          dbTables.push(...await this.query(tablesSql));
        }
        if (dbTables.length === 0) {
          return [];
        }
        const columnsCondiiton = dbTables.map(({ table_name, table_schema }) => {
          return `("table_schema" = '${table_schema}' AND "table_name" = '${table_name}')`;
        }).join(" OR ");
        const columnsSql = `SELECT "columns".*, "attr"."attgenerated" as "generated_type", pg_catalog.col_description(('"' || table_catalog || '"."' || table_schema || '"."' || table_name || '"')::regclass::oid, ordinal_position) as description FROM "information_schema"."columns" LEFT JOIN "pg_class" AS "cls" ON "cls"."relname" = "table_name" LEFT JOIN "pg_namespace" AS "ns" ON "ns"."oid" = "cls"."relnamespace" AND "ns"."nspname" = "table_schema" LEFT JOIN "pg_attribute" AS "attr" ON "attr"."attrelid" = "cls"."oid" AND "attr"."attname" = "column_name" AND "attr"."attnum" = "ordinal_position" WHERE "is_hidden" = 'NO' AND ` + columnsCondiiton;
        const constraintsCondition = dbTables.map(({ table_name, table_schema }) => {
          return `("ns"."nspname" = '${table_schema}' AND "t"."relname" = '${table_name}')`;
        }).join(" OR ");
        const constraintsSql = `SELECT "ns"."nspname" AS "table_schema", "t"."relname" AS "table_name", "cnst"."conname" AS "constraint_name", pg_get_constraintdef("cnst"."oid") AS "expression", CASE "cnst"."contype" WHEN 'p' THEN 'PRIMARY' WHEN 'u' THEN 'UNIQUE' WHEN 'c' THEN 'CHECK' WHEN 'x' THEN 'EXCLUDE' END AS "constraint_type", "a"."attname" AS "column_name" FROM "pg_constraint" "cnst" INNER JOIN "pg_class" "t" ON "t"."oid" = "cnst"."conrelid" INNER JOIN "pg_namespace" "ns" ON "ns"."oid" = "cnst"."connamespace" LEFT JOIN "pg_attribute" "a" ON "a"."attrelid" = "cnst"."conrelid" AND "a"."attnum" = ANY ("cnst"."conkey") WHERE "t"."relkind" = 'r' AND (${constraintsCondition})`;
        const indicesSql = `SELECT "ns"."nspname" AS "table_schema", "t"."relname" AS "table_name", "i"."relname" AS "constraint_name", "a"."attname" AS "column_name", CASE "ix"."indisunique" WHEN 't' THEN 'TRUE' ELSE'FALSE' END AS "is_unique", pg_get_expr("ix"."indpred", "ix"."indrelid") AS "condition", "types"."typname" AS "type_name" FROM "pg_class" "t" INNER JOIN "pg_index" "ix" ON "ix"."indrelid" = "t"."oid" INNER JOIN "pg_attribute" "a" ON "a"."attrelid" = "t"."oid"  AND "a"."attnum" = ANY ("ix"."indkey") INNER JOIN "pg_namespace" "ns" ON "ns"."oid" = "t"."relnamespace" INNER JOIN "pg_class" "i" ON "i"."oid" = "ix"."indexrelid" INNER JOIN "pg_type" "types" ON "types"."oid" = "a"."atttypid" LEFT JOIN "pg_constraint" "cnst" ON "cnst"."conname" = "i"."relname" WHERE "t"."relkind" = 'r' AND "cnst"."contype" IS NULL AND (${constraintsCondition})`;
        const foreignKeysCondition = dbTables.map(({ table_name, table_schema }) => {
          return `("ns"."nspname" = '${table_schema}' AND "cl"."relname" = '${table_name}')`;
        }).join(" OR ");
        const foreignKeysSql = `SELECT "con"."conname" AS "constraint_name", "con"."nspname" AS "table_schema", "con"."relname" AS "table_name", "att2"."attname" AS "column_name", "ns"."nspname" AS "referenced_table_schema", "cl"."relname" AS "referenced_table_name", "att"."attname" AS "referenced_column_name", "con"."confdeltype" AS "on_delete", "con"."confupdtype" AS "on_update" FROM ( SELECT UNNEST ("con1"."conkey") AS "parent", UNNEST ("con1"."confkey") AS "child", "con1"."confrelid", "con1"."conrelid", "con1"."conname", "con1"."contype", "ns"."nspname", "cl"."relname", CASE "con1"."confdeltype" WHEN 'a' THEN 'NO ACTION' WHEN 'r' THEN 'RESTRICT' WHEN 'c' THEN 'CASCADE' WHEN 'n' THEN 'SET NULL' WHEN 'd' THEN 'SET DEFAULT' END as "confdeltype", CASE "con1"."confupdtype" WHEN 'a' THEN 'NO ACTION' WHEN 'r' THEN 'RESTRICT' WHEN 'c' THEN 'CASCADE' WHEN 'n' THEN 'SET NULL' WHEN 'd' THEN 'SET DEFAULT' END as "confupdtype" FROM "pg_class" "cl" INNER JOIN "pg_namespace" "ns" ON "cl"."relnamespace" = "ns"."oid" INNER JOIN "pg_constraint" "con1" ON "con1"."conrelid" = "cl"."oid" WHERE "con1"."contype" = 'f' AND (${foreignKeysCondition}) ) "con" INNER JOIN "pg_attribute" "att" ON "att"."attrelid" = "con"."confrelid" AND "att"."attnum" = "con"."child" INNER JOIN "pg_class" "cl" ON "cl"."oid" = "con"."confrelid" INNER JOIN "pg_namespace" "ns" ON "cl"."relnamespace" = "ns"."oid" INNER JOIN "pg_attribute" "att2" ON "att2"."attrelid" = "con"."conrelid" AND "att2"."attnum" = "con"."parent"`;
        const tableSchemas = dbTables.map((dbTable) => `'${dbTable.table_schema}'`).join(", ");
        const enumsSql = `SELECT "t"."typname" AS "name", string_agg("e"."enumlabel", '|') AS "value" FROM "pg_enum" "e" INNER JOIN "pg_type" "t" ON "t"."oid" = "e"."enumtypid" INNER JOIN "pg_namespace" "n" ON "n"."oid" = "t"."typnamespace" WHERE "n"."nspname" IN (${tableSchemas}) GROUP BY "t"."typname"`;
        const [dbColumns, dbConstraints, dbIndices, dbForeignKeys, dbEnums] = await Promise.all([
          this.query(columnsSql),
          this.query(constraintsSql),
          this.query(indicesSql),
          this.query(foreignKeysSql),
          this.query(enumsSql)
        ]);
        return Promise.all(dbTables.map(async (dbTable) => {
          const table = new Table_1.Table();
          const getSchemaFromKey = (dbObject, key) => {
            return dbObject[key] === currentSchema && (!this.driver.options.schema || this.driver.options.schema === currentSchema) ? void 0 : dbObject[key];
          };
          const schema = getSchemaFromKey(dbTable, "table_schema");
          table.database = currentDatabase;
          table.schema = dbTable["table_schema"];
          table.name = this.driver.buildTableName(dbTable["table_name"], schema);
          table.columns = await Promise.all(dbColumns.filter((dbColumn) => dbColumn["table_name"] === dbTable["table_name"] && dbColumn["table_schema"] === dbTable["table_schema"]).map(async (dbColumn) => {
            const columnConstraints = dbConstraints.filter((dbConstraint) => {
              return dbConstraint["table_name"] === dbColumn["table_name"] && dbConstraint["table_schema"] === dbColumn["table_schema"] && dbConstraint["column_name"] === dbColumn["column_name"];
            });
            const tableColumn = new TableColumn_1.TableColumn();
            tableColumn.name = dbColumn["column_name"];
            tableColumn.type = dbColumn["crdb_sql_type"].toLowerCase();
            if (dbColumn["crdb_sql_type"].indexOf("COLLATE") !== -1) {
              tableColumn.collation = dbColumn["crdb_sql_type"].substr(dbColumn["crdb_sql_type"].indexOf("COLLATE") + "COLLATE".length + 1, dbColumn["crdb_sql_type"].length);
              tableColumn.type = tableColumn.type.substr(0, dbColumn["crdb_sql_type"].indexOf("COLLATE") - 1);
            }
            if (tableColumn.type.indexOf("(") !== -1)
              tableColumn.type = tableColumn.type.substr(0, tableColumn.type.indexOf("("));
            if (tableColumn.type === "numeric" || tableColumn.type === "decimal") {
              if (dbColumn["numeric_precision"] !== null && !this.isDefaultColumnPrecision(table, tableColumn, dbColumn["numeric_precision"])) {
                tableColumn.precision = parseInt(dbColumn["numeric_precision"]);
              } else if (dbColumn["numeric_scale"] !== null && !this.isDefaultColumnScale(table, tableColumn, dbColumn["numeric_scale"])) {
                tableColumn.precision = void 0;
              }
              if (dbColumn["numeric_scale"] !== null && !this.isDefaultColumnScale(table, tableColumn, dbColumn["numeric_scale"])) {
                tableColumn.scale = parseInt(dbColumn["numeric_scale"]);
              } else if (dbColumn["numeric_precision"] !== null && !this.isDefaultColumnPrecision(table, tableColumn, dbColumn["numeric_precision"])) {
                tableColumn.scale = void 0;
              }
            }
            let udtName = dbColumn["udt_name"];
            if (udtName.indexOf("_") === 0) {
              udtName = udtName.substr(1, udtName.length);
            }
            const enumType = dbEnums.find((dbEnum) => {
              return dbEnum["name"] === udtName;
            });
            if (enumType) {
              const builtEnumName = this.buildEnumName(table, tableColumn, false, true);
              const enumName = builtEnumName !== enumType["name"] ? enumType["name"] : void 0;
              tableColumn.type = "enum";
              tableColumn.enum = enumType["value"].split("|");
              tableColumn.enumName = enumName;
            }
            if (dbColumn["data_type"].toLowerCase() === "array") {
              tableColumn.isArray = true;
              if (!enumType) {
                const type = dbColumn["crdb_sql_type"].replace("[]", "").toLowerCase();
                tableColumn.type = this.connection.driver.normalizeType({
                  type
                });
              }
            }
            if (this.driver.withLengthColumnTypes.indexOf(tableColumn.type) !== -1 && dbColumn["character_maximum_length"]) {
              const length = dbColumn["character_maximum_length"].toString();
              tableColumn.length = !this.isDefaultColumnLength(table, tableColumn, length) ? length : "";
            }
            tableColumn.isNullable = dbColumn["is_nullable"] === "YES";
            const primaryConstraint = columnConstraints.find((constraint) => constraint["constraint_type"] === "PRIMARY");
            if (primaryConstraint) {
              tableColumn.isPrimary = true;
              const anotherPrimaryConstraints = dbConstraints.filter((constraint) => constraint["table_name"] === dbColumn["table_name"] && constraint["table_schema"] === dbColumn["table_schema"] && constraint["column_name"] !== dbColumn["column_name"] && constraint["constraint_type"] === "PRIMARY");
              const columnNames = anotherPrimaryConstraints.map((constraint) => constraint["column_name"]);
              columnNames.push(dbColumn["column_name"]);
              const pkName = this.connection.namingStrategy.primaryKeyName(table, columnNames);
              if (primaryConstraint["constraint_name"] !== pkName) {
                tableColumn.primaryKeyConstraintName = primaryConstraint["constraint_name"];
              }
            }
            const uniqueConstraints = columnConstraints.filter((constraint) => constraint["constraint_type"] === "UNIQUE");
            const isConstraintComposite = uniqueConstraints.every((uniqueConstraint) => {
              return dbConstraints.some((dbConstraint) => dbConstraint["constraint_type"] === "UNIQUE" && dbConstraint["constraint_name"] === uniqueConstraint["constraint_name"] && dbConstraint["column_name"] !== dbColumn["column_name"]);
            });
            tableColumn.isUnique = uniqueConstraints.length > 0 && !isConstraintComposite;
            if (dbColumn["column_default"] !== null && dbColumn["column_default"] !== void 0) {
              if (dbColumn["column_default"] === "unique_rowid()") {
                tableColumn.isGenerated = true;
                tableColumn.generationStrategy = "rowid";
              } else if (dbColumn["column_default"].indexOf("nextval") !== -1) {
                tableColumn.isGenerated = true;
                tableColumn.generationStrategy = "increment";
              } else if (dbColumn["column_default"] === "gen_random_uuid()") {
                tableColumn.isGenerated = true;
                tableColumn.generationStrategy = "uuid";
              } else {
                tableColumn.default = dbColumn["column_default"].replace(/:::[\w\s[\]"]+/g, "");
                tableColumn.default = tableColumn.default.replace(/^(-?[\d.]+)$/, "($1)");
                if (enumType) {
                  tableColumn.default = tableColumn.default.replace(`.${enumType["name"]}`, "");
                }
              }
            }
            if ((dbColumn["is_generated"] === "YES" || dbColumn["is_generated"] === "ALWAYS") && dbColumn["generation_expression"]) {
              tableColumn.generatedType = dbColumn["generated_type"] === "s" ? "STORED" : "VIRTUAL";
              const asExpressionQuery = this.selectTypeormMetadataSql({
                schema: dbTable["table_schema"],
                table: dbTable["table_name"],
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: tableColumn.name
              });
              const results = await this.query(asExpressionQuery.query, asExpressionQuery.parameters);
              if (results[0] && results[0].value) {
                tableColumn.asExpression = results[0].value;
              } else {
                tableColumn.asExpression = "";
              }
            }
            tableColumn.comment = dbColumn["description"] == null ? void 0 : dbColumn["description"];
            if (dbColumn["character_set_name"])
              tableColumn.charset = dbColumn["character_set_name"];
            if (tableColumn.type === "geometry" || tableColumn.type === "geography") {
              const sql = `SELECT * FROM (SELECT "f_table_schema" "table_schema", "f_table_name" "table_name", "f_${tableColumn.type}_column" "column_name", "srid", "type" FROM "${tableColumn.type}_columns") AS _ WHERE "column_name" = '${dbColumn["column_name"]}' AND "table_schema" = '${dbColumn["table_schema"]}' AND "table_name" = '${dbColumn["table_name"]}'`;
              const results = await this.query(sql);
              if (results.length > 0) {
                tableColumn.spatialFeatureType = results[0].type;
                tableColumn.srid = results[0].srid ? parseInt(results[0].srid) : void 0;
              }
            }
            return tableColumn;
          }));
          const tableUniqueConstraints = OrmUtils_1.OrmUtils.uniq(dbConstraints.filter((dbConstraint) => {
            return dbConstraint["table_name"] === dbTable["table_name"] && dbConstraint["table_schema"] === dbTable["table_schema"] && dbConstraint["constraint_type"] === "UNIQUE";
          }), (dbConstraint) => dbConstraint["constraint_name"]);
          table.uniques = tableUniqueConstraints.map((constraint) => {
            const uniques = dbConstraints.filter((dbC) => dbC["constraint_name"] === constraint["constraint_name"]);
            return new TableUnique_1.TableUnique({
              name: constraint["constraint_name"],
              columnNames: uniques.map((u) => u["column_name"])
            });
          });
          const tableCheckConstraints = OrmUtils_1.OrmUtils.uniq(dbConstraints.filter((dbConstraint) => {
            return dbConstraint["table_name"] === dbTable["table_name"] && dbConstraint["table_schema"] === dbTable["table_schema"] && dbConstraint["constraint_type"] === "CHECK";
          }), (dbConstraint) => dbConstraint["constraint_name"]);
          table.checks = tableCheckConstraints.map((constraint) => {
            const checks = dbConstraints.filter((dbC) => dbC["constraint_name"] === constraint["constraint_name"]);
            return new TableCheck_1.TableCheck({
              name: constraint["constraint_name"],
              columnNames: checks.map((c) => c["column_name"]),
              expression: constraint["expression"].replace(/^\s*CHECK\s*\((.*)\)\s*$/i, "$1")
            });
          });
          const tableExclusionConstraints = OrmUtils_1.OrmUtils.uniq(dbConstraints.filter((dbConstraint) => {
            return dbConstraint["table_name"] === dbTable["table_name"] && dbConstraint["table_schema"] === dbTable["table_schema"] && dbConstraint["constraint_type"] === "EXCLUDE";
          }), (dbConstraint) => dbConstraint["constraint_name"]);
          table.exclusions = tableExclusionConstraints.map((constraint) => {
            return new TableExclusion_1.TableExclusion({
              name: constraint["constraint_name"],
              expression: constraint["expression"].substring(8)
              // trim EXCLUDE from start of expression
            });
          });
          const tableForeignKeyConstraints = OrmUtils_1.OrmUtils.uniq(dbForeignKeys.filter((dbForeignKey) => {
            return dbForeignKey["table_name"] === dbTable["table_name"] && dbForeignKey["table_schema"] === dbTable["table_schema"];
          }), (dbForeignKey) => dbForeignKey["constraint_name"]);
          table.foreignKeys = tableForeignKeyConstraints.map((dbForeignKey) => {
            const foreignKeys = dbForeignKeys.filter((dbFk) => dbFk["constraint_name"] === dbForeignKey["constraint_name"]);
            const schema2 = getSchemaFromKey(dbForeignKey, "referenced_table_schema");
            const referencedTableName = this.driver.buildTableName(dbForeignKey["referenced_table_name"], schema2);
            return new TableForeignKey_1.TableForeignKey({
              name: dbForeignKey["constraint_name"],
              columnNames: foreignKeys.map((dbFk) => dbFk["column_name"]),
              referencedSchema: dbForeignKey["referenced_table_schema"],
              referencedTableName,
              referencedColumnNames: foreignKeys.map((dbFk) => dbFk["referenced_column_name"]),
              onDelete: dbForeignKey["on_delete"],
              onUpdate: dbForeignKey["on_update"]
            });
          });
          const tableIndexConstraints = OrmUtils_1.OrmUtils.uniq(dbIndices.filter((dbIndex) => {
            return dbIndex["table_name"] === dbTable["table_name"] && dbIndex["table_schema"] === dbTable["table_schema"];
          }), (dbIndex) => dbIndex["constraint_name"]);
          table.indices = tableIndexConstraints.map((constraint) => {
            const indices = dbIndices.filter((index) => index["constraint_name"] === constraint["constraint_name"]);
            return new TableIndex_1.TableIndex({
              table,
              name: constraint["constraint_name"],
              columnNames: indices.map((i) => i["column_name"]),
              isUnique: constraint["is_unique"] === "TRUE",
              where: constraint["condition"],
              isSpatial: indices.every((i) => this.driver.spatialTypes.indexOf(i["type_name"]) >= 0),
              isFulltext: false
            });
          });
          return table;
        }));
      }
      /**
       * Builds create table sql.
       */
      createTableSql(table, createForeignKeys) {
        const columnDefinitions = table.columns.map((column) => this.buildCreateColumnSql(table, column)).join(", ");
        let sql = `CREATE TABLE ${this.escapePath(table)} (${columnDefinitions}`;
        table.columns.filter((column) => column.isUnique).forEach((column) => {
          const isUniqueExist = table.uniques.some((unique) => unique.columnNames.length === 1 && unique.columnNames[0] === column.name);
          if (!isUniqueExist)
            table.uniques.push(new TableUnique_1.TableUnique({
              name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),
              columnNames: [column.name]
            }));
        });
        table.indices.filter((index) => index.isUnique).forEach((index) => {
          table.uniques.push(new TableUnique_1.TableUnique({
            name: this.connection.namingStrategy.uniqueConstraintName(table, index.columnNames),
            columnNames: index.columnNames
          }));
        });
        if (table.uniques.length > 0) {
          const uniquesSql = table.uniques.map((unique) => {
            const uniqueName = unique.name ? unique.name : this.connection.namingStrategy.uniqueConstraintName(table, unique.columnNames);
            const columnNames = unique.columnNames.map((columnName) => `"${columnName}"`).join(", ");
            return `CONSTRAINT "${uniqueName}" UNIQUE (${columnNames})`;
          }).join(", ");
          sql += `, ${uniquesSql}`;
        }
        if (table.checks.length > 0) {
          const checksSql = table.checks.map((check) => {
            const checkName = check.name ? check.name : this.connection.namingStrategy.checkConstraintName(table, check.expression);
            return `CONSTRAINT "${checkName}" CHECK (${check.expression})`;
          }).join(", ");
          sql += `, ${checksSql}`;
        }
        if (table.foreignKeys.length > 0 && createForeignKeys) {
          const foreignKeysSql = table.foreignKeys.map((fk) => {
            const columnNames = fk.columnNames.map((columnName) => `"${columnName}"`).join(", ");
            if (!fk.name)
              fk.name = this.connection.namingStrategy.foreignKeyName(table, fk.columnNames, this.getTablePath(fk), fk.referencedColumnNames);
            const referencedColumnNames = fk.referencedColumnNames.map((columnName) => `"${columnName}"`).join(", ");
            let constraint = `CONSTRAINT "${fk.name}" FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(fk))} (${referencedColumnNames})`;
            if (fk.onDelete)
              constraint += ` ON DELETE ${fk.onDelete}`;
            if (fk.onUpdate)
              constraint += ` ON UPDATE ${fk.onUpdate}`;
            return constraint;
          }).join(", ");
          sql += `, ${foreignKeysSql}`;
        }
        const primaryColumns = table.columns.filter((column) => column.isPrimary);
        if (primaryColumns.length > 0) {
          const primaryKeyName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(table, primaryColumns.map((column) => column.name));
          const columnNames = primaryColumns.map((column) => `"${column.name}"`).join(", ");
          sql += `, CONSTRAINT "${primaryKeyName}" PRIMARY KEY (${columnNames})`;
        }
        sql += `)`;
        table.columns.filter((it) => it.comment).forEach((it) => sql += `; COMMENT ON COLUMN ${this.escapePath(table)}."${it.name}" IS ${this.escapeComment(it.comment)}`);
        return new Query_1.Query(sql);
      }
      /**
       * Loads Cockroachdb version.
       */
      async getVersion() {
        const result = await this.query(`SELECT version() AS "version"`);
        const versionString = result[0].version;
        return versionString.replace(/^CockroachDB CCL v([\d.]+) .*$/, "$1");
      }
      /**
       * Builds drop table sql.
       */
      dropTableSql(tableOrPath) {
        return new Query_1.Query(`DROP TABLE ${this.escapePath(tableOrPath)}`);
      }
      createViewSql(view) {
        if (typeof view.expression === "string") {
          return new Query_1.Query(`CREATE VIEW ${this.escapePath(view)} AS ${view.expression}`);
        } else {
          return new Query_1.Query(`CREATE VIEW ${this.escapePath(view)} AS ${view.expression(this.connection).getQuery()}`);
        }
      }
      async insertViewDefinitionSql(view) {
        const currentSchema = await this.getCurrentSchema();
        let { schema, tableName: name } = this.driver.parseTableName(view);
        if (!schema) {
          schema = currentSchema;
        }
        const expression = typeof view.expression === "string" ? view.expression.trim() : view.expression(this.connection).getQuery();
        return this.insertTypeormMetadataSql({
          type: MetadataTableType_1.MetadataTableType.VIEW,
          schema,
          name,
          value: expression
        });
      }
      /**
       * Builds drop view sql.
       */
      dropViewSql(viewOrPath) {
        return new Query_1.Query(`DROP VIEW ${this.escapePath(viewOrPath)}`);
      }
      /**
       * Builds remove view sql.
       */
      async deleteViewDefinitionSql(viewOrPath) {
        const currentSchema = await this.getCurrentSchema();
        let { schema, tableName: name } = this.driver.parseTableName(viewOrPath);
        if (!schema) {
          schema = currentSchema;
        }
        return this.deleteTypeormMetadataSql({
          type: MetadataTableType_1.MetadataTableType.VIEW,
          schema,
          name
        });
      }
      /**
       * Drops ENUM type from given schemas.
       */
      async dropEnumTypes(schemaNames) {
        const selectDropsQuery = `SELECT 'DROP TYPE IF EXISTS "' || n.nspname || '"."' || t.typname || '";' as "query" FROM "pg_type" "t" INNER JOIN "pg_enum" "e" ON "e"."enumtypid" = "t"."oid" INNER JOIN "pg_namespace" "n" ON "n"."oid" = "t"."typnamespace" WHERE "n"."nspname" IN (${schemaNames}) GROUP BY "n"."nspname", "t"."typname"`;
        const dropQueries = await this.query(selectDropsQuery);
        await Promise.all(dropQueries.map((q) => this.query(q["query"])));
      }
      /**
       * Checks if enum with the given name exist in the database.
       */
      async hasEnumType(table, column) {
        let { schema } = this.driver.parseTableName(table);
        if (!schema) {
          schema = await this.getCurrentSchema();
        }
        const enumName = this.buildEnumName(table, column, false, true);
        const sql = `SELECT "n"."nspname", "t"."typname" FROM "pg_type" "t" INNER JOIN "pg_namespace" "n" ON "n"."oid" = "t"."typnamespace" WHERE "n"."nspname" = '${schema}' AND "t"."typname" = '${enumName}'`;
        const result = await this.query(sql);
        return result.length ? true : false;
      }
      /**
       * Builds create ENUM type sql.
       */
      createEnumTypeSql(table, column, enumName) {
        if (!enumName)
          enumName = this.buildEnumName(table, column);
        const enumValues = column.enum.map((value) => `'${value.replaceAll("'", "''")}'`).join(", ");
        return new Query_1.Query(`CREATE TYPE ${enumName} AS ENUM(${enumValues})`);
      }
      /**
       * Builds create ENUM type sql.
       */
      dropEnumTypeSql(table, column, enumName) {
        if (!enumName)
          enumName = this.buildEnumName(table, column);
        return new Query_1.Query(`DROP TYPE ${enumName}`);
      }
      /**
       * Builds create index sql.
       * UNIQUE indices creates as UNIQUE constraints.
       */
      createIndexSql(table, index) {
        const columns = index.columnNames.map((columnName) => `"${columnName}"`).join(", ");
        return new Query_1.Query(`CREATE ${index.isUnique ? "UNIQUE " : ""}INDEX "${index.name}" ON ${this.escapePath(table)} ${index.isSpatial ? "USING GiST " : ""}(${columns}) ${index.where ? "WHERE " + index.where : ""}`);
      }
      /**
       * Builds drop index sql.
       */
      dropIndexSql(table, indexOrName) {
        const indexName = InstanceChecker_1.InstanceChecker.isTableIndex(indexOrName) || InstanceChecker_1.InstanceChecker.isTableUnique(indexOrName) ? indexOrName.name : indexOrName;
        return new Query_1.Query(`DROP INDEX ${this.escapePath(table)}@"${indexName}" CASCADE`);
      }
      /**
       * Builds create primary key sql.
       */
      createPrimaryKeySql(table, columnNames, constraintName) {
        const primaryKeyName = constraintName ? constraintName : this.connection.namingStrategy.primaryKeyName(table, columnNames);
        const columnNamesString = columnNames.map((columnName) => `"${columnName}"`).join(", ");
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${primaryKeyName}" PRIMARY KEY (${columnNamesString})`);
      }
      /**
       * Builds drop primary key sql.
       */
      dropPrimaryKeySql(table) {
        if (!table.primaryColumns.length)
          throw new error_1.TypeORMError(`Table ${table} has no primary keys.`);
        const columnNames = table.primaryColumns.map((column) => column.name);
        const constraintName = table.primaryColumns[0].primaryKeyConstraintName;
        const primaryKeyName = constraintName ? constraintName : this.connection.namingStrategy.primaryKeyName(table, columnNames);
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${primaryKeyName}"`);
      }
      /**
       * Builds create unique constraint sql.
       */
      createUniqueConstraintSql(table, uniqueConstraint) {
        const columnNames = uniqueConstraint.columnNames.map((column) => `"` + column + `"`).join(", ");
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${uniqueConstraint.name}" UNIQUE (${columnNames})`);
      }
      /**
       * Builds drop unique constraint sql.
       */
      dropUniqueConstraintSql(table, uniqueOrName) {
        const uniqueName = InstanceChecker_1.InstanceChecker.isTableUnique(uniqueOrName) ? uniqueOrName.name : uniqueOrName;
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${uniqueName}"`);
      }
      /**
       * Builds create check constraint sql.
       */
      createCheckConstraintSql(table, checkConstraint) {
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${checkConstraint.name}" CHECK (${checkConstraint.expression})`);
      }
      /**
       * Builds drop check constraint sql.
       */
      dropCheckConstraintSql(table, checkOrName) {
        const checkName = InstanceChecker_1.InstanceChecker.isTableCheck(checkOrName) ? checkOrName.name : checkOrName;
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${checkName}"`);
      }
      /**
       * Builds create foreign key sql.
       */
      createForeignKeySql(table, foreignKey) {
        const columnNames = foreignKey.columnNames.map((column) => `"` + column + `"`).join(", ");
        const referencedColumnNames = foreignKey.referencedColumnNames.map((column) => `"` + column + `"`).join(",");
        let sql = `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${foreignKey.name}" FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;
        if (foreignKey.onDelete)
          sql += ` ON DELETE ${foreignKey.onDelete}`;
        if (foreignKey.onUpdate)
          sql += ` ON UPDATE ${foreignKey.onUpdate}`;
        return new Query_1.Query(sql);
      }
      /**
       * Builds drop foreign key sql.
       */
      dropForeignKeySql(table, foreignKeyOrName) {
        const foreignKeyName = InstanceChecker_1.InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName.name : foreignKeyOrName;
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${foreignKeyName}"`);
      }
      /**
       * Builds sequence name from given table and column.
       */
      buildSequenceName(table, columnOrName) {
        const { tableName } = this.driver.parseTableName(table);
        const columnName = InstanceChecker_1.InstanceChecker.isTableColumn(columnOrName) ? columnOrName.name : columnOrName;
        return `${tableName}_${columnName}_seq`;
      }
      buildSequencePath(table, columnOrName) {
        const { schema } = this.driver.parseTableName(table);
        return schema ? `${schema}.${this.buildSequenceName(table, columnOrName)}` : this.buildSequenceName(table, columnOrName);
      }
      /**
       * Builds ENUM type name from given table and column.
       */
      buildEnumName(table, column, withSchema = true, disableEscape, toOld) {
        const { schema, tableName } = this.driver.parseTableName(table);
        let enumName = column.enumName ? column.enumName : `${tableName}_${column.name.toLowerCase()}_enum`;
        if (schema && withSchema)
          enumName = `${schema}.${enumName}`;
        if (toOld)
          enumName = enumName + "_old";
        return enumName.split(".").map((i) => {
          return disableEscape ? i : `"${i}"`;
        }).join(".");
      }
      async getUserDefinedTypeName(table, column) {
        let { schema, tableName: name } = this.driver.parseTableName(table);
        if (!schema) {
          schema = await this.getCurrentSchema();
        }
        const result = await this.query(`SELECT "udt_schema", "udt_name" FROM "information_schema"."columns" WHERE "table_schema" = '${schema}' AND "table_name" = '${name}' AND "column_name"='${column.name}'`);
        let udtName = result[0]["udt_name"];
        if (udtName.indexOf("_") === 0) {
          udtName = udtName.substr(1, udtName.length);
        }
        return {
          schema: result[0]["udt_schema"],
          name: udtName
        };
      }
      /**
       * Escapes a given comment so it's safe to include in a query.
       */
      escapeComment(comment) {
        if (comment === void 0 || comment.length === 0) {
          return "NULL";
        }
        comment = comment.replace(/'/g, "''").replace(/\u0000/g, "");
        return `'${comment}'`;
      }
      /**
       * Escapes given table or view path.
       */
      escapePath(target) {
        const { schema, tableName } = this.driver.parseTableName(target);
        if (schema && schema !== this.driver.searchSchema) {
          return `"${schema}"."${tableName}"`;
        }
        return `"${tableName}"`;
      }
      /**
       * Builds a query for create column.
       */
      buildCreateColumnSql(table, column) {
        let c = '"' + column.name + '"';
        if (column.isGenerated) {
          if (column.generationStrategy === "increment") {
            c += ` INT DEFAULT nextval('${this.escapePath(this.buildSequencePath(table, column))}')`;
          } else if (column.generationStrategy === "rowid") {
            c += " INT DEFAULT unique_rowid()";
          } else if (column.generationStrategy === "uuid") {
            c += " UUID DEFAULT gen_random_uuid()";
          }
        }
        if (column.type === "enum" || column.type === "simple-enum") {
          c += " " + this.buildEnumName(table, column);
          if (column.isArray)
            c += " array";
        } else if (!column.isGenerated) {
          c += " " + this.connection.driver.createFullType(column);
        }
        if (column.asExpression) {
          c += ` AS (${column.asExpression}) ${column.generatedType ? column.generatedType : "VIRTUAL"}`;
        } else {
          if (column.charset)
            c += ' CHARACTER SET "' + column.charset + '"';
          if (column.collation)
            c += ' COLLATE "' + column.collation + '"';
        }
        if (!column.isNullable)
          c += " NOT NULL";
        if (!column.isGenerated && column.default !== void 0 && column.default !== null)
          c += " DEFAULT " + column.default;
        return c;
      }
      /**
       * Change table comment.
       */
      changeTableComment(tableOrName, comment) {
        throw new error_1.TypeORMError(`cockroachdb driver does not support change table comment.`);
      }
    };
    exports2.CockroachQueryRunner = CockroachQueryRunner;
  }
});

// node_modules/typeorm/driver/cockroachdb/CockroachDriver.js
var require_CockroachDriver = __commonJS({
  "node_modules/typeorm/driver/cockroachdb/CockroachDriver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CockroachDriver = void 0;
    var error_1 = require_error();
    var ConnectionIsNotSetError_1 = require_ConnectionIsNotSetError();
    var DriverPackageNotInstalledError_1 = require_DriverPackageNotInstalledError();
    var PlatformTools_1 = require_PlatformTools();
    var RdbmsSchemaBuilder_1 = require_RdbmsSchemaBuilder();
    var ApplyValueTransformers_1 = require_ApplyValueTransformers();
    var DateUtils_1 = require_DateUtils();
    var InstanceChecker_1 = require_InstanceChecker();
    var ObjectUtils_1 = require_ObjectUtils();
    var OrmUtils_1 = require_OrmUtils();
    var DriverUtils_1 = require_DriverUtils();
    var CockroachQueryRunner_1 = require_CockroachQueryRunner();
    var CockroachDriver = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection) {
        this.slaves = [];
        this.connectedQueryRunners = [];
        this.isReplicated = false;
        this.treeSupport = true;
        this.transactionSupport = "nested";
        this.supportedDataTypes = [
          "array",
          "bool",
          "boolean",
          "bytes",
          "bytea",
          "blob",
          "date",
          "enum",
          "geometry",
          "geography",
          "numeric",
          "decimal",
          "dec",
          "float",
          "float4",
          "float8",
          "double precision",
          "real",
          "inet",
          "int",
          "int4",
          "integer",
          "int2",
          "int8",
          "int64",
          "smallint",
          "bigint",
          "interval",
          "string",
          "character varying",
          "character",
          "char",
          "char varying",
          "varchar",
          "text",
          "time",
          "time without time zone",
          "timestamp",
          "timestamptz",
          "timestamp without time zone",
          "timestamp with time zone",
          "json",
          "jsonb",
          "uuid"
        ];
        this.supportedUpsertTypes = [
          "on-conflict-do-update",
          "primary-key"
        ];
        this.spatialTypes = ["geometry", "geography"];
        this.withLengthColumnTypes = [
          "character varying",
          "char varying",
          "varchar",
          "character",
          "char",
          "string"
        ];
        this.withPrecisionColumnTypes = ["numeric", "decimal", "dec"];
        this.withScaleColumnTypes = ["numeric", "decimal", "dec"];
        this.mappedDataTypes = {
          createDate: "timestamptz",
          createDateDefault: "now()",
          updateDate: "timestamptz",
          updateDateDefault: "now()",
          deleteDate: "timestamptz",
          deleteDateNullable: true,
          version: Number,
          treeLevel: Number,
          migrationId: Number,
          migrationName: "varchar",
          migrationTimestamp: "int8",
          cacheId: Number,
          cacheIdentifier: "varchar",
          cacheTime: "int8",
          cacheDuration: Number,
          cacheQuery: "string",
          cacheResult: "string",
          metadataType: "varchar",
          metadataDatabase: "varchar",
          metadataSchema: "varchar",
          metadataTable: "varchar",
          metadataName: "varchar",
          metadataValue: "string"
        };
        this.parametersPrefix = "$";
        this.dataTypeDefaults = {
          char: { length: 1 }
        };
        this.cteCapabilities = {
          enabled: true,
          writable: true,
          materializedHint: true,
          requiresRecursiveHint: true
        };
        this.connection = connection;
        this.options = connection.options;
        this.isReplicated = this.options.replication ? true : false;
        this.loadDependencies();
        this.database = DriverUtils_1.DriverUtils.buildDriverOptions(this.options.replication ? this.options.replication.master : this.options).database;
        this.schema = DriverUtils_1.DriverUtils.buildDriverOptions(this.options).schema;
      }
      // -------------------------------------------------------------------------
      // Public Implemented Methods
      // -------------------------------------------------------------------------
      /**
       * Performs connection to the database.
       * Based on pooling options, it can either create connection immediately,
       * either create a pool and create connection when needed.
       */
      async connect() {
        if (this.options.replication) {
          this.slaves = await Promise.all(this.options.replication.slaves.map((slave) => {
            return this.createPool(this.options, slave);
          }));
          this.master = await this.createPool(this.options, this.options.replication.master);
        } else {
          this.master = await this.createPool(this.options, this.options);
        }
        if (!this.database || !this.searchSchema) {
          const queryRunner = this.createQueryRunner("master");
          if (!this.database) {
            this.database = await queryRunner.getCurrentDatabase();
          }
          if (!this.searchSchema) {
            this.searchSchema = await queryRunner.getCurrentSchema();
          }
          await queryRunner.release();
        }
        if (!this.schema) {
          this.schema = this.searchSchema;
        }
      }
      /**
       * Makes any action after connection (e.g. create extensions in Postgres driver).
       */
      async afterConnect() {
        if (this.options.timeTravelQueries) {
          await this.connection.query(`SET default_transaction_use_follower_reads = 'on';`);
        }
        await this.connection.query("SET enable_experimental_alter_column_type_general = true");
        return Promise.resolve();
      }
      /**
       * Closes connection with database.
       */
      async disconnect() {
        if (!this.master) {
          throw new ConnectionIsNotSetError_1.ConnectionIsNotSetError("cockroachdb");
        }
        await this.closePool(this.master);
        await Promise.all(this.slaves.map((slave) => this.closePool(slave)));
        this.master = void 0;
        this.slaves = [];
      }
      /**
       * Creates a schema builder used to build and sync a schema.
       */
      createSchemaBuilder() {
        return new RdbmsSchemaBuilder_1.RdbmsSchemaBuilder(this.connection);
      }
      /**
       * Creates a query runner used to execute database queries.
       */
      createQueryRunner(mode) {
        return new CockroachQueryRunner_1.CockroachQueryRunner(this, mode);
      }
      /**
       * Prepares given value to a value to be persisted, based on its column type and metadata.
       */
      preparePersistentValue(value, columnMetadata) {
        if (columnMetadata.transformer)
          value = ApplyValueTransformers_1.ApplyValueTransformers.transformTo(columnMetadata.transformer, value);
        if (value === null || value === void 0)
          return value;
        if (columnMetadata.type === Boolean) {
          return value === true ? 1 : 0;
        } else if (columnMetadata.type === "date") {
          return DateUtils_1.DateUtils.mixedDateToDateString(value);
        } else if (columnMetadata.type === "time") {
          return DateUtils_1.DateUtils.mixedDateToTimeString(value);
        } else if (columnMetadata.type === "datetime" || columnMetadata.type === Date || columnMetadata.type === "timestamp" || columnMetadata.type === "timestamptz" || columnMetadata.type === "timestamp with time zone" || columnMetadata.type === "timestamp without time zone") {
          return DateUtils_1.DateUtils.mixedDateToDate(value);
        } else if (["json", "jsonb", ...this.spatialTypes].indexOf(columnMetadata.type) >= 0) {
          return JSON.stringify(value);
        } else if (columnMetadata.type === "simple-array") {
          return DateUtils_1.DateUtils.simpleArrayToString(value);
        } else if (columnMetadata.type === "simple-json") {
          return DateUtils_1.DateUtils.simpleJsonToString(value);
        }
        return value;
      }
      /**
       * Prepares given value to a value to be persisted, based on its column type or metadata.
       */
      prepareHydratedValue(value, columnMetadata) {
        if (value === null || value === void 0)
          return columnMetadata.transformer ? ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value) : value;
        if ([Number, "int4", "smallint", "int2"].some((v) => v === columnMetadata.type) && !columnMetadata.isArray || columnMetadata.generationStrategy === "increment") {
          value = parseInt(value);
        } else if (columnMetadata.type === Boolean) {
          value = value ? true : false;
        } else if (columnMetadata.type === "datetime" || columnMetadata.type === Date || columnMetadata.type === "timestamp" || columnMetadata.type === "timestamptz" || columnMetadata.type === "timestamp with time zone" || columnMetadata.type === "timestamp without time zone") {
          value = DateUtils_1.DateUtils.normalizeHydratedDate(value);
        } else if (columnMetadata.type === "date") {
          value = DateUtils_1.DateUtils.mixedDateToDateString(value);
        } else if (columnMetadata.type === "time") {
          value = DateUtils_1.DateUtils.mixedTimeToString(value);
        } else if (columnMetadata.type === "simple-array") {
          value = DateUtils_1.DateUtils.stringToSimpleArray(value);
        } else if (columnMetadata.type === "simple-json") {
          value = DateUtils_1.DateUtils.stringToSimpleJson(value);
        } else if (columnMetadata.type === "enum" || columnMetadata.type === "simple-enum") {
          if (columnMetadata.isArray) {
            if (value === "{}")
              return [];
            if (Array.isArray(value))
              return value;
            value = value.slice(1, -1).split(",").map((val) => {
              if (val.startsWith(`"`) && val.endsWith(`"`))
                val = val.slice(1, -1);
              return val.replace(/\\(\\|")/g, "$1");
            });
            value = value.map((val) => {
              return !isNaN(+val) && columnMetadata.enum.indexOf(parseInt(val)) >= 0 ? parseInt(val) : val;
            });
          } else {
            value = !isNaN(+value) && columnMetadata.enum.indexOf(parseInt(value)) >= 0 ? parseInt(value) : value;
          }
        }
        if (columnMetadata.transformer)
          value = ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);
        return value;
      }
      /**
       * Replaces parameters in the given sql with special escaping character
       * and an array of parameter names to be passed to a query.
       */
      escapeQueryWithParameters(sql, parameters, nativeParameters) {
        const escapedParameters = Object.keys(nativeParameters).map((key) => nativeParameters[key]);
        if (!parameters || !Object.keys(parameters).length)
          return [sql, escapedParameters];
        const parameterIndexMap = /* @__PURE__ */ new Map();
        sql = sql.replace(/:(\.\.\.)?([A-Za-z0-9_.]+)/g, (full, isArray, key) => {
          if (!parameters.hasOwnProperty(key)) {
            return full;
          }
          if (parameterIndexMap.has(key)) {
            return this.parametersPrefix + parameterIndexMap.get(key);
          }
          const value = parameters[key];
          if (isArray) {
            return value.map((v) => {
              escapedParameters.push(v);
              return this.createParameter(key, escapedParameters.length - 1);
            }).join(", ");
          }
          if (typeof value === "function") {
            return value();
          }
          escapedParameters.push(value);
          parameterIndexMap.set(key, escapedParameters.length);
          return this.createParameter(key, escapedParameters.length - 1);
        });
        return [sql, escapedParameters];
      }
      /**
       * Escapes a column name.
       */
      escape(columnName) {
        return '"' + columnName + '"';
      }
      /**
       * Build full table name with schema name and table name.
       * E.g. myDB.mySchema.myTable
       */
      buildTableName(tableName, schema) {
        const tablePath = [tableName];
        if (schema) {
          tablePath.unshift(schema);
        }
        return tablePath.join(".");
      }
      /**
       * Parse a target table name or other types and return a normalized table definition.
       */
      parseTableName(target) {
        const driverDatabase = this.database;
        const driverSchema = this.schema;
        if (InstanceChecker_1.InstanceChecker.isTable(target) || InstanceChecker_1.InstanceChecker.isView(target)) {
          const parsed = this.parseTableName(target.name);
          return {
            database: target.database || parsed.database || driverDatabase,
            schema: target.schema || parsed.schema || driverSchema,
            tableName: parsed.tableName
          };
        }
        if (InstanceChecker_1.InstanceChecker.isTableForeignKey(target)) {
          const parsed = this.parseTableName(target.referencedTableName);
          return {
            database: target.referencedDatabase || parsed.database || driverDatabase,
            schema: target.referencedSchema || parsed.schema || driverSchema,
            tableName: parsed.tableName
          };
        }
        if (InstanceChecker_1.InstanceChecker.isEntityMetadata(target)) {
          return {
            database: target.database || driverDatabase,
            schema: target.schema || driverSchema,
            tableName: target.tableName
          };
        }
        const parts = target.split(".");
        return {
          database: driverDatabase,
          schema: (parts.length > 1 ? parts[0] : void 0) || driverSchema,
          tableName: parts.length > 1 ? parts[1] : parts[0]
        };
      }
      /**
       * Creates a database type from a given column metadata.
       */
      normalizeType(column) {
        if (column.type === Number || column.type === "integer" || column.type === "int" || column.type === "bigint" || column.type === "int64") {
          return "int8";
        } else if (column.type === String || column.type === "character varying" || column.type === "char varying") {
          return "varchar";
        } else if (column.type === Date || column.type === "timestamp without time zone") {
          return "timestamp";
        } else if (column.type === "timestamp with time zone") {
          return "timestamptz";
        } else if (column.type === "time without time zone") {
          return "time";
        } else if (column.type === Boolean || column.type === "boolean") {
          return "bool";
        } else if (column.type === "simple-array" || column.type === "simple-json" || column.type === "text") {
          return "string";
        } else if (column.type === "bytea" || column.type === "blob") {
          return "bytes";
        } else if (column.type === "smallint") {
          return "int2";
        } else if (column.type === "numeric" || column.type === "dec") {
          return "decimal";
        } else if (column.type === "double precision" || column.type === "float") {
          return "float8";
        } else if (column.type === "real") {
          return "float4";
        } else if (column.type === "character") {
          return "char";
        } else if (column.type === "simple-enum") {
          return "enum";
        } else if (column.type === "json") {
          return "jsonb";
        } else {
          return column.type || "";
        }
      }
      /**
       * Normalizes "default" value of the column.
       */
      normalizeDefault(columnMetadata) {
        const defaultValue = columnMetadata.default;
        if (defaultValue === void 0 || defaultValue === null) {
          return void 0;
        }
        if ((columnMetadata.type === "enum" || columnMetadata.type === "simple-enum") && defaultValue !== void 0) {
          if (columnMetadata.isArray) {
            const enumName = this.buildEnumName(columnMetadata);
            let arrayValue = defaultValue;
            if (typeof defaultValue === "string") {
              if (defaultValue === "{}")
                return `ARRAY[]::${enumName}[]`;
              arrayValue = defaultValue.replace("{", "").replace("}", "").split(",");
            }
            if (Array.isArray(arrayValue)) {
              const expr = `ARRAY[${arrayValue.map((it) => `'${it}'`).join(",")}]`;
              return `${expr}::${enumName}[]`;
            }
          } else {
            return `'${defaultValue}'`;
          }
        } else if (typeof defaultValue === "number") {
          return `(${defaultValue})`;
        }
        if (typeof defaultValue === "boolean") {
          return defaultValue ? "true" : "false";
        }
        if (typeof defaultValue === "function") {
          const value = defaultValue();
          if (value.toUpperCase() === "CURRENT_TIMESTAMP") {
            return "current_timestamp()";
          } else if (value.toUpperCase() === "CURRENT_DATE") {
            return "current_date()";
          }
          return value;
        }
        if (typeof defaultValue === "string") {
          const arrayCast = columnMetadata.isArray ? `::${columnMetadata.type}[]` : "";
          return `'${defaultValue}'${arrayCast}`;
        }
        if (ObjectUtils_1.ObjectUtils.isObject(defaultValue) && defaultValue !== null) {
          return `'${JSON.stringify(defaultValue)}'`;
        }
        return `${defaultValue}`;
      }
      /**
       * Normalizes "isUnique" value of the column.
       */
      normalizeIsUnique(column) {
        return column.entityMetadata.uniques.some((uq) => uq.columns.length === 1 && uq.columns[0] === column);
      }
      /**
       * Returns default column lengths, which is required on column creation.
       */
      getColumnLength(column) {
        return column.length ? column.length.toString() : "";
      }
      /**
       * Creates column type definition including length, precision and scale
       */
      createFullType(column) {
        let type = column.type;
        if (column.length) {
          type += "(" + column.length + ")";
        } else if (column.precision !== null && column.precision !== void 0 && column.scale !== null && column.scale !== void 0) {
          type += "(" + column.precision + "," + column.scale + ")";
        } else if (column.precision !== null && column.precision !== void 0) {
          type += "(" + column.precision + ")";
        } else if (this.spatialTypes.indexOf(column.type) >= 0) {
          if (column.spatialFeatureType != null && column.srid != null) {
            type = `${column.type}(${column.spatialFeatureType},${column.srid})`;
          } else if (column.spatialFeatureType != null) {
            type = `${column.type}(${column.spatialFeatureType})`;
          } else {
            type = column.type;
          }
        }
        if (column.isArray)
          type += " array";
        return type;
      }
      /**
       * Obtains a new database connection to a master server.
       * Used for replication.
       * If replication is not setup then returns default connection's database connection.
       */
      async obtainMasterConnection() {
        if (!this.master) {
          throw new error_1.TypeORMError("Driver not Connected");
        }
        return new Promise((ok, fail) => {
          this.master.connect((err, connection, release) => {
            err ? fail(err) : ok([connection, release]);
          });
        });
      }
      /**
       * Obtains a new database connection to a slave server.
       * Used for replication.
       * If replication is not setup then returns master (default) connection's database connection.
       */
      async obtainSlaveConnection() {
        if (!this.slaves.length)
          return this.obtainMasterConnection();
        const random = Math.floor(Math.random() * this.slaves.length);
        return new Promise((ok, fail) => {
          this.slaves[random].connect((err, connection, release) => {
            err ? fail(err) : ok([connection, release]);
          });
        });
      }
      /**
       * Creates generated map of values generated or returned by database after INSERT query.
       *
       * todo: slow. optimize Object.keys(), OrmUtils.mergeDeep and column.createValueMap parts
       */
      createGeneratedMap(metadata, insertResult) {
        if (!insertResult)
          return void 0;
        return Object.keys(insertResult).reduce((map, key) => {
          const column = metadata.findColumnWithDatabaseName(key);
          if (column) {
            OrmUtils_1.OrmUtils.mergeDeep(map, column.createValueMap(this.prepareHydratedValue(insertResult[key], column)));
          }
          return map;
        }, {});
      }
      /**
       * Differentiate columns of this table and columns from the given column metadatas columns
       * and returns only changed.
       */
      findChangedColumns(tableColumns, columnMetadatas) {
        return columnMetadatas.filter((columnMetadata) => {
          const tableColumn = tableColumns.find((c) => c.name === columnMetadata.databaseName);
          if (!tableColumn)
            return false;
          return tableColumn.name !== columnMetadata.databaseName || tableColumn.type !== this.normalizeType(columnMetadata) || tableColumn.length !== columnMetadata.length || tableColumn.isArray !== columnMetadata.isArray || tableColumn.precision !== columnMetadata.precision || columnMetadata.scale !== void 0 && tableColumn.scale !== columnMetadata.scale || tableColumn.comment !== this.escapeComment(columnMetadata.comment) || !tableColumn.isGenerated && this.lowerDefaultValueIfNecessary(this.normalizeDefault(columnMetadata)) !== tableColumn.default || // we included check for generated here, because generated columns already can have default values
          tableColumn.isPrimary !== columnMetadata.isPrimary || tableColumn.isNullable !== columnMetadata.isNullable || tableColumn.isUnique !== this.normalizeIsUnique(columnMetadata) || tableColumn.enumName !== columnMetadata.enumName || tableColumn.enum && columnMetadata.enum && !OrmUtils_1.OrmUtils.isArraysEqual(tableColumn.enum, columnMetadata.enum.map((val) => val + "")) || // enums in postgres are always strings
          tableColumn.isGenerated !== columnMetadata.isGenerated || tableColumn.generatedType !== columnMetadata.generatedType || (tableColumn.asExpression || "").trim() !== (columnMetadata.asExpression || "").trim() || (tableColumn.spatialFeatureType || "").toLowerCase() !== (columnMetadata.spatialFeatureType || "").toLowerCase() || tableColumn.srid !== columnMetadata.srid;
        });
      }
      lowerDefaultValueIfNecessary(value) {
        if (!value) {
          return value;
        }
        return value.split(`'`).map((v, i) => {
          return i % 2 === 1 ? v : v.toLowerCase();
        }).join(`'`);
      }
      /**
       * Returns true if driver supports RETURNING / OUTPUT statement.
       */
      isReturningSqlSupported() {
        return true;
      }
      /**
       * Returns true if driver supports uuid values generation on its own.
       */
      isUUIDGenerationSupported() {
        return true;
      }
      /**
       * Returns true if driver supports fulltext indices.
       */
      isFullTextColumnTypeSupported() {
        return false;
      }
      /**
       * Creates an escaped parameter.
       */
      createParameter(parameterName, index) {
        return this.parametersPrefix + (index + 1);
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Loads postgres query stream package.
       */
      loadStreamDependency() {
        try {
          return PlatformTools_1.PlatformTools.load("pg-query-stream");
        } catch {
          throw new error_1.TypeORMError(`To use streams you should install pg-query-stream package. Please run "npm i pg-query-stream".`);
        }
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * If driver dependency is not given explicitly, then try to load it via "require".
       */
      loadDependencies() {
        try {
          const postgres = this.options.driver || PlatformTools_1.PlatformTools.load("pg");
          this.postgres = postgres;
          try {
            const pgNative = this.options.nativeDriver || PlatformTools_1.PlatformTools.load("pg-native");
            if (pgNative && this.postgres.native)
              this.postgres = this.postgres.native;
          } catch (e) {
          }
        } catch (e) {
          throw new DriverPackageNotInstalledError_1.DriverPackageNotInstalledError("Postgres", "pg");
        }
      }
      /**
       * Creates a new connection pool for a given database credentials.
       */
      async createPool(options, credentials) {
        credentials = Object.assign({}, credentials, DriverUtils_1.DriverUtils.buildDriverOptions(credentials));
        const connectionOptions = Object.assign({}, {
          host: credentials.host,
          user: credentials.username,
          password: credentials.password,
          database: credentials.database,
          port: credentials.port,
          ssl: credentials.ssl,
          application_name: options.applicationName,
          max: options.poolSize
        }, options.extra || {});
        const pool = new this.postgres.Pool(connectionOptions);
        const { logger } = this.connection;
        const poolErrorHandler = options.poolErrorHandler || ((error) => logger.log("warn", `Postgres pool raised an error. ${error}`));
        pool.on("error", poolErrorHandler);
        return new Promise((ok, fail) => {
          pool.connect((err, connection, release) => {
            if (err)
              return fail(err);
            release();
            ok(pool);
          });
        });
      }
      /**
       * Closes connection pool.
       */
      async closePool(pool) {
        await Promise.all(this.connectedQueryRunners.map((queryRunner) => queryRunner.release()));
        return new Promise((ok, fail) => {
          pool.end((err) => err ? fail(err) : ok());
        });
      }
      /**
       * Escapes a given comment.
       */
      escapeComment(comment) {
        if (!comment)
          return comment;
        comment = comment.replace(/'/g, "''").replace(/\u0000/g, "");
        return comment;
      }
      /**
       * Builds ENUM type name from given table and column.
       */
      buildEnumName(column) {
        const { schema, tableName } = this.parseTableName(column.entityMetadata);
        let enumName = column.enumName ? column.enumName : `${tableName}_${column.databaseName.toLowerCase()}_enum`;
        if (schema)
          enumName = `${schema}.${enumName}`;
        return enumName.split(".").map((i) => {
          return `"${i}"`;
        }).join(".");
      }
    };
    exports2.CockroachDriver = CockroachDriver;
  }
});

// node_modules/typeorm/driver/mongodb/MongoQueryRunner.js
var require_MongoQueryRunner = __commonJS({
  "node_modules/typeorm/driver/mongodb/MongoQueryRunner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MongoQueryRunner = void 0;
    var Broadcaster_1 = require_Broadcaster();
    var error_1 = require_error();
    var MongoQueryRunner = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection, databaseConnection) {
        this.isReleased = false;
        this.isTransactionActive = false;
        this.data = {};
        this.connection = connection;
        this.databaseConnection = databaseConnection;
        this.broadcaster = new Broadcaster_1.Broadcaster(this);
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Called before migrations are run.
       */
      async beforeMigration() {
      }
      /**
       * Called after migrations are run.
       */
      async afterMigration() {
      }
      /**
       * Creates a cursor for a query that can be used to iterate over results from MongoDB.
       */
      cursor(collectionName, filter) {
        return this.getCollection(collectionName).find(filter || {});
      }
      /**
       * Execute an aggregation framework pipeline against the collection.
       */
      aggregate(collectionName, pipeline, options) {
        return this.getCollection(collectionName).aggregate(pipeline, options || {});
      }
      /**
       * Perform a bulkWrite operation without a fluent API.
       */
      async bulkWrite(collectionName, operations, options) {
        return await this.getCollection(collectionName).bulkWrite(operations, options || {});
      }
      /**
       * Count number of matching documents in the db to a query.
       */
      async count(collectionName, filter, options) {
        return this.getCollection(collectionName).count(filter || {}, options || {});
      }
      /**
       * Count number of matching documents in the db to a query.
       */
      async countDocuments(collectionName, filter, options) {
        return this.getCollection(collectionName).countDocuments(filter || {}, options || {});
      }
      /**
       * Creates an index on the db and collection.
       */
      async createCollectionIndex(collectionName, indexSpec, options) {
        return this.getCollection(collectionName).createIndex(indexSpec, options || {});
      }
      /**
       * Creates multiple indexes in the collection, this method is only supported for MongoDB 2.6 or higher.
       * Earlier version of MongoDB will throw a command not supported error. Index specifications are defined at http://docs.mongodb.org/manual/reference/command/createIndexes/.
       */
      async createCollectionIndexes(collectionName, indexSpecs) {
        return this.getCollection(collectionName).createIndexes(indexSpecs);
      }
      /**
       * Delete multiple documents on MongoDB.
       */
      async deleteMany(collectionName, filter, options) {
        return this.getCollection(collectionName).deleteMany(filter, options || {});
      }
      /**
       * Delete a document on MongoDB.
       */
      async deleteOne(collectionName, filter, options) {
        return this.getCollection(collectionName).deleteOne(filter, options || {});
      }
      /**
       * The distinct command returns returns a list of distinct values for the given key across a collection.
       */
      async distinct(collectionName, key, filter, options) {
        return this.getCollection(collectionName).distinct(key, filter, options || {});
      }
      /**
       * Drops an index from this collection.
       */
      async dropCollectionIndex(collectionName, indexName, options) {
        return this.getCollection(collectionName).dropIndex(indexName, options || {});
      }
      /**
       * Drops all indexes from the collection.
       */
      async dropCollectionIndexes(collectionName) {
        return this.getCollection(collectionName).dropIndexes();
      }
      /**
       * Find a document and delete it in one atomic operation, requires a write lock for the duration of the operation.
       */
      async findOneAndDelete(collectionName, filter, options) {
        return this.getCollection(collectionName).findOneAndDelete(filter, options || {});
      }
      /**
       * Find a document and replace it in one atomic operation, requires a write lock for the duration of the operation.
       */
      async findOneAndReplace(collectionName, filter, replacement, options) {
        return this.getCollection(collectionName).findOneAndReplace(filter, replacement, options || {});
      }
      /**
       * Find a document and update it in one atomic operation, requires a write lock for the duration of the operation.
       */
      async findOneAndUpdate(collectionName, filter, update, options) {
        return this.getCollection(collectionName).findOneAndUpdate(filter, update, options || {});
      }
      /**
       * Retrieve all the indexes on the collection.
       */
      async collectionIndexes(collectionName) {
        return this.getCollection(collectionName).indexes();
      }
      /**
       * Retrieve all the indexes on the collection.
       */
      async collectionIndexExists(collectionName, indexes) {
        return this.getCollection(collectionName).indexExists(indexes);
      }
      /**
       * Retrieves this collections index info.
       */
      async collectionIndexInformation(collectionName, options) {
        return this.getCollection(collectionName).indexInformation(options || {});
      }
      /**
       * Initiate an In order bulk write operation, operations will be serially executed in the order they are added, creating a new operation for each switch in types.
       */
      initializeOrderedBulkOp(collectionName, options) {
        return this.getCollection(collectionName).initializeOrderedBulkOp(options);
      }
      /**
       * Initiate a Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.
       */
      initializeUnorderedBulkOp(collectionName, options) {
        return this.getCollection(collectionName).initializeUnorderedBulkOp(options);
      }
      /**
       * Inserts an array of documents into MongoDB.
       */
      async insertMany(collectionName, docs, options) {
        return this.getCollection(collectionName).insertMany(docs, options || {});
      }
      /**
       * Inserts a single document into MongoDB.
       */
      async insertOne(collectionName, doc, options) {
        return this.getCollection(collectionName).insertOne(doc, options || {});
      }
      /**
       * Returns if the collection is a capped collection.
       */
      async isCapped(collectionName) {
        return this.getCollection(collectionName).isCapped();
      }
      /**
       * Get the list of all indexes information for the collection.
       */
      listCollectionIndexes(collectionName, options) {
        return this.getCollection(collectionName).listIndexes(options);
      }
      /**
       * Reindex all indexes on the collection Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.
       */
      async rename(collectionName, newName, options) {
        return this.getCollection(collectionName).rename(newName, options || {});
      }
      /**
       * Replace a document on MongoDB.
       */
      async replaceOne(collectionName, filter, replacement, options) {
        return this.getCollection(collectionName).replaceOne(filter, replacement, options || {});
      }
      /**
       * Get all the collection statistics.
       */
      async stats(collectionName, options) {
        return this.getCollection(collectionName).stats(options || {});
      }
      /**
       * Watching new changes as stream.
       */
      watch(collectionName, pipeline, options) {
        return this.getCollection(collectionName).watch(pipeline, options);
      }
      /**
       * Update multiple documents on MongoDB.
       */
      async updateMany(collectionName, filter, update, options) {
        return this.getCollection(collectionName).updateMany(filter, update, options || {});
      }
      /**
       * Update a single document on MongoDB.
       */
      async updateOne(collectionName, filter, update, options) {
        return await this.getCollection(collectionName).updateOne(filter, update, options || {});
      }
      // -------------------------------------------------------------------------
      // Public Implemented Methods (from QueryRunner)
      // -------------------------------------------------------------------------
      /**
       * Removes all collections from the currently connected database.
       * Be careful with using this method and avoid using it in production or migrations
       * (because it can clear all your database).
       */
      async clearDatabase() {
        await this.databaseConnection.db(this.connection.driver.database).dropDatabase();
      }
      /**
       * For MongoDB database we don't create connection, because its single connection already created by a driver.
       */
      async connect() {
      }
      /**
       * For MongoDB database we don't release connection, because its single connection.
       */
      async release() {
      }
      /**
       * Starts transaction.
       */
      async startTransaction() {
      }
      /**
       * Commits transaction.
       */
      async commitTransaction() {
      }
      /**
       * Rollbacks transaction.
       */
      async rollbackTransaction() {
      }
      /**
       * Executes a given SQL query.
       */
      query(query, parameters) {
        throw new error_1.TypeORMError(`Executing SQL query is not supported by MongoDB driver.`);
      }
      /**
       * Unsupported - Executing SQL query is not supported by MongoDB driver.
       */
      async sql(strings, ...values) {
        throw new error_1.TypeORMError(`Executing SQL query is not supported by MongoDB driver.`);
      }
      /**
       * Returns raw data stream.
       */
      stream(query, parameters, onEnd, onError) {
        throw new error_1.TypeORMError(`Stream is not supported by MongoDB driver. Use watch instead.`);
      }
      /**
           * Insert a new row with given values into the given table.
           * Returns value of inserted object id.
      
          async insert(collectionName: string, keyValues: ObjectLiteral): Promise<any> { // todo: fix any
              const results = await this.databaseConnection
                  .collection(collectionName)
                  .insertOne(keyValues);
              const generatedMap = this.connection.getMetadata(collectionName).objectIdColumn!.createValueMap(results.insertedId);
              return {
                  result: results,
                  generatedMap: generatedMap
              };
          }*/
      /**
           * Updates rows that match given conditions in the given table.
      
          async update(collectionName: string, valuesMap: ObjectLiteral, conditions: ObjectLiteral): Promise<any> { // todo: fix any
              await this.databaseConnection
                  .collection(collectionName)
                  .updateOne(conditions, valuesMap);
          }*/
      /**
           * Deletes from the given table by a given conditions.
      
          async delete(collectionName: string, conditions: ObjectLiteral|ObjectLiteral[]|string, maybeParameters?: any[]): Promise<any> { // todo: fix any
              if (typeof conditions === "string")
                  throw new TypeORMError(`String condition is not supported by MongoDB driver.`);
      
              await this.databaseConnection
                  .collection(collectionName)
                  .deleteOne(conditions);
          }*/
      /**
       * Returns all available database names including system databases.
       */
      async getDatabases() {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Returns all available schema names including system schemas.
       * If database parameter specified, returns schemas of that database.
       */
      async getSchemas(database) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Loads given table's data from the database.
       */
      async getTable(collectionName) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Loads all tables (with given names) from the database and creates a Table from them.
       */
      async getTables(collectionNames) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Loads given views's data from the database.
       */
      async getView(collectionName) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Loads all views (with given names) from the database and creates a Table from them.
       */
      async getViews(collectionNames) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      getReplicationMode() {
        return "master";
      }
      /**
       * Checks if database with the given name exist.
       */
      async hasDatabase(database) {
        throw new error_1.TypeORMError(`Check database queries are not supported by MongoDB driver.`);
      }
      /**
       * Loads currently using database
       */
      async getCurrentDatabase() {
        throw new error_1.TypeORMError(`Check database queries are not supported by MongoDB driver.`);
      }
      /**
       * Checks if schema with the given name exist.
       */
      async hasSchema(schema) {
        throw new error_1.TypeORMError(`Check schema queries are not supported by MongoDB driver.`);
      }
      /**
       * Loads currently using database schema
       */
      async getCurrentSchema() {
        throw new error_1.TypeORMError(`Check schema queries are not supported by MongoDB driver.`);
      }
      /**
       * Checks if table with the given name exist in the database.
       */
      async hasTable(collectionName) {
        throw new error_1.TypeORMError(`Check schema queries are not supported by MongoDB driver.`);
      }
      /**
       * Checks if column with the given name exist in the given table.
       */
      async hasColumn(tableOrName, columnName) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Creates a database if it's not created.
       */
      async createDatabase(database) {
        throw new error_1.TypeORMError(`Database create queries are not supported by MongoDB driver.`);
      }
      /**
       * Drops database.
       */
      async dropDatabase(database, ifExist) {
        throw new error_1.TypeORMError(`Database drop queries are not supported by MongoDB driver.`);
      }
      /**
       * Creates a new table schema.
       */
      async createSchema(schemaPath, ifNotExist) {
        throw new error_1.TypeORMError(`Schema create queries are not supported by MongoDB driver.`);
      }
      /**
       * Drops table schema.
       */
      async dropSchema(schemaPath, ifExist) {
        throw new error_1.TypeORMError(`Schema drop queries are not supported by MongoDB driver.`);
      }
      /**
       * Creates a new table from the given table and columns inside it.
       */
      async createTable(table) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Drops the table.
       */
      async dropTable(tableName) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Creates a new view.
       */
      async createView(view) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Drops the view.
       */
      async dropView(target) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Renames the given table.
       */
      async renameTable(oldTableOrName, newTableOrName) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Creates a new column from the column in the table.
       */
      async addColumn(tableOrName, column) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Creates a new columns from the column in the table.
       */
      async addColumns(tableOrName, columns) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Renames column in the given table.
       */
      async renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Changes a column in the table.
       */
      async changeColumn(tableOrName, oldTableColumnOrName, newColumn) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Changes a column in the table.
       */
      async changeColumns(tableOrName, changedColumns) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Drops column in the table.
       */
      async dropColumn(tableOrName, columnOrName) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Drops the columns in the table.
       */
      async dropColumns(tableOrName, columns) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Creates a new primary key.
       */
      async createPrimaryKey(tableOrName, columnNames) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Updates composite primary keys.
       */
      async updatePrimaryKeys(tableOrName, columns) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Drops a primary key.
       */
      async dropPrimaryKey(tableOrName) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Creates a new unique constraint.
       */
      async createUniqueConstraint(tableOrName, uniqueConstraint) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Creates a new unique constraints.
       */
      async createUniqueConstraints(tableOrName, uniqueConstraints) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Drops an unique constraint.
       */
      async dropUniqueConstraint(tableOrName, uniqueOrName) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Drops an unique constraints.
       */
      async dropUniqueConstraints(tableOrName, uniqueConstraints) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Creates a new check constraint.
       */
      async createCheckConstraint(tableOrName, checkConstraint) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Creates a new check constraints.
       */
      async createCheckConstraints(tableOrName, checkConstraints) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Drops check constraint.
       */
      async dropCheckConstraint(tableOrName, checkOrName) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Drops check constraints.
       */
      async dropCheckConstraints(tableOrName, checkConstraints) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Creates a new exclusion constraint.
       */
      async createExclusionConstraint(tableOrName, exclusionConstraint) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Creates a new exclusion constraints.
       */
      async createExclusionConstraints(tableOrName, exclusionConstraints) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Drops exclusion constraint.
       */
      async dropExclusionConstraint(tableOrName, exclusionOrName) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Drops exclusion constraints.
       */
      async dropExclusionConstraints(tableOrName, exclusionConstraints) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Creates a new foreign key.
       */
      async createForeignKey(tableOrName, foreignKey) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Creates a new foreign keys.
       */
      async createForeignKeys(tableOrName, foreignKeys) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Drops a foreign key from the table.
       */
      async dropForeignKey(tableOrName, foreignKey) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Drops a foreign keys from the table.
       */
      async dropForeignKeys(tableOrName, foreignKeys) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Creates a new index.
       */
      async createIndex(tableOrName, index) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Creates a new indices
       */
      async createIndices(tableOrName, indices) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Drops an index from the table.
       */
      async dropIndex(collectionName, indexName) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Drops an indices from the table.
       */
      async dropIndices(tableOrName, indices) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
      }
      /**
       * Drops collection.
       */
      async clearTable(collectionName) {
        await this.databaseConnection.db(this.connection.driver.database).dropCollection(collectionName);
      }
      /**
       * Enables special query runner mode in which sql queries won't be executed,
       * instead they will be memorized into a special variable inside query runner.
       * You can get memorized sql using getMemorySql() method.
       */
      enableSqlMemory() {
        throw new error_1.TypeORMError(`This operation is not supported by MongoDB driver.`);
      }
      /**
       * Disables special query runner mode in which sql queries won't be executed
       * started by calling enableSqlMemory() method.
       *
       * Previously memorized sql will be flushed.
       */
      disableSqlMemory() {
        throw new error_1.TypeORMError(`This operation is not supported by MongoDB driver.`);
      }
      /**
       * Flushes all memorized sqls.
       */
      clearSqlMemory() {
        throw new error_1.TypeORMError(`This operation is not supported by MongoDB driver.`);
      }
      /**
       * Gets sql stored in the memory. Parameters in the sql are already replaced.
       */
      getMemorySql() {
        throw new error_1.TypeORMError(`This operation is not supported by MongoDB driver.`);
      }
      /**
       * Executes up sql queries.
       */
      async executeMemoryUpSql() {
        throw new error_1.TypeORMError(`This operation is not supported by MongoDB driver.`);
      }
      /**
       * Executes down sql queries.
       */
      async executeMemoryDownSql() {
        throw new error_1.TypeORMError(`This operation is not supported by MongoDB driver.`);
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Gets collection from the database with a given name.
       */
      getCollection(collectionName) {
        return this.databaseConnection.db(this.connection.driver.database).collection(collectionName);
      }
      /**
       * Change table comment.
       */
      changeTableComment(tableOrName, comment) {
        throw new error_1.TypeORMError(`mongodb driver does not support change table comment.`);
      }
    };
    exports2.MongoQueryRunner = MongoQueryRunner;
  }
});

// node_modules/typeorm/schema-builder/MongoSchemaBuilder.js
var require_MongoSchemaBuilder = __commonJS({
  "node_modules/typeorm/schema-builder/MongoSchemaBuilder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MongoSchemaBuilder = void 0;
    var SqlInMemory_1 = require_SqlInMemory();
    var MongoSchemaBuilder = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection) {
        this.connection = connection;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Creates complete schemas for the given entity metadatas.
       */
      async build() {
        const queryRunner = this.connection.createQueryRunner();
        const promises = [];
        this.connection.entityMetadatas.forEach((metadata) => {
          metadata.indices.forEach((index) => {
            const options = Object.assign({}, {
              name: index.name,
              unique: index.isUnique,
              sparse: index.isSparse,
              background: index.isBackground
            }, index.expireAfterSeconds === void 0 ? {} : { expireAfterSeconds: index.expireAfterSeconds });
            promises.push(queryRunner.createCollectionIndex(metadata.tableName, index.columnNamesWithOrderingMap, options));
          });
          metadata.uniques.forEach((unique) => {
            const options = {
              name: unique.name,
              unique: true
            };
            promises.push(queryRunner.createCollectionIndex(metadata.tableName, unique.columnNamesWithOrderingMap, options));
          });
        });
        await Promise.all(promises);
      }
      /**
       * Returns query to be executed by schema builder.
       */
      log() {
        return Promise.resolve(new SqlInMemory_1.SqlInMemory());
      }
    };
    exports2.MongoSchemaBuilder = MongoSchemaBuilder;
  }
});

// node_modules/typeorm/driver/mongodb/MongoDriver.js
var require_MongoDriver = __commonJS({
  "node_modules/typeorm/driver/mongodb/MongoDriver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MongoDriver = void 0;
    var ConnectionIsNotSetError_1 = require_ConnectionIsNotSetError();
    var DriverPackageNotInstalledError_1 = require_DriverPackageNotInstalledError();
    var MongoQueryRunner_1 = require_MongoQueryRunner();
    var PlatformTools_1 = require_PlatformTools();
    var MongoSchemaBuilder_1 = require_MongoSchemaBuilder();
    var ObjectUtils_1 = require_ObjectUtils();
    var ApplyValueTransformers_1 = require_ApplyValueTransformers();
    var DriverUtils_1 = require_DriverUtils();
    var error_1 = require_error();
    var InstanceChecker_1 = require_InstanceChecker();
    var MongoDriver = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection) {
        this.connection = connection;
        this.isReplicated = false;
        this.treeSupport = false;
        this.transactionSupport = "none";
        this.supportedDataTypes = [];
        this.spatialTypes = [];
        this.withLengthColumnTypes = [];
        this.withPrecisionColumnTypes = [];
        this.withScaleColumnTypes = [];
        this.mappedDataTypes = {
          createDate: "int",
          createDateDefault: "",
          updateDate: "int",
          updateDateDefault: "",
          deleteDate: "int",
          deleteDateNullable: true,
          version: "int",
          treeLevel: "int",
          migrationId: "int",
          migrationName: "int",
          migrationTimestamp: "int",
          cacheId: "int",
          cacheIdentifier: "int",
          cacheTime: "int",
          cacheDuration: "int",
          cacheQuery: "int",
          cacheResult: "int",
          metadataType: "int",
          metadataDatabase: "int",
          metadataSchema: "int",
          metadataTable: "int",
          metadataName: "int",
          metadataValue: "int"
        };
        this.cteCapabilities = {
          enabled: false
        };
        this.validOptionNames = [
          "appName",
          "authMechanism",
          "authSource",
          "autoEncryption",
          "checkServerIdentity",
          "compressors",
          "connectTimeoutMS",
          "directConnection",
          "family",
          "forceServerObjectId",
          "ignoreUndefined",
          "keepAlive",
          "keepAliveInitialDelay",
          "localThresholdMS",
          "maxStalenessSeconds",
          "minPoolSize",
          "monitorCommands",
          "noDelay",
          "pkFactory",
          "promoteBuffers",
          "promoteLongs",
          "promoteValues",
          "raw",
          "readConcern",
          "readPreference",
          "readPreferenceTags",
          "replicaSet",
          "retryWrites",
          "serializeFunctions",
          "socketTimeoutMS",
          "ssl",
          "sslCA",
          "sslCRL",
          "sslCert",
          "sslKey",
          "sslPass",
          "sslValidate",
          "tls",
          "tlsAllowInvalidCertificates",
          "tlsCAFile",
          "tlsCertificateKeyFile",
          "tlsCertificateKeyFilePassword",
          "w",
          "writeConcern",
          "wtimeoutMS",
          // Undocumented deprecated options
          // todo: remove next major version
          "appname",
          "fsync",
          "j",
          "useNewUrlParser",
          "useUnifiedTopology",
          "wtimeout"
        ];
        this.options = connection.options;
        this.validateOptions(connection.options);
        this.loadDependencies();
        this.database = DriverUtils_1.DriverUtils.buildMongoDBDriverOptions(this.options).database;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Performs connection to the database.
       */
      async connect() {
        const options = DriverUtils_1.DriverUtils.buildMongoDBDriverOptions(this.options);
        const client = await this.mongodb.MongoClient.connect(this.buildConnectionUrl(options), this.buildConnectionOptions(options));
        this.queryRunner = new MongoQueryRunner_1.MongoQueryRunner(this.connection, client);
        ObjectUtils_1.ObjectUtils.assign(this.queryRunner, {
          manager: this.connection.manager
        });
      }
      afterConnect() {
        return Promise.resolve();
      }
      /**
       * Closes connection with the database.
       */
      async disconnect() {
        const queryRunner = this.queryRunner;
        if (!queryRunner) {
          throw new ConnectionIsNotSetError_1.ConnectionIsNotSetError("mongodb");
        }
        this.queryRunner = void 0;
        await queryRunner.databaseConnection.close();
      }
      /**
       * Creates a schema builder used to build and sync a schema.
       */
      createSchemaBuilder() {
        return new MongoSchemaBuilder_1.MongoSchemaBuilder(this.connection);
      }
      /**
       * Creates a query runner used to execute database queries.
       */
      createQueryRunner(mode) {
        return this.queryRunner;
      }
      /**
       * Replaces parameters in the given sql with special escaping character
       * and an array of parameter names to be passed to a query.
       */
      escapeQueryWithParameters(sql, parameters, nativeParameters) {
        throw new error_1.TypeORMError(`This operation is not supported by Mongodb driver.`);
      }
      /**
       * Escapes a column name.
       */
      escape(columnName) {
        return columnName;
      }
      /**
       * Build full table name with database name, schema name and table name.
       * E.g. myDB.mySchema.myTable
       */
      buildTableName(tableName, schema, database) {
        return tableName;
      }
      /**
       * Parse a target table name or other types and return a normalized table definition.
       */
      parseTableName(target) {
        if (InstanceChecker_1.InstanceChecker.isEntityMetadata(target)) {
          return {
            tableName: target.tableName
          };
        }
        if (InstanceChecker_1.InstanceChecker.isTable(target) || InstanceChecker_1.InstanceChecker.isView(target)) {
          return {
            tableName: target.name
          };
        }
        if (InstanceChecker_1.InstanceChecker.isTableForeignKey(target)) {
          return {
            tableName: target.referencedTableName
          };
        }
        return {
          tableName: target
        };
      }
      /**
       * Prepares given value to a value to be persisted, based on its column type and metadata.
       */
      preparePersistentValue(value, columnMetadata) {
        if (columnMetadata.transformer)
          value = ApplyValueTransformers_1.ApplyValueTransformers.transformTo(columnMetadata.transformer, value);
        return value;
      }
      /**
       * Prepares given value to a value to be persisted, based on its column type or metadata.
       */
      prepareHydratedValue(value, columnMetadata) {
        if (columnMetadata.transformer)
          value = ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);
        return value;
      }
      /**
       * Creates a database type from a given column metadata.
       */
      normalizeType(column) {
        throw new error_1.TypeORMError(`MongoDB is schema-less, not supported by this driver.`);
      }
      /**
       * Normalizes "default" value of the column.
       */
      normalizeDefault(columnMetadata) {
        throw new error_1.TypeORMError(`MongoDB is schema-less, not supported by this driver.`);
      }
      /**
       * Normalizes "isUnique" value of the column.
       */
      normalizeIsUnique(column) {
        throw new error_1.TypeORMError(`MongoDB is schema-less, not supported by this driver.`);
      }
      /**
       * Calculates column length taking into account the default length values.
       */
      getColumnLength(column) {
        throw new error_1.TypeORMError(`MongoDB is schema-less, not supported by this driver.`);
      }
      /**
       * Normalizes "default" value of the column.
       */
      createFullType(column) {
        throw new error_1.TypeORMError(`MongoDB is schema-less, not supported by this driver.`);
      }
      /**
       * Obtains a new database connection to a master server.
       * Used for replication.
       * If replication is not setup then returns default connection's database connection.
       */
      obtainMasterConnection() {
        return Promise.resolve();
      }
      /**
       * Obtains a new database connection to a slave server.
       * Used for replication.
       * If replication is not setup then returns master (default) connection's database connection.
       */
      obtainSlaveConnection() {
        return Promise.resolve();
      }
      /**
       * Creates generated map of values generated or returned by database after INSERT query.
       */
      createGeneratedMap(metadata, insertedId) {
        return metadata.objectIdColumn.createValueMap(insertedId);
      }
      /**
       * Differentiate columns of this table and columns from the given column metadatas columns
       * and returns only changed.
       */
      findChangedColumns(tableColumns, columnMetadatas) {
        throw new error_1.TypeORMError(`MongoDB is schema-less, not supported by this driver.`);
      }
      /**
       * Returns true if driver supports RETURNING / OUTPUT statement.
       */
      isReturningSqlSupported() {
        return false;
      }
      /**
       * Returns true if driver supports uuid values generation on its own.
       */
      isUUIDGenerationSupported() {
        return false;
      }
      /**
       * Returns true if driver supports fulltext indices.
       */
      isFullTextColumnTypeSupported() {
        return false;
      }
      /**
       * Creates an escaped parameter.
       */
      createParameter(parameterName, index) {
        return "";
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Validate driver options to make sure everything is correct and driver will be able to establish connection.
       */
      validateOptions(options) {
      }
      /**
       * Loads all driver dependencies.
       */
      loadDependencies() {
        try {
          const mongodb = this.options.driver || PlatformTools_1.PlatformTools.load("mongodb");
          this.mongodb = mongodb;
        } catch (e) {
          throw new DriverPackageNotInstalledError_1.DriverPackageNotInstalledError("MongoDB", "mongodb");
        }
      }
      /**
       * Builds connection url that is passed to underlying driver to perform connection to the mongodb database.
       */
      buildConnectionUrl(options) {
        const schemaUrlPart = options.type.toLowerCase();
        const credentialsUrlPart = options.username && options.password ? `${encodeURIComponent(options.username)}:${encodeURIComponent(options.password)}@` : "";
        const portUrlPart = schemaUrlPart === "mongodb+srv" ? "" : `:${options.port || "27017"}`;
        let connectionString;
        if (options.replicaSet) {
          connectionString = `${schemaUrlPart}://${credentialsUrlPart}${options.hostReplicaSet || options.host + portUrlPart || "127.0.0.1" + portUrlPart}/${options.database || ""}`;
        } else {
          connectionString = `${schemaUrlPart}://${credentialsUrlPart}${options.host || "127.0.0.1"}${portUrlPart}/${options.database || ""}`;
        }
        return connectionString;
      }
      /**
       * Build connection options from MongoConnectionOptions
       */
      buildConnectionOptions(options) {
        const mongoOptions = {};
        for (const optionName of this.validOptionNames) {
          if (optionName in options) {
            mongoOptions[optionName] = options[optionName];
          }
        }
        mongoOptions.driverInfo = {
          name: "TypeORM"
        };
        if ("poolSize" in options) {
          mongoOptions["maxPoolSize"] = options["poolSize"];
        }
        Object.assign(mongoOptions, options.extra);
        return mongoOptions;
      }
    };
    exports2.MongoDriver = MongoDriver;
  }
});

// node_modules/typeorm/query-runner/QueryLock.js
var require_QueryLock = __commonJS({
  "node_modules/typeorm/query-runner/QueryLock.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryLock = void 0;
    var QueryLock = class {
      constructor() {
        this.queue = [];
      }
      async acquire() {
        let release;
        const waitingPromise = new Promise((ok) => release = ok);
        const otherWaitingPromises = [...this.queue];
        this.queue.push(waitingPromise);
        if (otherWaitingPromises.length > 0) {
          await Promise.all(otherWaitingPromises);
        }
        return () => {
          release();
          if (this.queue.includes(waitingPromise)) {
            this.queue.splice(this.queue.indexOf(waitingPromise), 1);
          }
        };
      }
    };
    exports2.QueryLock = QueryLock;
  }
});

// node_modules/typeorm/driver/sqlserver/SqlServerQueryRunner.js
var require_SqlServerQueryRunner = __commonJS({
  "node_modules/typeorm/driver/sqlserver/SqlServerQueryRunner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SqlServerQueryRunner = void 0;
    var error_1 = require_error();
    var QueryFailedError_1 = require_QueryFailedError();
    var QueryRunnerAlreadyReleasedError_1 = require_QueryRunnerAlreadyReleasedError();
    var TransactionNotStartedError_1 = require_TransactionNotStartedError();
    var BaseQueryRunner_1 = require_BaseQueryRunner();
    var QueryLock_1 = require_QueryLock();
    var QueryResult_1 = require_QueryResult();
    var Table_1 = require_Table();
    var TableCheck_1 = require_TableCheck();
    var TableColumn_1 = require_TableColumn();
    var TableForeignKey_1 = require_TableForeignKey();
    var TableIndex_1 = require_TableIndex();
    var TableUnique_1 = require_TableUnique();
    var View_1 = require_View();
    var Broadcaster_1 = require_Broadcaster();
    var BroadcasterResult_1 = require_BroadcasterResult();
    var InstanceChecker_1 = require_InstanceChecker();
    var OrmUtils_1 = require_OrmUtils();
    var Query_1 = require_Query();
    var MetadataTableType_1 = require_MetadataTableType();
    var SqlServerQueryRunner = class extends BaseQueryRunner_1.BaseQueryRunner {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(driver, mode) {
        super();
        this.lock = new QueryLock_1.QueryLock();
        this.driver = driver;
        this.connection = driver.connection;
        this.broadcaster = new Broadcaster_1.Broadcaster(this);
        this.mode = mode;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Creates/uses database connection from the connection pool to perform further operations.
       * Returns obtained database connection.
       */
      connect() {
        return Promise.resolve();
      }
      /**
       * Releases used database connection.
       * You cannot use query runner methods once its released.
       */
      release() {
        this.isReleased = true;
        return Promise.resolve();
      }
      /**
       * Starts transaction.
       */
      async startTransaction(isolationLevel) {
        if (this.isReleased)
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        this.isTransactionActive = true;
        try {
          await this.broadcaster.broadcast("BeforeTransactionStart");
        } catch (err) {
          this.isTransactionActive = false;
          throw err;
        }
        await new Promise(async (ok, fail) => {
          const transactionCallback = (err) => {
            if (err) {
              this.isTransactionActive = false;
              return fail(err);
            }
            ok();
          };
          if (this.transactionDepth === 0) {
            const pool = await (this.mode === "slave" ? this.driver.obtainSlaveConnection() : this.driver.obtainMasterConnection());
            this.databaseConnection = pool.transaction();
            this.connection.logger.logQuery("BEGIN TRANSACTION");
            if (isolationLevel) {
              this.databaseConnection.begin(this.convertIsolationLevel(isolationLevel), transactionCallback);
              this.connection.logger.logQuery("SET TRANSACTION ISOLATION LEVEL " + isolationLevel);
            } else {
              this.databaseConnection.begin(transactionCallback);
            }
          } else {
            await this.query(`SAVE TRANSACTION typeorm_${this.transactionDepth}`);
            ok();
          }
          this.transactionDepth += 1;
        });
        await this.broadcaster.broadcast("AfterTransactionStart");
      }
      /**
       * Commits transaction.
       * Error will be thrown if transaction was not started.
       */
      async commitTransaction() {
        if (this.isReleased)
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        if (!this.isTransactionActive)
          throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionCommit");
        if (this.transactionDepth === 1) {
          return new Promise((ok, fail) => {
            this.databaseConnection.commit(async (err) => {
              if (err)
                return fail(err);
              this.isTransactionActive = false;
              this.databaseConnection = null;
              await this.broadcaster.broadcast("AfterTransactionCommit");
              ok();
              this.connection.logger.logQuery("COMMIT");
              this.transactionDepth -= 1;
            });
          });
        }
        this.transactionDepth -= 1;
      }
      /**
       * Rollbacks transaction.
       * Error will be thrown if transaction was not started.
       */
      async rollbackTransaction() {
        if (this.isReleased)
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        if (!this.isTransactionActive)
          throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionRollback");
        if (this.transactionDepth > 1) {
          await this.query(`ROLLBACK TRANSACTION typeorm_${this.transactionDepth - 1}`);
          this.transactionDepth -= 1;
        } else {
          return new Promise((ok, fail) => {
            this.databaseConnection.rollback(async (err) => {
              if (err)
                return fail(err);
              this.isTransactionActive = false;
              this.databaseConnection = null;
              await this.broadcaster.broadcast("AfterTransactionRollback");
              ok();
              this.connection.logger.logQuery("ROLLBACK");
              this.transactionDepth -= 1;
            });
          });
        }
      }
      /**
       * Executes a given SQL query.
       */
      async query(query, parameters, useStructuredResult = false) {
        if (this.isReleased)
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        const release = await this.lock.acquire();
        this.driver.connection.logger.logQuery(query, parameters, this);
        await this.broadcaster.broadcast("BeforeQuery", query, parameters);
        const broadcasterResult = new BroadcasterResult_1.BroadcasterResult();
        try {
          const pool = await (this.mode === "slave" ? this.driver.obtainSlaveConnection() : this.driver.obtainMasterConnection());
          const request = new this.driver.mssql.Request(this.isTransactionActive ? this.databaseConnection : pool);
          if (parameters && parameters.length) {
            parameters.forEach((parameter, index) => {
              const parameterName = index.toString();
              if (InstanceChecker_1.InstanceChecker.isMssqlParameter(parameter)) {
                const mssqlParameter = this.mssqlParameterToNativeParameter(parameter);
                if (mssqlParameter) {
                  request.input(parameterName, mssqlParameter, parameter.value);
                } else {
                  request.input(parameterName, parameter.value);
                }
              } else {
                request.input(parameterName, parameter);
              }
            });
          }
          const queryStartTime = Date.now();
          const raw = await new Promise((ok, fail) => {
            request.query(query, (err, raw2) => {
              const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
              const queryEndTime = Date.now();
              const queryExecutionTime = queryEndTime - queryStartTime;
              this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, raw2, void 0);
              if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) {
                this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
              }
              if (err) {
                fail(new QueryFailedError_1.QueryFailedError(query, parameters, err));
              }
              ok(raw2);
            });
          });
          const result = new QueryResult_1.QueryResult();
          if (raw?.hasOwnProperty("recordset")) {
            result.records = raw.recordset;
          }
          if (raw?.hasOwnProperty("rowsAffected")) {
            result.affected = raw.rowsAffected[0];
          }
          const queryType = query.slice(0, query.indexOf(" "));
          switch (queryType) {
            case "DELETE":
              result.raw = [raw.recordset, raw.rowsAffected[0]];
              break;
            default:
              result.raw = raw.recordset;
          }
          if (useStructuredResult) {
            return result;
          } else {
            return result.raw;
          }
        } catch (err) {
          this.driver.connection.logger.logQueryError(err, query, parameters, this);
          this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, void 0, void 0, err);
          throw err;
        } finally {
          await broadcasterResult.wait();
          release();
        }
      }
      /**
       * Returns raw data stream.
       */
      async stream(query, parameters, onEnd, onError) {
        if (this.isReleased)
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        const release = await this.lock.acquire();
        this.driver.connection.logger.logQuery(query, parameters, this);
        const pool = await (this.mode === "slave" ? this.driver.obtainSlaveConnection() : this.driver.obtainMasterConnection());
        const request = new this.driver.mssql.Request(this.isTransactionActive ? this.databaseConnection : pool);
        if (parameters && parameters.length) {
          parameters.forEach((parameter, index) => {
            const parameterName = index.toString();
            if (InstanceChecker_1.InstanceChecker.isMssqlParameter(parameter)) {
              request.input(parameterName, this.mssqlParameterToNativeParameter(parameter), parameter.value);
            } else {
              request.input(parameterName, parameter);
            }
          });
        }
        request.query(query);
        const streamRequest = request.toReadableStream();
        streamRequest.on("error", (err) => {
          release();
          this.driver.connection.logger.logQueryError(err, query, parameters, this);
        });
        streamRequest.on("end", () => {
          release();
        });
        if (onEnd) {
          streamRequest.on("end", onEnd);
        }
        if (onError) {
          streamRequest.on("error", onError);
        }
        return streamRequest;
      }
      /**
       * Returns all available database names including system databases.
       */
      async getDatabases() {
        const results = await this.query(`EXEC sp_databases`);
        return results.map((result) => result["DATABASE_NAME"]);
      }
      /**
       * Returns all available schema names including system schemas.
       * If database parameter specified, returns schemas of that database.
       */
      async getSchemas(database) {
        const query = database ? `SELECT * FROM "${database}"."sys"."schema"` : `SELECT * FROM "sys"."schemas"`;
        const results = await this.query(query);
        return results.map((result) => result["name"]);
      }
      /**
       * Checks if database with the given name exist.
       */
      async hasDatabase(database) {
        const result = await this.query(`SELECT DB_ID('${database}') as "db_id"`);
        const dbId = result[0]["db_id"];
        return !!dbId;
      }
      /**
       * Loads currently using database
       */
      async getCurrentDatabase() {
        const currentDBQuery = await this.query(`SELECT DB_NAME() AS "db_name"`);
        return currentDBQuery[0]["db_name"];
      }
      /**
       * Checks if schema with the given name exist.
       */
      async hasSchema(schema) {
        const result = await this.query(`SELECT SCHEMA_ID('${schema}') as "schema_id"`);
        const schemaId = result[0]["schema_id"];
        return !!schemaId;
      }
      /**
       * Loads currently using database schema
       */
      async getCurrentSchema() {
        const currentSchemaQuery = await this.query(`SELECT SCHEMA_NAME() AS "schema_name"`);
        return currentSchemaQuery[0]["schema_name"];
      }
      /**
       * Checks if table with the given name exist in the database.
       */
      async hasTable(tableOrName) {
        const parsedTableName = this.driver.parseTableName(tableOrName);
        if (!parsedTableName.database) {
          parsedTableName.database = await this.getCurrentDatabase();
        }
        if (!parsedTableName.schema) {
          parsedTableName.schema = await this.getCurrentSchema();
        }
        const sql = `SELECT * FROM "${parsedTableName.database}"."INFORMATION_SCHEMA"."TABLES" WHERE "TABLE_NAME" = '${parsedTableName.tableName}' AND "TABLE_SCHEMA" = '${parsedTableName.schema}'`;
        const result = await this.query(sql);
        return result.length ? true : false;
      }
      /**
       * Checks if column exist in the table.
       */
      async hasColumn(tableOrName, columnName) {
        const parsedTableName = this.driver.parseTableName(tableOrName);
        if (!parsedTableName.database) {
          parsedTableName.database = await this.getCurrentDatabase();
        }
        if (!parsedTableName.schema) {
          parsedTableName.schema = await this.getCurrentSchema();
        }
        const sql = `SELECT * FROM "${parsedTableName.database}"."INFORMATION_SCHEMA"."COLUMNS" WHERE "TABLE_NAME" = '${parsedTableName.tableName}' AND "TABLE_SCHEMA" = '${parsedTableName.schema}' AND "COLUMN_NAME" = '${columnName}'`;
        const result = await this.query(sql);
        return result.length ? true : false;
      }
      /**
       * Creates a new database.
       */
      async createDatabase(database, ifNotExist) {
        const up = ifNotExist ? `IF DB_ID('${database}') IS NULL CREATE DATABASE "${database}"` : `CREATE DATABASE "${database}"`;
        const down = `DROP DATABASE "${database}"`;
        await this.executeQueries(new Query_1.Query(up), new Query_1.Query(down));
      }
      /**
       * Drops database.
       */
      async dropDatabase(database, ifExist) {
        const up = ifExist ? `IF DB_ID('${database}') IS NOT NULL DROP DATABASE "${database}"` : `DROP DATABASE "${database}"`;
        const down = `CREATE DATABASE "${database}"`;
        await this.executeQueries(new Query_1.Query(up), new Query_1.Query(down));
      }
      /**
       * Creates table schema.
       * If database name also specified (e.g. 'dbName.schemaName') schema will be created in specified database.
       */
      async createSchema(schemaPath, ifNotExist) {
        const upQueries = [];
        const downQueries = [];
        if (schemaPath.indexOf(".") === -1) {
          const upQuery = ifNotExist ? `IF SCHEMA_ID('${schemaPath}') IS NULL BEGIN EXEC ('CREATE SCHEMA "${schemaPath}"') END` : `CREATE SCHEMA "${schemaPath}"`;
          upQueries.push(new Query_1.Query(upQuery));
          downQueries.push(new Query_1.Query(`DROP SCHEMA "${schemaPath}"`));
        } else {
          const dbName = schemaPath.split(".")[0];
          const schema = schemaPath.split(".")[1];
          const currentDB = await this.getCurrentDatabase();
          upQueries.push(new Query_1.Query(`USE "${dbName}"`));
          downQueries.push(new Query_1.Query(`USE "${currentDB}"`));
          const upQuery = ifNotExist ? `IF SCHEMA_ID('${schema}') IS NULL BEGIN EXEC ('CREATE SCHEMA "${schema}"') END` : `CREATE SCHEMA "${schema}"`;
          upQueries.push(new Query_1.Query(upQuery));
          downQueries.push(new Query_1.Query(`DROP SCHEMA "${schema}"`));
          upQueries.push(new Query_1.Query(`USE "${currentDB}"`));
          downQueries.push(new Query_1.Query(`USE "${dbName}"`));
        }
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Drops table schema.
       * If database name also specified (e.g. 'dbName.schemaName') schema will be dropped in specified database.
       */
      async dropSchema(schemaPath, ifExist) {
        const upQueries = [];
        const downQueries = [];
        if (schemaPath.indexOf(".") === -1) {
          const upQuery = ifExist ? `IF SCHEMA_ID('${schemaPath}') IS NULL BEGIN EXEC ('DROP SCHEMA "${schemaPath}"') END` : `DROP SCHEMA "${schemaPath}"`;
          upQueries.push(new Query_1.Query(upQuery));
          downQueries.push(new Query_1.Query(`CREATE SCHEMA "${schemaPath}"`));
        } else {
          const dbName = schemaPath.split(".")[0];
          const schema = schemaPath.split(".")[1];
          const currentDB = await this.getCurrentDatabase();
          upQueries.push(new Query_1.Query(`USE "${dbName}"`));
          downQueries.push(new Query_1.Query(`USE "${currentDB}"`));
          const upQuery = ifExist ? `IF SCHEMA_ID('${schema}') IS NULL BEGIN EXEC ('DROP SCHEMA "${schema}"') END` : `DROP SCHEMA "${schema}"`;
          upQueries.push(new Query_1.Query(upQuery));
          downQueries.push(new Query_1.Query(`CREATE SCHEMA "${schema}"`));
          upQueries.push(new Query_1.Query(`USE "${currentDB}"`));
          downQueries.push(new Query_1.Query(`USE "${dbName}"`));
        }
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Creates a new table.
       */
      async createTable(table, ifNotExist = false, createForeignKeys = true, createIndices = true) {
        if (ifNotExist) {
          const isTableExist = await this.hasTable(table);
          if (isTableExist)
            return Promise.resolve();
        }
        const upQueries = [];
        const downQueries = [];
        upQueries.push(this.createTableSql(table, createForeignKeys));
        downQueries.push(this.dropTableSql(table));
        if (createForeignKeys)
          table.foreignKeys.forEach((foreignKey) => downQueries.push(this.dropForeignKeySql(table, foreignKey)));
        if (createIndices) {
          table.indices.forEach((index) => {
            if (!index.name)
              index.name = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);
            upQueries.push(this.createIndexSql(table, index));
            downQueries.push(this.dropIndexSql(table, index));
          });
        }
        const generatedColumns = table.columns.filter((column) => column.generatedType && column.asExpression);
        for (const column of generatedColumns) {
          const parsedTableName = this.driver.parseTableName(table);
          if (!parsedTableName.schema) {
            parsedTableName.schema = await this.getCurrentSchema();
          }
          const insertQuery = this.insertTypeormMetadataSql({
            database: parsedTableName.database,
            schema: parsedTableName.schema,
            table: parsedTableName.tableName,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name,
            value: column.asExpression
          });
          const deleteQuery = this.deleteTypeormMetadataSql({
            database: parsedTableName.database,
            schema: parsedTableName.schema,
            table: parsedTableName.tableName,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name
          });
          upQueries.push(insertQuery);
          downQueries.push(deleteQuery);
        }
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Drops the table.
       */
      async dropTable(tableOrName, ifExist, dropForeignKeys = true, dropIndices = true) {
        if (ifExist) {
          const isTableExist = await this.hasTable(tableOrName);
          if (!isTableExist)
            return Promise.resolve();
        }
        const createForeignKeys = dropForeignKeys;
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const upQueries = [];
        const downQueries = [];
        if (dropIndices) {
          table.indices.forEach((index) => {
            upQueries.push(this.dropIndexSql(table, index));
            downQueries.push(this.createIndexSql(table, index));
          });
        }
        if (dropForeignKeys)
          table.foreignKeys.forEach((foreignKey) => upQueries.push(this.dropForeignKeySql(table, foreignKey)));
        upQueries.push(this.dropTableSql(table));
        downQueries.push(this.createTableSql(table, createForeignKeys));
        const generatedColumns = table.columns.filter((column) => column.generatedType && column.asExpression);
        for (const column of generatedColumns) {
          const parsedTableName = this.driver.parseTableName(table);
          if (!parsedTableName.schema) {
            parsedTableName.schema = await this.getCurrentSchema();
          }
          const deleteQuery = this.deleteTypeormMetadataSql({
            database: parsedTableName.database,
            schema: parsedTableName.schema,
            table: parsedTableName.tableName,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name
          });
          const insertQuery = this.insertTypeormMetadataSql({
            database: parsedTableName.database,
            schema: parsedTableName.schema,
            table: parsedTableName.tableName,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name,
            value: column.asExpression
          });
          upQueries.push(deleteQuery);
          downQueries.push(insertQuery);
        }
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Creates a new view.
       */
      async createView(view, syncWithMetadata = false) {
        const upQueries = [];
        const downQueries = [];
        upQueries.push(this.createViewSql(view));
        if (syncWithMetadata)
          upQueries.push(await this.insertViewDefinitionSql(view));
        downQueries.push(this.dropViewSql(view));
        if (syncWithMetadata)
          downQueries.push(await this.deleteViewDefinitionSql(view));
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Drops the view.
       */
      async dropView(target) {
        const viewName = InstanceChecker_1.InstanceChecker.isView(target) ? target.name : target;
        const view = await this.getCachedView(viewName);
        const upQueries = [];
        const downQueries = [];
        upQueries.push(await this.deleteViewDefinitionSql(view));
        upQueries.push(this.dropViewSql(view));
        downQueries.push(await this.insertViewDefinitionSql(view));
        downQueries.push(this.createViewSql(view));
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Renames a table.
       */
      async renameTable(oldTableOrName, newTableName) {
        const upQueries = [];
        const downQueries = [];
        const oldTable = InstanceChecker_1.InstanceChecker.isTable(oldTableOrName) ? oldTableOrName : await this.getCachedTable(oldTableOrName);
        const newTable = oldTable.clone();
        let dbName = void 0;
        let schemaName = void 0;
        let oldTableName = oldTable.name;
        const splittedName = oldTable.name.split(".");
        if (splittedName.length === 3) {
          dbName = splittedName[0];
          oldTableName = splittedName[2];
          if (splittedName[1] !== "")
            schemaName = splittedName[1];
        } else if (splittedName.length === 2) {
          schemaName = splittedName[0];
          oldTableName = splittedName[1];
        }
        newTable.name = this.driver.buildTableName(newTableName, schemaName, dbName);
        const currentDB = await this.getCurrentDatabase();
        if (dbName && dbName !== currentDB) {
          upQueries.push(new Query_1.Query(`USE "${dbName}"`));
          downQueries.push(new Query_1.Query(`USE "${currentDB}"`));
        }
        upQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(oldTable)}", "${newTableName}"`));
        downQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(newTable)}", "${oldTableName}"`));
        if (newTable.primaryColumns.length > 0 && !newTable.primaryColumns[0].primaryKeyConstraintName) {
          const columnNames = newTable.primaryColumns.map((column) => column.name);
          const oldPkName = this.connection.namingStrategy.primaryKeyName(oldTable, columnNames);
          const newPkName = this.connection.namingStrategy.primaryKeyName(newTable, columnNames);
          upQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(newTable)}.${oldPkName}", "${newPkName}"`));
          downQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(newTable)}.${newPkName}", "${oldPkName}"`));
        }
        newTable.uniques.forEach((unique) => {
          const oldUniqueName = this.connection.namingStrategy.uniqueConstraintName(oldTable, unique.columnNames);
          if (unique.name !== oldUniqueName)
            return;
          const newUniqueName = this.connection.namingStrategy.uniqueConstraintName(newTable, unique.columnNames);
          upQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(newTable)}.${unique.name}", "${newUniqueName}"`));
          downQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(newTable)}.${newUniqueName}", "${unique.name}"`));
          unique.name = newUniqueName;
        });
        newTable.indices.forEach((index) => {
          const oldIndexName = this.connection.namingStrategy.indexName(oldTable, index.columnNames, index.where);
          if (index.name !== oldIndexName)
            return;
          const newIndexName = this.connection.namingStrategy.indexName(newTable, index.columnNames, index.where);
          upQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(newTable)}.${index.name}", "${newIndexName}", "INDEX"`));
          downQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(newTable)}.${newIndexName}", "${index.name}", "INDEX"`));
          index.name = newIndexName;
        });
        newTable.foreignKeys.forEach((foreignKey) => {
          const oldForeignKeyName = this.connection.namingStrategy.foreignKeyName(oldTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
          if (foreignKey.name !== oldForeignKeyName)
            return;
          const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(newTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
          upQueries.push(new Query_1.Query(`EXEC sp_rename "${this.buildForeignKeyName(foreignKey.name, schemaName, dbName)}", "${newForeignKeyName}"`));
          downQueries.push(new Query_1.Query(`EXEC sp_rename "${this.buildForeignKeyName(newForeignKeyName, schemaName, dbName)}", "${foreignKey.name}"`));
          foreignKey.name = newForeignKeyName;
        });
        if (dbName && dbName !== currentDB) {
          upQueries.push(new Query_1.Query(`USE "${currentDB}"`));
          downQueries.push(new Query_1.Query(`USE "${dbName}"`));
        }
        await this.executeQueries(upQueries, downQueries);
        oldTable.name = newTable.name;
        this.replaceCachedTable(oldTable, newTable);
      }
      /**
       * Creates a new column from the column in the table.
       */
      async addColumn(tableOrName, column) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(table, column, false, true)}`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN "${column.name}"`));
        if (column.isPrimary) {
          const primaryColumns = clonedTable.primaryColumns;
          if (primaryColumns.length > 0) {
            const pkName2 = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column2) => column2.name));
            const columnNames2 = primaryColumns.map((column2) => `"${column2.name}"`).join(", ");
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName2}"`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName2}" PRIMARY KEY (${columnNames2})`));
          }
          primaryColumns.push(column);
          const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column2) => column2.name));
          const columnNames = primaryColumns.map((column2) => `"${column2.name}"`).join(", ");
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
        }
        const columnIndex = clonedTable.indices.find((index) => index.columnNames.length === 1 && index.columnNames[0] === column.name);
        if (columnIndex) {
          upQueries.push(this.createIndexSql(table, columnIndex));
          downQueries.push(this.dropIndexSql(table, columnIndex));
        }
        if (column.isUnique) {
          const uniqueConstraint = new TableUnique_1.TableUnique({
            name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),
            columnNames: [column.name]
          });
          clonedTable.uniques.push(uniqueConstraint);
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${uniqueConstraint.name}" UNIQUE ("${column.name}")`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${uniqueConstraint.name}"`));
        }
        if (column.default !== null && column.default !== void 0) {
          const defaultName = this.connection.namingStrategy.defaultConstraintName(table, column.name);
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${defaultName}"`));
        }
        if (column.generatedType && column.asExpression) {
          const parsedTableName = this.driver.parseTableName(table);
          if (!parsedTableName.schema) {
            parsedTableName.schema = await this.getCurrentSchema();
          }
          const insertQuery = this.insertTypeormMetadataSql({
            database: parsedTableName.database,
            schema: parsedTableName.schema,
            table: parsedTableName.tableName,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name,
            value: column.asExpression
          });
          const deleteQuery = this.deleteTypeormMetadataSql({
            database: parsedTableName.database,
            schema: parsedTableName.schema,
            table: parsedTableName.tableName,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name
          });
          upQueries.push(insertQuery);
          downQueries.push(deleteQuery);
        }
        await this.executeQueries(upQueries, downQueries);
        clonedTable.addColumn(column);
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Creates a new columns from the column in the table.
       */
      async addColumns(tableOrName, columns) {
        for (const column of columns) {
          await this.addColumn(tableOrName, column);
        }
      }
      /**
       * Renames column in the given table.
       */
      async renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const oldColumn = InstanceChecker_1.InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find((c) => c.name === oldTableColumnOrName);
        if (!oldColumn)
          throw new error_1.TypeORMError(`Column "${oldTableColumnOrName}" was not found in the "${table.name}" table.`);
        let newColumn = void 0;
        if (InstanceChecker_1.InstanceChecker.isTableColumn(newTableColumnOrName)) {
          newColumn = newTableColumnOrName;
        } else {
          newColumn = oldColumn.clone();
          newColumn.name = newTableColumnOrName;
        }
        await this.changeColumn(table, oldColumn, newColumn);
      }
      /**
       * Changes a column in the table.
       */
      async changeColumn(tableOrName, oldTableColumnOrName, newColumn) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        let clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        const oldColumn = InstanceChecker_1.InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find((column) => column.name === oldTableColumnOrName);
        if (!oldColumn)
          throw new error_1.TypeORMError(`Column "${oldTableColumnOrName}" was not found in the "${table.name}" table.`);
        if (newColumn.isGenerated !== oldColumn.isGenerated && newColumn.generationStrategy !== "uuid" || newColumn.type !== oldColumn.type || newColumn.length !== oldColumn.length || newColumn.asExpression !== oldColumn.asExpression || newColumn.generatedType !== oldColumn.generatedType) {
          await this.dropColumn(table, oldColumn);
          await this.addColumn(table, newColumn);
          clonedTable = table.clone();
        } else {
          if (newColumn.name !== oldColumn.name) {
            let dbName = void 0;
            let schemaName = void 0;
            const splittedName = table.name.split(".");
            if (splittedName.length === 3) {
              dbName = splittedName[0];
              if (splittedName[1] !== "")
                schemaName = splittedName[1];
            } else if (splittedName.length === 2) {
              schemaName = splittedName[0];
            }
            const currentDB = await this.getCurrentDatabase();
            if (dbName && dbName !== currentDB) {
              upQueries.push(new Query_1.Query(`USE "${dbName}"`));
              downQueries.push(new Query_1.Query(`USE "${currentDB}"`));
            }
            upQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(table)}.${oldColumn.name}", "${newColumn.name}"`));
            downQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(table)}.${newColumn.name}", "${oldColumn.name}"`));
            if (oldColumn.isPrimary === true && !oldColumn.primaryKeyConstraintName) {
              const primaryColumns = clonedTable.primaryColumns;
              const columnNames = primaryColumns.map((column) => column.name);
              const oldPkName = this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);
              columnNames.splice(columnNames.indexOf(oldColumn.name), 1);
              columnNames.push(newColumn.name);
              const newPkName = this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);
              upQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(clonedTable)}.${oldPkName}", "${newPkName}"`));
              downQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(clonedTable)}.${newPkName}", "${oldPkName}"`));
            }
            clonedTable.findColumnIndices(oldColumn).forEach((index) => {
              const oldIndexName = this.connection.namingStrategy.indexName(clonedTable, index.columnNames, index.where);
              if (index.name !== oldIndexName)
                return;
              index.columnNames.splice(index.columnNames.indexOf(oldColumn.name), 1);
              index.columnNames.push(newColumn.name);
              const newIndexName = this.connection.namingStrategy.indexName(clonedTable, index.columnNames, index.where);
              upQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(clonedTable)}.${index.name}", "${newIndexName}", "INDEX"`));
              downQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(clonedTable)}.${newIndexName}", "${index.name}", "INDEX"`));
              index.name = newIndexName;
            });
            clonedTable.findColumnForeignKeys(oldColumn).forEach((foreignKey) => {
              const foreignKeyName = this.connection.namingStrategy.foreignKeyName(clonedTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
              if (foreignKey.name !== foreignKeyName)
                return;
              foreignKey.columnNames.splice(foreignKey.columnNames.indexOf(oldColumn.name), 1);
              foreignKey.columnNames.push(newColumn.name);
              const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(clonedTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
              upQueries.push(new Query_1.Query(`EXEC sp_rename "${this.buildForeignKeyName(foreignKey.name, schemaName, dbName)}", "${newForeignKeyName}"`));
              downQueries.push(new Query_1.Query(`EXEC sp_rename "${this.buildForeignKeyName(newForeignKeyName, schemaName, dbName)}", "${foreignKey.name}"`));
              foreignKey.name = newForeignKeyName;
            });
            clonedTable.findColumnChecks(oldColumn).forEach((check) => {
              check.columnNames.splice(check.columnNames.indexOf(oldColumn.name), 1);
              check.columnNames.push(newColumn.name);
              const newCheckName = this.connection.namingStrategy.checkConstraintName(clonedTable, check.expression);
              upQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(clonedTable)}.${check.name}", "${newCheckName}"`));
              downQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(clonedTable)}.${newCheckName}", "${check.name}"`));
              check.name = newCheckName;
            });
            clonedTable.findColumnUniques(oldColumn).forEach((unique) => {
              const oldUniqueName = this.connection.namingStrategy.uniqueConstraintName(clonedTable, unique.columnNames);
              if (unique.name !== oldUniqueName)
                return;
              unique.columnNames.splice(unique.columnNames.indexOf(oldColumn.name), 1);
              unique.columnNames.push(newColumn.name);
              const newUniqueName = this.connection.namingStrategy.uniqueConstraintName(clonedTable, unique.columnNames);
              upQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(clonedTable)}.${unique.name}", "${newUniqueName}"`));
              downQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(clonedTable)}.${newUniqueName}", "${unique.name}"`));
              unique.name = newUniqueName;
            });
            if (oldColumn.default !== null && oldColumn.default !== void 0) {
              const oldDefaultName = this.connection.namingStrategy.defaultConstraintName(table, oldColumn.name);
              const newDefaultName = this.connection.namingStrategy.defaultConstraintName(table, newColumn.name);
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${oldDefaultName}"`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${oldDefaultName}" DEFAULT ${oldColumn.default} FOR "${newColumn.name}"`));
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${newDefaultName}" DEFAULT ${oldColumn.default} FOR "${newColumn.name}"`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${newDefaultName}"`));
            }
            if (dbName && dbName !== currentDB) {
              upQueries.push(new Query_1.Query(`USE "${currentDB}"`));
              downQueries.push(new Query_1.Query(`USE "${dbName}"`));
            }
            const oldTableColumn = clonedTable.columns.find((column) => column.name === oldColumn.name);
            clonedTable.columns[clonedTable.columns.indexOf(oldTableColumn)].name = newColumn.name;
            oldColumn.name = newColumn.name;
          }
          if (this.isColumnChanged(oldColumn, newColumn, false, false, false)) {
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN ${this.buildCreateColumnSql(table, newColumn, true, false, true)}`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN ${this.buildCreateColumnSql(table, oldColumn, true, false, true)}`));
          }
          if (this.isEnumChanged(oldColumn, newColumn)) {
            const oldExpression = this.getEnumExpression(oldColumn);
            const oldCheck = new TableCheck_1.TableCheck({
              name: this.connection.namingStrategy.checkConstraintName(table, oldExpression, true),
              expression: oldExpression
            });
            const newExpression = this.getEnumExpression(newColumn);
            const newCheck = new TableCheck_1.TableCheck({
              name: this.connection.namingStrategy.checkConstraintName(table, newExpression, true),
              expression: newExpression
            });
            upQueries.push(this.dropCheckConstraintSql(table, oldCheck));
            upQueries.push(this.createCheckConstraintSql(table, newCheck));
            downQueries.push(this.dropCheckConstraintSql(table, newCheck));
            downQueries.push(this.createCheckConstraintSql(table, oldCheck));
          }
          if (newColumn.isPrimary !== oldColumn.isPrimary) {
            const primaryColumns = clonedTable.primaryColumns;
            if (primaryColumns.length > 0) {
              const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column) => column.name));
              const columnNames = primaryColumns.map((column) => `"${column.name}"`).join(", ");
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
            }
            if (newColumn.isPrimary === true) {
              primaryColumns.push(newColumn);
              const column = clonedTable.columns.find((column2) => column2.name === newColumn.name);
              column.isPrimary = true;
              const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column2) => column2.name));
              const columnNames = primaryColumns.map((column2) => `"${column2.name}"`).join(", ");
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
            } else {
              const primaryColumn = primaryColumns.find((c) => c.name === newColumn.name);
              primaryColumns.splice(primaryColumns.indexOf(primaryColumn), 1);
              const column = clonedTable.columns.find((column2) => column2.name === newColumn.name);
              column.isPrimary = false;
              if (primaryColumns.length > 0) {
                const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column2) => column2.name));
                const columnNames = primaryColumns.map((column2) => `"${column2.name}"`).join(", ");
                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
              }
            }
          }
          if (newColumn.isUnique !== oldColumn.isUnique) {
            if (newColumn.isUnique === true) {
              const uniqueConstraint = new TableUnique_1.TableUnique({
                name: this.connection.namingStrategy.uniqueConstraintName(table, [newColumn.name]),
                columnNames: [newColumn.name]
              });
              clonedTable.uniques.push(uniqueConstraint);
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${uniqueConstraint.name}" UNIQUE ("${newColumn.name}")`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${uniqueConstraint.name}"`));
            } else {
              const uniqueConstraint = clonedTable.uniques.find((unique) => {
                return unique.columnNames.length === 1 && !!unique.columnNames.find((columnName) => columnName === newColumn.name);
              });
              clonedTable.uniques.splice(clonedTable.uniques.indexOf(uniqueConstraint), 1);
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${uniqueConstraint.name}"`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${uniqueConstraint.name}" UNIQUE ("${newColumn.name}")`));
            }
          }
          if (newColumn.default !== oldColumn.default) {
            if (oldColumn.default !== null && oldColumn.default !== void 0) {
              const defaultName = this.connection.namingStrategy.defaultConstraintName(table, oldColumn.name);
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${defaultName}"`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${defaultName}" DEFAULT ${oldColumn.default} FOR "${oldColumn.name}"`));
            }
            if (newColumn.default !== null && newColumn.default !== void 0) {
              const defaultName = this.connection.namingStrategy.defaultConstraintName(table, newColumn.name);
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${defaultName}" DEFAULT ${newColumn.default} FOR "${newColumn.name}"`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${defaultName}"`));
            }
          }
          await this.executeQueries(upQueries, downQueries);
          this.replaceCachedTable(table, clonedTable);
        }
      }
      /**
       * Changes a column in the table.
       */
      async changeColumns(tableOrName, changedColumns) {
        for (const { oldColumn, newColumn } of changedColumns) {
          await this.changeColumn(tableOrName, oldColumn, newColumn);
        }
      }
      /**
       * Drops column in the table.
       */
      async dropColumn(tableOrName, columnOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const column = InstanceChecker_1.InstanceChecker.isTableColumn(columnOrName) ? columnOrName : table.findColumnByName(columnOrName);
        if (!column)
          throw new error_1.TypeORMError(`Column "${columnOrName}" was not found in table "${table.name}"`);
        const clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        if (column.isPrimary) {
          const pkName = column.primaryKeyConstraintName ? column.primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, clonedTable.primaryColumns.map((column2) => column2.name));
          const columnNames = clonedTable.primaryColumns.map((primaryColumn) => `"${primaryColumn.name}"`).join(", ");
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP CONSTRAINT "${pkName}"`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
          const tableColumn = clonedTable.findColumnByName(column.name);
          tableColumn.isPrimary = false;
          if (clonedTable.primaryColumns.length > 0) {
            const pkName2 = clonedTable.primaryColumns[0].primaryKeyConstraintName ? clonedTable.primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, clonedTable.primaryColumns.map((column2) => column2.name));
            const columnNames2 = clonedTable.primaryColumns.map((primaryColumn) => `"${primaryColumn.name}"`).join(", ");
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD CONSTRAINT "${pkName2}" PRIMARY KEY (${columnNames2})`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP CONSTRAINT "${pkName2}"`));
          }
        }
        const columnIndex = clonedTable.indices.find((index) => index.columnNames.length === 1 && index.columnNames[0] === column.name);
        if (columnIndex) {
          clonedTable.indices.splice(clonedTable.indices.indexOf(columnIndex), 1);
          upQueries.push(this.dropIndexSql(table, columnIndex));
          downQueries.push(this.createIndexSql(table, columnIndex));
        }
        const columnCheck = clonedTable.checks.find((check) => !!check.columnNames && check.columnNames.length === 1 && check.columnNames[0] === column.name);
        if (columnCheck) {
          clonedTable.checks.splice(clonedTable.checks.indexOf(columnCheck), 1);
          upQueries.push(this.dropCheckConstraintSql(table, columnCheck));
          downQueries.push(this.createCheckConstraintSql(table, columnCheck));
        }
        const columnUnique = clonedTable.uniques.find((unique) => unique.columnNames.length === 1 && unique.columnNames[0] === column.name);
        if (columnUnique) {
          clonedTable.uniques.splice(clonedTable.uniques.indexOf(columnUnique), 1);
          upQueries.push(this.dropUniqueConstraintSql(table, columnUnique));
          downQueries.push(this.createUniqueConstraintSql(table, columnUnique));
        }
        if (column.default !== null && column.default !== void 0) {
          const defaultName = this.connection.namingStrategy.defaultConstraintName(table, column.name);
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${defaultName}"`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${defaultName}" DEFAULT ${column.default} FOR "${column.name}"`));
        }
        if (column.generatedType && column.asExpression) {
          const parsedTableName = this.driver.parseTableName(table);
          if (!parsedTableName.schema) {
            parsedTableName.schema = await this.getCurrentSchema();
          }
          const deleteQuery = this.deleteTypeormMetadataSql({
            database: parsedTableName.database,
            schema: parsedTableName.schema,
            table: parsedTableName.tableName,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name
          });
          const insertQuery = this.insertTypeormMetadataSql({
            database: parsedTableName.database,
            schema: parsedTableName.schema,
            table: parsedTableName.tableName,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name,
            value: column.asExpression
          });
          upQueries.push(deleteQuery);
          downQueries.push(insertQuery);
        }
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN "${column.name}"`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(table, column, false, false)}`));
        await this.executeQueries(upQueries, downQueries);
        clonedTable.removeColumn(column);
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Drops the columns in the table.
       */
      async dropColumns(tableOrName, columns) {
        for (const column of [...columns]) {
          await this.dropColumn(tableOrName, column);
        }
      }
      /**
       * Creates a new primary key.
       */
      async createPrimaryKey(tableOrName, columnNames, constraintName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const clonedTable = table.clone();
        const up = this.createPrimaryKeySql(table, columnNames, constraintName);
        clonedTable.columns.forEach((column) => {
          if (columnNames.find((columnName) => columnName === column.name))
            column.isPrimary = true;
        });
        const down = this.dropPrimaryKeySql(clonedTable);
        await this.executeQueries(up, down);
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Updates composite primary keys.
       */
      async updatePrimaryKeys(tableOrName, columns) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const clonedTable = table.clone();
        const columnNames = columns.map((column) => column.name);
        const upQueries = [];
        const downQueries = [];
        const primaryColumns = clonedTable.primaryColumns;
        if (primaryColumns.length > 0) {
          const pkName2 = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column) => column.name));
          const columnNamesString2 = primaryColumns.map((column) => `"${column.name}"`).join(", ");
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName2}"`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName2}" PRIMARY KEY (${columnNamesString2})`));
        }
        clonedTable.columns.filter((column) => columnNames.indexOf(column.name) !== -1).forEach((column) => column.isPrimary = true);
        const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);
        const columnNamesString = columnNames.map((columnName) => `"${columnName}"`).join(", ");
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNamesString})`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
        await this.executeQueries(upQueries, downQueries);
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Drops a primary key.
       */
      async dropPrimaryKey(tableOrName, constraintName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const up = this.dropPrimaryKeySql(table);
        const down = this.createPrimaryKeySql(table, table.primaryColumns.map((column) => column.name), constraintName);
        await this.executeQueries(up, down);
        table.primaryColumns.forEach((column) => {
          column.isPrimary = false;
        });
      }
      /**
       * Creates a new unique constraint.
       */
      async createUniqueConstraint(tableOrName, uniqueConstraint) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        if (!uniqueConstraint.name)
          uniqueConstraint.name = this.connection.namingStrategy.uniqueConstraintName(table, uniqueConstraint.columnNames);
        const up = this.createUniqueConstraintSql(table, uniqueConstraint);
        const down = this.dropUniqueConstraintSql(table, uniqueConstraint);
        await this.executeQueries(up, down);
        table.addUniqueConstraint(uniqueConstraint);
      }
      /**
       * Creates a new unique constraints.
       */
      async createUniqueConstraints(tableOrName, uniqueConstraints) {
        const promises = uniqueConstraints.map((uniqueConstraint) => this.createUniqueConstraint(tableOrName, uniqueConstraint));
        await Promise.all(promises);
      }
      /**
       * Drops unique constraint.
       */
      async dropUniqueConstraint(tableOrName, uniqueOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const uniqueConstraint = InstanceChecker_1.InstanceChecker.isTableUnique(uniqueOrName) ? uniqueOrName : table.uniques.find((u) => u.name === uniqueOrName);
        if (!uniqueConstraint)
          throw new error_1.TypeORMError(`Supplied unique constraint was not found in table ${table.name}`);
        const up = this.dropUniqueConstraintSql(table, uniqueConstraint);
        const down = this.createUniqueConstraintSql(table, uniqueConstraint);
        await this.executeQueries(up, down);
        table.removeUniqueConstraint(uniqueConstraint);
      }
      /**
       * Drops an unique constraints.
       */
      async dropUniqueConstraints(tableOrName, uniqueConstraints) {
        const promises = uniqueConstraints.map((uniqueConstraint) => this.dropUniqueConstraint(tableOrName, uniqueConstraint));
        await Promise.all(promises);
      }
      /**
       * Creates a new check constraint.
       */
      async createCheckConstraint(tableOrName, checkConstraint) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        if (!checkConstraint.name)
          checkConstraint.name = this.connection.namingStrategy.checkConstraintName(table, checkConstraint.expression);
        const up = this.createCheckConstraintSql(table, checkConstraint);
        const down = this.dropCheckConstraintSql(table, checkConstraint);
        await this.executeQueries(up, down);
        table.addCheckConstraint(checkConstraint);
      }
      /**
       * Creates a new check constraints.
       */
      async createCheckConstraints(tableOrName, checkConstraints) {
        const promises = checkConstraints.map((checkConstraint) => this.createCheckConstraint(tableOrName, checkConstraint));
        await Promise.all(promises);
      }
      /**
       * Drops check constraint.
       */
      async dropCheckConstraint(tableOrName, checkOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const checkConstraint = InstanceChecker_1.InstanceChecker.isTableCheck(checkOrName) ? checkOrName : table.checks.find((c) => c.name === checkOrName);
        if (!checkConstraint)
          throw new error_1.TypeORMError(`Supplied check constraint was not found in table ${table.name}`);
        const up = this.dropCheckConstraintSql(table, checkConstraint);
        const down = this.createCheckConstraintSql(table, checkConstraint);
        await this.executeQueries(up, down);
        table.removeCheckConstraint(checkConstraint);
      }
      /**
       * Drops check constraints.
       */
      async dropCheckConstraints(tableOrName, checkConstraints) {
        const promises = checkConstraints.map((checkConstraint) => this.dropCheckConstraint(tableOrName, checkConstraint));
        await Promise.all(promises);
      }
      /**
       * Creates a new exclusion constraint.
       */
      async createExclusionConstraint(tableOrName, exclusionConstraint) {
        throw new error_1.TypeORMError(`SqlServer does not support exclusion constraints.`);
      }
      /**
       * Creates a new exclusion constraints.
       */
      async createExclusionConstraints(tableOrName, exclusionConstraints) {
        throw new error_1.TypeORMError(`SqlServer does not support exclusion constraints.`);
      }
      /**
       * Drops exclusion constraint.
       */
      async dropExclusionConstraint(tableOrName, exclusionOrName) {
        throw new error_1.TypeORMError(`SqlServer does not support exclusion constraints.`);
      }
      /**
       * Drops exclusion constraints.
       */
      async dropExclusionConstraints(tableOrName, exclusionConstraints) {
        throw new error_1.TypeORMError(`SqlServer does not support exclusion constraints.`);
      }
      /**
       * Creates a new foreign key.
       */
      async createForeignKey(tableOrName, foreignKey) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const metadata = this.connection.hasMetadata(table.name) ? this.connection.getMetadata(table.name) : void 0;
        if (metadata && metadata.treeParentRelation && metadata.treeParentRelation.isTreeParent && metadata.foreignKeys.find((foreignKey2) => foreignKey2.onDelete !== "NO ACTION"))
          throw new error_1.TypeORMError("SqlServer does not support options in TreeParent.");
        if (!foreignKey.name)
          foreignKey.name = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
        const up = this.createForeignKeySql(table, foreignKey);
        const down = this.dropForeignKeySql(table, foreignKey);
        await this.executeQueries(up, down);
        table.addForeignKey(foreignKey);
      }
      /**
       * Creates a new foreign keys.
       */
      async createForeignKeys(tableOrName, foreignKeys) {
        const promises = foreignKeys.map((foreignKey) => this.createForeignKey(tableOrName, foreignKey));
        await Promise.all(promises);
      }
      /**
       * Drops a foreign key from the table.
       */
      async dropForeignKey(tableOrName, foreignKeyOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const foreignKey = InstanceChecker_1.InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName : table.foreignKeys.find((fk) => fk.name === foreignKeyOrName);
        if (!foreignKey)
          throw new error_1.TypeORMError(`Supplied foreign key was not found in table ${table.name}`);
        const up = this.dropForeignKeySql(table, foreignKey);
        const down = this.createForeignKeySql(table, foreignKey);
        await this.executeQueries(up, down);
        table.removeForeignKey(foreignKey);
      }
      /**
       * Drops a foreign keys from the table.
       */
      async dropForeignKeys(tableOrName, foreignKeys) {
        const promises = foreignKeys.map((foreignKey) => this.dropForeignKey(tableOrName, foreignKey));
        await Promise.all(promises);
      }
      /**
       * Creates a new index.
       */
      async createIndex(tableOrName, index) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        if (!index.name)
          index.name = this.generateIndexName(table, index);
        const up = this.createIndexSql(table, index);
        const down = this.dropIndexSql(table, index);
        await this.executeQueries(up, down);
        table.addIndex(index);
      }
      /**
       * Creates a new indices
       */
      async createIndices(tableOrName, indices) {
        const promises = indices.map((index) => this.createIndex(tableOrName, index));
        await Promise.all(promises);
      }
      /**
       * Drops an index.
       */
      async dropIndex(tableOrName, indexOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const index = InstanceChecker_1.InstanceChecker.isTableIndex(indexOrName) ? indexOrName : table.indices.find((i) => i.name === indexOrName);
        if (!index)
          throw new error_1.TypeORMError(`Supplied index was not found in table ${table.name}`);
        if (!index.name)
          index.name = this.generateIndexName(table, index);
        const up = this.dropIndexSql(table, index);
        const down = this.createIndexSql(table, index);
        await this.executeQueries(up, down);
        table.removeIndex(index);
      }
      /**
       * Drops an indices from the table.
       */
      async dropIndices(tableOrName, indices) {
        const promises = indices.map((index) => this.dropIndex(tableOrName, index));
        await Promise.all(promises);
      }
      /**
       * Clears all table contents.
       * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.
       */
      async clearTable(tablePath) {
        await this.query(`TRUNCATE TABLE ${this.escapePath(tablePath)}`);
      }
      /**
       * Removes all tables from the currently connected database.
       */
      async clearDatabase(database) {
        if (database) {
          const isDatabaseExist = await this.hasDatabase(database);
          if (!isDatabaseExist)
            return Promise.resolve();
        }
        const isAnotherTransactionActive = this.isTransactionActive;
        if (!isAnotherTransactionActive)
          await this.startTransaction();
        try {
          const allViewsSql = database ? `SELECT * FROM "${database}"."INFORMATION_SCHEMA"."VIEWS"` : `SELECT * FROM "INFORMATION_SCHEMA"."VIEWS"`;
          const allViewsResults = await this.query(allViewsSql);
          await Promise.all(allViewsResults.map((viewResult) => {
            const dropTableSql = `DROP VIEW "${viewResult["TABLE_SCHEMA"]}"."${viewResult["TABLE_NAME"]}"`;
            return this.query(dropTableSql);
          }));
          const allTablesSql = database ? `SELECT * FROM "${database}"."INFORMATION_SCHEMA"."TABLES" WHERE "TABLE_TYPE" = 'BASE TABLE'` : `SELECT * FROM "INFORMATION_SCHEMA"."TABLES" WHERE "TABLE_TYPE" = 'BASE TABLE'`;
          const allTablesResults = await this.query(allTablesSql);
          if (allTablesResults.length > 0) {
            const tablesByCatalog = allTablesResults.reduce((c, { TABLE_CATALOG, TABLE_SCHEMA, TABLE_NAME }) => {
              c[TABLE_CATALOG] = c[TABLE_CATALOG] || [];
              c[TABLE_CATALOG].push({ TABLE_SCHEMA, TABLE_NAME });
              return c;
            }, {});
            const foreignKeysSql = Object.entries(tablesByCatalog).map(([TABLE_CATALOG, tables]) => {
              const conditions = tables.map(({ TABLE_SCHEMA, TABLE_NAME }) => {
                return `("fk"."referenced_object_id" = OBJECT_ID('"${TABLE_CATALOG}"."${TABLE_SCHEMA}"."${TABLE_NAME}"'))`;
              }).join(" OR ");
              return `
                        SELECT DISTINCT '${TABLE_CATALOG}' AS                                              "TABLE_CATALOG",
                                        OBJECT_SCHEMA_NAME("fk"."parent_object_id",
                                                           DB_ID('${TABLE_CATALOG}')) AS                   "TABLE_SCHEMA",
                                        OBJECT_NAME("fk"."parent_object_id", DB_ID('${TABLE_CATALOG}')) AS "TABLE_NAME",
                                        "fk"."name" AS                                                     "CONSTRAINT_NAME"
                        FROM "${TABLE_CATALOG}"."sys"."foreign_keys" AS "fk"
                        WHERE (${conditions})
                    `;
            }).join(" UNION ALL ");
            const foreignKeys = await this.query(foreignKeysSql);
            await Promise.all(foreignKeys.map(async ({ TABLE_CATALOG, TABLE_SCHEMA, TABLE_NAME, CONSTRAINT_NAME }) => {
              await this.query(`ALTER TABLE "${TABLE_CATALOG}"."${TABLE_SCHEMA}"."${TABLE_NAME}" NOCHECK CONSTRAINT "${CONSTRAINT_NAME}"`);
              await this.query(`ALTER TABLE "${TABLE_CATALOG}"."${TABLE_SCHEMA}"."${TABLE_NAME}" DROP CONSTRAINT "${CONSTRAINT_NAME}" -- FROM CLEAR`);
            }));
            await Promise.all(allTablesResults.map((tablesResult) => {
              if (tablesResult["TABLE_NAME"].startsWith("#")) {
                return;
              }
              const dropTableSql = `DROP TABLE "${tablesResult["TABLE_CATALOG"]}"."${tablesResult["TABLE_SCHEMA"]}"."${tablesResult["TABLE_NAME"]}"`;
              return this.query(dropTableSql);
            }));
          }
          if (!isAnotherTransactionActive)
            await this.commitTransaction();
        } catch (error) {
          try {
            if (!isAnotherTransactionActive)
              await this.rollbackTransaction();
          } catch (rollbackError) {
          }
          throw error;
        }
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      async loadViews(viewPaths) {
        const hasTable = await this.hasTable(this.getTypeormMetadataTableName());
        if (!hasTable) {
          return [];
        }
        if (!viewPaths) {
          viewPaths = [];
        }
        const currentSchema = await this.getCurrentSchema();
        const currentDatabase = await this.getCurrentDatabase();
        const dbNames = viewPaths.map((viewPath) => this.driver.parseTableName(viewPath).database).filter((database) => database);
        if (this.driver.database && !dbNames.find((dbName) => dbName === this.driver.database))
          dbNames.push(this.driver.database);
        const viewsCondition = viewPaths.map((viewPath) => {
          let { schema, tableName: name } = this.driver.parseTableName(viewPath);
          if (!schema) {
            schema = currentSchema;
          }
          return `("T"."SCHEMA" = '${schema}' AND "T"."NAME" = '${name}')`;
        }).join(" OR ");
        const query = dbNames.map((dbName) => {
          return `SELECT "T".*, "V"."CHECK_OPTION" FROM ${this.escapePath(this.getTypeormMetadataTableName())} "t" INNER JOIN "${dbName}"."INFORMATION_SCHEMA"."VIEWS" "V" ON "V"."TABLE_SCHEMA" = "T"."SCHEMA" AND "v"."TABLE_NAME" = "T"."NAME" WHERE "T"."TYPE" = '${MetadataTableType_1.MetadataTableType.VIEW}' ${viewsCondition ? `AND (${viewsCondition})` : ""}`;
        }).join(" UNION ALL ");
        const dbViews = await this.query(query);
        return dbViews.map((dbView) => {
          const view = new View_1.View();
          const db = dbView["TABLE_CATALOG"] === currentDatabase ? void 0 : dbView["TABLE_CATALOG"];
          const schema = dbView["schema"] === currentSchema && !this.driver.options.schema ? void 0 : dbView["schema"];
          view.database = dbView["TABLE_CATALOG"];
          view.schema = dbView["schema"];
          view.name = this.driver.buildTableName(dbView["name"], schema, db);
          view.expression = dbView["value"];
          return view;
        });
      }
      /**
       * Loads all tables (with given names) from the database and creates a Table from them.
       */
      async loadTables(tableNames) {
        if (tableNames && tableNames.length === 0) {
          return [];
        }
        const currentSchema = await this.getCurrentSchema();
        const currentDatabase = await this.getCurrentDatabase();
        const dbTables = [];
        if (!tableNames) {
          const databasesSql = `SELECT DISTINCT "name" FROM "master"."dbo"."sysdatabases" WHERE "name" NOT IN ('master', 'model', 'msdb')`;
          const dbDatabases = await this.query(databasesSql);
          const tablesSql = dbDatabases.map(({ name }) => {
            return `
                    SELECT DISTINCT
                        "TABLE_CATALOG", "TABLE_SCHEMA", "TABLE_NAME"
                    FROM "${name}"."INFORMATION_SCHEMA"."TABLES"
                    WHERE
                      "TABLE_TYPE" = 'BASE TABLE'
                      AND
                      "TABLE_CATALOG" = '${name}'
                      AND
                      ISNULL(Objectproperty(Object_id("TABLE_CATALOG" + '.' + "TABLE_SCHEMA" + '.' + "TABLE_NAME"), 'IsMSShipped'), 0) = 0
                `;
          }).join(" UNION ALL ");
          dbTables.push(...await this.query(tablesSql));
        } else {
          const tableNamesByCatalog = tableNames.map((tableName) => this.driver.parseTableName(tableName)).reduce((c, { database, ...other }) => {
            database = database || currentDatabase;
            c[database] = c[database] || [];
            c[database].push({
              schema: other.schema || currentSchema,
              tableName: other.tableName
            });
            return c;
          }, {});
          const tablesSql = Object.entries(tableNamesByCatalog).map(([database, tables]) => {
            const tablesCondition = tables.map(({ schema, tableName }) => {
              return `("TABLE_SCHEMA" = '${schema}' AND "TABLE_NAME" = '${tableName}')`;
            }).join(" OR ");
            return `
                    SELECT DISTINCT
                        "TABLE_CATALOG", "TABLE_SCHEMA", "TABLE_NAME"
                    FROM "${database}"."INFORMATION_SCHEMA"."TABLES"
                    WHERE
                          "TABLE_TYPE" = 'BASE TABLE' AND
                          "TABLE_CATALOG" = '${database}' AND
                          ${tablesCondition}
                `;
          }).join(" UNION ALL ");
          dbTables.push(...await this.query(tablesSql));
        }
        if (dbTables.length === 0) {
          return [];
        }
        const dbTablesByCatalog = dbTables.reduce((c, { TABLE_CATALOG, ...other }) => {
          c[TABLE_CATALOG] = c[TABLE_CATALOG] || [];
          c[TABLE_CATALOG].push(other);
          return c;
        }, {});
        const columnsSql = Object.entries(dbTablesByCatalog).map(([TABLE_CATALOG, tables]) => {
          const condition = tables.map(({ TABLE_SCHEMA, TABLE_NAME }) => `("TABLE_SCHEMA" = '${TABLE_SCHEMA}' AND "TABLE_NAME" = '${TABLE_NAME}')`).join("OR");
          return `SELECT "COLUMNS".*, "cc"."is_persisted", "cc"."definition" FROM "${TABLE_CATALOG}"."INFORMATION_SCHEMA"."COLUMNS" LEFT JOIN "sys"."computed_columns" "cc" ON COL_NAME("cc"."object_id", "cc"."column_id") = "column_name" WHERE (${condition})`;
        }).join(" UNION ALL ");
        const constraintsSql = Object.entries(dbTablesByCatalog).map(([TABLE_CATALOG, tables]) => {
          const conditions = tables.map(({ TABLE_NAME, TABLE_SCHEMA }) => `("columnUsages"."TABLE_SCHEMA" = '${TABLE_SCHEMA}' AND "columnUsages"."TABLE_NAME" = '${TABLE_NAME}')`).join(" OR ");
          return `SELECT "columnUsages".*, "tableConstraints"."CONSTRAINT_TYPE", "chk"."definition" FROM "${TABLE_CATALOG}"."INFORMATION_SCHEMA"."CONSTRAINT_COLUMN_USAGE" "columnUsages" INNER JOIN "${TABLE_CATALOG}"."INFORMATION_SCHEMA"."TABLE_CONSTRAINTS" "tableConstraints" ON "tableConstraints"."CONSTRAINT_NAME" = "columnUsages"."CONSTRAINT_NAME" AND "tableConstraints"."TABLE_SCHEMA" = "columnUsages"."TABLE_SCHEMA" AND "tableConstraints"."TABLE_NAME" = "columnUsages"."TABLE_NAME" LEFT JOIN "${TABLE_CATALOG}"."sys"."check_constraints" "chk" ON "chk"."object_id" = OBJECT_ID("columnUsages"."TABLE_CATALOG" + '.' + "columnUsages"."TABLE_SCHEMA" + '.' + "columnUsages"."CONSTRAINT_NAME") WHERE (${conditions}) AND "tableConstraints"."CONSTRAINT_TYPE" IN ('PRIMARY KEY', 'UNIQUE', 'CHECK')`;
        }).join(" UNION ALL ");
        const foreignKeysSql = Object.entries(dbTablesByCatalog).map(([TABLE_CATALOG, tables]) => {
          const conditions = tables.map(({ TABLE_NAME, TABLE_SCHEMA }) => `("s1"."name" = '${TABLE_SCHEMA}' AND "t1"."name" = '${TABLE_NAME}')`).join(" OR ");
          return `SELECT "fk"."name" AS "FK_NAME", '${TABLE_CATALOG}' AS "TABLE_CATALOG", "s1"."name" AS "TABLE_SCHEMA", "t1"."name" AS "TABLE_NAME", "col1"."name" AS "COLUMN_NAME", "s2"."name" AS "REF_SCHEMA", "t2"."name" AS "REF_TABLE", "col2"."name" AS "REF_COLUMN", "fk"."delete_referential_action_desc" AS "ON_DELETE", "fk"."update_referential_action_desc" AS "ON_UPDATE" FROM "${TABLE_CATALOG}"."sys"."foreign_keys" "fk" INNER JOIN "${TABLE_CATALOG}"."sys"."foreign_key_columns" "fkc" ON "fkc"."constraint_object_id" = "fk"."object_id" INNER JOIN "${TABLE_CATALOG}"."sys"."tables" "t1" ON "t1"."object_id" = "fk"."parent_object_id" INNER JOIN "${TABLE_CATALOG}"."sys"."schemas" "s1" ON "s1"."schema_id" = "t1"."schema_id" INNER JOIN "${TABLE_CATALOG}"."sys"."tables" "t2" ON "t2"."object_id" = "fk"."referenced_object_id" INNER JOIN "${TABLE_CATALOG}"."sys"."schemas" "s2" ON "s2"."schema_id" = "t2"."schema_id" INNER JOIN "${TABLE_CATALOG}"."sys"."columns" "col1" ON "col1"."column_id" = "fkc"."parent_column_id" AND "col1"."object_id" = "fk"."parent_object_id" INNER JOIN "${TABLE_CATALOG}"."sys"."columns" "col2" ON "col2"."column_id" = "fkc"."referenced_column_id" AND "col2"."object_id" = "fk"."referenced_object_id" WHERE (${conditions})`;
        }).join(" UNION ALL ");
        const identityColumnsSql = Object.entries(dbTablesByCatalog).map(([TABLE_CATALOG, tables]) => {
          const conditions = tables.map(({ TABLE_NAME, TABLE_SCHEMA }) => `("TABLE_SCHEMA" = '${TABLE_SCHEMA}' AND "TABLE_NAME" = '${TABLE_NAME}')`).join(" OR ");
          return `SELECT "TABLE_CATALOG", "TABLE_SCHEMA", "COLUMN_NAME", "TABLE_NAME" FROM "${TABLE_CATALOG}"."INFORMATION_SCHEMA"."COLUMNS" WHERE EXISTS(SELECT 1 FROM "${TABLE_CATALOG}"."sys"."columns" "S" WHERE OBJECT_ID("TABLE_CATALOG" + '.' + "TABLE_SCHEMA" + '.' + "TABLE_NAME") = "S"."OBJECT_ID" AND "COLUMN_NAME" = "S"."NAME" AND "S"."is_identity" = 1) AND (${conditions})`;
        }).join(" UNION ALL ");
        const dbCollationsSql = `SELECT "NAME", "COLLATION_NAME" FROM "sys"."databases"`;
        const indicesSql = Object.entries(dbTablesByCatalog).map(([TABLE_CATALOG, tables]) => {
          const conditions = tables.map(({ TABLE_NAME, TABLE_SCHEMA }) => `("s"."name" = '${TABLE_SCHEMA}' AND "t"."name" = '${TABLE_NAME}')`).join(" OR ");
          return `SELECT '${TABLE_CATALOG}' AS "TABLE_CATALOG", "s"."name" AS "TABLE_SCHEMA", "t"."name" AS "TABLE_NAME", "ind"."name" AS "INDEX_NAME", "col"."name" AS "COLUMN_NAME", "ind"."is_unique" AS "IS_UNIQUE", "ind"."filter_definition" as "CONDITION" FROM "${TABLE_CATALOG}"."sys"."indexes" "ind" INNER JOIN "${TABLE_CATALOG}"."sys"."index_columns" "ic" ON "ic"."object_id" = "ind"."object_id" AND "ic"."index_id" = "ind"."index_id" INNER JOIN "${TABLE_CATALOG}"."sys"."columns" "col" ON "col"."object_id" = "ic"."object_id" AND "col"."column_id" = "ic"."column_id" INNER JOIN "${TABLE_CATALOG}"."sys"."tables" "t" ON "t"."object_id" = "ind"."object_id" INNER JOIN "${TABLE_CATALOG}"."sys"."schemas" "s" ON "s"."schema_id" = "t"."schema_id" WHERE "ind"."is_primary_key" = 0 AND "ind"."is_unique_constraint" = 0 AND "t"."is_ms_shipped" = 0 AND (${conditions})`;
        }).join(" UNION ALL ");
        const [dbColumns, dbConstraints, dbForeignKeys, dbIdentityColumns, dbCollations, dbIndices] = await Promise.all([
          this.query(columnsSql),
          this.query(constraintsSql),
          this.query(foreignKeysSql),
          this.query(identityColumnsSql),
          this.query(dbCollationsSql),
          this.query(indicesSql)
        ]);
        return await Promise.all(dbTables.map(async (dbTable) => {
          const table = new Table_1.Table();
          const getSchemaFromKey = (dbObject, key) => {
            return dbObject[key] === currentSchema && (!this.driver.options.schema || this.driver.options.schema === currentSchema) ? void 0 : dbObject[key];
          };
          const db = dbTable["TABLE_CATALOG"] === currentDatabase ? void 0 : dbTable["TABLE_CATALOG"];
          const schema = getSchemaFromKey(dbTable, "TABLE_SCHEMA");
          table.database = dbTable["TABLE_CATALOG"];
          table.schema = dbTable["TABLE_SCHEMA"];
          table.name = this.driver.buildTableName(dbTable["TABLE_NAME"], schema, db);
          const defaultCollation = dbCollations.find((dbCollation) => dbCollation["NAME"] === dbTable["TABLE_CATALOG"]);
          table.columns = await Promise.all(dbColumns.filter((dbColumn) => dbColumn["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbColumn["TABLE_SCHEMA"] === dbTable["TABLE_SCHEMA"] && dbColumn["TABLE_CATALOG"] === dbTable["TABLE_CATALOG"]).map(async (dbColumn) => {
            const columnConstraints = dbConstraints.filter((dbConstraint) => dbConstraint["TABLE_NAME"] === dbColumn["TABLE_NAME"] && dbConstraint["TABLE_SCHEMA"] === dbColumn["TABLE_SCHEMA"] && dbConstraint["TABLE_CATALOG"] === dbColumn["TABLE_CATALOG"] && dbConstraint["COLUMN_NAME"] === dbColumn["COLUMN_NAME"]);
            const uniqueConstraints = columnConstraints.filter((constraint) => constraint["CONSTRAINT_TYPE"] === "UNIQUE");
            const isConstraintComposite = uniqueConstraints.every((uniqueConstraint) => {
              return dbConstraints.some((dbConstraint) => dbConstraint["CONSTRAINT_TYPE"] === "UNIQUE" && dbConstraint["CONSTRAINT_NAME"] === uniqueConstraint["CONSTRAINT_NAME"] && dbConstraint["TABLE_SCHEMA"] === dbColumn["TABLE_SCHEMA"] && dbConstraint["TABLE_CATALOG"] === dbColumn["TABLE_CATALOG"] && dbConstraint["COLUMN_NAME"] !== dbColumn["COLUMN_NAME"]);
            });
            const isGenerated = !!dbIdentityColumns.find((column) => column["TABLE_NAME"] === dbColumn["TABLE_NAME"] && column["TABLE_SCHEMA"] === dbColumn["TABLE_SCHEMA"] && column["TABLE_CATALOG"] === dbColumn["TABLE_CATALOG"] && column["COLUMN_NAME"] === dbColumn["COLUMN_NAME"]);
            const tableColumn = new TableColumn_1.TableColumn();
            tableColumn.name = dbColumn["COLUMN_NAME"];
            tableColumn.type = dbColumn["DATA_TYPE"].toLowerCase();
            if (this.driver.withLengthColumnTypes.indexOf(tableColumn.type) !== -1 && dbColumn["CHARACTER_MAXIMUM_LENGTH"]) {
              const length = dbColumn["CHARACTER_MAXIMUM_LENGTH"].toString();
              if (length === "-1") {
                tableColumn.length = "MAX";
              } else {
                tableColumn.length = !this.isDefaultColumnLength(table, tableColumn, length) ? length : "";
              }
            }
            if (tableColumn.type === "decimal" || tableColumn.type === "numeric") {
              if (dbColumn["NUMERIC_PRECISION"] !== null && !this.isDefaultColumnPrecision(table, tableColumn, dbColumn["NUMERIC_PRECISION"]))
                tableColumn.precision = dbColumn["NUMERIC_PRECISION"];
              if (dbColumn["NUMERIC_SCALE"] !== null && !this.isDefaultColumnScale(table, tableColumn, dbColumn["NUMERIC_SCALE"]))
                tableColumn.scale = dbColumn["NUMERIC_SCALE"];
            }
            if (tableColumn.type === "nvarchar") {
              const columnCheckConstraints = columnConstraints.filter((constraint) => constraint["CONSTRAINT_TYPE"] === "CHECK");
              if (columnCheckConstraints.length) {
                for (const checkConstraint of columnCheckConstraints) {
                  if (this.isEnumCheckConstraint(checkConstraint["CONSTRAINT_NAME"])) {
                    tableColumn.enum = [];
                    const enumValueRegexp = new RegExp("\\[" + tableColumn.name + "\\]='([^']+)'", "g");
                    let result;
                    while ((result = enumValueRegexp.exec(checkConstraint["definition"])) !== null) {
                      tableColumn.enum.unshift(result[1]);
                    }
                    break;
                  }
                }
              }
            }
            const primaryConstraint = columnConstraints.find((constraint) => constraint["CONSTRAINT_TYPE"] === "PRIMARY KEY");
            if (primaryConstraint) {
              tableColumn.isPrimary = true;
              const anotherPrimaryConstraints = dbConstraints.filter((constraint) => constraint["TABLE_NAME"] === dbColumn["TABLE_NAME"] && constraint["TABLE_SCHEMA"] === dbColumn["TABLE_SCHEMA"] && constraint["TABLE_CATALOG"] === dbColumn["TABLE_CATALOG"] && constraint["COLUMN_NAME"] !== dbColumn["COLUMN_NAME"] && constraint["CONSTRAINT_TYPE"] === "PRIMARY KEY");
              const columnNames = anotherPrimaryConstraints.map((constraint) => constraint["COLUMN_NAME"]);
              columnNames.push(dbColumn["COLUMN_NAME"]);
              const pkName = this.connection.namingStrategy.primaryKeyName(table, columnNames);
              if (primaryConstraint["CONSTRAINT_NAME"] !== pkName) {
                tableColumn.primaryKeyConstraintName = primaryConstraint["CONSTRAINT_NAME"];
              }
            }
            tableColumn.default = dbColumn["COLUMN_DEFAULT"] !== null && dbColumn["COLUMN_DEFAULT"] !== void 0 ? this.removeParenthesisFromDefault(dbColumn["COLUMN_DEFAULT"]) : void 0;
            tableColumn.isNullable = dbColumn["IS_NULLABLE"] === "YES";
            tableColumn.isUnique = uniqueConstraints.length > 0 && !isConstraintComposite;
            tableColumn.isGenerated = isGenerated;
            if (isGenerated)
              tableColumn.generationStrategy = "increment";
            if (tableColumn.default === "newsequentialid()") {
              tableColumn.isGenerated = true;
              tableColumn.generationStrategy = "uuid";
              tableColumn.default = void 0;
            }
            if (dbColumn["COLLATION_NAME"])
              tableColumn.collation = dbColumn["COLLATION_NAME"] === defaultCollation["COLLATION_NAME"] ? void 0 : dbColumn["COLLATION_NAME"];
            if (tableColumn.type === "datetime2" || tableColumn.type === "time" || tableColumn.type === "datetimeoffset") {
              tableColumn.precision = !this.isDefaultColumnPrecision(table, tableColumn, dbColumn["DATETIME_PRECISION"]) ? dbColumn["DATETIME_PRECISION"] : void 0;
            }
            if (dbColumn["is_persisted"] !== null && dbColumn["is_persisted"] !== void 0 && dbColumn["definition"]) {
              tableColumn.generatedType = dbColumn["is_persisted"] === true ? "STORED" : "VIRTUAL";
              const asExpressionQuery = this.selectTypeormMetadataSql({
                database: dbTable["TABLE_CATALOG"],
                schema: dbTable["TABLE_SCHEMA"],
                table: dbTable["TABLE_NAME"],
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: tableColumn.name
              });
              const results = await this.query(asExpressionQuery.query, asExpressionQuery.parameters);
              if (results[0] && results[0].value) {
                tableColumn.asExpression = results[0].value;
              } else {
                tableColumn.asExpression = "";
              }
            }
            return tableColumn;
          }));
          const tableUniqueConstraints = OrmUtils_1.OrmUtils.uniq(dbConstraints.filter((dbConstraint) => dbConstraint["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbConstraint["TABLE_SCHEMA"] === dbTable["TABLE_SCHEMA"] && dbConstraint["TABLE_CATALOG"] === dbTable["TABLE_CATALOG"] && dbConstraint["CONSTRAINT_TYPE"] === "UNIQUE"), (dbConstraint) => dbConstraint["CONSTRAINT_NAME"]);
          table.uniques = tableUniqueConstraints.map((constraint) => {
            const uniques = dbConstraints.filter((dbC) => dbC["CONSTRAINT_NAME"] === constraint["CONSTRAINT_NAME"]);
            return new TableUnique_1.TableUnique({
              name: constraint["CONSTRAINT_NAME"],
              columnNames: uniques.map((u) => u["COLUMN_NAME"])
            });
          });
          const tableCheckConstraints = OrmUtils_1.OrmUtils.uniq(dbConstraints.filter((dbConstraint) => dbConstraint["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbConstraint["TABLE_SCHEMA"] === dbTable["TABLE_SCHEMA"] && dbConstraint["TABLE_CATALOG"] === dbTable["TABLE_CATALOG"] && dbConstraint["CONSTRAINT_TYPE"] === "CHECK"), (dbConstraint) => dbConstraint["CONSTRAINT_NAME"]);
          table.checks = tableCheckConstraints.filter((constraint) => !this.isEnumCheckConstraint(constraint["CONSTRAINT_NAME"])).map((constraint) => {
            const checks = dbConstraints.filter((dbC) => dbC["CONSTRAINT_NAME"] === constraint["CONSTRAINT_NAME"]);
            return new TableCheck_1.TableCheck({
              name: constraint["CONSTRAINT_NAME"],
              columnNames: checks.map((c) => c["COLUMN_NAME"]),
              expression: constraint["definition"]
            });
          });
          const tableForeignKeyConstraints = OrmUtils_1.OrmUtils.uniq(dbForeignKeys.filter((dbForeignKey) => dbForeignKey["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbForeignKey["TABLE_SCHEMA"] === dbTable["TABLE_SCHEMA"] && dbForeignKey["TABLE_CATALOG"] === dbTable["TABLE_CATALOG"]), (dbForeignKey) => dbForeignKey["FK_NAME"]);
          table.foreignKeys = tableForeignKeyConstraints.map((dbForeignKey) => {
            const foreignKeys = dbForeignKeys.filter((dbFk) => dbFk["FK_NAME"] === dbForeignKey["FK_NAME"]);
            const db2 = dbForeignKey["TABLE_CATALOG"] === currentDatabase ? void 0 : dbForeignKey["TABLE_CATALOG"];
            const schema2 = getSchemaFromKey(dbForeignKey, "REF_SCHEMA");
            const referencedTableName = this.driver.buildTableName(dbForeignKey["REF_TABLE"], schema2, db2);
            return new TableForeignKey_1.TableForeignKey({
              name: dbForeignKey["FK_NAME"],
              columnNames: foreignKeys.map((dbFk) => dbFk["COLUMN_NAME"]),
              referencedDatabase: dbForeignKey["TABLE_CATALOG"],
              referencedSchema: dbForeignKey["REF_SCHEMA"],
              referencedTableName,
              referencedColumnNames: foreignKeys.map((dbFk) => dbFk["REF_COLUMN"]),
              onDelete: dbForeignKey["ON_DELETE"].replace("_", " "),
              // SqlServer returns NO_ACTION, instead of NO ACTION
              onUpdate: dbForeignKey["ON_UPDATE"].replace("_", " ")
              // SqlServer returns NO_ACTION, instead of NO ACTION
            });
          });
          const tableIndexConstraints = OrmUtils_1.OrmUtils.uniq(dbIndices.filter((dbIndex) => dbIndex["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbIndex["TABLE_SCHEMA"] === dbTable["TABLE_SCHEMA"] && dbIndex["TABLE_CATALOG"] === dbTable["TABLE_CATALOG"]), (dbIndex) => dbIndex["INDEX_NAME"]);
          table.indices = tableIndexConstraints.map((constraint) => {
            const indices = dbIndices.filter((index) => {
              return index["TABLE_CATALOG"] === constraint["TABLE_CATALOG"] && index["TABLE_SCHEMA"] === constraint["TABLE_SCHEMA"] && index["TABLE_NAME"] === constraint["TABLE_NAME"] && index["INDEX_NAME"] === constraint["INDEX_NAME"];
            });
            return new TableIndex_1.TableIndex({
              table,
              name: constraint["INDEX_NAME"],
              columnNames: indices.map((i) => i["COLUMN_NAME"]),
              isUnique: constraint["IS_UNIQUE"],
              where: constraint["CONDITION"]
            });
          });
          return table;
        }));
      }
      /**
       * Builds and returns SQL for create table.
       */
      createTableSql(table, createForeignKeys) {
        const columnDefinitions = table.columns.map((column) => this.buildCreateColumnSql(table, column, false, true)).join(", ");
        let sql = `CREATE TABLE ${this.escapePath(table)} (${columnDefinitions}`;
        table.columns.filter((column) => column.isUnique).forEach((column) => {
          const isUniqueExist = table.uniques.some((unique) => unique.columnNames.length === 1 && unique.columnNames[0] === column.name);
          if (!isUniqueExist)
            table.uniques.push(new TableUnique_1.TableUnique({
              name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),
              columnNames: [column.name]
            }));
        });
        if (table.uniques.length > 0) {
          const uniquesSql = table.uniques.map((unique) => {
            const uniqueName = unique.name ? unique.name : this.connection.namingStrategy.uniqueConstraintName(table, unique.columnNames);
            const columnNames = unique.columnNames.map((columnName) => `"${columnName}"`).join(", ");
            return `CONSTRAINT "${uniqueName}" UNIQUE (${columnNames})`;
          }).join(", ");
          sql += `, ${uniquesSql}`;
        }
        if (table.checks.length > 0) {
          const checksSql = table.checks.map((check) => {
            const checkName = check.name ? check.name : this.connection.namingStrategy.checkConstraintName(table, check.expression);
            return `CONSTRAINT "${checkName}" CHECK (${check.expression})`;
          }).join(", ");
          sql += `, ${checksSql}`;
        }
        if (table.foreignKeys.length > 0 && createForeignKeys) {
          const foreignKeysSql = table.foreignKeys.map((fk) => {
            const columnNames = fk.columnNames.map((columnName) => `"${columnName}"`).join(", ");
            if (!fk.name)
              fk.name = this.connection.namingStrategy.foreignKeyName(table, fk.columnNames, this.getTablePath(fk), fk.referencedColumnNames);
            const referencedColumnNames = fk.referencedColumnNames.map((columnName) => `"${columnName}"`).join(", ");
            let constraint = `CONSTRAINT "${fk.name}" FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(fk))} (${referencedColumnNames})`;
            if (fk.onDelete)
              constraint += ` ON DELETE ${fk.onDelete}`;
            if (fk.onUpdate)
              constraint += ` ON UPDATE ${fk.onUpdate}`;
            return constraint;
          }).join(", ");
          sql += `, ${foreignKeysSql}`;
        }
        const primaryColumns = table.columns.filter((column) => column.isPrimary);
        if (primaryColumns.length > 0) {
          const primaryKeyName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(table, primaryColumns.map((column) => column.name));
          const columnNames = primaryColumns.map((column) => `"${column.name}"`).join(", ");
          sql += `, CONSTRAINT "${primaryKeyName}" PRIMARY KEY (${columnNames})`;
        }
        sql += `)`;
        return new Query_1.Query(sql);
      }
      /**
       * Builds drop table sql.
       */
      dropTableSql(tableOrName, ifExist) {
        const query = ifExist ? `DROP TABLE IF EXISTS ${this.escapePath(tableOrName)}` : `DROP TABLE ${this.escapePath(tableOrName)}`;
        return new Query_1.Query(query);
      }
      createViewSql(view) {
        const parsedName = this.driver.parseTableName(view);
        const viewIdentifier = parsedName.schema ? `"${parsedName.schema}"."${parsedName.tableName}"` : `"${parsedName.tableName}"`;
        if (typeof view.expression === "string") {
          return new Query_1.Query(`CREATE VIEW ${viewIdentifier} AS ${view.expression}`);
        } else {
          return new Query_1.Query(`CREATE VIEW ${viewIdentifier} AS ${view.expression(this.connection).getQuery()}`);
        }
      }
      async insertViewDefinitionSql(view) {
        const parsedTableName = this.driver.parseTableName(view);
        if (!parsedTableName.schema) {
          parsedTableName.schema = await this.getCurrentSchema();
        }
        const expression = typeof view.expression === "string" ? view.expression.trim() : view.expression(this.connection).getQuery();
        return this.insertTypeormMetadataSql({
          type: MetadataTableType_1.MetadataTableType.VIEW,
          database: parsedTableName.database,
          schema: parsedTableName.schema,
          name: parsedTableName.tableName,
          value: expression
        });
      }
      /**
       * Builds drop view sql.
       */
      dropViewSql(viewOrPath) {
        return new Query_1.Query(`DROP VIEW ${this.escapePath(viewOrPath)}`);
      }
      /**
       * Builds remove view sql.
       */
      async deleteViewDefinitionSql(viewOrPath) {
        const parsedTableName = this.driver.parseTableName(viewOrPath);
        if (!parsedTableName.schema) {
          parsedTableName.schema = await this.getCurrentSchema();
        }
        return this.deleteTypeormMetadataSql({
          type: MetadataTableType_1.MetadataTableType.VIEW,
          database: parsedTableName.database,
          schema: parsedTableName.schema,
          name: parsedTableName.tableName
        });
      }
      /**
       * Builds create index sql.
       */
      createIndexSql(table, index) {
        const columns = index.columnNames.map((columnName) => `"${columnName}"`).join(", ");
        return new Query_1.Query(`CREATE ${index.isUnique ? "UNIQUE " : ""}INDEX "${index.name}" ON ${this.escapePath(table)} (${columns}) ${index.where ? "WHERE " + index.where : ""}`);
      }
      /**
       * Builds drop index sql.
       */
      dropIndexSql(table, indexOrName) {
        const indexName = InstanceChecker_1.InstanceChecker.isTableIndex(indexOrName) ? indexOrName.name : indexOrName;
        return new Query_1.Query(`DROP INDEX "${indexName}" ON ${this.escapePath(table)}`);
      }
      /**
       * Builds create primary key sql.
       */
      createPrimaryKeySql(table, columnNames, constraintName) {
        const primaryKeyName = constraintName ? constraintName : this.connection.namingStrategy.primaryKeyName(table, columnNames);
        const columnNamesString = columnNames.map((columnName) => `"${columnName}"`).join(", ");
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${primaryKeyName}" PRIMARY KEY (${columnNamesString})`);
      }
      /**
       * Builds drop primary key sql.
       */
      dropPrimaryKeySql(table) {
        const columnNames = table.primaryColumns.map((column) => column.name);
        const constraintName = table.primaryColumns[0].primaryKeyConstraintName;
        const primaryKeyName = constraintName ? constraintName : this.connection.namingStrategy.primaryKeyName(table, columnNames);
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${primaryKeyName}"`);
      }
      /**
       * Builds create unique constraint sql.
       */
      createUniqueConstraintSql(table, uniqueConstraint) {
        const columnNames = uniqueConstraint.columnNames.map((column) => `"` + column + `"`).join(", ");
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${uniqueConstraint.name}" UNIQUE (${columnNames})`);
      }
      /**
       * Builds drop unique constraint sql.
       */
      dropUniqueConstraintSql(table, uniqueOrName) {
        const uniqueName = InstanceChecker_1.InstanceChecker.isTableUnique(uniqueOrName) ? uniqueOrName.name : uniqueOrName;
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${uniqueName}"`);
      }
      /**
       * Builds create check constraint sql.
       */
      createCheckConstraintSql(table, checkConstraint) {
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${checkConstraint.name}" CHECK (${checkConstraint.expression})`);
      }
      /**
       * Builds drop check constraint sql.
       */
      dropCheckConstraintSql(table, checkOrName) {
        const checkName = InstanceChecker_1.InstanceChecker.isTableCheck(checkOrName) ? checkOrName.name : checkOrName;
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${checkName}"`);
      }
      /**
       * Builds create foreign key sql.
       */
      createForeignKeySql(table, foreignKey) {
        const columnNames = foreignKey.columnNames.map((column) => `"` + column + `"`).join(", ");
        const referencedColumnNames = foreignKey.referencedColumnNames.map((column) => `"` + column + `"`).join(",");
        let sql = `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${foreignKey.name}" FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;
        if (foreignKey.onDelete)
          sql += ` ON DELETE ${foreignKey.onDelete}`;
        if (foreignKey.onUpdate)
          sql += ` ON UPDATE ${foreignKey.onUpdate}`;
        return new Query_1.Query(sql);
      }
      /**
       * Builds drop foreign key sql.
       */
      dropForeignKeySql(table, foreignKeyOrName) {
        const foreignKeyName = InstanceChecker_1.InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName.name : foreignKeyOrName;
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${foreignKeyName}"`);
      }
      /**
       * Escapes given table or View path.
       */
      escapePath(target) {
        const { database, schema, tableName } = this.driver.parseTableName(target);
        if (database && database !== this.driver.database) {
          if (schema && schema !== this.driver.searchSchema) {
            return `"${database}"."${schema}"."${tableName}"`;
          }
          return `"${database}".."${tableName}"`;
        }
        if (schema && schema !== this.driver.searchSchema) {
          return `"${schema}"."${tableName}"`;
        }
        return `"${tableName}"`;
      }
      /**
       * Concat database name and schema name to the foreign key name.
       * Needs because FK name is relevant to the schema and database.
       */
      buildForeignKeyName(fkName, schemaName, dbName) {
        let joinedFkName = fkName;
        if (schemaName && schemaName !== this.driver.searchSchema)
          joinedFkName = schemaName + "." + joinedFkName;
        if (dbName && dbName !== this.driver.database)
          joinedFkName = dbName + "." + joinedFkName;
        return joinedFkName;
      }
      /**
       * Removes parenthesis around default value.
       * Sql server returns default value with parenthesis around, e.g.
       *  ('My text') - for string
       *  ((1)) - for number
       *  (newsequentialId()) - for function
       */
      removeParenthesisFromDefault(defaultValue) {
        if (defaultValue.substr(0, 1) !== "(")
          return defaultValue;
        const normalizedDefault = defaultValue.substr(1, defaultValue.lastIndexOf(")") - 1);
        return this.removeParenthesisFromDefault(normalizedDefault);
      }
      /**
       * Builds a query for create column.
       */
      buildCreateColumnSql(table, column, skipIdentity, createDefault, skipEnum) {
        let c = `"${column.name}" ${this.connection.driver.createFullType(column)}`;
        if (!skipEnum && column.enum) {
          const expression = this.getEnumExpression(column);
          const checkName = this.connection.namingStrategy.checkConstraintName(table, expression, true);
          c += ` CONSTRAINT ${checkName} CHECK(${expression})`;
        }
        if (column.collation)
          c += " COLLATE " + column.collation;
        if (column.asExpression) {
          c += ` AS (${column.asExpression})`;
          if (column.generatedType === "STORED") {
            c += ` PERSISTED`;
            if (column.isNullable !== true)
              c += " NOT NULL";
          }
        } else {
          if (column.isNullable !== true)
            c += " NOT NULL";
        }
        if (column.isGenerated === true && column.generationStrategy === "increment" && !skipIdentity)
          c += " IDENTITY(1,1)";
        if (column.default !== void 0 && column.default !== null && createDefault) {
          const defaultName = this.connection.namingStrategy.defaultConstraintName(table, column.name);
          c += ` CONSTRAINT "${defaultName}" DEFAULT ${column.default}`;
        }
        if (column.isGenerated && column.generationStrategy === "uuid" && !column.default) {
          const defaultName = this.connection.namingStrategy.defaultConstraintName(table, column.name);
          c += ` CONSTRAINT "${defaultName}" DEFAULT NEWSEQUENTIALID()`;
        }
        return c;
      }
      getEnumExpression(column) {
        if (!column.enum) {
          throw new Error(`Enum is not defined in column ${column.name}`);
        }
        return column.name + " IN (" + column.enum.map((val) => "'" + val + "'").join(",") + ")";
      }
      isEnumCheckConstraint(name) {
        return name.indexOf("CHK_") !== -1 && name.indexOf("_ENUM") !== -1;
      }
      /**
       * Converts MssqlParameter into real mssql parameter type.
       */
      mssqlParameterToNativeParameter(parameter) {
        switch (this.driver.normalizeType({ type: parameter.type })) {
          case "bit":
            return this.driver.mssql.Bit;
          case "bigint":
            return this.driver.mssql.BigInt;
          case "decimal":
            return this.driver.mssql.Decimal(...parameter.params);
          case "float":
            return this.driver.mssql.Float;
          case "int":
            return this.driver.mssql.Int;
          case "money":
            return this.driver.mssql.Money;
          case "numeric":
            return this.driver.mssql.Numeric(...parameter.params);
          case "smallint":
            return this.driver.mssql.SmallInt;
          case "smallmoney":
            return this.driver.mssql.SmallMoney;
          case "real":
            return this.driver.mssql.Real;
          case "tinyint":
            return this.driver.mssql.TinyInt;
          case "char":
            if (this.driver.options.options?.disableAsciiToUnicodeParamConversion) {
              return this.driver.mssql.Char(...parameter.params);
            }
            return this.driver.mssql.NChar(...parameter.params);
          case "nchar":
            return this.driver.mssql.NChar(...parameter.params);
          case "text":
            if (this.driver.options.options?.disableAsciiToUnicodeParamConversion) {
              return this.driver.mssql.Text;
            }
            return this.driver.mssql.Ntext;
          case "ntext":
            return this.driver.mssql.Ntext;
          case "varchar":
            if (this.driver.options.options?.disableAsciiToUnicodeParamConversion) {
              return this.driver.mssql.VarChar(...parameter.params);
            }
            return this.driver.mssql.NVarChar(...parameter.params);
          case "nvarchar":
            return this.driver.mssql.NVarChar(...parameter.params);
          case "xml":
            return this.driver.mssql.Xml;
          case "time":
            return this.driver.mssql.Time(...parameter.params);
          case "date":
            return this.driver.mssql.Date;
          case "datetime":
            return this.driver.mssql.DateTime;
          case "datetime2":
            return this.driver.mssql.DateTime2(...parameter.params);
          case "datetimeoffset":
            return this.driver.mssql.DateTimeOffset(...parameter.params);
          case "smalldatetime":
            return this.driver.mssql.SmallDateTime;
          case "uniqueidentifier":
            return this.driver.mssql.UniqueIdentifier;
          case "variant":
            return this.driver.mssql.Variant;
          case "binary":
            return this.driver.mssql.Binary;
          case "varbinary":
            return this.driver.mssql.VarBinary(...parameter.params);
          case "image":
            return this.driver.mssql.Image;
          case "udt":
            return this.driver.mssql.UDT;
          case "rowversion":
            return this.driver.mssql.RowVersion;
        }
      }
      /**
       * Converts string literal of isolation level to enum.
       * The underlying mssql driver requires an enum for the isolation level.
       */
      convertIsolationLevel(isolation) {
        const ISOLATION_LEVEL = this.driver.mssql.ISOLATION_LEVEL;
        switch (isolation) {
          case "READ UNCOMMITTED":
            return ISOLATION_LEVEL.READ_UNCOMMITTED;
          case "REPEATABLE READ":
            return ISOLATION_LEVEL.REPEATABLE_READ;
          case "SERIALIZABLE":
            return ISOLATION_LEVEL.SERIALIZABLE;
          case "READ COMMITTED":
          default:
            return ISOLATION_LEVEL.READ_COMMITTED;
        }
      }
      /**
       * Change table comment.
       */
      changeTableComment(tableOrName, comment) {
        throw new error_1.TypeORMError(`sqlserver driver does not support change table comment.`);
      }
    };
    exports2.SqlServerQueryRunner = SqlServerQueryRunner;
  }
});

// node_modules/typeorm/driver/sqlserver/SqlServerDriver.js
var require_SqlServerDriver = __commonJS({
  "node_modules/typeorm/driver/sqlserver/SqlServerDriver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SqlServerDriver = void 0;
    var ConnectionIsNotSetError_1 = require_ConnectionIsNotSetError();
    var DriverPackageNotInstalledError_1 = require_DriverPackageNotInstalledError();
    var DriverUtils_1 = require_DriverUtils();
    var SqlServerQueryRunner_1 = require_SqlServerQueryRunner();
    var DateUtils_1 = require_DateUtils();
    var PlatformTools_1 = require_PlatformTools();
    var RdbmsSchemaBuilder_1 = require_RdbmsSchemaBuilder();
    var MssqlParameter_1 = require_MssqlParameter();
    var TableColumn_1 = require_TableColumn();
    var OrmUtils_1 = require_OrmUtils();
    var ApplyValueTransformers_1 = require_ApplyValueTransformers();
    var error_1 = require_error();
    var InstanceChecker_1 = require_InstanceChecker();
    var FindOperator_1 = require_FindOperator();
    var SqlServerDriver = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection) {
        this.slaves = [];
        this.isReplicated = false;
        this.treeSupport = true;
        this.transactionSupport = "simple";
        this.supportedDataTypes = [
          "int",
          "bigint",
          "bit",
          "decimal",
          "money",
          "numeric",
          "smallint",
          "smallmoney",
          "tinyint",
          "float",
          "real",
          "date",
          "datetime2",
          "datetime",
          "datetimeoffset",
          "smalldatetime",
          "time",
          "char",
          "varchar",
          "text",
          "nchar",
          "nvarchar",
          "ntext",
          "binary",
          "image",
          "varbinary",
          "hierarchyid",
          "sql_variant",
          "timestamp",
          "uniqueidentifier",
          "xml",
          "geometry",
          "geography",
          "rowversion"
        ];
        this.supportedUpsertTypes = ["merge-into"];
        this.spatialTypes = ["geometry", "geography"];
        this.withLengthColumnTypes = [
          "char",
          "varchar",
          "nchar",
          "nvarchar",
          "binary",
          "varbinary"
        ];
        this.withPrecisionColumnTypes = [
          "decimal",
          "numeric",
          "time",
          "datetime2",
          "datetimeoffset"
        ];
        this.withScaleColumnTypes = ["decimal", "numeric"];
        this.mappedDataTypes = {
          createDate: "datetime2",
          createDateDefault: "getdate()",
          updateDate: "datetime2",
          updateDateDefault: "getdate()",
          deleteDate: "datetime2",
          deleteDateNullable: true,
          version: "int",
          treeLevel: "int",
          migrationId: "int",
          migrationName: "varchar",
          migrationTimestamp: "bigint",
          cacheId: "int",
          cacheIdentifier: "nvarchar",
          cacheTime: "bigint",
          cacheDuration: "int",
          cacheQuery: "nvarchar(MAX)",
          cacheResult: "nvarchar(MAX)",
          metadataType: "varchar",
          metadataDatabase: "varchar",
          metadataSchema: "varchar",
          metadataTable: "varchar",
          metadataName: "varchar",
          metadataValue: "nvarchar(MAX)"
        };
        this.parametersPrefix = "@";
        this.dataTypeDefaults = {
          char: { length: 1 },
          nchar: { length: 1 },
          varchar: { length: 255 },
          nvarchar: { length: 255 },
          binary: { length: 1 },
          varbinary: { length: 1 },
          decimal: { precision: 18, scale: 0 },
          numeric: { precision: 18, scale: 0 },
          time: { precision: 7 },
          datetime2: { precision: 7 },
          datetimeoffset: { precision: 7 }
        };
        this.cteCapabilities = {
          enabled: true,
          // todo: enable it for SQL Server - it's partially supported, but there are issues with generation of non-standard OUTPUT clause
          writable: false
        };
        this.maxAliasLength = 128;
        this.connection = connection;
        this.options = connection.options;
        this.isReplicated = this.options.replication ? true : false;
        this.loadDependencies();
        this.database = DriverUtils_1.DriverUtils.buildDriverOptions(this.options.replication ? this.options.replication.master : this.options).database;
        this.schema = DriverUtils_1.DriverUtils.buildDriverOptions(this.options).schema;
      }
      // -------------------------------------------------------------------------
      // Public Implemented Methods
      // -------------------------------------------------------------------------
      /**
       * Performs connection to the database.
       * Based on pooling options, it can either create connection immediately,
       * either create a pool and create connection when needed.
       */
      async connect() {
        if (this.options.replication) {
          this.slaves = await Promise.all(this.options.replication.slaves.map((slave) => {
            return this.createPool(this.options, slave);
          }));
          this.master = await this.createPool(this.options, this.options.replication.master);
        } else {
          this.master = await this.createPool(this.options, this.options);
        }
        if (!this.database || !this.searchSchema) {
          const queryRunner = this.createQueryRunner("master");
          if (!this.database) {
            this.database = await queryRunner.getCurrentDatabase();
          }
          if (!this.searchSchema) {
            this.searchSchema = await queryRunner.getCurrentSchema();
          }
          await queryRunner.release();
        }
        if (!this.schema) {
          this.schema = this.searchSchema;
        }
      }
      /**
       * Makes any action after connection (e.g. create extensions in Postgres driver).
       */
      afterConnect() {
        return Promise.resolve();
      }
      /**
       * Closes connection with the database.
       */
      async disconnect() {
        if (!this.master) {
          throw new ConnectionIsNotSetError_1.ConnectionIsNotSetError("mssql");
        }
        await this.closePool(this.master);
        await Promise.all(this.slaves.map((slave) => this.closePool(slave)));
        this.master = void 0;
        this.slaves = [];
      }
      /**
       * Closes connection pool.
       */
      async closePool(pool) {
        return new Promise((ok, fail) => {
          pool.close((err) => err ? fail(err) : ok());
        });
      }
      /**
       * Creates a schema builder used to build and sync a schema.
       */
      createSchemaBuilder() {
        return new RdbmsSchemaBuilder_1.RdbmsSchemaBuilder(this.connection);
      }
      /**
       * Creates a query runner used to execute database queries.
       */
      createQueryRunner(mode) {
        return new SqlServerQueryRunner_1.SqlServerQueryRunner(this, mode);
      }
      /**
       * Replaces parameters in the given sql with special escaping character
       * and an array of parameter names to be passed to a query.
       */
      escapeQueryWithParameters(sql, parameters, nativeParameters) {
        const escapedParameters = Object.keys(nativeParameters).map((key) => nativeParameters[key]);
        if (!parameters || !Object.keys(parameters).length)
          return [sql, escapedParameters];
        const parameterIndexMap = /* @__PURE__ */ new Map();
        sql = sql.replace(/:(\.\.\.)?([A-Za-z0-9_.]+)/g, (full, isArray, key) => {
          if (!parameters.hasOwnProperty(key)) {
            return full;
          }
          if (parameterIndexMap.has(key)) {
            return this.parametersPrefix + parameterIndexMap.get(key);
          }
          const value = parameters[key];
          if (isArray) {
            return value.map((v) => {
              escapedParameters.push(v);
              return this.createParameter(key, escapedParameters.length - 1);
            }).join(", ");
          }
          if (typeof value === "function") {
            return value();
          }
          escapedParameters.push(value);
          parameterIndexMap.set(key, escapedParameters.length - 1);
          return this.createParameter(key, escapedParameters.length - 1);
        });
        return [sql, escapedParameters];
      }
      /**
       * Escapes a column name.
       */
      escape(columnName) {
        return `"${columnName}"`;
      }
      /**
       * Build full table name with database name, schema name and table name.
       * E.g. myDB.mySchema.myTable
       */
      buildTableName(tableName, schema, database) {
        const tablePath = [tableName];
        if (schema) {
          tablePath.unshift(schema);
        }
        if (database) {
          if (!schema) {
            tablePath.unshift("");
          }
          tablePath.unshift(database);
        }
        return tablePath.join(".");
      }
      /**
       * Parse a target table name or other types and return a normalized table definition.
       */
      parseTableName(target) {
        const driverDatabase = this.database;
        const driverSchema = this.schema;
        if (InstanceChecker_1.InstanceChecker.isTable(target) || InstanceChecker_1.InstanceChecker.isView(target)) {
          const parsed = this.parseTableName(target.name);
          return {
            database: target.database || parsed.database || driverDatabase,
            schema: target.schema || parsed.schema || driverSchema,
            tableName: parsed.tableName
          };
        }
        if (InstanceChecker_1.InstanceChecker.isTableForeignKey(target)) {
          const parsed = this.parseTableName(target.referencedTableName);
          return {
            database: target.referencedDatabase || parsed.database || driverDatabase,
            schema: target.referencedSchema || parsed.schema || driverSchema,
            tableName: parsed.tableName
          };
        }
        if (InstanceChecker_1.InstanceChecker.isEntityMetadata(target)) {
          return {
            database: target.database || driverDatabase,
            schema: target.schema || driverSchema,
            tableName: target.tableName
          };
        }
        const parts = target.split(".");
        if (parts.length === 3) {
          return {
            database: parts[0] || driverDatabase,
            schema: parts[1] || driverSchema,
            tableName: parts[2]
          };
        } else if (parts.length === 2) {
          return {
            database: driverDatabase,
            schema: parts[0],
            tableName: parts[1]
          };
        } else {
          return {
            database: driverDatabase,
            schema: driverSchema,
            tableName: target
          };
        }
      }
      /**
       * Prepares given value to a value to be persisted, based on its column type and metadata.
       */
      preparePersistentValue(value, columnMetadata) {
        if (columnMetadata.transformer)
          value = ApplyValueTransformers_1.ApplyValueTransformers.transformTo(columnMetadata.transformer, value);
        if (value === null || value === void 0)
          return value;
        if (columnMetadata.type === Boolean) {
          return value === true ? 1 : 0;
        } else if (columnMetadata.type === "date") {
          return DateUtils_1.DateUtils.mixedDateToDate(value);
        } else if (columnMetadata.type === "time") {
          return DateUtils_1.DateUtils.mixedTimeToDate(value);
        } else if (columnMetadata.type === "datetime" || columnMetadata.type === "smalldatetime" || columnMetadata.type === Date) {
          return DateUtils_1.DateUtils.mixedDateToDate(value, false, false);
        } else if (columnMetadata.type === "datetime2" || columnMetadata.type === "datetimeoffset") {
          return DateUtils_1.DateUtils.mixedDateToDate(value, false, true);
        } else if (columnMetadata.type === "simple-array") {
          return DateUtils_1.DateUtils.simpleArrayToString(value);
        } else if (columnMetadata.type === "simple-json") {
          return DateUtils_1.DateUtils.simpleJsonToString(value);
        } else if (columnMetadata.type === "simple-enum") {
          return DateUtils_1.DateUtils.simpleEnumToString(value);
        }
        return value;
      }
      /**
       * Prepares given value to a value to be persisted, based on its column type or metadata.
       */
      prepareHydratedValue(value, columnMetadata) {
        if (value === null || value === void 0)
          return columnMetadata.transformer ? ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value) : value;
        if (columnMetadata.type === Boolean) {
          value = value ? true : false;
        } else if (columnMetadata.type === "datetime" || columnMetadata.type === Date || columnMetadata.type === "datetime2" || columnMetadata.type === "smalldatetime" || columnMetadata.type === "datetimeoffset") {
          value = DateUtils_1.DateUtils.normalizeHydratedDate(value);
        } else if (columnMetadata.type === "date") {
          value = DateUtils_1.DateUtils.mixedDateToDateString(value);
        } else if (columnMetadata.type === "time") {
          value = DateUtils_1.DateUtils.mixedTimeToString(value);
        } else if (columnMetadata.type === "simple-array") {
          value = DateUtils_1.DateUtils.stringToSimpleArray(value);
        } else if (columnMetadata.type === "simple-json") {
          value = DateUtils_1.DateUtils.stringToSimpleJson(value);
        } else if (columnMetadata.type === "simple-enum") {
          value = DateUtils_1.DateUtils.stringToSimpleEnum(value, columnMetadata);
        } else if (columnMetadata.type === Number) {
          value = !isNaN(+value) ? parseInt(value) : value;
        }
        if (columnMetadata.transformer)
          value = ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);
        return value;
      }
      /**
       * Creates a database type from a given column metadata.
       */
      normalizeType(column) {
        if (column.type === Number || column.type === "integer") {
          return "int";
        } else if (column.type === String) {
          return "nvarchar";
        } else if (column.type === Date) {
          return "datetime";
        } else if (column.type === Boolean) {
          return "bit";
        } else if (column.type === Buffer) {
          return "binary";
        } else if (column.type === "uuid") {
          return "uniqueidentifier";
        } else if (column.type === "simple-array" || column.type === "simple-json") {
          return "ntext";
        } else if (column.type === "simple-enum") {
          return "nvarchar";
        } else if (column.type === "dec") {
          return "decimal";
        } else if (column.type === "double precision") {
          return "float";
        } else if (column.type === "rowversion") {
          return "timestamp";
        } else {
          return column.type || "";
        }
      }
      /**
       * Normalizes "default" value of the column.
       */
      normalizeDefault(columnMetadata) {
        const defaultValue = columnMetadata.default;
        if (typeof defaultValue === "number") {
          return `${defaultValue}`;
        }
        if (typeof defaultValue === "boolean") {
          return defaultValue ? "1" : "0";
        }
        if (typeof defaultValue === "function") {
          const value = defaultValue();
          if (value.toUpperCase() === "CURRENT_TIMESTAMP") {
            return "getdate()";
          }
          return value;
        }
        if (typeof defaultValue === "string") {
          return `'${defaultValue}'`;
        }
        if (defaultValue === void 0 || defaultValue === null) {
          return void 0;
        }
        return `${defaultValue}`;
      }
      /**
       * Normalizes "isUnique" value of the column.
       */
      normalizeIsUnique(column) {
        return column.entityMetadata.uniques.some((uq) => uq.columns.length === 1 && uq.columns[0] === column);
      }
      /**
       * Returns default column lengths, which is required on column creation.
       */
      getColumnLength(column) {
        if (column.length)
          return column.length.toString();
        if (column.type === "varchar" || column.type === "nvarchar" || column.type === String)
          return "255";
        return "";
      }
      /**
       * Creates column type definition including length, precision and scale
       */
      createFullType(column) {
        if (column.asExpression)
          return "";
        let type = column.type;
        if (this.getColumnLength(column)) {
          type += `(${this.getColumnLength(column)})`;
        } else if (column.precision !== null && column.precision !== void 0 && column.scale !== null && column.scale !== void 0) {
          type += `(${column.precision},${column.scale})`;
        } else if (column.precision !== null && column.precision !== void 0) {
          type += `(${column.precision})`;
        }
        if (column.isArray)
          type += " array";
        return type;
      }
      /**
       * Obtains a new database connection to a master server.
       * Used for replication.
       * If replication is not setup then returns default connection's database connection.
       */
      obtainMasterConnection() {
        if (!this.master) {
          return Promise.reject(new error_1.TypeORMError("Driver not Connected"));
        }
        return Promise.resolve(this.master);
      }
      /**
       * Obtains a new database connection to a slave server.
       * Used for replication.
       * If replication is not setup then returns master (default) connection's database connection.
       */
      obtainSlaveConnection() {
        if (!this.slaves.length)
          return this.obtainMasterConnection();
        const random = Math.floor(Math.random() * this.slaves.length);
        return Promise.resolve(this.slaves[random]);
      }
      /**
       * Creates generated map of values generated or returned by database after INSERT query.
       */
      createGeneratedMap(metadata, insertResult) {
        if (!insertResult)
          return void 0;
        return Object.keys(insertResult).reduce((map, key) => {
          const column = metadata.findColumnWithDatabaseName(key);
          if (column) {
            OrmUtils_1.OrmUtils.mergeDeep(map, column.createValueMap(this.prepareHydratedValue(insertResult[key], column)));
          }
          return map;
        }, {});
      }
      /**
       * Differentiate columns of this table and columns from the given column metadatas columns
       * and returns only changed.
       */
      findChangedColumns(tableColumns, columnMetadatas) {
        return columnMetadatas.filter((columnMetadata) => {
          const tableColumn = tableColumns.find((c) => c.name === columnMetadata.databaseName);
          if (!tableColumn)
            return false;
          const isColumnChanged = tableColumn.name !== columnMetadata.databaseName || this.compareColumnType(tableColumn, columnMetadata) || this.compareColumnLength(tableColumn, columnMetadata) || tableColumn.precision !== columnMetadata.precision || tableColumn.scale !== columnMetadata.scale || // || tableColumn.comment !== columnMetadata.comment || // todo
          tableColumn.isGenerated !== columnMetadata.isGenerated || !tableColumn.isGenerated && this.lowerDefaultValueIfNecessary(this.normalizeDefault(columnMetadata)) !== this.lowerDefaultValueIfNecessary(tableColumn.default) || // we included check for generated here, because generated columns already can have default values
          tableColumn.isPrimary !== columnMetadata.isPrimary || tableColumn.isNullable !== columnMetadata.isNullable || tableColumn.asExpression !== columnMetadata.asExpression || tableColumn.generatedType !== columnMetadata.generatedType || tableColumn.isUnique !== this.normalizeIsUnique(columnMetadata) || tableColumn.enum && columnMetadata.enum && !OrmUtils_1.OrmUtils.isArraysEqual(tableColumn.enum, columnMetadata.enum.map((val) => val + ""));
          return isColumnChanged;
        });
      }
      /**
       * Returns true if driver supports RETURNING / OUTPUT statement.
       */
      isReturningSqlSupported() {
        if (this.options.options && this.options.options.disableOutputReturning) {
          return false;
        }
        return true;
      }
      /**
       * Returns true if driver supports uuid values generation on its own.
       */
      isUUIDGenerationSupported() {
        return true;
      }
      /**
       * Returns true if driver supports fulltext indices.
       */
      isFullTextColumnTypeSupported() {
        return false;
      }
      /**
       * Creates an escaped parameter.
       */
      createParameter(parameterName, index) {
        return this.parametersPrefix + index;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Sql server's parameters needs to be wrapped into special object with type information about this value.
       * This method wraps given value into MssqlParameter based on its column definition.
       */
      parametrizeValue(column, value) {
        if (InstanceChecker_1.InstanceChecker.isMssqlParameter(value))
          return value;
        const normalizedType = this.normalizeType({ type: column.type });
        if (column.length) {
          return new MssqlParameter_1.MssqlParameter(value, normalizedType, column.length);
        } else if (column.precision !== null && column.precision !== void 0 && column.scale !== null && column.scale !== void 0) {
          return new MssqlParameter_1.MssqlParameter(value, normalizedType, column.precision, column.scale);
        } else if (column.precision !== null && column.precision !== void 0) {
          return new MssqlParameter_1.MssqlParameter(value, normalizedType, column.precision);
        } else if (column.scale !== null && column.scale !== void 0) {
          return new MssqlParameter_1.MssqlParameter(value, normalizedType, column.scale);
        }
        return new MssqlParameter_1.MssqlParameter(value, normalizedType);
      }
      /**
       * Recursively wraps values (including those inside FindOperators) into MssqlParameter instances,
       * ensuring correct type metadata is passed to the SQL Server driver.
       *
       * - If the value is a FindOperator containing an array, all elements are individually parametrized.
       * - If the value is a non-raw FindOperator, a transformation is applied to its internal value.
       * - Otherwise, the value is passed directly to parametrizeValue for wrapping.
       *
       * This ensures SQL Server receives properly typed parameters for queries involving operators like
       * In, MoreThan, Between, etc.
       */
      parametrizeValues(column, value) {
        if (value instanceof FindOperator_1.FindOperator) {
          if (value.type !== "raw") {
            value.transformValue({
              to: (v) => this.parametrizeValues(column, v),
              from: (v) => v
            });
          }
          return value;
        }
        return this.parametrizeValue(column, value);
      }
      /**
       * Sql server's parameters needs to be wrapped into special object with type information about this value.
       * This method wraps all values of the given object into MssqlParameter based on their column definitions in the given table.
       */
      parametrizeMap(tablePath, map) {
        if (!this.connection.hasMetadata(tablePath))
          return map;
        const metadata = this.connection.getMetadata(tablePath);
        return Object.keys(map).reduce((newMap, key) => {
          const value = map[key];
          const column = metadata.findColumnWithDatabaseName(key);
          if (!column)
            return value;
          newMap[key] = this.parametrizeValue(column, value);
          return newMap;
        }, {});
      }
      buildTableVariableDeclaration(identifier, columns) {
        const outputColumns = columns.map((column) => {
          return `${this.escape(column.databaseName)} ${this.createFullType(new TableColumn_1.TableColumn({
            name: column.databaseName,
            type: this.normalizeType(column),
            length: column.length,
            isNullable: column.isNullable,
            isArray: column.isArray
          }))}`;
        });
        return `DECLARE ${identifier} TABLE (${outputColumns.join(", ")})`;
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * If driver dependency is not given explicitly, then try to load it via "require".
       */
      loadDependencies() {
        try {
          const mssql = this.options.driver || PlatformTools_1.PlatformTools.load("mssql");
          this.mssql = mssql;
        } catch (e) {
          throw new DriverPackageNotInstalledError_1.DriverPackageNotInstalledError("SQL Server", "mssql");
        }
      }
      compareColumnType(tableColumn, columnMetadata) {
        if (columnMetadata.asExpression)
          return false;
        return tableColumn.type !== this.normalizeType(columnMetadata);
      }
      compareColumnLength(tableColumn, columnMetadata) {
        if (columnMetadata.asExpression)
          return false;
        return tableColumn.length.toUpperCase() !== this.getColumnLength(columnMetadata).toUpperCase();
      }
      lowerDefaultValueIfNecessary(value) {
        if (!value) {
          return value;
        }
        return value.split(`'`).map((v, i) => {
          return i % 2 === 1 ? v : v.toLowerCase();
        }).join(`'`);
      }
      /**
       * Creates a new connection pool for a given database credentials.
       */
      createPool(options, credentials) {
        credentials = Object.assign({}, credentials, DriverUtils_1.DriverUtils.buildDriverOptions(credentials));
        const authentication = !credentials.domain ? credentials.authentication : {
          type: "ntlm",
          options: {
            domain: credentials.domain,
            userName: credentials.username,
            password: credentials.password
          }
        };
        const connectionOptions = Object.assign({}, {
          connectionTimeout: this.options.connectionTimeout,
          requestTimeout: this.options.requestTimeout,
          stream: this.options.stream,
          pool: this.options.pool,
          options: this.options.options
        }, {
          server: credentials.host,
          database: credentials.database,
          port: credentials.port,
          user: credentials.username,
          password: credentials.password,
          authentication
        }, options.extra || {});
        if (!connectionOptions.options) {
          connectionOptions.options = { useUTC: false };
        } else if (!connectionOptions.options.useUTC) {
          Object.assign(connectionOptions.options, { useUTC: false });
        }
        Object.assign(connectionOptions.options, { enableArithAbort: true });
        return new Promise((ok, fail) => {
          const pool = new this.mssql.ConnectionPool(connectionOptions);
          const { logger } = this.connection;
          const poolErrorHandler = options.pool && options.pool.errorHandler || ((error) => logger.log("warn", `MSSQL pool raised an error. ${error}`));
          pool.on("error", poolErrorHandler);
          const connection = pool.connect((err) => {
            if (err)
              return fail(err);
            ok(connection);
          });
        });
      }
    };
    exports2.SqlServerDriver = SqlServerDriver;
  }
});

// node_modules/typeorm/driver/oracle/OracleQueryRunner.js
var require_OracleQueryRunner = __commonJS({
  "node_modules/typeorm/driver/oracle/OracleQueryRunner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OracleQueryRunner = void 0;
    var error_1 = require_error();
    var QueryFailedError_1 = require_QueryFailedError();
    var QueryRunnerAlreadyReleasedError_1 = require_QueryRunnerAlreadyReleasedError();
    var TransactionNotStartedError_1 = require_TransactionNotStartedError();
    var BaseQueryRunner_1 = require_BaseQueryRunner();
    var QueryResult_1 = require_QueryResult();
    var Table_1 = require_Table();
    var TableCheck_1 = require_TableCheck();
    var TableColumn_1 = require_TableColumn();
    var TableForeignKey_1 = require_TableForeignKey();
    var TableIndex_1 = require_TableIndex();
    var TableUnique_1 = require_TableUnique();
    var View_1 = require_View();
    var Broadcaster_1 = require_Broadcaster();
    var BroadcasterResult_1 = require_BroadcasterResult();
    var InstanceChecker_1 = require_InstanceChecker();
    var OrmUtils_1 = require_OrmUtils();
    var Query_1 = require_Query();
    var MetadataTableType_1 = require_MetadataTableType();
    var OracleQueryRunner = class extends BaseQueryRunner_1.BaseQueryRunner {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(driver, mode) {
        super();
        this.driver = driver;
        this.connection = driver.connection;
        this.broadcaster = new Broadcaster_1.Broadcaster(this);
        this.mode = mode;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Creates/uses database connection from the connection pool to perform further operations.
       * Returns obtained database connection.
       */
      connect() {
        if (this.databaseConnection)
          return Promise.resolve(this.databaseConnection);
        if (this.databaseConnectionPromise)
          return this.databaseConnectionPromise;
        if (this.mode === "slave" && this.driver.isReplicated) {
          this.databaseConnectionPromise = this.driver.obtainSlaveConnection().then((connection) => {
            this.databaseConnection = connection;
            return this.databaseConnection;
          });
        } else {
          this.databaseConnectionPromise = this.driver.obtainMasterConnection().then((connection) => {
            this.databaseConnection = connection;
            return this.databaseConnection;
          });
        }
        return this.databaseConnectionPromise;
      }
      /**
       * Releases used database connection.
       * You cannot use query runner methods once its released.
       */
      async release() {
        this.isReleased = true;
        if (!this.databaseConnection) {
          return;
        }
        await this.databaseConnection.close();
      }
      /**
       * Starts transaction.
       */
      async startTransaction(isolationLevel = "READ COMMITTED") {
        if (this.isReleased)
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        if (isolationLevel !== "SERIALIZABLE" && isolationLevel !== "READ COMMITTED") {
          throw new error_1.TypeORMError(`Oracle only supports SERIALIZABLE and READ COMMITTED isolation`);
        }
        this.isTransactionActive = true;
        try {
          await this.broadcaster.broadcast("BeforeTransactionStart");
        } catch (err) {
          this.isTransactionActive = false;
          throw err;
        }
        if (this.transactionDepth === 0) {
          await this.query("SET TRANSACTION ISOLATION LEVEL " + isolationLevel);
        } else {
          await this.query(`SAVEPOINT typeorm_${this.transactionDepth}`);
        }
        this.transactionDepth += 1;
        await this.broadcaster.broadcast("AfterTransactionStart");
      }
      /**
       * Commits transaction.
       * Error will be thrown if transaction was not started.
       */
      async commitTransaction() {
        if (!this.isTransactionActive)
          throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionCommit");
        if (this.transactionDepth === 1) {
          await this.query("COMMIT");
          this.isTransactionActive = false;
        }
        this.transactionDepth -= 1;
        await this.broadcaster.broadcast("AfterTransactionCommit");
      }
      /**
       * Rollbacks transaction.
       * Error will be thrown if transaction was not started.
       */
      async rollbackTransaction() {
        if (!this.isTransactionActive)
          throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionRollback");
        if (this.transactionDepth > 1) {
          await this.query(`ROLLBACK TO SAVEPOINT typeorm_${this.transactionDepth - 1}`);
        } else {
          await this.query("ROLLBACK");
          this.isTransactionActive = false;
        }
        this.transactionDepth -= 1;
        await this.broadcaster.broadcast("AfterTransactionRollback");
      }
      /**
       * Executes a given SQL query.
       */
      async query(query, parameters, useStructuredResult = false) {
        if (this.isReleased)
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        const databaseConnection = await this.connect();
        this.driver.connection.logger.logQuery(query, parameters, this);
        await this.broadcaster.broadcast("BeforeQuery", query, parameters);
        const broadcasterResult = new BroadcasterResult_1.BroadcasterResult();
        const queryStartTime = Date.now();
        try {
          const executionOptions = {
            autoCommit: !this.isTransactionActive,
            outFormat: this.driver.oracle.OUT_FORMAT_OBJECT
          };
          const raw = await databaseConnection.execute(query, parameters || {}, executionOptions);
          const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
          const queryEndTime = Date.now();
          const queryExecutionTime = queryEndTime - queryStartTime;
          this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, raw, void 0);
          if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime)
            this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
          const result = new QueryResult_1.QueryResult();
          result.raw = raw.rows || raw.outBinds || raw.rowsAffected || raw.implicitResults;
          if (raw?.hasOwnProperty("rows") && Array.isArray(raw.rows)) {
            result.records = raw.rows;
          }
          if (raw?.hasOwnProperty("outBinds") && Array.isArray(raw.outBinds)) {
            result.records = raw.outBinds;
          }
          if (raw?.hasOwnProperty("implicitResults") && Array.isArray(raw.implicitResults)) {
            result.records = raw.implicitResults;
          }
          if (raw?.hasOwnProperty("rowsAffected")) {
            result.affected = raw.rowsAffected;
          }
          if (useStructuredResult) {
            return result;
          } else {
            return result.raw;
          }
        } catch (err) {
          this.driver.connection.logger.logQueryError(err, query, parameters, this);
          this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, void 0, void 0, err);
          throw new QueryFailedError_1.QueryFailedError(query, parameters, err);
        } finally {
          await broadcasterResult.wait();
        }
      }
      /**
       * Returns raw data stream.
       */
      async stream(query, parameters, onEnd, onError) {
        if (this.isReleased) {
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        }
        const executionOptions = {
          autoCommit: !this.isTransactionActive,
          outFormat: this.driver.oracle.OUT_FORMAT_OBJECT
        };
        const databaseConnection = await this.connect();
        this.driver.connection.logger.logQuery(query, parameters, this);
        try {
          const stream = databaseConnection.queryStream(query, parameters, executionOptions);
          if (onEnd) {
            stream.on("end", onEnd);
          }
          if (onError) {
            stream.on("error", onError);
          }
          return stream;
        } catch (err) {
          this.driver.connection.logger.logQueryError(err, query, parameters, this);
          throw new QueryFailedError_1.QueryFailedError(query, parameters, err);
        }
      }
      /**
       * Returns all available database names including system databases.
       */
      async getDatabases() {
        return Promise.resolve([]);
      }
      /**
       * Returns all available schema names including system schemas.
       * If database parameter specified, returns schemas of that database.
       */
      async getSchemas(database) {
        return Promise.resolve([]);
      }
      /**
       * Checks if database with the given name exist.
       */
      async hasDatabase(database) {
        try {
          const query = await this.query(`SELECT 1 AS "exists" FROM global_name@"${database}"`);
          return query.length > 0;
        } catch (e) {
          return false;
        }
      }
      /**
       * Loads currently using database
       */
      async getCurrentDatabase() {
        const query = await this.query(`SELECT SYS_CONTEXT('USERENV','DB_NAME') AS "db_name" FROM dual`);
        return query[0]["db_name"];
      }
      /**
       * Checks if schema with the given name exist.
       */
      async hasSchema(schema) {
        return Promise.resolve(false);
      }
      /**
       * Loads currently using database schema
       */
      async getCurrentSchema() {
        const query = await this.query(`SELECT SYS_CONTEXT('USERENV','CURRENT_SCHEMA') AS "schema_name" FROM dual`);
        return query[0]["schema_name"];
      }
      /**
       * Checks if table with the given name exist in the database.
       */
      async hasTable(tableOrName) {
        const { tableName } = this.driver.parseTableName(tableOrName);
        const sql = `SELECT "TABLE_NAME" FROM "USER_TABLES" WHERE "TABLE_NAME" = '${tableName}'`;
        const result = await this.query(sql);
        return result.length ? true : false;
      }
      /**
       * Checks if column with the given name exist in the given table.
       */
      async hasColumn(tableOrName, columnName) {
        const { tableName } = this.driver.parseTableName(tableOrName);
        const sql = `SELECT "COLUMN_NAME" FROM "USER_TAB_COLS" WHERE "TABLE_NAME" = '${tableName}' AND "COLUMN_NAME" = '${columnName}'`;
        const result = await this.query(sql);
        return result.length ? true : false;
      }
      /**
       * Creates a new database.
       */
      async createDatabase(database, ifNotExist) {
        if (ifNotExist) {
          try {
            await this.query(`CREATE DATABASE IF NOT EXISTS "${database}";`);
          } catch (e) {
            if (e.message.includes("ORA-01100: database already mounted")) {
              return;
            }
            throw e;
          }
        } else {
          await this.query(`CREATE DATABASE "${database}"`);
        }
      }
      /**
       * Drops database.
       */
      async dropDatabase(database, ifExist) {
        return Promise.resolve();
      }
      /**
       * Creates a new table schema.
       */
      async createSchema(schemaPath, ifNotExist) {
        throw new error_1.TypeORMError(`Schema create queries are not supported by Oracle driver.`);
      }
      /**
       * Drops table schema.
       */
      async dropSchema(schemaPath, ifExist) {
        throw new error_1.TypeORMError(`Schema drop queries are not supported by Oracle driver.`);
      }
      /**
       * Creates a new table.
       */
      async createTable(table, ifNotExist = false, createForeignKeys = true, createIndices = true) {
        if (ifNotExist) {
          const isTableExist = await this.hasTable(table);
          if (isTableExist)
            return Promise.resolve();
        }
        const upQueries = [];
        const downQueries = [];
        upQueries.push(this.createTableSql(table, createForeignKeys));
        downQueries.push(this.dropTableSql(table));
        if (createForeignKeys)
          table.foreignKeys.forEach((foreignKey) => downQueries.push(this.dropForeignKeySql(table, foreignKey)));
        if (createIndices) {
          table.indices.forEach((index) => {
            if (!index.name)
              index.name = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);
            upQueries.push(this.createIndexSql(table, index));
            downQueries.push(this.dropIndexSql(index));
          });
        }
        const generatedColumns = table.columns.filter((column) => column.generatedType && column.asExpression);
        for (const column of generatedColumns) {
          const insertQuery = this.insertTypeormMetadataSql({
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name,
            value: column.asExpression
          });
          const deleteQuery = this.deleteTypeormMetadataSql({
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name
          });
          upQueries.push(insertQuery);
          downQueries.push(deleteQuery);
        }
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Drops the table.
       */
      async dropTable(tableOrName, ifExist, dropForeignKeys = true, dropIndices = true) {
        if (ifExist) {
          const isTableExist = await this.hasTable(tableOrName);
          if (!isTableExist)
            return Promise.resolve();
        }
        const createForeignKeys = dropForeignKeys;
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const upQueries = [];
        const downQueries = [];
        if (dropIndices) {
          table.indices.forEach((index) => {
            upQueries.push(this.dropIndexSql(index));
            downQueries.push(this.createIndexSql(table, index));
          });
        }
        if (dropForeignKeys)
          table.foreignKeys.forEach((foreignKey) => upQueries.push(this.dropForeignKeySql(table, foreignKey)));
        upQueries.push(this.dropTableSql(table));
        downQueries.push(this.createTableSql(table, createForeignKeys));
        const generatedColumns = table.columns.filter((column) => column.generatedType && column.asExpression);
        for (const column of generatedColumns) {
          const deleteQuery = this.deleteTypeormMetadataSql({
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name
          });
          const insertQuery = this.insertTypeormMetadataSql({
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name,
            value: column.asExpression
          });
          upQueries.push(deleteQuery);
          downQueries.push(insertQuery);
        }
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Creates a new view.
       */
      async createView(view, syncWithMetadata = false) {
        const upQueries = [];
        const downQueries = [];
        upQueries.push(this.createViewSql(view));
        if (syncWithMetadata)
          upQueries.push(this.insertViewDefinitionSql(view));
        downQueries.push(this.dropViewSql(view));
        if (syncWithMetadata)
          downQueries.push(this.deleteViewDefinitionSql(view));
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Drops the view.
       */
      async dropView(target) {
        const viewName = InstanceChecker_1.InstanceChecker.isView(target) ? target.name : target;
        const view = await this.getCachedView(viewName);
        const upQueries = [];
        const downQueries = [];
        upQueries.push(this.deleteViewDefinitionSql(view));
        upQueries.push(this.dropViewSql(view));
        downQueries.push(this.insertViewDefinitionSql(view));
        downQueries.push(this.createViewSql(view));
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Renames the given table.
       */
      async renameTable(oldTableOrName, newTableName) {
        const upQueries = [];
        const downQueries = [];
        const oldTable = InstanceChecker_1.InstanceChecker.isTable(oldTableOrName) ? oldTableOrName : await this.getCachedTable(oldTableOrName);
        const newTable = oldTable.clone();
        const { database: dbName, tableName: oldTableName } = this.driver.parseTableName(oldTable);
        newTable.name = dbName ? `${dbName}.${newTableName}` : newTableName;
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(oldTable)} RENAME TO "${newTableName}"`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME TO "${oldTableName}"`));
        if (newTable.primaryColumns.length > 0 && !newTable.primaryColumns[0].primaryKeyConstraintName) {
          const columnNames = newTable.primaryColumns.map((column) => column.name);
          const oldPkName = this.connection.namingStrategy.primaryKeyName(oldTable, columnNames);
          const newPkName = this.connection.namingStrategy.primaryKeyName(newTable, columnNames);
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${oldPkName}" TO "${newPkName}"`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${newPkName}" TO "${oldPkName}"`));
        }
        newTable.uniques.forEach((unique) => {
          const oldUniqueName = this.connection.namingStrategy.uniqueConstraintName(oldTable, unique.columnNames);
          if (unique.name !== oldUniqueName)
            return;
          const newUniqueName = this.connection.namingStrategy.uniqueConstraintName(newTable, unique.columnNames);
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${unique.name}" TO "${newUniqueName}"`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${newUniqueName}" TO "${unique.name}"`));
          unique.name = newUniqueName;
        });
        newTable.indices.forEach((index) => {
          const oldIndexName = this.connection.namingStrategy.indexName(oldTable, index.columnNames, index.where);
          if (index.name !== oldIndexName)
            return;
          const newIndexName = this.connection.namingStrategy.indexName(newTable, index.columnNames, index.where);
          upQueries.push(new Query_1.Query(`ALTER INDEX "${index.name}" RENAME TO "${newIndexName}"`));
          downQueries.push(new Query_1.Query(`ALTER INDEX "${newIndexName}" RENAME TO "${index.name}"`));
          index.name = newIndexName;
        });
        newTable.foreignKeys.forEach((foreignKey) => {
          const oldForeignKeyName = this.connection.namingStrategy.foreignKeyName(oldTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
          if (foreignKey.name !== oldForeignKeyName)
            return;
          const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(newTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${foreignKey.name}" TO "${newForeignKeyName}"`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${newForeignKeyName}" TO "${foreignKey.name}"`));
          foreignKey.name = newForeignKeyName;
        });
        await this.executeQueries(upQueries, downQueries);
        oldTable.name = newTable.name;
        this.replaceCachedTable(oldTable, newTable);
      }
      /**
       * Creates a new column from the column in the table.
       */
      async addColumn(tableOrName, column) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(column)}`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN "${column.name}"`));
        if (column.isPrimary) {
          const primaryColumns = clonedTable.primaryColumns;
          if (primaryColumns.length > 0) {
            const pkName2 = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column2) => column2.name));
            const columnNames2 = primaryColumns.map((column2) => `"${column2.name}"`).join(", ");
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName2}"`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName2}" PRIMARY KEY (${columnNames2})`));
          }
          primaryColumns.push(column);
          const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column2) => column2.name));
          const columnNames = primaryColumns.map((column2) => `"${column2.name}"`).join(", ");
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
        }
        const columnIndex = clonedTable.indices.find((index) => index.columnNames.length === 1 && index.columnNames[0] === column.name);
        if (columnIndex) {
          clonedTable.indices.splice(clonedTable.indices.indexOf(columnIndex), 1);
          upQueries.push(this.createIndexSql(table, columnIndex));
          downQueries.push(this.dropIndexSql(columnIndex));
        }
        if (column.isUnique) {
          const uniqueConstraint = new TableUnique_1.TableUnique({
            name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),
            columnNames: [column.name]
          });
          clonedTable.uniques.push(uniqueConstraint);
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${uniqueConstraint.name}" UNIQUE ("${column.name}")`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${uniqueConstraint.name}"`));
        }
        if (column.generatedType && column.asExpression) {
          const insertQuery = this.insertTypeormMetadataSql({
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name,
            value: column.asExpression
          });
          const deleteQuery = this.deleteTypeormMetadataSql({
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name
          });
          upQueries.push(insertQuery);
          downQueries.push(deleteQuery);
        }
        await this.executeQueries(upQueries, downQueries);
        clonedTable.addColumn(column);
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Creates a new columns from the column in the table.
       */
      async addColumns(tableOrName, columns) {
        for (const column of columns) {
          await this.addColumn(tableOrName, column);
        }
      }
      /**
       * Renames column in the given table.
       */
      async renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const oldColumn = InstanceChecker_1.InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find((c) => c.name === oldTableColumnOrName);
        if (!oldColumn)
          throw new error_1.TypeORMError(`Column "${oldTableColumnOrName}" was not found in the ${this.escapePath(table)} table.`);
        let newColumn = void 0;
        if (InstanceChecker_1.InstanceChecker.isTableColumn(newTableColumnOrName)) {
          newColumn = newTableColumnOrName;
        } else {
          newColumn = oldColumn.clone();
          newColumn.name = newTableColumnOrName;
        }
        await this.changeColumn(table, oldColumn, newColumn);
      }
      /**
       * Changes a column in the table.
       */
      async changeColumn(tableOrName, oldTableColumnOrName, newColumn) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        let clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        const oldColumn = InstanceChecker_1.InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find((column) => column.name === oldTableColumnOrName);
        if (!oldColumn)
          throw new error_1.TypeORMError(`Column "${oldTableColumnOrName}" was not found in the ${this.escapePath(table)} table.`);
        if (newColumn.isGenerated !== oldColumn.isGenerated && newColumn.generationStrategy !== "uuid" || oldColumn.type !== newColumn.type || oldColumn.length !== newColumn.length || oldColumn.generatedType !== newColumn.generatedType || oldColumn.asExpression !== newColumn.asExpression) {
          await this.dropColumn(table, oldColumn);
          await this.addColumn(table, newColumn);
          clonedTable = table.clone();
        } else {
          if (newColumn.name !== oldColumn.name) {
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME COLUMN "${oldColumn.name}" TO "${newColumn.name}"`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME COLUMN "${newColumn.name}" TO "${oldColumn.name}"`));
            if (oldColumn.isPrimary === true && !oldColumn.primaryKeyConstraintName) {
              const primaryColumns = clonedTable.primaryColumns;
              const columnNames = primaryColumns.map((column) => column.name);
              const oldPkName = this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);
              columnNames.splice(columnNames.indexOf(oldColumn.name), 1);
              columnNames.push(newColumn.name);
              const newPkName = this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${oldPkName}" TO "${newPkName}"`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${newPkName}" TO "${oldPkName}"`));
            }
            clonedTable.findColumnUniques(oldColumn).forEach((unique) => {
              const oldUniqueName = this.connection.namingStrategy.uniqueConstraintName(clonedTable, unique.columnNames);
              if (unique.name !== oldUniqueName)
                return;
              unique.columnNames.splice(unique.columnNames.indexOf(oldColumn.name), 1);
              unique.columnNames.push(newColumn.name);
              const newUniqueName = this.connection.namingStrategy.uniqueConstraintName(clonedTable, unique.columnNames);
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${unique.name}" TO "${newUniqueName}"`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${newUniqueName}" TO "${unique.name}"`));
              unique.name = newUniqueName;
            });
            clonedTable.findColumnIndices(oldColumn).forEach((index) => {
              const oldIndexName = this.connection.namingStrategy.indexName(clonedTable, index.columnNames, index.where);
              if (index.name !== oldIndexName)
                return;
              index.columnNames.splice(index.columnNames.indexOf(oldColumn.name), 1);
              index.columnNames.push(newColumn.name);
              const newIndexName = this.connection.namingStrategy.indexName(clonedTable, index.columnNames, index.where);
              upQueries.push(new Query_1.Query(`ALTER INDEX "${index.name}" RENAME TO "${newIndexName}"`));
              downQueries.push(new Query_1.Query(`ALTER INDEX "${newIndexName}" RENAME TO "${index.name}"`));
              index.name = newIndexName;
            });
            clonedTable.findColumnForeignKeys(oldColumn).forEach((foreignKey) => {
              const foreignKeyName = this.connection.namingStrategy.foreignKeyName(clonedTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
              if (foreignKey.name !== foreignKeyName)
                return;
              foreignKey.columnNames.splice(foreignKey.columnNames.indexOf(oldColumn.name), 1);
              foreignKey.columnNames.push(newColumn.name);
              const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(clonedTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${foreignKey.name}" TO "${newForeignKeyName}"`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${newForeignKeyName}" TO "${foreignKey.name}"`));
              foreignKey.name = newForeignKeyName;
            });
            const oldTableColumn = clonedTable.columns.find((column) => column.name === oldColumn.name);
            clonedTable.columns[clonedTable.columns.indexOf(oldTableColumn)].name = newColumn.name;
            oldColumn.name = newColumn.name;
          }
          if (this.isColumnChanged(oldColumn, newColumn, true)) {
            let defaultUp = "";
            let defaultDown = "";
            let nullableUp = "";
            let nullableDown = "";
            if (newColumn.default !== null && newColumn.default !== void 0) {
              defaultUp = `DEFAULT ${newColumn.default}`;
              if (oldColumn.default !== null && oldColumn.default !== void 0) {
                defaultDown = `DEFAULT ${oldColumn.default}`;
              } else {
                defaultDown = "DEFAULT NULL";
              }
            } else if (oldColumn.default !== null && oldColumn.default !== void 0) {
              defaultUp = "DEFAULT NULL";
              defaultDown = `DEFAULT ${oldColumn.default}`;
            }
            if (newColumn.isNullable !== oldColumn.isNullable) {
              if (newColumn.isNullable === true) {
                nullableUp = "NULL";
                nullableDown = "NOT NULL";
              } else {
                nullableUp = "NOT NULL";
                nullableDown = "NULL";
              }
            }
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} MODIFY "${oldColumn.name}" ${this.connection.driver.createFullType(newColumn)} ${defaultUp} ${nullableUp}`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} MODIFY "${oldColumn.name}" ${this.connection.driver.createFullType(oldColumn)} ${defaultDown} ${nullableDown}`));
          }
          if (newColumn.isPrimary !== oldColumn.isPrimary) {
            const primaryColumns = clonedTable.primaryColumns;
            if (primaryColumns.length > 0) {
              const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column) => column.name));
              const columnNames = primaryColumns.map((column) => `"${column.name}"`).join(", ");
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
            }
            if (newColumn.isPrimary === true) {
              primaryColumns.push(newColumn);
              const column = clonedTable.columns.find((column2) => column2.name === newColumn.name);
              column.isPrimary = true;
              const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column2) => column2.name));
              const columnNames = primaryColumns.map((column2) => `"${column2.name}"`).join(", ");
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
            } else {
              const primaryColumn = primaryColumns.find((c) => c.name === newColumn.name);
              primaryColumns.splice(primaryColumns.indexOf(primaryColumn), 1);
              const column = clonedTable.columns.find((column2) => column2.name === newColumn.name);
              column.isPrimary = false;
              if (primaryColumns.length > 0) {
                const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column2) => column2.name));
                const columnNames = primaryColumns.map((column2) => `"${column2.name}"`).join(", ");
                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
              }
            }
          }
          if (newColumn.isUnique !== oldColumn.isUnique) {
            if (newColumn.isUnique === true) {
              const uniqueConstraint = new TableUnique_1.TableUnique({
                name: this.connection.namingStrategy.uniqueConstraintName(table, [newColumn.name]),
                columnNames: [newColumn.name]
              });
              clonedTable.uniques.push(uniqueConstraint);
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${uniqueConstraint.name}" UNIQUE ("${newColumn.name}")`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${uniqueConstraint.name}"`));
            } else {
              const uniqueConstraint = clonedTable.uniques.find((unique) => {
                return unique.columnNames.length === 1 && !!unique.columnNames.find((columnName) => columnName === newColumn.name);
              });
              clonedTable.uniques.splice(clonedTable.uniques.indexOf(uniqueConstraint), 1);
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${uniqueConstraint.name}"`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${uniqueConstraint.name}" UNIQUE ("${newColumn.name}")`));
            }
          }
          await this.executeQueries(upQueries, downQueries);
          this.replaceCachedTable(table, clonedTable);
        }
      }
      /**
       * Changes a column in the table.
       */
      async changeColumns(tableOrName, changedColumns) {
        for (const { oldColumn, newColumn } of changedColumns) {
          await this.changeColumn(tableOrName, oldColumn, newColumn);
        }
      }
      /**
       * Drops column in the table.
       */
      async dropColumn(tableOrName, columnOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const column = InstanceChecker_1.InstanceChecker.isTableColumn(columnOrName) ? columnOrName : table.findColumnByName(columnOrName);
        if (!column)
          throw new error_1.TypeORMError(`Column "${columnOrName}" was not found in table ${this.escapePath(table)}`);
        const clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        if (column.isPrimary) {
          const pkName = column.primaryKeyConstraintName ? column.primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, clonedTable.primaryColumns.map((column2) => column2.name));
          const columnNames = clonedTable.primaryColumns.map((primaryColumn) => `"${primaryColumn.name}"`).join(", ");
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP CONSTRAINT "${pkName}"`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
          const tableColumn = clonedTable.findColumnByName(column.name);
          tableColumn.isPrimary = false;
          if (clonedTable.primaryColumns.length > 0) {
            const pkName2 = clonedTable.primaryColumns[0].primaryKeyConstraintName ? clonedTable.primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, clonedTable.primaryColumns.map((column2) => column2.name));
            const columnNames2 = clonedTable.primaryColumns.map((primaryColumn) => `"${primaryColumn.name}"`).join(", ");
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD CONSTRAINT "${pkName2}" PRIMARY KEY (${columnNames2})`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP CONSTRAINT "${pkName2}"`));
          }
        }
        const columnIndex = clonedTable.indices.find((index) => index.columnNames.length === 1 && index.columnNames[0] === column.name);
        if (columnIndex) {
          upQueries.push(this.dropIndexSql(columnIndex));
          downQueries.push(this.createIndexSql(table, columnIndex));
        }
        const columnCheck = clonedTable.checks.find((check) => !!check.columnNames && check.columnNames.length === 1 && check.columnNames[0] === column.name);
        if (columnCheck) {
          clonedTable.checks.splice(clonedTable.checks.indexOf(columnCheck), 1);
          upQueries.push(this.dropCheckConstraintSql(table, columnCheck));
          downQueries.push(this.createCheckConstraintSql(table, columnCheck));
        }
        const columnUnique = clonedTable.uniques.find((unique) => unique.columnNames.length === 1 && unique.columnNames[0] === column.name);
        if (columnUnique) {
          clonedTable.uniques.splice(clonedTable.uniques.indexOf(columnUnique), 1);
          upQueries.push(this.dropUniqueConstraintSql(table, columnUnique));
          downQueries.push(this.createUniqueConstraintSql(table, columnUnique));
        }
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN "${column.name}"`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(column)}`));
        if (column.generatedType && column.asExpression) {
          const deleteQuery = this.deleteTypeormMetadataSql({
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name
          });
          const insertQuery = this.insertTypeormMetadataSql({
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name,
            value: column.asExpression
          });
          upQueries.push(deleteQuery);
          downQueries.push(insertQuery);
        }
        await this.executeQueries(upQueries, downQueries);
        clonedTable.removeColumn(column);
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Drops the columns in the table.
       */
      async dropColumns(tableOrName, columns) {
        for (const column of [...columns]) {
          await this.dropColumn(tableOrName, column);
        }
      }
      /**
       * Creates a new primary key.
       */
      async createPrimaryKey(tableOrName, columnNames, constraintName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const clonedTable = table.clone();
        const up = this.createPrimaryKeySql(table, columnNames, constraintName);
        clonedTable.columns.forEach((column) => {
          if (columnNames.find((columnName) => columnName === column.name))
            column.isPrimary = true;
        });
        const down = this.dropPrimaryKeySql(clonedTable);
        await this.executeQueries(up, down);
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Updates composite primary keys.
       */
      async updatePrimaryKeys(tableOrName, columns) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const columnNames = columns.map((column) => column.name);
        const clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        const primaryColumns = clonedTable.primaryColumns;
        if (primaryColumns.length > 0) {
          const pkName2 = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column) => column.name));
          const columnNamesString2 = primaryColumns.map((column) => `"${column.name}"`).join(", ");
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName2}"`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName2}" PRIMARY KEY (${columnNamesString2})`));
        }
        clonedTable.columns.filter((column) => columnNames.indexOf(column.name) !== -1).forEach((column) => column.isPrimary = true);
        const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);
        const columnNamesString = columnNames.map((columnName) => `"${columnName}"`).join(", ");
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNamesString})`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
        await this.executeQueries(upQueries, downQueries);
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Drops a primary key.
       */
      async dropPrimaryKey(tableOrName, constraintName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const up = this.dropPrimaryKeySql(table);
        const down = this.createPrimaryKeySql(table, table.primaryColumns.map((column) => column.name), constraintName);
        await this.executeQueries(up, down);
        table.primaryColumns.forEach((column) => {
          column.isPrimary = false;
        });
      }
      /**
       * Creates a new unique constraint.
       */
      async createUniqueConstraint(tableOrName, uniqueConstraint) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        if (!uniqueConstraint.name)
          uniqueConstraint.name = this.connection.namingStrategy.uniqueConstraintName(table, uniqueConstraint.columnNames);
        const up = this.createUniqueConstraintSql(table, uniqueConstraint);
        const down = this.dropUniqueConstraintSql(table, uniqueConstraint);
        await this.executeQueries(up, down);
        table.addUniqueConstraint(uniqueConstraint);
      }
      /**
       * Creates a new unique constraints.
       */
      async createUniqueConstraints(tableOrName, uniqueConstraints) {
        const promises = uniqueConstraints.map((uniqueConstraint) => this.createUniqueConstraint(tableOrName, uniqueConstraint));
        await Promise.all(promises);
      }
      /**
       * Drops an unique constraint.
       */
      async dropUniqueConstraint(tableOrName, uniqueOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const uniqueConstraint = InstanceChecker_1.InstanceChecker.isTableUnique(uniqueOrName) ? uniqueOrName : table.uniques.find((u) => u.name === uniqueOrName);
        if (!uniqueConstraint)
          throw new error_1.TypeORMError(`Supplied unique constraint was not found in table ${table.name}`);
        const up = this.dropUniqueConstraintSql(table, uniqueConstraint);
        const down = this.createUniqueConstraintSql(table, uniqueConstraint);
        await this.executeQueries(up, down);
        table.removeUniqueConstraint(uniqueConstraint);
      }
      /**
       * Creates an unique constraints.
       */
      async dropUniqueConstraints(tableOrName, uniqueConstraints) {
        const promises = uniqueConstraints.map((uniqueConstraint) => this.dropUniqueConstraint(tableOrName, uniqueConstraint));
        await Promise.all(promises);
      }
      /**
       * Creates new check constraint.
       */
      async createCheckConstraint(tableOrName, checkConstraint) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        if (!checkConstraint.name)
          checkConstraint.name = this.connection.namingStrategy.checkConstraintName(table, checkConstraint.expression);
        const up = this.createCheckConstraintSql(table, checkConstraint);
        const down = this.dropCheckConstraintSql(table, checkConstraint);
        await this.executeQueries(up, down);
        table.addCheckConstraint(checkConstraint);
      }
      /**
       * Creates new check constraints.
       */
      async createCheckConstraints(tableOrName, checkConstraints) {
        const promises = checkConstraints.map((checkConstraint) => this.createCheckConstraint(tableOrName, checkConstraint));
        await Promise.all(promises);
      }
      /**
       * Drops check constraint.
       */
      async dropCheckConstraint(tableOrName, checkOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const checkConstraint = InstanceChecker_1.InstanceChecker.isTableCheck(checkOrName) ? checkOrName : table.checks.find((c) => c.name === checkOrName);
        if (!checkConstraint)
          throw new error_1.TypeORMError(`Supplied check constraint was not found in table ${table.name}`);
        const up = this.dropCheckConstraintSql(table, checkConstraint);
        const down = this.createCheckConstraintSql(table, checkConstraint);
        await this.executeQueries(up, down);
        table.removeCheckConstraint(checkConstraint);
      }
      /**
       * Drops check constraints.
       */
      async dropCheckConstraints(tableOrName, checkConstraints) {
        const promises = checkConstraints.map((checkConstraint) => this.dropCheckConstraint(tableOrName, checkConstraint));
        await Promise.all(promises);
      }
      /**
       * Creates a new exclusion constraint.
       */
      async createExclusionConstraint(tableOrName, exclusionConstraint) {
        throw new error_1.TypeORMError(`Oracle does not support exclusion constraints.`);
      }
      /**
       * Creates a new exclusion constraints.
       */
      async createExclusionConstraints(tableOrName, exclusionConstraints) {
        throw new error_1.TypeORMError(`Oracle does not support exclusion constraints.`);
      }
      /**
       * Drops exclusion constraint.
       */
      async dropExclusionConstraint(tableOrName, exclusionOrName) {
        throw new error_1.TypeORMError(`Oracle does not support exclusion constraints.`);
      }
      /**
       * Drops exclusion constraints.
       */
      async dropExclusionConstraints(tableOrName, exclusionConstraints) {
        throw new error_1.TypeORMError(`Oracle does not support exclusion constraints.`);
      }
      /**
       * Creates a new foreign key.
       */
      async createForeignKey(tableOrName, foreignKey) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        if (!foreignKey.name)
          foreignKey.name = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
        const up = this.createForeignKeySql(table, foreignKey);
        const down = this.dropForeignKeySql(table, foreignKey);
        await this.executeQueries(up, down);
        table.addForeignKey(foreignKey);
      }
      /**
       * Creates a new foreign keys.
       */
      async createForeignKeys(tableOrName, foreignKeys) {
        const promises = foreignKeys.map((foreignKey) => this.createForeignKey(tableOrName, foreignKey));
        await Promise.all(promises);
      }
      /**
       * Drops a foreign key from the table.
       */
      async dropForeignKey(tableOrName, foreignKeyOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const foreignKey = InstanceChecker_1.InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName : table.foreignKeys.find((fk) => fk.name === foreignKeyOrName);
        if (!foreignKey)
          throw new error_1.TypeORMError(`Supplied foreign key was not found in table ${table.name}`);
        const up = this.dropForeignKeySql(table, foreignKey);
        const down = this.createForeignKeySql(table, foreignKey);
        await this.executeQueries(up, down);
        table.removeForeignKey(foreignKey);
      }
      /**
       * Drops a foreign keys from the table.
       */
      async dropForeignKeys(tableOrName, foreignKeys) {
        const promises = foreignKeys.map((foreignKey) => this.dropForeignKey(tableOrName, foreignKey));
        await Promise.all(promises);
      }
      /**
       * Creates a new index.
       */
      async createIndex(tableOrName, index) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        if (!index.name)
          index.name = this.generateIndexName(table, index);
        const up = this.createIndexSql(table, index);
        const down = this.dropIndexSql(index);
        await this.executeQueries(up, down);
        table.addIndex(index);
      }
      /**
       * Creates a new indices
       */
      async createIndices(tableOrName, indices) {
        const promises = indices.map((index) => this.createIndex(tableOrName, index));
        await Promise.all(promises);
      }
      /**
       * Drops an index from the table.
       */
      async dropIndex(tableOrName, indexOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const index = InstanceChecker_1.InstanceChecker.isTableIndex(indexOrName) ? indexOrName : table.indices.find((i) => i.name === indexOrName);
        if (!index)
          throw new error_1.TypeORMError(`Supplied index ${indexOrName} was not found in table ${table.name}`);
        if (!index.name)
          index.name = this.generateIndexName(table, index);
        const up = this.dropIndexSql(index);
        const down = this.createIndexSql(table, index);
        await this.executeQueries(up, down);
        table.removeIndex(index);
      }
      /**
       * Drops an indices from the table.
       */
      async dropIndices(tableOrName, indices) {
        const promises = indices.map((index) => this.dropIndex(tableOrName, index));
        await Promise.all(promises);
      }
      /**
       * Clears all table contents.
       * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.
       */
      async clearTable(tableName) {
        await this.query(`TRUNCATE TABLE ${this.escapePath(tableName)}`);
      }
      /**
       * Removes all tables from the currently connected database.
       */
      async clearDatabase() {
        const isAnotherTransactionActive = this.isTransactionActive;
        if (!isAnotherTransactionActive)
          await this.startTransaction();
        try {
          const dropViewsQuery = `SELECT 'DROP VIEW "' || VIEW_NAME || '"' AS "query" FROM "USER_VIEWS"`;
          const dropViewQueries = await this.query(dropViewsQuery);
          await Promise.all(dropViewQueries.map((query) => this.query(query["query"])));
          const dropMatViewsQuery = `SELECT 'DROP MATERIALIZED VIEW "' || MVIEW_NAME || '"' AS "query" FROM "USER_MVIEWS"`;
          const dropMatViewQueries = await this.query(dropMatViewsQuery);
          await Promise.all(dropMatViewQueries.map((query) => this.query(query["query"])));
          const dropTablesQuery = `SELECT 'DROP TABLE "' || TABLE_NAME || '" CASCADE CONSTRAINTS' AS "query" FROM "USER_TABLES"`;
          const dropTableQueries = await this.query(dropTablesQuery);
          await Promise.all(dropTableQueries.map((query) => this.query(query["query"])));
          if (!isAnotherTransactionActive)
            await this.commitTransaction();
        } catch (error) {
          try {
            if (!isAnotherTransactionActive)
              await this.rollbackTransaction();
          } catch (rollbackError) {
          }
          throw error;
        }
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      async loadViews(viewNames) {
        const hasTable = await this.hasTable(this.getTypeormMetadataTableName());
        if (!hasTable) {
          return [];
        }
        if (!viewNames) {
          viewNames = [];
        }
        const currentDatabase = await this.getCurrentDatabase();
        const currentSchema = await this.getCurrentSchema();
        const viewsCondition = viewNames.map((viewName) => this.driver.parseTableName(viewName)).map(({ schema, tableName }) => {
          if (!schema) {
            schema = this.driver.options.schema || currentSchema;
          }
          return `("T"."schema" = '${schema}' AND "T"."name" = '${tableName}')`;
        }).join(" OR ");
        let query = `SELECT "T".* FROM ${this.escapePath(this.getTypeormMetadataTableName())} "T" INNER JOIN "USER_OBJECTS" "O" ON "O"."OBJECT_NAME" = "T"."name" AND "O"."OBJECT_TYPE" IN ( 'MATERIALIZED VIEW', 'VIEW' ) WHERE "T"."type" IN ('${MetadataTableType_1.MetadataTableType.MATERIALIZED_VIEW}', '${MetadataTableType_1.MetadataTableType.VIEW}')`;
        if (viewsCondition.length > 0)
          query += ` AND ${viewsCondition}`;
        const dbViews = await this.query(query);
        return dbViews.map((dbView) => {
          const parsedName = this.driver.parseTableName(dbView["name"]);
          const view = new View_1.View();
          view.database = parsedName.database || dbView["database"] || currentDatabase;
          view.schema = parsedName.schema || dbView["schema"] || currentSchema;
          view.name = parsedName.tableName;
          view.expression = dbView["value"];
          view.materialized = dbView["type"] === MetadataTableType_1.MetadataTableType.MATERIALIZED_VIEW;
          return view;
        });
      }
      /**
       * Loads all tables (with given names) from the database and creates a Table from them.
       */
      async loadTables(tableNames) {
        if (tableNames && tableNames.length === 0) {
          return [];
        }
        const dbTables = [];
        const currentSchema = await this.getCurrentSchema();
        const currentDatabase = await this.getCurrentDatabase();
        if (!tableNames) {
          const tablesSql = `SELECT "TABLE_NAME", "OWNER" FROM "ALL_TABLES"`;
          dbTables.push(...await this.query(tablesSql));
        } else {
          const tablesCondition = tableNames.map((tableName) => {
            const parts = tableName.split(".");
            if (parts.length >= 3) {
              const [, schema, name] = parts;
              return `("OWNER" = '${schema}' AND "TABLE_NAME" = '${name}')`;
            } else if (parts.length === 2) {
              const [schema, name] = parts;
              return `("OWNER" = '${schema}' AND "TABLE_NAME" = '${name}')`;
            } else if (parts.length === 1) {
              const [name] = parts;
              return `("TABLE_NAME" = '${name}')`;
            } else {
              return `(1=0)`;
            }
          }).join(" OR ");
          const tablesSql = `SELECT "TABLE_NAME", "OWNER" FROM "ALL_TABLES" WHERE ${tablesCondition}`;
          dbTables.push(...await this.query(tablesSql));
        }
        if (dbTables.length === 0) {
          return [];
        }
        const columnsCondition = dbTables.map(({ TABLE_NAME, OWNER }) => {
          return `("C"."OWNER" = '${OWNER}' AND "C"."TABLE_NAME" = '${TABLE_NAME}')`;
        }).join(" OR ");
        const columnsSql = `SELECT * FROM "ALL_TAB_COLS" "C" WHERE (${columnsCondition})`;
        const indicesSql = `SELECT "C"."INDEX_NAME", "C"."OWNER", "C"."TABLE_NAME", "C"."UNIQUENESS", LISTAGG ("COL"."COLUMN_NAME", ',') WITHIN GROUP (ORDER BY "COL"."COLUMN_NAME") AS "COLUMN_NAMES" FROM "ALL_INDEXES" "C" INNER JOIN "ALL_IND_COLUMNS" "COL" ON "COL"."INDEX_OWNER" = "C"."OWNER" AND "COL"."INDEX_NAME" = "C"."INDEX_NAME" LEFT JOIN "ALL_CONSTRAINTS" "CON" ON "CON"."OWNER" = "C"."OWNER" AND "CON"."CONSTRAINT_NAME" = "C"."INDEX_NAME" WHERE (${columnsCondition}) AND "CON"."CONSTRAINT_NAME" IS NULL GROUP BY "C"."INDEX_NAME", "C"."OWNER", "C"."TABLE_NAME", "C"."UNIQUENESS"`;
        const foreignKeysSql = `SELECT "C"."CONSTRAINT_NAME", "C"."OWNER", "C"."TABLE_NAME", "COL"."COLUMN_NAME", "REF_COL"."TABLE_NAME" AS "REFERENCED_TABLE_NAME", "REF_COL"."COLUMN_NAME" AS "REFERENCED_COLUMN_NAME", "C"."DELETE_RULE" AS "ON_DELETE" FROM "ALL_CONSTRAINTS" "C" INNER JOIN "ALL_CONS_COLUMNS" "COL" ON "COL"."OWNER" = "C"."OWNER" AND "COL"."CONSTRAINT_NAME" = "C"."CONSTRAINT_NAME" INNER JOIN "ALL_CONS_COLUMNS" "REF_COL" ON "REF_COL"."OWNER" = "C"."R_OWNER" AND "REF_COL"."CONSTRAINT_NAME" = "C"."R_CONSTRAINT_NAME" AND "REF_COL"."POSITION" = "COL"."POSITION" WHERE (${columnsCondition}) AND "C"."CONSTRAINT_TYPE" = 'R'`;
        const constraintsSql = `SELECT "C"."CONSTRAINT_NAME", "C"."CONSTRAINT_TYPE", "C"."OWNER", "C"."TABLE_NAME", "COL"."COLUMN_NAME", "C"."SEARCH_CONDITION" FROM "ALL_CONSTRAINTS" "C" INNER JOIN "ALL_CONS_COLUMNS" "COL" ON "COL"."OWNER" = "C"."OWNER" AND "COL"."CONSTRAINT_NAME" = "C"."CONSTRAINT_NAME" WHERE (${columnsCondition}) AND "C"."CONSTRAINT_TYPE" IN ('C', 'U', 'P') AND "C"."GENERATED" = 'USER NAME'`;
        const [dbColumns, dbIndices, dbForeignKeys, dbConstraints] = await Promise.all([
          this.query(columnsSql),
          this.query(indicesSql),
          this.query(foreignKeysSql),
          this.query(constraintsSql)
        ]);
        return await Promise.all(dbTables.map(async (dbTable) => {
          const table = new Table_1.Table();
          const owner = dbTable["OWNER"] === currentSchema && (!this.driver.options.schema || this.driver.options.schema === currentSchema) ? void 0 : dbTable["OWNER"];
          table.database = currentDatabase;
          table.schema = dbTable["OWNER"];
          table.name = this.driver.buildTableName(dbTable["TABLE_NAME"], owner);
          table.columns = await Promise.all(dbColumns.filter((dbColumn) => dbColumn["OWNER"] === dbTable["OWNER"] && dbColumn["TABLE_NAME"] === dbTable["TABLE_NAME"] && // Filter out auto-generated virtual columns,
          // since TypeORM will have no info about them.
          !(dbColumn["VIRTUAL_COLUMN"] === "YES" && dbColumn["USER_GENERATED"] === "NO")).map(async (dbColumn) => {
            const columnConstraints = dbConstraints.filter((dbConstraint) => dbConstraint["OWNER"] === dbColumn["OWNER"] && dbConstraint["TABLE_NAME"] === dbColumn["TABLE_NAME"] && dbConstraint["COLUMN_NAME"] === dbColumn["COLUMN_NAME"]);
            const uniqueConstraints = columnConstraints.filter((constraint) => constraint["CONSTRAINT_TYPE"] === "U");
            const isConstraintComposite = uniqueConstraints.every((uniqueConstraint) => {
              return dbConstraints.some((dbConstraint) => dbConstraint["OWNER"] === dbColumn["OWNER"] && dbConstraint["TABLE_NAME"] === dbColumn["TABLE_NAME"] && dbConstraint["COLUMN_NAME"] !== dbColumn["COLUMN_NAME"] && dbConstraint["CONSTRAINT_NAME"] === uniqueConstraint["CONSTRAINT_NAME"] && dbConstraint["CONSTRAINT_TYPE"] === "U");
            });
            const tableColumn = new TableColumn_1.TableColumn();
            tableColumn.name = dbColumn["COLUMN_NAME"];
            tableColumn.type = dbColumn["DATA_TYPE"].toLowerCase();
            if (tableColumn.type.indexOf("(") !== -1)
              tableColumn.type = tableColumn.type.replace(/\([0-9]*\)/, "");
            if (this.driver.withLengthColumnTypes.indexOf(tableColumn.type) !== -1) {
              const length = tableColumn.type === "raw" ? dbColumn["DATA_LENGTH"] : dbColumn["CHAR_COL_DECL_LENGTH"];
              tableColumn.length = length && !this.isDefaultColumnLength(table, tableColumn, length) ? length.toString() : "";
            }
            if (tableColumn.type === "number" || tableColumn.type === "float") {
              if (dbColumn["DATA_PRECISION"] !== null && !this.isDefaultColumnPrecision(table, tableColumn, dbColumn["DATA_PRECISION"]))
                tableColumn.precision = dbColumn["DATA_PRECISION"];
              if (dbColumn["DATA_SCALE"] !== null && !this.isDefaultColumnScale(table, tableColumn, dbColumn["DATA_SCALE"]))
                tableColumn.scale = dbColumn["DATA_SCALE"];
            } else if ((tableColumn.type === "timestamp" || tableColumn.type === "timestamp with time zone" || tableColumn.type === "timestamp with local time zone") && dbColumn["DATA_SCALE"] !== null) {
              tableColumn.precision = !this.isDefaultColumnPrecision(table, tableColumn, dbColumn["DATA_SCALE"]) ? dbColumn["DATA_SCALE"] : void 0;
            }
            tableColumn.default = dbColumn["DATA_DEFAULT"] !== null && dbColumn["DATA_DEFAULT"] !== void 0 && dbColumn["VIRTUAL_COLUMN"] === "NO" && dbColumn["DATA_DEFAULT"].trim() !== "NULL" ? tableColumn.default = dbColumn["DATA_DEFAULT"].trim() : void 0;
            const primaryConstraint = columnConstraints.find((constraint) => constraint["CONSTRAINT_TYPE"] === "P");
            if (primaryConstraint) {
              tableColumn.isPrimary = true;
              const anotherPrimaryConstraints = dbConstraints.filter((constraint) => constraint["OWNER"] === dbColumn["OWNER"] && constraint["TABLE_NAME"] === dbColumn["TABLE_NAME"] && constraint["COLUMN_NAME"] !== dbColumn["COLUMN_NAME"] && constraint["CONSTRAINT_TYPE"] === "P");
              const columnNames = anotherPrimaryConstraints.map((constraint) => constraint["COLUMN_NAME"]);
              columnNames.push(dbColumn["COLUMN_NAME"]);
              const pkName = this.connection.namingStrategy.primaryKeyName(table, columnNames);
              if (primaryConstraint["CONSTRAINT_NAME"] !== pkName) {
                tableColumn.primaryKeyConstraintName = primaryConstraint["CONSTRAINT_NAME"];
              }
            }
            tableColumn.isNullable = dbColumn["NULLABLE"] === "Y";
            tableColumn.isUnique = uniqueConstraints.length > 0 && !isConstraintComposite;
            tableColumn.isGenerated = dbColumn["IDENTITY_COLUMN"] === "YES";
            if (tableColumn.isGenerated) {
              tableColumn.generationStrategy = "increment";
              tableColumn.default = void 0;
            }
            tableColumn.comment = "";
            if (dbColumn["VIRTUAL_COLUMN"] === "YES") {
              tableColumn.generatedType = "VIRTUAL";
              const asExpressionQuery = this.selectTypeormMetadataSql({
                table: dbTable["TABLE_NAME"],
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: tableColumn.name
              });
              const results = await this.query(asExpressionQuery.query, asExpressionQuery.parameters);
              if (results[0] && results[0].value) {
                tableColumn.asExpression = results[0].value;
              } else {
                tableColumn.asExpression = "";
              }
            }
            return tableColumn;
          }));
          const tableUniqueConstraints = OrmUtils_1.OrmUtils.uniq(dbConstraints.filter((dbConstraint) => {
            return dbConstraint["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbConstraint["OWNER"] === dbTable["OWNER"] && dbConstraint["CONSTRAINT_TYPE"] === "U";
          }), (dbConstraint) => dbConstraint["CONSTRAINT_NAME"]);
          table.uniques = tableUniqueConstraints.map((constraint) => {
            const uniques = dbConstraints.filter((dbC) => dbC["CONSTRAINT_NAME"] === constraint["CONSTRAINT_NAME"]);
            return new TableUnique_1.TableUnique({
              name: constraint["CONSTRAINT_NAME"],
              columnNames: uniques.map((u) => u["COLUMN_NAME"])
            });
          });
          const tableCheckConstraints = OrmUtils_1.OrmUtils.uniq(dbConstraints.filter((dbConstraint) => {
            return dbConstraint["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbConstraint["OWNER"] === dbTable["OWNER"] && dbConstraint["CONSTRAINT_TYPE"] === "C";
          }), (dbConstraint) => dbConstraint["CONSTRAINT_NAME"]);
          table.checks = tableCheckConstraints.map((constraint) => {
            const checks = dbConstraints.filter((dbC) => dbC["TABLE_NAME"] === constraint["TABLE_NAME"] && dbC["OWNER"] === constraint["OWNER"] && dbC["CONSTRAINT_NAME"] === constraint["CONSTRAINT_NAME"]);
            return new TableCheck_1.TableCheck({
              name: constraint["CONSTRAINT_NAME"],
              columnNames: checks.map((c) => c["COLUMN_NAME"]),
              expression: constraint["SEARCH_CONDITION"]
            });
          });
          const tableForeignKeyConstraints = OrmUtils_1.OrmUtils.uniq(dbForeignKeys.filter((dbForeignKey) => dbForeignKey["OWNER"] === dbTable["OWNER"] && dbForeignKey["TABLE_NAME"] === dbTable["TABLE_NAME"]), (dbForeignKey) => dbForeignKey["CONSTRAINT_NAME"]);
          table.foreignKeys = tableForeignKeyConstraints.map((dbForeignKey) => {
            const foreignKeys = dbForeignKeys.filter((dbFk) => dbFk["TABLE_NAME"] === dbForeignKey["TABLE_NAME"] && dbFk["OWNER"] === dbForeignKey["OWNER"] && dbFk["CONSTRAINT_NAME"] === dbForeignKey["CONSTRAINT_NAME"]);
            return new TableForeignKey_1.TableForeignKey({
              name: dbForeignKey["CONSTRAINT_NAME"],
              columnNames: foreignKeys.map((dbFk) => dbFk["COLUMN_NAME"]),
              referencedDatabase: table.database,
              referencedSchema: dbForeignKey["OWNER"],
              referencedTableName: dbForeignKey["REFERENCED_TABLE_NAME"],
              referencedColumnNames: foreignKeys.map((dbFk) => dbFk["REFERENCED_COLUMN_NAME"]),
              onDelete: dbForeignKey["ON_DELETE"],
              onUpdate: "NO ACTION"
              // Oracle does not have onUpdate option in FK's, but we need it for proper synchronization
            });
          });
          const autoGenVirtualDbColumns = dbColumns.filter((dbColumn) => dbColumn["OWNER"] === dbTable["OWNER"] && dbColumn["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbColumn["VIRTUAL_COLUMN"] === "YES" && dbColumn["USER_GENERATED"] === "NO").reduce((acc, x) => {
            const referencedDbColumn = dbColumns.find((dbColumn) => x["DATA_DEFAULT"].includes(dbColumn["COLUMN_NAME"]));
            if (!referencedDbColumn)
              return acc;
            return {
              ...acc,
              [x["COLUMN_NAME"]]: referencedDbColumn["COLUMN_NAME"]
            };
          }, {});
          table.indices = dbIndices.filter((dbIndex) => dbIndex["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbIndex["OWNER"] === dbTable["OWNER"]).map((dbIndex) => {
            const columnNames = dbIndex["COLUMN_NAMES"].split(",").map((columnName) => autoGenVirtualDbColumns[columnName] ?? columnName);
            return new TableIndex_1.TableIndex({
              name: dbIndex["INDEX_NAME"],
              columnNames,
              isUnique: dbIndex["UNIQUENESS"] === "UNIQUE"
            });
          });
          return table;
        }));
      }
      /**
       * Builds and returns SQL for create table.
       */
      createTableSql(table, createForeignKeys) {
        const columnDefinitions = table.columns.map((column) => this.buildCreateColumnSql(column)).join(", ");
        let sql = `CREATE TABLE ${this.escapePath(table)} (${columnDefinitions}`;
        table.columns.filter((column) => column.isUnique).forEach((column) => {
          const isUniqueExist = table.uniques.some((unique) => unique.columnNames.length === 1 && unique.columnNames[0] === column.name);
          if (!isUniqueExist)
            table.uniques.push(new TableUnique_1.TableUnique({
              name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),
              columnNames: [column.name]
            }));
        });
        if (table.uniques.length > 0) {
          const uniquesSql = table.uniques.map((unique) => {
            const uniqueName = unique.name ? unique.name : this.connection.namingStrategy.uniqueConstraintName(table, unique.columnNames);
            const columnNames = unique.columnNames.map((columnName) => `"${columnName}"`).join(", ");
            return `CONSTRAINT "${uniqueName}" UNIQUE (${columnNames})`;
          }).join(", ");
          sql += `, ${uniquesSql}`;
        }
        if (table.checks.length > 0) {
          const checksSql = table.checks.map((check) => {
            const checkName = check.name ? check.name : this.connection.namingStrategy.checkConstraintName(table, check.expression);
            return `CONSTRAINT "${checkName}" CHECK (${check.expression})`;
          }).join(", ");
          sql += `, ${checksSql}`;
        }
        if (table.foreignKeys.length > 0 && createForeignKeys) {
          const foreignKeysSql = table.foreignKeys.map((fk) => {
            const columnNames = fk.columnNames.map((columnName) => `"${columnName}"`).join(", ");
            if (!fk.name)
              fk.name = this.connection.namingStrategy.foreignKeyName(table, fk.columnNames, this.getTablePath(fk), fk.referencedColumnNames);
            const referencedColumnNames = fk.referencedColumnNames.map((columnName) => `"${columnName}"`).join(", ");
            let constraint = `CONSTRAINT "${fk.name}" FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(fk))} (${referencedColumnNames})`;
            if (fk.onDelete && fk.onDelete !== "NO ACTION") {
              constraint += ` ON DELETE ${fk.onDelete}`;
            }
            return constraint;
          }).join(", ");
          sql += `, ${foreignKeysSql}`;
        }
        const primaryColumns = table.columns.filter((column) => column.isPrimary);
        if (primaryColumns.length > 0) {
          const primaryKeyName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(table, primaryColumns.map((column) => column.name));
          const columnNames = primaryColumns.map((column) => `"${column.name}"`).join(", ");
          sql += `, CONSTRAINT "${primaryKeyName}" PRIMARY KEY (${columnNames})`;
        }
        sql += `)`;
        return new Query_1.Query(sql);
      }
      /**
       * Builds drop table sql.
       */
      dropTableSql(tableOrName, ifExist) {
        const query = ifExist ? `DROP TABLE IF EXISTS ${this.escapePath(tableOrName)}` : `DROP TABLE ${this.escapePath(tableOrName)}`;
        return new Query_1.Query(query);
      }
      createViewSql(view) {
        const materializedClause = view.materialized ? "MATERIALIZED " : "";
        if (typeof view.expression === "string") {
          return new Query_1.Query(`CREATE ${materializedClause}VIEW ${this.escapePath(view)} AS ${view.expression}`);
        } else {
          return new Query_1.Query(`CREATE ${materializedClause}VIEW ${this.escapePath(view)} AS ${view.expression(this.connection).getQuery()}`);
        }
      }
      insertViewDefinitionSql(view) {
        const expression = typeof view.expression === "string" ? view.expression.trim() : view.expression(this.connection).getQuery();
        const type = view.materialized ? MetadataTableType_1.MetadataTableType.MATERIALIZED_VIEW : MetadataTableType_1.MetadataTableType.VIEW;
        const { schema, tableName } = this.driver.parseTableName(view);
        return this.insertTypeormMetadataSql({
          type,
          name: tableName,
          schema,
          value: expression
        });
      }
      /**
       * Builds drop view sql.
       */
      dropViewSql(view) {
        const materializedClause = view.materialized ? "MATERIALIZED " : "";
        return new Query_1.Query(`DROP ${materializedClause}VIEW ${this.escapePath(view)}`);
      }
      /**
       * Builds remove view sql.
       */
      deleteViewDefinitionSql(view) {
        const type = view.materialized ? MetadataTableType_1.MetadataTableType.MATERIALIZED_VIEW : MetadataTableType_1.MetadataTableType.VIEW;
        return this.deleteTypeormMetadataSql({ type, name: view.name });
      }
      /**
       * Builds create index sql.
       */
      createIndexSql(table, index) {
        const columns = index.columnNames.map((columnName) => `"${columnName}"`).join(", ");
        return new Query_1.Query(`CREATE ${index.isUnique ? "UNIQUE " : ""}INDEX "${index.name}" ON ${this.escapePath(table)} (${columns})`);
      }
      /**
       * Builds drop index sql.
       */
      dropIndexSql(indexOrName) {
        const indexName = InstanceChecker_1.InstanceChecker.isTableIndex(indexOrName) ? indexOrName.name : indexOrName;
        return new Query_1.Query(`DROP INDEX "${indexName}"`);
      }
      /**
       * Builds create primary key sql.
       */
      createPrimaryKeySql(table, columnNames, constraintName) {
        const primaryKeyName = constraintName ? constraintName : this.connection.namingStrategy.primaryKeyName(table, columnNames);
        const columnNamesString = columnNames.map((columnName) => `"${columnName}"`).join(", ");
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${primaryKeyName}" PRIMARY KEY (${columnNamesString})`);
      }
      /**
       * Builds drop primary key sql.
       */
      dropPrimaryKeySql(table) {
        if (!table.primaryColumns.length)
          throw new error_1.TypeORMError(`Table ${table} has no primary keys.`);
        const columnNames = table.primaryColumns.map((column) => column.name);
        const constraintName = table.primaryColumns[0].primaryKeyConstraintName;
        const primaryKeyName = constraintName ? constraintName : this.connection.namingStrategy.primaryKeyName(table, columnNames);
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${primaryKeyName}"`);
      }
      /**
       * Builds create unique constraint sql.
       */
      createUniqueConstraintSql(table, uniqueConstraint) {
        const columnNames = uniqueConstraint.columnNames.map((column) => `"` + column + `"`).join(", ");
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${uniqueConstraint.name}" UNIQUE (${columnNames})`);
      }
      /**
       * Builds drop unique constraint sql.
       */
      dropUniqueConstraintSql(table, uniqueOrName) {
        const uniqueName = InstanceChecker_1.InstanceChecker.isTableUnique(uniqueOrName) ? uniqueOrName.name : uniqueOrName;
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${uniqueName}"`);
      }
      /**
       * Builds create check constraint sql.
       */
      createCheckConstraintSql(table, checkConstraint) {
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${checkConstraint.name}" CHECK (${checkConstraint.expression})`);
      }
      /**
       * Builds drop check constraint sql.
       */
      dropCheckConstraintSql(table, checkOrName) {
        const checkName = InstanceChecker_1.InstanceChecker.isTableCheck(checkOrName) ? checkOrName.name : checkOrName;
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${checkName}"`);
      }
      /**
       * Builds create foreign key sql.
       */
      createForeignKeySql(table, foreignKey) {
        const columnNames = foreignKey.columnNames.map((column) => `"` + column + `"`).join(", ");
        const referencedColumnNames = foreignKey.referencedColumnNames.map((column) => `"` + column + `"`).join(",");
        let sql = `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${foreignKey.name}" FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(foreignKey))} (${referencedColumnNames})`;
        if (foreignKey.onDelete && foreignKey.onDelete !== "NO ACTION") {
          sql += ` ON DELETE ${foreignKey.onDelete}`;
        }
        return new Query_1.Query(sql);
      }
      /**
       * Builds drop foreign key sql.
       */
      dropForeignKeySql(table, foreignKeyOrName) {
        const foreignKeyName = InstanceChecker_1.InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName.name : foreignKeyOrName;
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${foreignKeyName}"`);
      }
      /**
       * Builds a query for create column.
       */
      buildCreateColumnSql(column) {
        let c = `"${column.name}" ` + this.connection.driver.createFullType(column);
        if (column.charset)
          c += " CHARACTER SET " + column.charset;
        if (column.collation)
          c += " COLLATE " + column.collation;
        if (column.asExpression)
          c += ` AS (${column.asExpression}) VIRTUAL`;
        if (column.default !== void 0 && column.default !== null)
          c += " DEFAULT " + column.default;
        if (column.isNullable !== true && !column.isGenerated)
          c += " NOT NULL";
        if (column.isGenerated === true && column.generationStrategy === "increment")
          c += " GENERATED BY DEFAULT AS IDENTITY";
        return c;
      }
      /**
       * Escapes given table or view path.
       */
      escapePath(target) {
        const { schema, tableName } = this.driver.parseTableName(target);
        if (schema && schema !== this.driver.schema) {
          return `"${schema}"."${tableName}"`;
        }
        return `"${tableName}"`;
      }
      /**
       * Change table comment.
       */
      changeTableComment(tableOrName, comment) {
        throw new error_1.TypeORMError(`oracle driver does not support change table comment.`);
      }
    };
    exports2.OracleQueryRunner = OracleQueryRunner;
  }
});

// node_modules/typeorm/driver/oracle/OracleDriver.js
var require_OracleDriver = __commonJS({
  "node_modules/typeorm/driver/oracle/OracleDriver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OracleDriver = void 0;
    var ConnectionIsNotSetError_1 = require_ConnectionIsNotSetError();
    var DriverPackageNotInstalledError_1 = require_DriverPackageNotInstalledError();
    var OracleQueryRunner_1 = require_OracleQueryRunner();
    var DateUtils_1 = require_DateUtils();
    var PlatformTools_1 = require_PlatformTools();
    var RdbmsSchemaBuilder_1 = require_RdbmsSchemaBuilder();
    var DriverUtils_1 = require_DriverUtils();
    var OrmUtils_1 = require_OrmUtils();
    var ApplyValueTransformers_1 = require_ApplyValueTransformers();
    var error_1 = require_error();
    var InstanceChecker_1 = require_InstanceChecker();
    var OracleDriver = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection) {
        this.slaves = [];
        this.isReplicated = false;
        this.treeSupport = true;
        this.transactionSupport = "nested";
        this.supportedDataTypes = [
          "char",
          "nchar",
          "nvarchar2",
          "varchar2",
          "long",
          "raw",
          "long raw",
          "number",
          "numeric",
          "float",
          "dec",
          "decimal",
          "integer",
          "int",
          "smallint",
          "real",
          "double precision",
          "date",
          "timestamp",
          "timestamp with time zone",
          "timestamp with local time zone",
          "interval year to month",
          "interval day to second",
          "bfile",
          "blob",
          "clob",
          "nclob",
          "rowid",
          "urowid",
          "simple-json",
          "json"
        ];
        this.supportedUpsertTypes = ["merge-into"];
        this.supportedOnDeleteTypes = [
          "CASCADE",
          "SET NULL",
          "NO ACTION"
        ];
        this.supportedOnUpdateTypes = ["NO ACTION"];
        this.spatialTypes = [];
        this.withLengthColumnTypes = [
          "char",
          "nchar",
          "nvarchar2",
          "varchar2",
          "varchar",
          "raw"
        ];
        this.withPrecisionColumnTypes = [
          "number",
          "float",
          "timestamp",
          "timestamp with time zone",
          "timestamp with local time zone"
        ];
        this.withScaleColumnTypes = ["number"];
        this.mappedDataTypes = {
          createDate: "timestamp",
          createDateDefault: "CURRENT_TIMESTAMP",
          updateDate: "timestamp",
          updateDateDefault: "CURRENT_TIMESTAMP",
          deleteDate: "timestamp",
          deleteDateNullable: true,
          version: "number",
          treeLevel: "number",
          migrationId: "number",
          migrationName: "varchar2",
          migrationTimestamp: "number",
          cacheId: "number",
          cacheIdentifier: "varchar2",
          cacheTime: "number",
          cacheDuration: "number",
          cacheQuery: "clob",
          cacheResult: "clob",
          metadataType: "varchar2",
          metadataDatabase: "varchar2",
          metadataSchema: "varchar2",
          metadataTable: "varchar2",
          metadataName: "varchar2",
          metadataValue: "clob"
        };
        this.parametersPrefix = ":";
        this.dataTypeDefaults = {
          char: { length: 1 },
          nchar: { length: 1 },
          varchar: { length: 255 },
          varchar2: { length: 255 },
          nvarchar2: { length: 255 },
          raw: { length: 2e3 },
          float: { precision: 126 },
          timestamp: { precision: 6 },
          "timestamp with time zone": { precision: 6 },
          "timestamp with local time zone": { precision: 6 }
        };
        this.maxAliasLength = 29;
        this.cteCapabilities = {
          enabled: true
        };
        this.dummyTableName = "DUAL";
        this.connection = connection;
        this.options = connection.options;
        if (this.options.useUTC === true) {
          process.env.ORA_SDTZ = "UTC";
        }
        this.loadDependencies();
        this.database = DriverUtils_1.DriverUtils.buildDriverOptions(this.options.replication ? this.options.replication.master : this.options).database;
        this.schema = DriverUtils_1.DriverUtils.buildDriverOptions(this.options).schema;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Performs connection to the database.
       * Based on pooling options, it can either create connection immediately,
       * either create a pool and create connection when needed.
       */
      async connect() {
        this.oracle.fetchAsString = [this.oracle.DB_TYPE_CLOB];
        this.oracle.fetchAsBuffer = [this.oracle.DB_TYPE_BLOB];
        if (this.options.replication) {
          this.slaves = await Promise.all(this.options.replication.slaves.map((slave) => {
            return this.createPool(this.options, slave);
          }));
          this.master = await this.createPool(this.options, this.options.replication.master);
        } else {
          this.master = await this.createPool(this.options, this.options);
        }
        if (!this.database || !this.schema) {
          const queryRunner = this.createQueryRunner("master");
          if (!this.database) {
            this.database = await queryRunner.getCurrentDatabase();
          }
          if (!this.schema) {
            this.schema = await queryRunner.getCurrentSchema();
          }
          await queryRunner.release();
        }
      }
      /**
       * Makes any action after connection (e.g. create extensions in Postgres driver).
       */
      afterConnect() {
        return Promise.resolve();
      }
      /**
       * Closes connection with the database.
       */
      async disconnect() {
        if (!this.master) {
          throw new ConnectionIsNotSetError_1.ConnectionIsNotSetError("oracle");
        }
        await this.closePool(this.master);
        await Promise.all(this.slaves.map((slave) => this.closePool(slave)));
        this.master = void 0;
        this.slaves = [];
      }
      /**
       * Creates a schema builder used to build and sync a schema.
       */
      createSchemaBuilder() {
        return new RdbmsSchemaBuilder_1.RdbmsSchemaBuilder(this.connection);
      }
      /**
       * Creates a query runner used to execute database queries.
       */
      createQueryRunner(mode) {
        return new OracleQueryRunner_1.OracleQueryRunner(this, mode);
      }
      /**
       * Replaces parameters in the given sql with special escaping character
       * and an array of parameter names to be passed to a query.
       */
      escapeQueryWithParameters(sql, parameters, nativeParameters) {
        const escapedParameters = Object.keys(nativeParameters).map((key) => {
          if (typeof nativeParameters[key] === "boolean")
            return nativeParameters[key] ? 1 : 0;
          return nativeParameters[key];
        });
        if (!parameters || !Object.keys(parameters).length)
          return [sql, escapedParameters];
        sql = sql.replace(/:(\.\.\.)?([A-Za-z0-9_.]+)/g, (full, isArray, key) => {
          if (!parameters.hasOwnProperty(key)) {
            return full;
          }
          const value = parameters[key];
          if (isArray) {
            return value.map((v) => {
              escapedParameters.push(v);
              return this.createParameter(key, escapedParameters.length - 1);
            }).join(", ");
          }
          if (typeof value === "function") {
            return value();
          }
          if (typeof value === "boolean") {
            return value ? "1" : "0";
          }
          escapedParameters.push(value);
          return this.createParameter(key, escapedParameters.length - 1);
        });
        return [sql, escapedParameters];
      }
      /**
       * Escapes a column name.
       */
      escape(columnName) {
        return `"${columnName}"`;
      }
      /**
       * Build full table name with database name, schema name and table name.
       * Oracle does not support table schemas. One user can have only one schema.
       */
      buildTableName(tableName, schema, database) {
        const tablePath = [tableName];
        if (schema) {
          tablePath.unshift(schema);
        }
        return tablePath.join(".");
      }
      /**
       * Parse a target table name or other types and return a normalized table definition.
       */
      parseTableName(target) {
        const driverDatabase = this.database;
        const driverSchema = this.schema;
        if (InstanceChecker_1.InstanceChecker.isTable(target) || InstanceChecker_1.InstanceChecker.isView(target)) {
          const parsed = this.parseTableName(target.name);
          return {
            database: target.database || parsed.database || driverDatabase,
            schema: target.schema || parsed.schema || driverSchema,
            tableName: parsed.tableName
          };
        }
        if (InstanceChecker_1.InstanceChecker.isTableForeignKey(target)) {
          const parsed = this.parseTableName(target.referencedTableName);
          return {
            database: target.referencedDatabase || parsed.database || driverDatabase,
            schema: target.referencedSchema || parsed.schema || driverSchema,
            tableName: parsed.tableName
          };
        }
        if (InstanceChecker_1.InstanceChecker.isEntityMetadata(target)) {
          return {
            database: target.database || driverDatabase,
            schema: target.schema || driverSchema,
            tableName: target.tableName
          };
        }
        const parts = target.split(".");
        if (parts.length === 3) {
          return {
            database: parts[0] || driverDatabase,
            schema: parts[1] || driverSchema,
            tableName: parts[2]
          };
        } else if (parts.length === 2) {
          return {
            database: driverDatabase,
            schema: parts[0] || driverSchema,
            tableName: parts[1]
          };
        } else {
          return {
            database: driverDatabase,
            schema: driverSchema,
            tableName: target
          };
        }
      }
      /**
       * Prepares given value to a value to be persisted, based on its column type and metadata.
       */
      preparePersistentValue(value, columnMetadata) {
        if (columnMetadata.transformer)
          value = ApplyValueTransformers_1.ApplyValueTransformers.transformTo(columnMetadata.transformer, value);
        if (value === null || value === void 0)
          return value;
        if (columnMetadata.type === Boolean) {
          return value ? 1 : 0;
        } else if (columnMetadata.type === "date") {
          if (typeof value === "string")
            value = value.replace(/[^0-9-]/g, "");
          return () => `TO_DATE('${DateUtils_1.DateUtils.mixedDateToDateString(value)}', 'YYYY-MM-DD')`;
        } else if (columnMetadata.type === Date || columnMetadata.type === "timestamp" || columnMetadata.type === "timestamp with time zone" || columnMetadata.type === "timestamp with local time zone") {
          return DateUtils_1.DateUtils.mixedDateToDate(value);
        } else if (columnMetadata.type === "simple-array") {
          return DateUtils_1.DateUtils.simpleArrayToString(value);
        } else if (columnMetadata.type === "simple-json") {
          return DateUtils_1.DateUtils.simpleJsonToString(value);
        } else if (columnMetadata.type === "json") {
          return DateUtils_1.DateUtils.simpleJsonToString(value);
        }
        return value;
      }
      /**
       * Prepares given value to a value to be persisted, based on its column type or metadata.
       */
      prepareHydratedValue(value, columnMetadata) {
        if (value === null || value === void 0)
          return columnMetadata.transformer ? ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value) : value;
        if (columnMetadata.type === Boolean) {
          value = !!value;
        } else if (columnMetadata.type === "date") {
          value = DateUtils_1.DateUtils.mixedDateToDateString(value);
        } else if (columnMetadata.type === "time") {
          value = DateUtils_1.DateUtils.mixedTimeToString(value);
        } else if (columnMetadata.type === Date || columnMetadata.type === "timestamp" || columnMetadata.type === "timestamp with time zone" || columnMetadata.type === "timestamp with local time zone") {
          value = DateUtils_1.DateUtils.normalizeHydratedDate(value);
        } else if (columnMetadata.type === "simple-array") {
          value = DateUtils_1.DateUtils.stringToSimpleArray(value);
        } else if (columnMetadata.type === "simple-json") {
          value = DateUtils_1.DateUtils.stringToSimpleJson(value);
        } else if (columnMetadata.type === Number) {
          value = !isNaN(+value) ? parseInt(value) : value;
        }
        if (columnMetadata.transformer)
          value = ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);
        return value;
      }
      /**
       * Creates a database type from a given column metadata.
       */
      normalizeType(column) {
        if (column.type === Number || column.type === Boolean || column.type === "numeric" || column.type === "dec" || column.type === "decimal" || column.type === "int" || column.type === "integer" || column.type === "smallint") {
          return "number";
        } else if (column.type === "real" || column.type === "double precision") {
          return "float";
        } else if (column.type === String || column.type === "varchar") {
          return "varchar2";
        } else if (column.type === Date) {
          return "timestamp";
        } else if (column.type === Buffer) {
          return "blob";
        } else if (column.type === "uuid") {
          return "varchar2";
        } else if (column.type === "simple-array") {
          return "clob";
        } else if (column.type === "simple-json") {
          return "clob";
        } else if (column.type === "json") {
          return "json";
        } else {
          return column.type || "";
        }
      }
      /**
       * Normalizes "default" value of the column.
       */
      normalizeDefault(columnMetadata) {
        const defaultValue = columnMetadata.default;
        if (typeof defaultValue === "number") {
          return "" + defaultValue;
        }
        if (typeof defaultValue === "boolean") {
          return defaultValue ? "1" : "0";
        }
        if (typeof defaultValue === "function") {
          return defaultValue();
        }
        if (typeof defaultValue === "string") {
          return `'${defaultValue}'`;
        }
        if (defaultValue === null || defaultValue === void 0) {
          return void 0;
        }
        return `${defaultValue}`;
      }
      /**
       * Normalizes "isUnique" value of the column.
       */
      normalizeIsUnique(column) {
        return column.entityMetadata.uniques.some((uq) => uq.columns.length === 1 && uq.columns[0] === column);
      }
      /**
       * Calculates column length taking into account the default length values.
       */
      getColumnLength(column) {
        if (column.length)
          return column.length.toString();
        switch (column.type) {
          case String:
          case "varchar":
          case "varchar2":
          case "nvarchar2":
            return "255";
          case "raw":
            return "2000";
          case "uuid":
            return "36";
          default:
            return "";
        }
      }
      createFullType(column) {
        let type = column.type;
        if (this.getColumnLength(column)) {
          type += `(${this.getColumnLength(column)})`;
        } else if (column.precision !== null && column.precision !== void 0 && column.scale !== null && column.scale !== void 0) {
          type += "(" + column.precision + "," + column.scale + ")";
        } else if (column.precision !== null && column.precision !== void 0) {
          type += "(" + column.precision + ")";
        }
        if (column.type === "timestamp with time zone") {
          type = "TIMESTAMP" + (column.precision !== null && column.precision !== void 0 ? "(" + column.precision + ")" : "") + " WITH TIME ZONE";
        } else if (column.type === "timestamp with local time zone") {
          type = "TIMESTAMP" + (column.precision !== null && column.precision !== void 0 ? "(" + column.precision + ")" : "") + " WITH LOCAL TIME ZONE";
        }
        if (column.isArray)
          type += " array";
        return type;
      }
      /**
       * Obtains a new database connection to a master server.
       * Used for replication.
       * If replication is not setup then returns default connection's database connection.
       */
      obtainMasterConnection() {
        return new Promise((ok, fail) => {
          if (!this.master) {
            return fail(new error_1.TypeORMError("Driver not Connected"));
          }
          this.master.getConnection((err, connection, release) => {
            if (err)
              return fail(err);
            ok(connection);
          });
        });
      }
      /**
       * Obtains a new database connection to a slave server.
       * Used for replication.
       * If replication is not setup then returns master (default) connection's database connection.
       */
      obtainSlaveConnection() {
        if (!this.slaves.length)
          return this.obtainMasterConnection();
        return new Promise((ok, fail) => {
          const random = Math.floor(Math.random() * this.slaves.length);
          this.slaves[random].getConnection((err, connection) => {
            if (err)
              return fail(err);
            ok(connection);
          });
        });
      }
      /**
       * Creates generated map of values generated or returned by database after INSERT query.
       */
      createGeneratedMap(metadata, insertResult) {
        if (!insertResult)
          return void 0;
        return Object.keys(insertResult).reduce((map, key) => {
          const column = metadata.findColumnWithDatabaseName(key);
          if (column) {
            OrmUtils_1.OrmUtils.mergeDeep(map, column.createValueMap(this.prepareHydratedValue(insertResult[key], column)));
          }
          return map;
        }, {});
      }
      /**
       * Differentiate columns of this table and columns from the given column metadatas columns
       * and returns only changed.
       */
      findChangedColumns(tableColumns, columnMetadatas) {
        return columnMetadatas.filter((columnMetadata) => {
          const tableColumn = tableColumns.find((c) => c.name === columnMetadata.databaseName);
          if (!tableColumn)
            return false;
          const isColumnChanged = tableColumn.name !== columnMetadata.databaseName || tableColumn.type !== this.normalizeType(columnMetadata) || tableColumn.length !== this.getColumnLength(columnMetadata) || tableColumn.precision !== columnMetadata.precision || tableColumn.scale !== columnMetadata.scale || // || tableColumn.comment !== columnMetadata.comment
          tableColumn.default !== this.normalizeDefault(columnMetadata) || tableColumn.isPrimary !== columnMetadata.isPrimary || tableColumn.isNullable !== columnMetadata.isNullable || tableColumn.asExpression !== columnMetadata.asExpression || tableColumn.generatedType !== columnMetadata.generatedType || tableColumn.isUnique !== this.normalizeIsUnique(columnMetadata) || columnMetadata.generationStrategy !== "uuid" && tableColumn.isGenerated !== columnMetadata.isGenerated;
          return isColumnChanged;
        });
      }
      /**
       * Returns true if driver supports RETURNING / OUTPUT statement.
       */
      isReturningSqlSupported() {
        return true;
      }
      /**
       * Returns true if driver supports uuid values generation on its own.
       */
      isUUIDGenerationSupported() {
        return false;
      }
      /**
       * Returns true if driver supports fulltext indices.
       */
      isFullTextColumnTypeSupported() {
        return false;
      }
      /**
       * Creates an escaped parameter.
       */
      createParameter(parameterName, index) {
        return this.parametersPrefix + (index + 1);
      }
      /**
       * Converts column type in to native oracle type.
       */
      columnTypeToNativeParameter(type) {
        switch (this.normalizeType({ type })) {
          case "number":
          case "numeric":
          case "int":
          case "integer":
          case "smallint":
          case "dec":
          case "decimal":
            return this.oracle.DB_TYPE_NUMBER;
          case "char":
          case "nchar":
          case "nvarchar2":
          case "varchar2":
            return this.oracle.DB_TYPE_VARCHAR;
          case "blob":
            return this.oracle.DB_TYPE_BLOB;
          case "simple-json":
          case "clob":
            return this.oracle.DB_TYPE_CLOB;
          case "date":
          case "timestamp":
          case "timestamp with time zone":
          case "timestamp with local time zone":
            return this.oracle.DB_TYPE_TIMESTAMP;
          case "json":
            return this.oracle.DB_TYPE_JSON;
        }
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Loads all driver dependencies.
       */
      loadDependencies() {
        try {
          const oracle = this.options.driver || PlatformTools_1.PlatformTools.load("oracledb");
          this.oracle = oracle;
        } catch (e) {
          throw new DriverPackageNotInstalledError_1.DriverPackageNotInstalledError("Oracle", "oracledb");
        }
        const thickMode = this.options.thickMode;
        if (thickMode) {
          typeof thickMode === "object" ? this.oracle.initOracleClient(thickMode) : this.oracle.initOracleClient();
        }
      }
      /**
       * Creates a new connection pool for a given database credentials.
       */
      async createPool(options, credentials) {
        credentials = Object.assign({}, credentials, DriverUtils_1.DriverUtils.buildDriverOptions(credentials));
        if (!credentials.connectString) {
          let address = `(PROTOCOL=TCP)`;
          if (credentials.host) {
            address += `(HOST=${credentials.host})`;
          }
          if (credentials.port) {
            address += `(PORT=${credentials.port})`;
          }
          let connectData = `(SERVER=DEDICATED)`;
          if (credentials.sid) {
            connectData += `(SID=${credentials.sid})`;
          }
          if (credentials.serviceName) {
            connectData += `(SERVICE_NAME=${credentials.serviceName})`;
          }
          const connectString = `(DESCRIPTION=(ADDRESS=${address})(CONNECT_DATA=${connectData}))`;
          Object.assign(credentials, { connectString });
        }
        const connectionOptions = Object.assign({}, {
          user: credentials.username,
          password: credentials.password,
          connectString: credentials.connectString
        }, {
          poolMax: options.poolSize
        }, options.extra || {});
        return new Promise((ok, fail) => {
          this.oracle.createPool(connectionOptions, (err, pool) => {
            if (err)
              return fail(err);
            ok(pool);
          });
        });
      }
      /**
       * Closes connection pool.
       */
      async closePool(pool) {
        return new Promise((ok, fail) => {
          pool.close((err) => err ? fail(err) : ok());
          pool = void 0;
        });
      }
    };
    exports2.OracleDriver = OracleDriver;
  }
});

// node_modules/typeorm/driver/sqlite-abstract/AbstractSqliteQueryRunner.js
var require_AbstractSqliteQueryRunner = __commonJS({
  "node_modules/typeorm/driver/sqlite-abstract/AbstractSqliteQueryRunner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractSqliteQueryRunner = void 0;
    var TransactionNotStartedError_1 = require_TransactionNotStartedError();
    var TableColumn_1 = require_TableColumn();
    var Table_1 = require_Table();
    var TableIndex_1 = require_TableIndex();
    var TableForeignKey_1 = require_TableForeignKey();
    var View_1 = require_View();
    var Query_1 = require_Query();
    var TableUnique_1 = require_TableUnique();
    var BaseQueryRunner_1 = require_BaseQueryRunner();
    var OrmUtils_1 = require_OrmUtils();
    var TableCheck_1 = require_TableCheck();
    var error_1 = require_error();
    var MetadataTableType_1 = require_MetadataTableType();
    var InstanceChecker_1 = require_InstanceChecker();
    var AbstractSqliteQueryRunner = class extends BaseQueryRunner_1.BaseQueryRunner {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor() {
        super();
        this.transactionPromise = null;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Creates/uses database connection from the connection pool to perform further operations.
       * Returns obtained database connection.
       */
      connect() {
        return Promise.resolve(this.driver.databaseConnection);
      }
      /**
       * Releases used database connection.
       * We just clear loaded tables and sql in memory, because sqlite do not support multiple connections thus query runners.
       */
      release() {
        this.loadedTables = [];
        this.clearSqlMemory();
        return Promise.resolve();
      }
      /**
       * Starts transaction.
       */
      async startTransaction(isolationLevel) {
        if (this.driver.transactionSupport === "none")
          throw new error_1.TypeORMError(`Transactions aren't supported by ${this.connection.driver.options.type}.`);
        if (this.isTransactionActive && this.driver.transactionSupport === "simple")
          throw new error_1.TransactionAlreadyStartedError();
        if (isolationLevel && isolationLevel !== "READ UNCOMMITTED" && isolationLevel !== "SERIALIZABLE")
          throw new error_1.TypeORMError(`SQLite only supports SERIALIZABLE and READ UNCOMMITTED isolation`);
        this.isTransactionActive = true;
        try {
          await this.broadcaster.broadcast("BeforeTransactionStart");
        } catch (err) {
          this.isTransactionActive = false;
          throw err;
        }
        if (this.transactionDepth === 0) {
          if (isolationLevel) {
            if (isolationLevel === "READ UNCOMMITTED") {
              await this.query("PRAGMA read_uncommitted = true");
            } else {
              await this.query("PRAGMA read_uncommitted = false");
            }
          }
          await this.query("BEGIN TRANSACTION");
        } else {
          await this.query(`SAVEPOINT typeorm_${this.transactionDepth}`);
        }
        this.transactionDepth += 1;
        await this.broadcaster.broadcast("AfterTransactionStart");
      }
      /**
       * Commits transaction.
       * Error will be thrown if transaction was not started.
       */
      async commitTransaction() {
        if (!this.isTransactionActive)
          throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionCommit");
        if (this.transactionDepth > 1) {
          await this.query(`RELEASE SAVEPOINT typeorm_${this.transactionDepth - 1}`);
        } else {
          await this.query("COMMIT");
          this.isTransactionActive = false;
        }
        this.transactionDepth -= 1;
        await this.broadcaster.broadcast("AfterTransactionCommit");
      }
      /**
       * Rollbacks transaction.
       * Error will be thrown if transaction was not started.
       */
      async rollbackTransaction() {
        if (!this.isTransactionActive)
          throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionRollback");
        if (this.transactionDepth > 1) {
          await this.query(`ROLLBACK TO SAVEPOINT typeorm_${this.transactionDepth - 1}`);
        } else {
          await this.query("ROLLBACK");
          this.isTransactionActive = false;
        }
        this.transactionDepth -= 1;
        await this.broadcaster.broadcast("AfterTransactionRollback");
      }
      /**
       * Returns raw data stream.
       */
      stream(query, parameters, onEnd, onError) {
        throw new error_1.TypeORMError(`Stream is not supported by sqlite driver.`);
      }
      /**
       * Returns all available database names including system databases.
       */
      async getDatabases() {
        return Promise.resolve([]);
      }
      /**
       * Returns all available schema names including system schemas.
       * If database parameter specified, returns schemas of that database.
       */
      async getSchemas(database) {
        return Promise.resolve([]);
      }
      /**
       * Checks if database with the given name exist.
       */
      async hasDatabase(database) {
        return Promise.resolve(false);
      }
      /**
       * Loads currently using database
       */
      async getCurrentDatabase() {
        return Promise.resolve(void 0);
      }
      /**
       * Checks if schema with the given name exist.
       */
      async hasSchema(schema) {
        throw new error_1.TypeORMError(`This driver does not support table schemas`);
      }
      /**
       * Loads currently using database schema
       */
      async getCurrentSchema() {
        return Promise.resolve(void 0);
      }
      /**
       * Checks if table with the given name exist in the database.
       */
      async hasTable(tableOrName) {
        const tableName = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName.name : tableOrName;
        const sql = `SELECT * FROM "sqlite_master" WHERE "type" = 'table' AND "name" = '${tableName}'`;
        const result = await this.query(sql);
        return result.length ? true : false;
      }
      /**
       * Checks if column with the given name exist in the given table.
       */
      async hasColumn(tableOrName, columnName) {
        const tableName = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName.name : tableOrName;
        const sql = `PRAGMA table_xinfo(${this.escapePath(tableName)})`;
        const columns = await this.query(sql);
        return !!columns.find((column) => column["name"] === columnName);
      }
      /**
       * Creates a new database.
       */
      async createDatabase(database, ifNotExist) {
        return Promise.resolve();
      }
      /**
       * Drops database.
       */
      async dropDatabase(database, ifExist) {
        return Promise.resolve();
      }
      /**
       * Creates a new table schema.
       */
      async createSchema(schemaPath, ifNotExist) {
        return Promise.resolve();
      }
      /**
       * Drops table schema.
       */
      async dropSchema(schemaPath, ifExist) {
        return Promise.resolve();
      }
      /**
       * Creates a new table.
       */
      async createTable(table, ifNotExist = false, createForeignKeys = true, createIndices = true) {
        const upQueries = [];
        const downQueries = [];
        if (ifNotExist) {
          const isTableExist = await this.hasTable(table);
          if (isTableExist)
            return Promise.resolve();
        }
        upQueries.push(this.createTableSql(table, createForeignKeys));
        downQueries.push(this.dropTableSql(table));
        if (createIndices) {
          table.indices.forEach((index) => {
            if (!index.name)
              index.name = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);
            upQueries.push(this.createIndexSql(table, index));
            downQueries.push(this.dropIndexSql(index));
          });
        }
        const generatedColumns = table.columns.filter((column) => column.generatedType && column.asExpression);
        for (const column of generatedColumns) {
          const insertQuery = this.insertTypeormMetadataSql({
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name,
            value: column.asExpression
          });
          const deleteQuery = this.deleteTypeormMetadataSql({
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name
          });
          upQueries.push(insertQuery);
          downQueries.push(deleteQuery);
        }
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Drops the table.
       */
      async dropTable(tableOrName, ifExist, dropForeignKeys = true, dropIndices = true) {
        if (ifExist) {
          const isTableExist = await this.hasTable(tableOrName);
          if (!isTableExist)
            return Promise.resolve();
        }
        const createForeignKeys = dropForeignKeys;
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const upQueries = [];
        const downQueries = [];
        if (dropIndices) {
          table.indices.forEach((index) => {
            upQueries.push(this.dropIndexSql(index));
            downQueries.push(this.createIndexSql(table, index));
          });
        }
        upQueries.push(this.dropTableSql(table, ifExist));
        downQueries.push(this.createTableSql(table, createForeignKeys));
        const generatedColumns = table.columns.filter((column) => column.generatedType && column.asExpression);
        for (const column of generatedColumns) {
          const deleteQuery = this.deleteTypeormMetadataSql({
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name
          });
          const insertQuery = this.insertTypeormMetadataSql({
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name,
            value: column.asExpression
          });
          upQueries.push(deleteQuery);
          downQueries.push(insertQuery);
        }
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Creates a new view.
       */
      async createView(view, syncWithMetadata = false) {
        const upQueries = [];
        const downQueries = [];
        upQueries.push(this.createViewSql(view));
        if (syncWithMetadata)
          upQueries.push(this.insertViewDefinitionSql(view));
        downQueries.push(this.dropViewSql(view));
        if (syncWithMetadata)
          downQueries.push(this.deleteViewDefinitionSql(view));
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Drops the view.
       */
      async dropView(target) {
        const viewName = InstanceChecker_1.InstanceChecker.isView(target) ? target.name : target;
        const view = await this.getCachedView(viewName);
        const upQueries = [];
        const downQueries = [];
        upQueries.push(this.deleteViewDefinitionSql(view));
        upQueries.push(this.dropViewSql(view));
        downQueries.push(this.insertViewDefinitionSql(view));
        downQueries.push(this.createViewSql(view));
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Renames the given table.
       */
      async renameTable(oldTableOrName, newTableName) {
        const oldTable = InstanceChecker_1.InstanceChecker.isTable(oldTableOrName) ? oldTableOrName : await this.getCachedTable(oldTableOrName);
        const newTable = oldTable.clone();
        newTable.name = newTableName;
        const up = new Query_1.Query(`ALTER TABLE ${this.escapePath(oldTable.name)} RENAME TO ${this.escapePath(newTableName)}`);
        const down = new Query_1.Query(`ALTER TABLE ${this.escapePath(newTableName)} RENAME TO ${this.escapePath(oldTable.name)}`);
        await this.executeQueries(up, down);
        newTable.uniques.forEach((unique) => {
          const oldUniqueName = this.connection.namingStrategy.uniqueConstraintName(oldTable, unique.columnNames);
          if (unique.name !== oldUniqueName)
            return;
          unique.name = this.connection.namingStrategy.uniqueConstraintName(newTable, unique.columnNames);
        });
        newTable.foreignKeys.forEach((foreignKey) => {
          const oldForeignKeyName = this.connection.namingStrategy.foreignKeyName(oldTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
          if (foreignKey.name !== oldForeignKeyName)
            return;
          foreignKey.name = this.connection.namingStrategy.foreignKeyName(newTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
        });
        newTable.indices.forEach((index) => {
          const oldIndexName = this.connection.namingStrategy.indexName(oldTable, index.columnNames, index.where);
          if (index.name !== oldIndexName)
            return;
          index.name = this.connection.namingStrategy.indexName(newTable, index.columnNames, index.where);
        });
        oldTable.name = newTable.name;
        await this.recreateTable(newTable, oldTable);
      }
      /**
       * Creates a new column from the column in the table.
       */
      async addColumn(tableOrName, column) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        return this.addColumns(table, [column]);
      }
      /**
       * Creates a new columns from the column in the table.
       */
      async addColumns(tableOrName, columns) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const changedTable = table.clone();
        columns.forEach((column) => changedTable.addColumn(column));
        await this.recreateTable(changedTable, table);
      }
      /**
       * Renames column in the given table.
       */
      async renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const oldColumn = InstanceChecker_1.InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find((c) => c.name === oldTableColumnOrName);
        if (!oldColumn)
          throw new error_1.TypeORMError(`Column "${oldTableColumnOrName}" was not found in the "${table.name}" table.`);
        let newColumn = void 0;
        if (InstanceChecker_1.InstanceChecker.isTableColumn(newTableColumnOrName)) {
          newColumn = newTableColumnOrName;
        } else {
          newColumn = oldColumn.clone();
          newColumn.name = newTableColumnOrName;
        }
        return this.changeColumn(table, oldColumn, newColumn);
      }
      /**
       * Changes a column in the table.
       */
      async changeColumn(tableOrName, oldTableColumnOrName, newColumn) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const oldColumn = InstanceChecker_1.InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find((c) => c.name === oldTableColumnOrName);
        if (!oldColumn)
          throw new error_1.TypeORMError(`Column "${oldTableColumnOrName}" was not found in the "${table.name}" table.`);
        await this.changeColumns(table, [{ oldColumn, newColumn }]);
      }
      /**
       * Changes a column in the table.
       * Changed column looses all its keys in the db.
       */
      async changeColumns(tableOrName, changedColumns) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const changedTable = table.clone();
        changedColumns.forEach((changedColumnSet) => {
          if (changedColumnSet.newColumn.name !== changedColumnSet.oldColumn.name) {
            changedTable.findColumnUniques(changedColumnSet.oldColumn).forEach((unique) => {
              const uniqueName = this.connection.namingStrategy.uniqueConstraintName(table, unique.columnNames);
              unique.columnNames.splice(unique.columnNames.indexOf(changedColumnSet.oldColumn.name), 1);
              unique.columnNames.push(changedColumnSet.newColumn.name);
              if (unique.name === uniqueName) {
                unique.name = this.connection.namingStrategy.uniqueConstraintName(changedTable, unique.columnNames);
              }
            });
            changedTable.findColumnForeignKeys(changedColumnSet.oldColumn).forEach((foreignKey) => {
              const foreignKeyName = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
              foreignKey.columnNames.splice(foreignKey.columnNames.indexOf(changedColumnSet.oldColumn.name), 1);
              foreignKey.columnNames.push(changedColumnSet.newColumn.name);
              if (foreignKey.name === foreignKeyName) {
                foreignKey.name = this.connection.namingStrategy.foreignKeyName(changedTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
              }
            });
            changedTable.findColumnIndices(changedColumnSet.oldColumn).forEach((index) => {
              const indexName = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);
              index.columnNames.splice(index.columnNames.indexOf(changedColumnSet.oldColumn.name), 1);
              index.columnNames.push(changedColumnSet.newColumn.name);
              if (index.name === indexName) {
                index.name = this.connection.namingStrategy.indexName(changedTable, index.columnNames, index.where);
              }
            });
          }
          const originalColumn = changedTable.columns.find((column) => column.name === changedColumnSet.oldColumn.name);
          if (originalColumn)
            changedTable.columns[changedTable.columns.indexOf(originalColumn)] = changedColumnSet.newColumn;
        });
        await this.recreateTable(changedTable, table);
      }
      /**
       * Drops column in the table.
       */
      async dropColumn(tableOrName, columnOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const column = InstanceChecker_1.InstanceChecker.isTableColumn(columnOrName) ? columnOrName : table.findColumnByName(columnOrName);
        if (!column)
          throw new error_1.TypeORMError(`Column "${columnOrName}" was not found in table "${table.name}"`);
        await this.dropColumns(table, [column]);
      }
      /**
       * Drops the columns in the table.
       */
      async dropColumns(tableOrName, columns) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const changedTable = table.clone();
        columns.forEach((column) => {
          const columnInstance = InstanceChecker_1.InstanceChecker.isTableColumn(column) ? column : table.findColumnByName(column);
          if (!columnInstance)
            throw new Error(`Column "${column}" was not found in table "${table.name}"`);
          changedTable.removeColumn(columnInstance);
          changedTable.findColumnUniques(columnInstance).forEach((unique) => changedTable.removeUniqueConstraint(unique));
          changedTable.findColumnIndices(columnInstance).forEach((index) => changedTable.removeIndex(index));
          changedTable.findColumnForeignKeys(columnInstance).forEach((fk) => changedTable.removeForeignKey(fk));
        });
        await this.recreateTable(changedTable, table);
      }
      /**
       * Creates a new primary key.
       */
      async createPrimaryKey(tableOrName, columnNames) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const changedTable = table.clone();
        changedTable.columns.forEach((column) => {
          if (columnNames.find((columnName) => columnName === column.name))
            column.isPrimary = true;
        });
        await this.recreateTable(changedTable, table);
        table.columns.forEach((column) => {
          if (columnNames.find((columnName) => columnName === column.name))
            column.isPrimary = true;
        });
      }
      /**
       * Updates composite primary keys.
       */
      async updatePrimaryKeys(tableOrName, columns) {
        await Promise.resolve();
      }
      /**
       * Drops a primary key.
       */
      async dropPrimaryKey(tableOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const changedTable = table.clone();
        changedTable.primaryColumns.forEach((column) => {
          column.isPrimary = false;
        });
        await this.recreateTable(changedTable, table);
        table.primaryColumns.forEach((column) => {
          column.isPrimary = false;
        });
      }
      /**
       * Creates a new unique constraint.
       */
      async createUniqueConstraint(tableOrName, uniqueConstraint) {
        await this.createUniqueConstraints(tableOrName, [uniqueConstraint]);
      }
      /**
       * Creates a new unique constraints.
       */
      async createUniqueConstraints(tableOrName, uniqueConstraints) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const changedTable = table.clone();
        uniqueConstraints.forEach((uniqueConstraint) => changedTable.addUniqueConstraint(uniqueConstraint));
        await this.recreateTable(changedTable, table);
      }
      /**
       * Drops an unique constraint.
       */
      async dropUniqueConstraint(tableOrName, uniqueOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const uniqueConstraint = InstanceChecker_1.InstanceChecker.isTableUnique(uniqueOrName) ? uniqueOrName : table.uniques.find((u) => u.name === uniqueOrName);
        if (!uniqueConstraint)
          throw new error_1.TypeORMError(`Supplied unique constraint was not found in table ${table.name}`);
        await this.dropUniqueConstraints(table, [uniqueConstraint]);
      }
      /**
       * Creates an unique constraints.
       */
      async dropUniqueConstraints(tableOrName, uniqueConstraints) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const changedTable = table.clone();
        uniqueConstraints.forEach((uniqueConstraint) => changedTable.removeUniqueConstraint(uniqueConstraint));
        await this.recreateTable(changedTable, table);
      }
      /**
       * Creates new check constraint.
       */
      async createCheckConstraint(tableOrName, checkConstraint) {
        await this.createCheckConstraints(tableOrName, [checkConstraint]);
      }
      /**
       * Creates new check constraints.
       */
      async createCheckConstraints(tableOrName, checkConstraints) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const changedTable = table.clone();
        checkConstraints.forEach((checkConstraint) => changedTable.addCheckConstraint(checkConstraint));
        await this.recreateTable(changedTable, table);
      }
      /**
       * Drops check constraint.
       */
      async dropCheckConstraint(tableOrName, checkOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const checkConstraint = InstanceChecker_1.InstanceChecker.isTableCheck(checkOrName) ? checkOrName : table.checks.find((c) => c.name === checkOrName);
        if (!checkConstraint)
          throw new error_1.TypeORMError(`Supplied check constraint was not found in table ${table.name}`);
        await this.dropCheckConstraints(table, [checkConstraint]);
      }
      /**
       * Drops check constraints.
       */
      async dropCheckConstraints(tableOrName, checkConstraints) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const changedTable = table.clone();
        checkConstraints.forEach((checkConstraint) => changedTable.removeCheckConstraint(checkConstraint));
        await this.recreateTable(changedTable, table);
      }
      /**
       * Creates a new exclusion constraint.
       */
      async createExclusionConstraint(tableOrName, exclusionConstraint) {
        throw new error_1.TypeORMError(`Sqlite does not support exclusion constraints.`);
      }
      /**
       * Creates a new exclusion constraints.
       */
      async createExclusionConstraints(tableOrName, exclusionConstraints) {
        throw new error_1.TypeORMError(`Sqlite does not support exclusion constraints.`);
      }
      /**
       * Drops exclusion constraint.
       */
      async dropExclusionConstraint(tableOrName, exclusionOrName) {
        throw new error_1.TypeORMError(`Sqlite does not support exclusion constraints.`);
      }
      /**
       * Drops exclusion constraints.
       */
      async dropExclusionConstraints(tableOrName, exclusionConstraints) {
        throw new error_1.TypeORMError(`Sqlite does not support exclusion constraints.`);
      }
      /**
       * Creates a new foreign key.
       */
      async createForeignKey(tableOrName, foreignKey) {
        await this.createForeignKeys(tableOrName, [foreignKey]);
      }
      /**
       * Creates a new foreign keys.
       */
      async createForeignKeys(tableOrName, foreignKeys) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const changedTable = table.clone();
        foreignKeys.forEach((foreignKey) => changedTable.addForeignKey(foreignKey));
        await this.recreateTable(changedTable, table);
      }
      /**
       * Drops a foreign key from the table.
       */
      async dropForeignKey(tableOrName, foreignKeyOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const foreignKey = InstanceChecker_1.InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName : table.foreignKeys.find((fk) => fk.name === foreignKeyOrName);
        if (!foreignKey)
          throw new error_1.TypeORMError(`Supplied foreign key was not found in table ${table.name}`);
        await this.dropForeignKeys(tableOrName, [foreignKey]);
      }
      /**
       * Drops a foreign keys from the table.
       */
      async dropForeignKeys(tableOrName, foreignKeys) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const changedTable = table.clone();
        foreignKeys.forEach((foreignKey) => changedTable.removeForeignKey(foreignKey));
        await this.recreateTable(changedTable, table);
      }
      /**
       * Creates a new index.
       */
      async createIndex(tableOrName, index) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        if (!index.name)
          index.name = this.generateIndexName(table, index);
        const up = this.createIndexSql(table, index);
        const down = this.dropIndexSql(index);
        await this.executeQueries(up, down);
        table.addIndex(index);
      }
      /**
       * Creates a new indices
       */
      async createIndices(tableOrName, indices) {
        const promises = indices.map((index) => this.createIndex(tableOrName, index));
        await Promise.all(promises);
      }
      /**
       * Drops an index from the table.
       */
      async dropIndex(tableOrName, indexOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const index = InstanceChecker_1.InstanceChecker.isTableIndex(indexOrName) ? indexOrName : table.indices.find((i) => i.name === indexOrName);
        if (!index)
          throw new error_1.TypeORMError(`Supplied index ${indexOrName} was not found in table ${table.name}`);
        if (!index.name)
          index.name = this.generateIndexName(table, index);
        const up = this.dropIndexSql(index);
        const down = this.createIndexSql(table, index);
        await this.executeQueries(up, down);
        table.removeIndex(index);
      }
      /**
       * Drops an indices from the table.
       */
      async dropIndices(tableOrName, indices) {
        const promises = indices.map((index) => this.dropIndex(tableOrName, index));
        await Promise.all(promises);
      }
      /**
       * Clears all table contents.
       * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.
       */
      async clearTable(tableName) {
        await this.query(`DELETE FROM ${this.escapePath(tableName)}`);
      }
      /**
       * Removes all tables from the currently connected database.
       */
      async clearDatabase(database) {
        let dbPath = void 0;
        if (database && this.driver.getAttachedDatabaseHandleByRelativePath(database)) {
          dbPath = this.driver.getAttachedDatabaseHandleByRelativePath(database);
        }
        await this.query(`PRAGMA foreign_keys = OFF`);
        const isAnotherTransactionActive = this.isTransactionActive;
        if (!isAnotherTransactionActive)
          await this.startTransaction();
        try {
          const selectViewDropsQuery = dbPath ? `SELECT 'DROP VIEW "${dbPath}"."' || name || '";' as query FROM "${dbPath}"."sqlite_master" WHERE "type" = 'view'` : `SELECT 'DROP VIEW "' || name || '";' as query FROM "sqlite_master" WHERE "type" = 'view'`;
          const dropViewQueries = await this.query(selectViewDropsQuery);
          await Promise.all(dropViewQueries.map((q) => this.query(q["query"])));
          const selectTableDropsQuery = dbPath ? `SELECT 'DROP TABLE "${dbPath}"."' || name || '";' as query FROM "${dbPath}"."sqlite_master" WHERE "type" = 'table' AND "name" != 'sqlite_sequence'` : `SELECT 'DROP TABLE "' || name || '";' as query FROM "sqlite_master" WHERE "type" = 'table' AND "name" != 'sqlite_sequence'`;
          const dropTableQueries = await this.query(selectTableDropsQuery);
          await Promise.all(dropTableQueries.map((q) => this.query(q["query"])));
          if (!isAnotherTransactionActive)
            await this.commitTransaction();
        } catch (error) {
          try {
            if (!isAnotherTransactionActive)
              await this.rollbackTransaction();
          } catch (rollbackError) {
          }
          throw error;
        } finally {
          await this.query(`PRAGMA foreign_keys = ON`);
        }
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      async loadViews(viewNames) {
        const hasTable = await this.hasTable(this.getTypeormMetadataTableName());
        if (!hasTable) {
          return [];
        }
        if (!viewNames) {
          viewNames = [];
        }
        const viewNamesString = viewNames.map((name) => "'" + name + "'").join(", ");
        let query = `SELECT "t".* FROM "${this.getTypeormMetadataTableName()}" "t" INNER JOIN "sqlite_master" s ON "s"."name" = "t"."name" AND "s"."type" = 'view' WHERE "t"."type" = '${MetadataTableType_1.MetadataTableType.VIEW}'`;
        if (viewNamesString.length > 0)
          query += ` AND "t"."name" IN (${viewNamesString})`;
        const dbViews = await this.query(query);
        return dbViews.map((dbView) => {
          const view = new View_1.View();
          view.name = dbView["name"];
          view.expression = dbView["value"];
          return view;
        });
      }
      async loadTableRecords(tablePath, tableOrIndex) {
        let database = void 0;
        const [schema, tableName] = this.splitTablePath(tablePath);
        if (schema && this.driver.getAttachedDatabasePathRelativeByHandle(schema)) {
          database = this.driver.getAttachedDatabasePathRelativeByHandle(schema);
        }
        return this.query(`SELECT ${database ? `'${database}'` : null} as database, ${schema ? `'${schema}'` : null} as schema, * FROM ${schema ? `"${schema}".` : ""}${this.escapePath(`sqlite_master`)} WHERE "type" = '${tableOrIndex}' AND "${tableOrIndex === "table" ? "name" : "tbl_name"}" IN ('${tableName}')`);
      }
      async loadPragmaRecords(tablePath, pragma) {
        const [, tableName] = this.splitTablePath(tablePath);
        return this.query(`PRAGMA ${pragma}("${tableName}")`);
      }
      /**
       * Loads all tables (with given names) from the database and creates a Table from them.
       */
      async loadTables(tableNames) {
        if (tableNames && tableNames.length === 0) {
          return [];
        }
        let dbTables = [];
        let dbIndicesDef;
        if (!tableNames) {
          const tablesSql = `SELECT * FROM "sqlite_master" WHERE "type" = 'table'`;
          dbTables.push(...await this.query(tablesSql));
          const tableNamesString = dbTables.map(({ name }) => `'${name}'`).join(", ");
          dbIndicesDef = await this.query(`SELECT * FROM "sqlite_master" WHERE "type" = 'index' AND "tbl_name" IN (${tableNamesString})`);
        } else {
          const tableNamesWithoutDot = tableNames.filter((tableName) => {
            return tableName.split(".").length === 1;
          }).map((tableName) => `'${tableName}'`);
          const tableNamesWithDot = tableNames.filter((tableName) => {
            return tableName.split(".").length > 1;
          });
          const queryPromises = (type) => {
            const promises = [
              ...tableNamesWithDot.map((tableName) => this.loadTableRecords(tableName, type))
            ];
            if (tableNamesWithoutDot.length) {
              promises.push(this.query(`SELECT * FROM "sqlite_master" WHERE "type" = '${type}' AND "${type === "table" ? "name" : "tbl_name"}" IN (${tableNamesWithoutDot})`));
            }
            return promises;
          };
          dbTables = (await Promise.all(queryPromises("table"))).reduce((acc, res) => [...acc, ...res], []).filter(Boolean);
          dbIndicesDef = (await Promise.all(queryPromises("index"))).reduce((acc, res) => [...acc, ...res], []).filter(Boolean);
        }
        if (dbTables.length === 0) {
          return [];
        }
        return Promise.all(dbTables.map(async (dbTable) => {
          const tablePath = dbTable["database"] && this.driver.getAttachedDatabaseHandleByRelativePath(dbTable["database"]) ? `${this.driver.getAttachedDatabaseHandleByRelativePath(dbTable["database"])}.${dbTable["name"]}` : dbTable["name"];
          const sql = dbTable["sql"];
          const withoutRowid = sql.includes("WITHOUT ROWID");
          const table = new Table_1.Table({ name: tablePath, withoutRowid });
          const [dbColumns, dbIndices, dbForeignKeys] = await Promise.all([
            this.loadPragmaRecords(tablePath, `table_xinfo`),
            this.loadPragmaRecords(tablePath, `index_list`),
            this.loadPragmaRecords(tablePath, `foreign_key_list`)
          ]);
          let autoIncrementColumnName = void 0;
          const tableSql = dbTable["sql"];
          const autoIncrementIndex = tableSql.toUpperCase().indexOf("AUTOINCREMENT");
          if (autoIncrementIndex !== -1) {
            autoIncrementColumnName = tableSql.substr(0, autoIncrementIndex);
            const comma = autoIncrementColumnName.lastIndexOf(",");
            const bracket = autoIncrementColumnName.lastIndexOf("(");
            if (comma !== -1) {
              autoIncrementColumnName = autoIncrementColumnName.substr(comma);
              autoIncrementColumnName = autoIncrementColumnName.substr(0, autoIncrementColumnName.lastIndexOf('"'));
              autoIncrementColumnName = autoIncrementColumnName.substr(autoIncrementColumnName.indexOf('"') + 1);
            } else if (bracket !== -1) {
              autoIncrementColumnName = autoIncrementColumnName.substr(bracket);
              autoIncrementColumnName = autoIncrementColumnName.substr(0, autoIncrementColumnName.lastIndexOf('"'));
              autoIncrementColumnName = autoIncrementColumnName.substr(autoIncrementColumnName.indexOf('"') + 1);
            }
          }
          table.columns = await Promise.all(dbColumns.map(async (dbColumn) => {
            const tableColumn = new TableColumn_1.TableColumn();
            tableColumn.name = dbColumn["name"];
            tableColumn.type = dbColumn["type"].toLowerCase();
            tableColumn.default = dbColumn["dflt_value"] !== null && dbColumn["dflt_value"] !== void 0 ? dbColumn["dflt_value"] : void 0;
            tableColumn.isNullable = dbColumn["notnull"] === 0;
            tableColumn.isPrimary = dbColumn["pk"] > 0;
            tableColumn.comment = "";
            tableColumn.isGenerated = autoIncrementColumnName === dbColumn["name"];
            if (tableColumn.isGenerated) {
              tableColumn.generationStrategy = "increment";
            }
            if (dbColumn["hidden"] === 2 || dbColumn["hidden"] === 3) {
              tableColumn.generatedType = dbColumn["hidden"] === 2 ? "VIRTUAL" : "STORED";
              const asExpressionQuery = this.selectTypeormMetadataSql({
                table: table.name,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: tableColumn.name
              });
              const results = await this.query(asExpressionQuery.query, asExpressionQuery.parameters);
              if (results[0] && results[0].value) {
                tableColumn.asExpression = results[0].value;
              } else {
                tableColumn.asExpression = "";
              }
            }
            if (tableColumn.type === "varchar") {
              tableColumn.enum = OrmUtils_1.OrmUtils.parseSqlCheckExpression(sql, tableColumn.name);
            }
            const pos = tableColumn.type.indexOf("(");
            if (pos !== -1) {
              const fullType = tableColumn.type;
              const dataType = fullType.substr(0, pos);
              if (this.driver.withLengthColumnTypes.find((col) => col === dataType)) {
                const len = parseInt(fullType.substring(pos + 1, fullType.length - 1));
                if (len) {
                  tableColumn.length = len.toString();
                  tableColumn.type = dataType;
                }
              }
              if (this.driver.withPrecisionColumnTypes.find((col) => col === dataType)) {
                const re = new RegExp(`^${dataType}\\((\\d+),?\\s?(\\d+)?\\)`);
                const matches = fullType.match(re);
                if (matches && matches[1]) {
                  tableColumn.precision = +matches[1];
                }
                if (this.driver.withScaleColumnTypes.find((col) => col === dataType)) {
                  if (matches && matches[2]) {
                    tableColumn.scale = +matches[2];
                  }
                }
                tableColumn.type = dataType;
              }
            }
            return tableColumn;
          }));
          let fkResult;
          const fkMappings = [];
          const fkRegex = /CONSTRAINT "([^"]*)" FOREIGN KEY ?\((.*?)\) REFERENCES "([^"]*)"/g;
          while ((fkResult = fkRegex.exec(sql)) !== null) {
            fkMappings.push({
              name: fkResult[1],
              columns: fkResult[2].substr(1, fkResult[2].length - 2).split(`", "`),
              referencedTableName: fkResult[3]
            });
          }
          const tableForeignKeyConstraints = OrmUtils_1.OrmUtils.uniq(dbForeignKeys, (dbForeignKey) => dbForeignKey["id"]);
          table.foreignKeys = tableForeignKeyConstraints.map((foreignKey) => {
            const ownForeignKeys = dbForeignKeys.filter((dbForeignKey) => dbForeignKey["id"] === foreignKey["id"] && dbForeignKey["table"] === foreignKey["table"]);
            const columnNames = ownForeignKeys.map((dbForeignKey) => dbForeignKey["from"]);
            const referencedColumnNames = ownForeignKeys.map((dbForeignKey) => dbForeignKey["to"]);
            const fkMapping = fkMappings.find((it) => it.referencedTableName === foreignKey["table"] && it.columns.every((column) => columnNames.indexOf(column) !== -1));
            return new TableForeignKey_1.TableForeignKey({
              name: fkMapping?.name,
              columnNames,
              referencedTableName: foreignKey["table"],
              referencedColumnNames,
              onDelete: foreignKey["on_delete"],
              onUpdate: foreignKey["on_update"]
            });
          });
          let uniqueRegexResult;
          const uniqueMappings = [];
          const uniqueRegex = /CONSTRAINT "([^"]*)" UNIQUE ?\((.*?)\)/g;
          while ((uniqueRegexResult = uniqueRegex.exec(sql)) !== null) {
            uniqueMappings.push({
              name: uniqueRegexResult[1],
              columns: uniqueRegexResult[2].substr(1, uniqueRegexResult[2].length - 2).split(`", "`)
            });
          }
          const tableUniquePromises = dbIndices.filter((dbIndex) => dbIndex["origin"] === "u").map((dbIndex) => dbIndex["name"]).filter((value, index, self2) => self2.indexOf(value) === index).map(async (dbIndexName) => {
            const dbIndex = dbIndices.find((dbIndex2) => dbIndex2["name"] === dbIndexName);
            const indexInfos = await this.query(`PRAGMA index_info("${dbIndex["name"]}")`);
            const indexColumns = indexInfos.sort((indexInfo1, indexInfo2) => parseInt(indexInfo1["seqno"]) - parseInt(indexInfo2["seqno"])).map((indexInfo) => indexInfo["name"]);
            if (indexColumns.length === 1) {
              const column = table.columns.find((column2) => {
                return !!indexColumns.find((indexColumn) => indexColumn === column2.name);
              });
              if (column)
                column.isUnique = true;
            }
            const foundMapping = uniqueMappings.find((mapping) => {
              return mapping.columns.every((column) => indexColumns.indexOf(column) !== -1);
            });
            return new TableUnique_1.TableUnique({
              name: foundMapping ? foundMapping.name : this.connection.namingStrategy.uniqueConstraintName(table, indexColumns),
              columnNames: indexColumns
            });
          });
          table.uniques = await Promise.all(tableUniquePromises);
          let result;
          const regexp = /CONSTRAINT "([^"]*)" CHECK ?(\(.*?\))([,]|[)]$)/g;
          while ((result = regexp.exec(sql)) !== null) {
            table.checks.push(new TableCheck_1.TableCheck({
              name: result[1],
              expression: result[2]
            }));
          }
          const indicesPromises = dbIndices.filter((dbIndex) => dbIndex["origin"] === "c").map((dbIndex) => dbIndex["name"]).filter((value, index, self2) => self2.indexOf(value) === index).map(async (dbIndexName) => {
            const indexDef = dbIndicesDef.find((dbIndexDef) => dbIndexDef["name"] === dbIndexName);
            const condition = /WHERE (.*)/.exec(indexDef["sql"]);
            const dbIndex = dbIndices.find((dbIndex2) => dbIndex2["name"] === dbIndexName);
            const indexInfos = await this.query(`PRAGMA index_info("${dbIndex["name"]}")`);
            const indexColumns = indexInfos.sort((indexInfo1, indexInfo2) => parseInt(indexInfo1["seqno"]) - parseInt(indexInfo2["seqno"])).map((indexInfo) => indexInfo["name"]);
            const dbIndexPath = `${dbTable["database"] ? `${dbTable["database"]}.` : ""}${dbIndex["name"]}`;
            const isUnique = dbIndex["unique"] === "1" || dbIndex["unique"] === 1;
            return new TableIndex_1.TableIndex({
              table,
              name: dbIndexPath,
              columnNames: indexColumns,
              isUnique,
              where: condition ? condition[1] : void 0
            });
          });
          const indices = await Promise.all(indicesPromises);
          table.indices = indices.filter((index) => !!index);
          return table;
        }));
      }
      /**
       * Builds create table sql.
       */
      createTableSql(table, createForeignKeys, temporaryTable) {
        const primaryColumns = table.columns.filter((column) => column.isPrimary);
        const hasAutoIncrement = primaryColumns.find((column) => column.isGenerated && column.generationStrategy === "increment");
        const skipPrimary = primaryColumns.length > 1;
        if (skipPrimary && hasAutoIncrement)
          throw new error_1.TypeORMError(`Sqlite does not support AUTOINCREMENT on composite primary key`);
        const columnDefinitions = table.columns.map((column) => this.buildCreateColumnSql(column, skipPrimary)).join(", ");
        const [database] = this.splitTablePath(table.name);
        let sql = `CREATE TABLE ${this.escapePath(table.name)} (${columnDefinitions}`;
        const [databaseNew, tableName] = this.splitTablePath(table.name);
        const newTableName = temporaryTable ? `${databaseNew ? `${databaseNew}.` : ""}${tableName.replace(/^temporary_/, "")}` : table.name;
        table.columns.filter((column) => column.isUnique).forEach((column) => {
          const isUniqueExist = table.uniques.some((unique) => unique.columnNames.length === 1 && unique.columnNames[0] === column.name);
          if (!isUniqueExist)
            table.uniques.push(new TableUnique_1.TableUnique({
              name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),
              columnNames: [column.name]
            }));
        });
        if (table.uniques.length > 0) {
          const uniquesSql = table.uniques.map((unique) => {
            const uniqueName = unique.name ? unique.name : this.connection.namingStrategy.uniqueConstraintName(newTableName, unique.columnNames);
            const columnNames = unique.columnNames.map((columnName) => `"${columnName}"`).join(", ");
            return `CONSTRAINT "${uniqueName}" UNIQUE (${columnNames})`;
          }).join(", ");
          sql += `, ${uniquesSql}`;
        }
        if (table.checks.length > 0) {
          const checksSql = table.checks.map((check) => {
            const checkName = check.name ? check.name : this.connection.namingStrategy.checkConstraintName(newTableName, check.expression);
            return `CONSTRAINT "${checkName}" CHECK (${check.expression})`;
          }).join(", ");
          sql += `, ${checksSql}`;
        }
        if (table.foreignKeys.length > 0 && createForeignKeys) {
          const foreignKeysSql = table.foreignKeys.filter((fk) => {
            const [referencedDatabase] = this.splitTablePath(fk.referencedTableName);
            if (referencedDatabase !== database) {
              return false;
            }
            return true;
          }).map((fk) => {
            const [, referencedTable] = this.splitTablePath(fk.referencedTableName);
            const columnNames = fk.columnNames.map((columnName) => `"${columnName}"`).join(", ");
            if (!fk.name)
              fk.name = this.connection.namingStrategy.foreignKeyName(newTableName, fk.columnNames, this.getTablePath(fk), fk.referencedColumnNames);
            const referencedColumnNames = fk.referencedColumnNames.map((columnName) => `"${columnName}"`).join(", ");
            let constraint = `CONSTRAINT "${fk.name}" FOREIGN KEY (${columnNames}) REFERENCES "${referencedTable}" (${referencedColumnNames})`;
            if (fk.onDelete)
              constraint += ` ON DELETE ${fk.onDelete}`;
            if (fk.onUpdate)
              constraint += ` ON UPDATE ${fk.onUpdate}`;
            if (fk.deferrable)
              constraint += ` DEFERRABLE ${fk.deferrable}`;
            return constraint;
          }).join(", ");
          sql += `, ${foreignKeysSql}`;
        }
        if (primaryColumns.length > 1) {
          const columnNames = primaryColumns.map((column) => `"${column.name}"`).join(", ");
          sql += `, PRIMARY KEY (${columnNames})`;
        }
        sql += `)`;
        if (table.withoutRowid) {
          sql += " WITHOUT ROWID";
        }
        return new Query_1.Query(sql);
      }
      /**
       * Builds drop table sql.
       */
      dropTableSql(tableOrName, ifExist) {
        const tableName = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName.name : tableOrName;
        const query = ifExist ? `DROP TABLE IF EXISTS ${this.escapePath(tableName)}` : `DROP TABLE ${this.escapePath(tableName)}`;
        return new Query_1.Query(query);
      }
      createViewSql(view) {
        if (typeof view.expression === "string") {
          return new Query_1.Query(`CREATE VIEW "${view.name}" AS ${view.expression}`);
        } else {
          return new Query_1.Query(`CREATE VIEW "${view.name}" AS ${view.expression(this.connection).getQuery()}`);
        }
      }
      insertViewDefinitionSql(view) {
        const expression = typeof view.expression === "string" ? view.expression.trim() : view.expression(this.connection).getQuery();
        return this.insertTypeormMetadataSql({
          type: MetadataTableType_1.MetadataTableType.VIEW,
          name: view.name,
          value: expression
        });
      }
      /**
       * Builds drop view sql.
       */
      dropViewSql(viewOrPath) {
        const viewName = InstanceChecker_1.InstanceChecker.isView(viewOrPath) ? viewOrPath.name : viewOrPath;
        return new Query_1.Query(`DROP VIEW "${viewName}"`);
      }
      /**
       * Builds remove view sql.
       */
      deleteViewDefinitionSql(viewOrPath) {
        const viewName = InstanceChecker_1.InstanceChecker.isView(viewOrPath) ? viewOrPath.name : viewOrPath;
        return this.deleteTypeormMetadataSql({
          type: MetadataTableType_1.MetadataTableType.VIEW,
          name: viewName
        });
      }
      /**
       * Builds create index sql.
       */
      createIndexSql(table, index) {
        const columns = index.columnNames.map((columnName) => `"${columnName}"`).join(", ");
        const [database, tableName] = this.splitTablePath(table.name);
        return new Query_1.Query(`CREATE ${index.isUnique ? "UNIQUE " : ""}INDEX ${database ? `"${database}".` : ""}${this.escapePath(index.name)} ON "${tableName}" (${columns}) ${index.where ? "WHERE " + index.where : ""}`);
      }
      /**
       * Builds drop index sql.
       */
      dropIndexSql(indexOrName) {
        const indexName = InstanceChecker_1.InstanceChecker.isTableIndex(indexOrName) ? indexOrName.name : indexOrName;
        return new Query_1.Query(`DROP INDEX ${this.escapePath(indexName)}`);
      }
      /**
       * Builds a query for create column.
       */
      buildCreateColumnSql(column, skipPrimary) {
        let c = '"' + column.name + '"';
        if (InstanceChecker_1.InstanceChecker.isColumnMetadata(column)) {
          c += " " + this.driver.normalizeType(column);
        } else {
          c += " " + this.connection.driver.createFullType(column);
        }
        if (column.enum)
          c += ' CHECK( "' + column.name + '" IN (' + column.enum.map((val) => "'" + val + "'").join(",") + ") )";
        if (column.isPrimary && !skipPrimary)
          c += " PRIMARY KEY";
        if (column.isGenerated === true && column.generationStrategy === "increment")
          c += " AUTOINCREMENT";
        if (column.collation)
          c += " COLLATE " + column.collation;
        if (column.isNullable !== true)
          c += " NOT NULL";
        if (column.asExpression) {
          c += ` AS (${column.asExpression}) ${column.generatedType ? column.generatedType : "VIRTUAL"}`;
        } else {
          if (column.default !== void 0 && column.default !== null)
            c += " DEFAULT (" + column.default + ")";
        }
        return c;
      }
      async recreateTable(newTable, oldTable, migrateData = true) {
        const upQueries = [];
        const downQueries = [];
        oldTable.indices.forEach((index) => {
          upQueries.push(this.dropIndexSql(index));
          downQueries.push(this.createIndexSql(oldTable, index));
        });
        let [databaseNew, tableNameNew] = this.splitTablePath(newTable.name);
        const [, tableNameOld] = this.splitTablePath(oldTable.name);
        newTable.name = tableNameNew = `${databaseNew ? `${databaseNew}.` : ""}temporary_${tableNameNew}`;
        upQueries.push(this.createTableSql(newTable, true, true));
        downQueries.push(this.dropTableSql(newTable));
        if (migrateData) {
          let newColumnNames = newTable.columns.filter((column) => !column.generatedType).map((column) => `"${column.name}"`);
          let oldColumnNames = oldTable.columns.filter((column) => !column.generatedType).map((column) => `"${column.name}"`);
          if (oldColumnNames.length < newColumnNames.length) {
            newColumnNames = newTable.columns.filter((column) => {
              const oldColumn = oldTable.columns.find((c) => c.name === column.name);
              if (oldColumn && oldColumn.generatedType)
                return false;
              return !column.generatedType && oldColumn;
            }).map((column) => `"${column.name}"`);
          } else if (oldColumnNames.length > newColumnNames.length) {
            oldColumnNames = oldTable.columns.filter((column) => {
              return !column.generatedType && newTable.columns.find((c) => c.name === column.name);
            }).map((column) => `"${column.name}"`);
          }
          upQueries.push(new Query_1.Query(`INSERT INTO ${this.escapePath(newTable.name)}(${newColumnNames.join(", ")}) SELECT ${oldColumnNames.join(", ")} FROM ${this.escapePath(oldTable.name)}`));
          downQueries.push(new Query_1.Query(`INSERT INTO ${this.escapePath(oldTable.name)}(${oldColumnNames.join(", ")}) SELECT ${newColumnNames.join(", ")} FROM ${this.escapePath(newTable.name)}`));
        }
        upQueries.push(this.dropTableSql(oldTable));
        downQueries.push(this.createTableSql(oldTable, true));
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable.name)} RENAME TO ${this.escapePath(tableNameOld)}`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(oldTable.name)} RENAME TO ${this.escapePath(tableNameNew)}`));
        newTable.name = oldTable.name;
        newTable.indices.forEach((index) => {
          if (!index.name)
            index.name = this.connection.namingStrategy.indexName(newTable, index.columnNames, index.where);
          upQueries.push(this.createIndexSql(newTable, index));
          downQueries.push(this.dropIndexSql(index));
        });
        oldTable.columns.filter((column) => {
          const newTableColumn = newTable.columns.find((c) => c.name === column.name);
          return column.generatedType && column.asExpression && (!newTableColumn || !newTableColumn.generatedType && !newTableColumn.asExpression);
        }).forEach((column) => {
          const deleteQuery = this.deleteTypeormMetadataSql({
            table: oldTable.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name
          });
          const insertQuery = this.insertTypeormMetadataSql({
            table: oldTable.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name,
            value: column.asExpression
          });
          upQueries.push(deleteQuery);
          downQueries.push(insertQuery);
        });
        newTable.columns.filter((column) => column.generatedType && column.asExpression && !oldTable.columns.some((c) => c.name === column.name)).forEach((column) => {
          const insertQuery = this.insertTypeormMetadataSql({
            table: newTable.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name,
            value: column.asExpression
          });
          const deleteQuery = this.deleteTypeormMetadataSql({
            table: newTable.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name
          });
          upQueries.push(insertQuery);
          downQueries.push(deleteQuery);
        });
        newTable.columns.filter((column) => column.generatedType && column.asExpression).forEach((column) => {
          const oldColumn = oldTable.columns.find((c) => c.name === column.name && c.generatedType && column.generatedType && c.asExpression !== column.asExpression);
          if (!oldColumn)
            return;
          const deleteQuery = this.deleteTypeormMetadataSql({
            table: oldTable.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: oldColumn.name
          });
          const insertQuery = this.insertTypeormMetadataSql({
            table: newTable.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name,
            value: column.asExpression
          });
          upQueries.push(deleteQuery);
          upQueries.push(insertQuery);
          const revertInsertQuery = this.insertTypeormMetadataSql({
            table: newTable.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: oldColumn.name,
            value: oldColumn.asExpression
          });
          const revertDeleteQuery = this.deleteTypeormMetadataSql({
            table: oldTable.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name
          });
          downQueries.push(revertInsertQuery);
          downQueries.push(revertDeleteQuery);
        });
        await this.executeQueries(upQueries, downQueries);
        this.replaceCachedTable(oldTable, newTable);
      }
      /**
       * tablePath e.g. "myDB.myTable", "myTable"
       */
      splitTablePath(tablePath) {
        return tablePath.indexOf(".") !== -1 ? tablePath.split(".") : [void 0, tablePath];
      }
      /**
       * Escapes given table or view path. Tolerates leading/trailing dots
       */
      escapePath(target, disableEscape) {
        const tableName = InstanceChecker_1.InstanceChecker.isTable(target) || InstanceChecker_1.InstanceChecker.isView(target) ? target.name : target;
        return tableName.replace(/^\.+|\.+$/g, "").split(".").map((i) => disableEscape ? i : `"${i}"`).join(".");
      }
      /**
       * Change table comment.
       */
      changeTableComment(tableOrName, comment) {
        throw new error_1.TypeORMError(`sqlit driver does not support change comment.`);
      }
    };
    exports2.AbstractSqliteQueryRunner = AbstractSqliteQueryRunner;
  }
});

// node_modules/typeorm/driver/sqlite/SqliteQueryRunner.js
var require_SqliteQueryRunner = __commonJS({
  "node_modules/typeorm/driver/sqlite/SqliteQueryRunner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SqliteQueryRunner = void 0;
    var ConnectionIsNotSetError_1 = require_ConnectionIsNotSetError();
    var QueryFailedError_1 = require_QueryFailedError();
    var QueryRunnerAlreadyReleasedError_1 = require_QueryRunnerAlreadyReleasedError();
    var QueryResult_1 = require_QueryResult();
    var Broadcaster_1 = require_Broadcaster();
    var BroadcasterResult_1 = require_BroadcasterResult();
    var AbstractSqliteQueryRunner_1 = require_AbstractSqliteQueryRunner();
    var SqliteQueryRunner = class extends AbstractSqliteQueryRunner_1.AbstractSqliteQueryRunner {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(driver) {
        super();
        this.driver = driver;
        this.connection = driver.connection;
        this.broadcaster = new Broadcaster_1.Broadcaster(this);
      }
      /**
       * Called before migrations are run.
       */
      async beforeMigration() {
        await this.query(`PRAGMA foreign_keys = OFF`);
      }
      /**
       * Called after migrations are run.
       */
      async afterMigration() {
        await this.query(`PRAGMA foreign_keys = ON`);
      }
      /**
       * Executes a given SQL query.
       */
      async query(query, parameters, useStructuredResult = false) {
        if (this.isReleased)
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        const connection = this.driver.connection;
        const options = connection.options;
        const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
        const broadcaster = this.broadcaster;
        if (!connection.isInitialized) {
          throw new ConnectionIsNotSetError_1.ConnectionIsNotSetError("sqlite");
        }
        const databaseConnection = await this.connect();
        this.driver.connection.logger.logQuery(query, parameters, this);
        await broadcaster.broadcast("BeforeQuery", query, parameters);
        const broadcasterResult = new BroadcasterResult_1.BroadcasterResult();
        return new Promise(async (ok, fail) => {
          try {
            const queryStartTime = Date.now();
            const isInsertQuery = query.startsWith("INSERT ");
            const isDeleteQuery = query.startsWith("DELETE ");
            const isUpdateQuery = query.startsWith("UPDATE ");
            const execute = async () => {
              if (isInsertQuery || isDeleteQuery || isUpdateQuery) {
                await databaseConnection.run(query, parameters, handler2);
              } else {
                await databaseConnection.all(query, parameters, handler2);
              }
            };
            const self2 = this;
            const handler2 = function(err, rows) {
              if (err && err.toString().indexOf("SQLITE_BUSY:") !== -1) {
                if (typeof options.busyErrorRetry === "number" && options.busyErrorRetry > 0) {
                  setTimeout(execute, options.busyErrorRetry);
                  return;
                }
              }
              const queryEndTime = Date.now();
              const queryExecutionTime = queryEndTime - queryStartTime;
              if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime)
                connection.logger.logQuerySlow(queryExecutionTime, query, parameters, self2);
              if (err) {
                connection.logger.logQueryError(err, query, parameters, self2);
                broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, void 0, void 0, err);
                return fail(new QueryFailedError_1.QueryFailedError(query, parameters, err));
              } else {
                const result = new QueryResult_1.QueryResult();
                if (isInsertQuery) {
                  result.raw = this["lastID"];
                } else {
                  result.raw = rows;
                }
                broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, result.raw, void 0);
                if (Array.isArray(rows)) {
                  result.records = rows;
                }
                result.affected = this["changes"];
                if (useStructuredResult) {
                  ok(result);
                } else {
                  ok(result.raw);
                }
              }
            };
            await execute();
          } catch (err) {
            fail(err);
          } finally {
            await broadcasterResult.wait();
          }
        });
      }
    };
    exports2.SqliteQueryRunner = SqliteQueryRunner;
  }
});

// node_modules/typeorm/driver/sqlite-abstract/AbstractSqliteDriver.js
var require_AbstractSqliteDriver = __commonJS({
  "node_modules/typeorm/driver/sqlite-abstract/AbstractSqliteDriver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractSqliteDriver = void 0;
    var DateUtils_1 = require_DateUtils();
    var RdbmsSchemaBuilder_1 = require_RdbmsSchemaBuilder();
    var OrmUtils_1 = require_OrmUtils();
    var ApplyValueTransformers_1 = require_ApplyValueTransformers();
    var DriverUtils_1 = require_DriverUtils();
    var error_1 = require_error();
    var InstanceChecker_1 = require_InstanceChecker();
    var AbstractSqliteDriver = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection) {
        this.isReplicated = false;
        this.treeSupport = true;
        this.transactionSupport = "nested";
        this.supportedDataTypes = [
          "int",
          "integer",
          "tinyint",
          "smallint",
          "mediumint",
          "bigint",
          "unsigned big int",
          "int2",
          "int8",
          "integer",
          "character",
          "varchar",
          "varying character",
          "nchar",
          "native character",
          "nvarchar",
          "text",
          "clob",
          "text",
          "blob",
          "real",
          "double",
          "double precision",
          "float",
          "real",
          "numeric",
          "decimal",
          "boolean",
          "date",
          "time",
          "datetime",
          "json"
        ];
        this.supportedUpsertTypes = ["on-conflict-do-update"];
        this.withLengthColumnTypes = [
          "character",
          "varchar",
          "varying character",
          "nchar",
          "native character",
          "nvarchar",
          "text",
          "blob",
          "clob"
        ];
        this.spatialTypes = [];
        this.withPrecisionColumnTypes = [
          "real",
          "double",
          "double precision",
          "float",
          "real",
          "numeric",
          "decimal",
          "date",
          "time",
          "datetime"
        ];
        this.withScaleColumnTypes = [
          "real",
          "double",
          "double precision",
          "float",
          "real",
          "numeric",
          "decimal"
        ];
        this.mappedDataTypes = {
          createDate: "datetime",
          createDateDefault: "datetime('now')",
          updateDate: "datetime",
          updateDateDefault: "datetime('now')",
          deleteDate: "datetime",
          deleteDateNullable: true,
          version: "integer",
          treeLevel: "integer",
          migrationId: "integer",
          migrationName: "varchar",
          migrationTimestamp: "bigint",
          cacheId: "int",
          cacheIdentifier: "varchar",
          cacheTime: "bigint",
          cacheDuration: "int",
          cacheQuery: "text",
          cacheResult: "text",
          metadataType: "varchar",
          metadataDatabase: "varchar",
          metadataSchema: "varchar",
          metadataTable: "varchar",
          metadataName: "varchar",
          metadataValue: "text"
        };
        this.cteCapabilities = {
          enabled: true,
          requiresRecursiveHint: true
        };
        this.attachedDatabases = {};
        this.connection = connection;
        this.options = connection.options;
        this.database = DriverUtils_1.DriverUtils.buildDriverOptions(this.options).database;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Performs connection to the database.
       */
      async connect() {
        this.databaseConnection = await this.createDatabaseConnection();
      }
      /**
       * Makes any action after connection (e.g. create extensions in Postgres driver).
       */
      afterConnect() {
        return Promise.resolve();
      }
      /**
       * Closes connection with database.
       */
      async disconnect() {
        return new Promise((ok, fail) => {
          this.queryRunner = void 0;
          this.databaseConnection.close((err) => err ? fail(err) : ok());
        });
      }
      hasAttachedDatabases() {
        return !!Object.keys(this.attachedDatabases).length;
      }
      getAttachedDatabaseHandleByRelativePath(path) {
        return this.attachedDatabases?.[path]?.attachHandle;
      }
      getAttachedDatabasePathRelativeByHandle(handle) {
        return Object.values(this.attachedDatabases).find(({ attachHandle }) => handle === attachHandle)?.attachFilepathRelative;
      }
      /**
       * Creates a schema builder used to build and sync a schema.
       */
      createSchemaBuilder() {
        return new RdbmsSchemaBuilder_1.RdbmsSchemaBuilder(this.connection);
      }
      /**
       * Prepares given value to a value to be persisted, based on its column type and metadata.
       */
      preparePersistentValue(value, columnMetadata) {
        if (columnMetadata.transformer)
          value = ApplyValueTransformers_1.ApplyValueTransformers.transformTo(columnMetadata.transformer, value);
        if (value === null || value === void 0)
          return value;
        if (columnMetadata.type === Boolean || columnMetadata.type === "boolean") {
          return value === true ? 1 : 0;
        } else if (columnMetadata.type === "date") {
          return DateUtils_1.DateUtils.mixedDateToDateString(value);
        } else if (columnMetadata.type === "time") {
          return DateUtils_1.DateUtils.mixedDateToTimeString(value);
        } else if (columnMetadata.type === "datetime" || columnMetadata.type === Date) {
          return DateUtils_1.DateUtils.mixedDateToUtcDatetimeString(value);
        } else if (columnMetadata.type === "json" || columnMetadata.type === "simple-json") {
          return DateUtils_1.DateUtils.simpleJsonToString(value);
        } else if (columnMetadata.type === "simple-array") {
          return DateUtils_1.DateUtils.simpleArrayToString(value);
        } else if (columnMetadata.type === "simple-enum") {
          return DateUtils_1.DateUtils.simpleEnumToString(value);
        }
        return value;
      }
      /**
       * Prepares given value to a value to be hydrated, based on its column type or metadata.
       */
      prepareHydratedValue(value, columnMetadata) {
        if (value === null || value === void 0)
          return columnMetadata.transformer ? ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value) : value;
        if (columnMetadata.type === Boolean || columnMetadata.type === "boolean") {
          value = value ? true : false;
        } else if (columnMetadata.type === "datetime" || columnMetadata.type === Date) {
          if (value && typeof value === "string") {
            if (/^\d\d\d\d-\d\d-\d\d \d\d:\d\d/.test(value)) {
              value = value.replace(" ", "T");
            }
            if (/^\d\d\d\d-\d\d-\d\dT\d\d:\d\d(:\d\d(\.\d\d\d)?)?$/.test(value)) {
              value += "Z";
            }
          }
          value = DateUtils_1.DateUtils.normalizeHydratedDate(value);
        } else if (columnMetadata.type === "date") {
          value = DateUtils_1.DateUtils.mixedDateToDateString(value);
        } else if (columnMetadata.type === "time") {
          value = DateUtils_1.DateUtils.mixedTimeToString(value);
        } else if (columnMetadata.type === "json" || columnMetadata.type === "simple-json") {
          value = DateUtils_1.DateUtils.stringToSimpleJson(value);
        } else if (columnMetadata.type === "simple-array") {
          value = DateUtils_1.DateUtils.stringToSimpleArray(value);
        } else if (columnMetadata.type === "simple-enum") {
          value = DateUtils_1.DateUtils.stringToSimpleEnum(value, columnMetadata);
        } else if (columnMetadata.type === Number) {
          value = !isNaN(+value) ? parseInt(value) : value;
        }
        if (columnMetadata.transformer)
          value = ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);
        return value;
      }
      /**
       * Replaces parameters in the given sql with special escaping character
       * and an array of parameter names to be passed to a query.
       */
      escapeQueryWithParameters(sql, parameters, nativeParameters) {
        const escapedParameters = Object.keys(nativeParameters).map((key) => {
          if (typeof nativeParameters[key] === "boolean") {
            return nativeParameters[key] === true ? 1 : 0;
          }
          if (nativeParameters[key] instanceof Date) {
            return DateUtils_1.DateUtils.mixedDateToUtcDatetimeString(nativeParameters[key]);
          }
          return nativeParameters[key];
        });
        if (!parameters || !Object.keys(parameters).length)
          return [sql, escapedParameters];
        sql = sql.replace(/:(\.\.\.)?([A-Za-z0-9_.]+)/g, (full, isArray, key) => {
          if (!parameters.hasOwnProperty(key)) {
            return full;
          }
          const value = parameters[key];
          if (isArray) {
            return value.map((v) => {
              escapedParameters.push(v);
              return this.createParameter(key, escapedParameters.length - 1);
            }).join(", ");
          }
          if (typeof value === "function") {
            return value();
          } else if (typeof value === "number") {
            return String(value);
          }
          if (typeof value === "boolean") {
            escapedParameters.push(+value);
            return this.createParameter(key, escapedParameters.length - 1);
          }
          if (value instanceof Date) {
            escapedParameters.push(DateUtils_1.DateUtils.mixedDateToUtcDatetimeString(value));
            return this.createParameter(key, escapedParameters.length - 1);
          }
          escapedParameters.push(value);
          return this.createParameter(key, escapedParameters.length - 1);
        });
        return [sql, escapedParameters];
      }
      /**
       * Escapes a column name.
       */
      escape(columnName) {
        return '"' + columnName + '"';
      }
      /**
       * Build full table name with database name, schema name and table name.
       * E.g. myDB.mySchema.myTable
       *
       * Returns only simple table name because all inherited drivers does not supports schema and database.
       */
      buildTableName(tableName, schema, database) {
        return tableName;
      }
      /**
       * Parse a target table name or other types and return a normalized table definition.
       */
      parseTableName(target) {
        const driverDatabase = this.database;
        const driverSchema = void 0;
        if (InstanceChecker_1.InstanceChecker.isTable(target) || InstanceChecker_1.InstanceChecker.isView(target)) {
          const parsed = this.parseTableName(target.schema ? `"${target.schema}"."${target.name}"` : target.name);
          return {
            database: target.database || parsed.database || driverDatabase,
            schema: target.schema || parsed.schema || driverSchema,
            tableName: parsed.tableName
          };
        }
        if (InstanceChecker_1.InstanceChecker.isTableForeignKey(target)) {
          const parsed = this.parseTableName(target.referencedTableName);
          return {
            database: target.referencedDatabase || parsed.database || driverDatabase,
            schema: target.referencedSchema || parsed.schema || driverSchema,
            tableName: parsed.tableName
          };
        }
        if (InstanceChecker_1.InstanceChecker.isEntityMetadata(target)) {
          return {
            database: target.database || driverDatabase,
            schema: target.schema || driverSchema,
            tableName: target.tableName
          };
        }
        const parts = target.split(".");
        if (parts.length === 3) {
          return {
            database: parts[0] || driverDatabase,
            schema: parts[1] || driverSchema,
            tableName: parts[2]
          };
        } else if (parts.length === 2) {
          const database = this.getAttachedDatabasePathRelativeByHandle(parts[0]) ?? driverDatabase;
          return {
            database,
            schema: parts[0],
            tableName: parts[1]
          };
        } else {
          return {
            database: driverDatabase,
            schema: driverSchema,
            tableName: target
          };
        }
      }
      /**
       * Creates a database type from a given column metadata.
       */
      normalizeType(column) {
        if (column.type === Number || column.type === "int") {
          return "integer";
        } else if (column.type === String) {
          return "varchar";
        } else if (column.type === Date) {
          return "datetime";
        } else if (column.type === Boolean) {
          return "boolean";
        } else if (column.type === "uuid") {
          return "varchar";
        } else if (column.type === "simple-array") {
          return "text";
        } else if (column.type === "simple-json") {
          return "text";
        } else if (column.type === "simple-enum") {
          return "varchar";
        } else {
          return column.type || "";
        }
      }
      /**
       * Normalizes "default" value of the column.
       */
      normalizeDefault(columnMetadata) {
        const defaultValue = columnMetadata.default;
        if (typeof defaultValue === "number") {
          return "" + defaultValue;
        }
        if (typeof defaultValue === "boolean") {
          return defaultValue ? "1" : "0";
        }
        if (typeof defaultValue === "function") {
          return defaultValue();
        }
        if (typeof defaultValue === "string") {
          return `'${defaultValue}'`;
        }
        if (defaultValue === null || defaultValue === void 0) {
          return void 0;
        }
        return `${defaultValue}`;
      }
      /**
       * Normalizes "isUnique" value of the column.
       */
      normalizeIsUnique(column) {
        return column.entityMetadata.uniques.some((uq) => uq.columns.length === 1 && uq.columns[0] === column);
      }
      /**
       * Calculates column length taking into account the default length values.
       */
      getColumnLength(column) {
        return column.length ? column.length.toString() : "";
      }
      /**
       * Normalizes "default" value of the column.
       */
      createFullType(column) {
        let type = column.type;
        if (column.enum) {
          return "varchar";
        }
        if (column.length) {
          type += "(" + column.length + ")";
        } else if (column.precision !== null && column.precision !== void 0 && column.scale !== null && column.scale !== void 0) {
          type += "(" + column.precision + "," + column.scale + ")";
        } else if (column.precision !== null && column.precision !== void 0) {
          type += "(" + column.precision + ")";
        }
        if (column.isArray)
          type += " array";
        return type;
      }
      /**
       * Obtains a new database connection to a master server.
       * Used for replication.
       * If replication is not setup then returns default connection's database connection.
       */
      obtainMasterConnection() {
        return Promise.resolve();
      }
      /**
       * Obtains a new database connection to a slave server.
       * Used for replication.
       * If replication is not setup then returns master (default) connection's database connection.
       */
      obtainSlaveConnection() {
        return Promise.resolve();
      }
      /**
       * Creates generated map of values generated or returned by database after INSERT query.
       */
      createGeneratedMap(metadata, insertResult, entityIndex, entityNum) {
        const generatedMap = metadata.generatedColumns.reduce((map, generatedColumn) => {
          let value;
          if (generatedColumn.generationStrategy === "increment" && insertResult) {
            value = insertResult - entityNum + entityIndex + 1;
          }
          if (!value)
            return map;
          return OrmUtils_1.OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));
        }, {});
        return Object.keys(generatedMap).length > 0 ? generatedMap : void 0;
      }
      /**
       * Differentiate columns of this table and columns from the given column metadatas columns
       * and returns only changed.
       */
      findChangedColumns(tableColumns, columnMetadatas) {
        return columnMetadatas.filter((columnMetadata) => {
          const tableColumn = tableColumns.find((c) => c.name === columnMetadata.databaseName);
          if (!tableColumn)
            return false;
          const isColumnChanged = tableColumn.name !== columnMetadata.databaseName || tableColumn.type !== this.normalizeType(columnMetadata) || tableColumn.length !== columnMetadata.length || tableColumn.precision !== columnMetadata.precision || tableColumn.scale !== columnMetadata.scale || this.normalizeDefault(columnMetadata) !== tableColumn.default || tableColumn.isPrimary !== columnMetadata.isPrimary || tableColumn.isNullable !== columnMetadata.isNullable || tableColumn.generatedType !== columnMetadata.generatedType || tableColumn.asExpression !== columnMetadata.asExpression || tableColumn.isUnique !== this.normalizeIsUnique(columnMetadata) || tableColumn.enum && columnMetadata.enum && !OrmUtils_1.OrmUtils.isArraysEqual(tableColumn.enum, columnMetadata.enum.map((val) => val + "")) || columnMetadata.generationStrategy !== "uuid" && tableColumn.isGenerated !== columnMetadata.isGenerated;
          return isColumnChanged;
        });
      }
      /**
       * Returns true if driver supports RETURNING / OUTPUT statement.
       */
      isReturningSqlSupported() {
        return false;
      }
      /**
       * Returns true if driver supports uuid values generation on its own.
       */
      isUUIDGenerationSupported() {
        return false;
      }
      /**
       * Returns true if driver supports fulltext indices.
       */
      isFullTextColumnTypeSupported() {
        return false;
      }
      /**
       * Creates an escaped parameter.
       */
      createParameter(parameterName, index) {
        return "?";
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Creates connection with the database.
       */
      async createDatabaseConnection() {
        throw new error_1.TypeORMError("Do not use AbstractSqlite directly, it has to be used with one of the sqlite drivers");
      }
      /**
       * If driver dependency is not given explicitly, then try to load it via "require".
       */
      loadDependencies() {
      }
    };
    exports2.AbstractSqliteDriver = AbstractSqliteDriver;
  }
});

// node_modules/typeorm/driver/sqlite/SqliteDriver.js
var require_SqliteDriver = __commonJS({
  "node_modules/typeorm/driver/sqlite/SqliteDriver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SqliteDriver = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var promises_1 = tslib_1.__importDefault(require("fs/promises"));
    var path_1 = tslib_1.__importDefault(require("path"));
    var DriverPackageNotInstalledError_1 = require_DriverPackageNotInstalledError();
    var SqliteQueryRunner_1 = require_SqliteQueryRunner();
    var PlatformTools_1 = require_PlatformTools();
    var AbstractSqliteDriver_1 = require_AbstractSqliteDriver();
    var PathUtils_1 = require_PathUtils();
    var SqliteDriver = class extends AbstractSqliteDriver_1.AbstractSqliteDriver {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection) {
        super(connection);
        this.connection = connection;
        this.options = connection.options;
        this.database = this.options.database;
        this.loadDependencies();
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Closes connection with database.
       */
      async disconnect() {
        return new Promise((ok, fail) => {
          this.queryRunner = void 0;
          this.databaseConnection.close((err) => err ? fail(err) : ok());
        });
      }
      /**
       * Creates a query runner used to execute database queries.
       */
      createQueryRunner(mode) {
        if (!this.queryRunner)
          this.queryRunner = new SqliteQueryRunner_1.SqliteQueryRunner(this);
        return this.queryRunner;
      }
      normalizeType(column) {
        if (column.type === Buffer) {
          return "blob";
        }
        return super.normalizeType(column);
      }
      async afterConnect() {
        return this.attachDatabases();
      }
      /**
       * For SQLite, the database may be added in the decorator metadata. It will be a filepath to a database file.
       */
      buildTableName(tableName, _schema, database) {
        if (!database)
          return tableName;
        if (this.getAttachedDatabaseHandleByRelativePath(database))
          return `${this.getAttachedDatabaseHandleByRelativePath(database)}.${tableName}`;
        if (database === this.options.database)
          return tableName;
        const identifierHash = (0, PathUtils_1.filepathToName)(database);
        const absFilepath = (0, PathUtils_1.isAbsolute)(database) ? database : path_1.default.join(this.getMainDatabasePath(), database);
        this.attachedDatabases[database] = {
          attachFilepathAbsolute: absFilepath,
          attachFilepathRelative: database,
          attachHandle: identifierHash
        };
        return `${identifierHash}.${tableName}`;
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Creates connection with the database.
       */
      async createDatabaseConnection() {
        if (this.options.flags === void 0 || !(this.options.flags & this.sqlite.OPEN_URI)) {
          await this.createDatabaseDirectory(this.options.database);
        }
        const databaseConnection = await new Promise((ok, fail) => {
          if (this.options.flags === void 0) {
            const connection = new this.sqlite.Database(this.options.database, (err) => {
              if (err)
                return fail(err);
              ok(connection);
            });
          } else {
            const connection = new this.sqlite.Database(this.options.database, this.options.flags, (err) => {
              if (err)
                return fail(err);
              ok(connection);
            });
          }
        });
        function run(line) {
          return new Promise((ok, fail) => {
            databaseConnection.run(line, (err) => {
              if (err)
                return fail(err);
              ok();
            });
          });
        }
        if (this.options.key) {
          await run(`PRAGMA key = ${JSON.stringify(this.options.key)}`);
        }
        if (this.options.enableWAL) {
          await run(`PRAGMA journal_mode = WAL`);
        }
        if (this.options.busyTimeout && typeof this.options.busyTimeout === "number" && this.options.busyTimeout > 0) {
          await run(`PRAGMA busy_timeout = ${this.options.busyTimeout}`);
        }
        await run(`PRAGMA foreign_keys = ON`);
        return databaseConnection;
      }
      /**
       * If driver dependency is not given explicitly, then try to load it via "require".
       */
      loadDependencies() {
        try {
          const sqlite = this.options.driver || PlatformTools_1.PlatformTools.load("sqlite3");
          this.sqlite = sqlite.verbose();
        } catch (e) {
          throw new DriverPackageNotInstalledError_1.DriverPackageNotInstalledError("SQLite", "sqlite3");
        }
      }
      /**
       * Auto creates database directory if it does not exist.
       */
      async createDatabaseDirectory(fullPath) {
        await promises_1.default.mkdir(path_1.default.dirname(fullPath), { recursive: true });
      }
      /**
       * Performs the attaching of the database files. The attachedDatabase should have been populated during calls to #buildTableName
       * during EntityMetadata production (see EntityMetadata#buildTablePath)
       *
       * https://sqlite.org/lang_attach.html
       */
      async attachDatabases() {
        for (const { attachHandle, attachFilepathAbsolute } of Object.values(this.attachedDatabases)) {
          await this.createDatabaseDirectory(attachFilepathAbsolute);
          await this.connection.query(`ATTACH "${attachFilepathAbsolute}" AS "${attachHandle}"`);
        }
      }
      getMainDatabasePath() {
        const optionsDb = this.options.database;
        return path_1.default.dirname((0, PathUtils_1.isAbsolute)(optionsDb) ? optionsDb : path_1.default.join(process.cwd(), optionsDb));
      }
    };
    exports2.SqliteDriver = SqliteDriver;
  }
});

// node_modules/typeorm/driver/cordova/CordovaQueryRunner.js
var require_CordovaQueryRunner = __commonJS({
  "node_modules/typeorm/driver/cordova/CordovaQueryRunner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CordovaQueryRunner = void 0;
    var error_1 = require_error();
    var QueryFailedError_1 = require_QueryFailedError();
    var QueryRunnerAlreadyReleasedError_1 = require_QueryRunnerAlreadyReleasedError();
    var QueryResult_1 = require_QueryResult();
    var Broadcaster_1 = require_Broadcaster();
    var BroadcasterResult_1 = require_BroadcasterResult();
    var AbstractSqliteQueryRunner_1 = require_AbstractSqliteQueryRunner();
    var CordovaQueryRunner = class extends AbstractSqliteQueryRunner_1.AbstractSqliteQueryRunner {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(driver) {
        super();
        this.driver = driver;
        this.connection = driver.connection;
        this.broadcaster = new Broadcaster_1.Broadcaster(this);
      }
      /**
       * Called before migrations are run.
       */
      async beforeMigration() {
        await this.query(`PRAGMA foreign_keys = OFF`);
      }
      /**
       * Called after migrations are run.
       */
      async afterMigration() {
        await this.query(`PRAGMA foreign_keys = ON`);
      }
      /**
       * Executes a given SQL query.
       */
      async query(query, parameters, useStructuredResult = false) {
        if (this.isReleased)
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        const databaseConnection = await this.connect();
        this.driver.connection.logger.logQuery(query, parameters, this);
        await this.broadcaster.broadcast("BeforeQuery", query, parameters);
        const broadcasterResult = new BroadcasterResult_1.BroadcasterResult();
        const queryStartTime = Date.now();
        try {
          const raw = await new Promise((ok, fail) => {
            databaseConnection.executeSql(query, parameters, (raw2) => ok(raw2), (err) => fail(err));
          });
          const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
          const queryEndTime = Date.now();
          const queryExecutionTime = queryEndTime - queryStartTime;
          this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, raw, void 0);
          if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) {
            this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
          }
          const result = new QueryResult_1.QueryResult();
          if (query.substr(0, 11) === "INSERT INTO") {
            result.raw = raw.insertId;
          } else {
            const resultSet = [];
            for (let i = 0; i < raw.rows.length; i++) {
              resultSet.push(raw.rows.item(i));
            }
            result.records = resultSet;
            result.raw = resultSet;
          }
          if (useStructuredResult) {
            return result;
          } else {
            return result.raw;
          }
        } catch (err) {
          this.driver.connection.logger.logQueryError(err, query, parameters, this);
          this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, void 0, void 0, err);
          throw new QueryFailedError_1.QueryFailedError(query, parameters, err);
        } finally {
          await broadcasterResult.wait();
        }
      }
      /**
           * Insert a new row with given values into the given table.
           * Returns value of the generated column if given and generate column exist in the table.
           // todo: implement new syntax
          async insert(tableName: string, keyValues: ObjectLiteral): Promise<InsertResult> {
              const keys = Object.keys(keyValues);
              const columns = keys.map(key => `"${key}"`).join(", ");
              const values = keys.map(key => "?").join(",");
              const generatedColumns = this.connection.hasMetadata(tableName) ? this.connection.getMetadata(tableName).generatedColumns : [];
              const sql = columns.length > 0 ? (`INSERT INTO "${tableName}"(${columns}) VALUES (${values})`) : `INSERT INTO "${tableName}" DEFAULT VALUES`;
              const parameters = keys.map(key => keyValues[key]);
      
              return new Promise<InsertResult>(async (ok, fail) => {
                  this.driver.connection.logger.logQuery(sql, parameters, this);
                  const __this = this;
                  const databaseConnection = await this.connect();
                  databaseConnection.executeSql(sql, parameters, (resultSet: any) => {
                      const generatedMap = generatedColumns.reduce((map, generatedColumn) => {
                          const value = generatedColumn.isPrimary && generatedColumn.generationStrategy === "increment" && resultSet.insertId ? resultSet.insertId : keyValues[generatedColumn.databaseName];
                          if (!value) return map;
                          return OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));
                      }, {} as ObjectLiteral);
      
                      ok({
                          result: undefined,
                          generatedMap: Object.keys(generatedMap).length > 0 ? generatedMap : undefined
                      });
                  }, (err: any) => {
                      __this.driver.connection.logger.logQueryError(err, sql, parameters, this);
                      fail(err);
                  });
              });
          }*/
      /**
       * Would start a transaction but this driver does not support transactions.
       */
      async startTransaction() {
        throw new error_1.TypeORMError("Transactions are not supported by the Cordova driver");
      }
      /**
       * Would start a transaction but this driver does not support transactions.
       */
      async commitTransaction() {
        throw new error_1.TypeORMError("Transactions are not supported by the Cordova driver");
      }
      /**
       * Would start a transaction but this driver does not support transactions.
       */
      async rollbackTransaction() {
        throw new error_1.TypeORMError("Transactions are not supported by the Cordova driver");
      }
      /**
       * Removes all tables from the currently connected database.
       * Be careful with using this method and avoid using it in production or migrations
       * (because it can clear all your database).
       */
      async clearDatabase() {
        await this.query(`PRAGMA foreign_keys = OFF`);
        try {
          const selectViewDropsQuery = `SELECT 'DROP VIEW "' || name || '";' as query FROM "sqlite_master" WHERE "type" = 'view'`;
          const dropViewQueries = await this.query(selectViewDropsQuery);
          const selectTableDropsQuery = `SELECT 'DROP TABLE "' || name || '";' as query FROM "sqlite_master" WHERE "type" = 'table' AND "name" != 'sqlite_sequence'`;
          const dropTableQueries = await this.query(selectTableDropsQuery);
          await Promise.all(dropViewQueries.map((q) => this.query(q["query"])));
          await Promise.all(dropTableQueries.map((q) => this.query(q["query"])));
        } finally {
          await this.query(`PRAGMA foreign_keys = ON`);
        }
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Parametrizes given object of values. Used to create column=value queries.
       */
      parametrize(objectLiteral, startIndex = 0) {
        return Object.keys(objectLiteral).map((key, index) => `"${key}"=?`);
      }
    };
    exports2.CordovaQueryRunner = CordovaQueryRunner;
  }
});

// node_modules/typeorm/driver/cordova/CordovaDriver.js
var require_CordovaDriver = __commonJS({
  "node_modules/typeorm/driver/cordova/CordovaDriver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CordovaDriver = void 0;
    var AbstractSqliteDriver_1 = require_AbstractSqliteDriver();
    var CordovaQueryRunner_1 = require_CordovaQueryRunner();
    var DriverPackageNotInstalledError_1 = require_DriverPackageNotInstalledError();
    var CordovaDriver = class extends AbstractSqliteDriver_1.AbstractSqliteDriver {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection) {
        super(connection);
        this.transactionSupport = "none";
        this.database = this.options.database;
        this.loadDependencies();
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Closes connection with database.
       */
      async disconnect() {
        this.queryRunner = void 0;
        return new Promise((ok, fail) => {
          this.databaseConnection.close(ok, fail);
        });
      }
      /**
       * Creates a query runner used to execute database queries.
       */
      createQueryRunner(mode) {
        if (!this.queryRunner)
          this.queryRunner = new CordovaQueryRunner_1.CordovaQueryRunner(this);
        return this.queryRunner;
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Creates connection with the database.
       */
      async createDatabaseConnection() {
        const options = Object.assign({}, {
          name: this.options.database,
          location: this.options.location
        }, this.options.extra || {});
        const connection = await new Promise((resolve, fail) => {
          this.sqlite.openDatabase(options, (db) => resolve(db), (err) => fail(err));
        });
        await new Promise((ok, fail) => {
          connection.executeSql(`PRAGMA foreign_keys = ON`, [], () => ok(), (err) => fail(err));
        });
        return connection;
      }
      /**
       * If driver dependency is not given explicitly, then try to load it via "require".
       */
      loadDependencies() {
        try {
          const sqlite = this.options.driver || window.sqlitePlugin;
          this.sqlite = sqlite;
        } catch (e) {
          throw new DriverPackageNotInstalledError_1.DriverPackageNotInstalledError("Cordova-SQLite", "cordova-sqlite-storage");
        }
      }
    };
    exports2.CordovaDriver = CordovaDriver;
  }
});

// node_modules/typeorm/driver/react-native/ReactNativeQueryRunner.js
var require_ReactNativeQueryRunner = __commonJS({
  "node_modules/typeorm/driver/react-native/ReactNativeQueryRunner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReactNativeQueryRunner = void 0;
    var QueryFailedError_1 = require_QueryFailedError();
    var QueryRunnerAlreadyReleasedError_1 = require_QueryRunnerAlreadyReleasedError();
    var QueryResult_1 = require_QueryResult();
    var Broadcaster_1 = require_Broadcaster();
    var BroadcasterResult_1 = require_BroadcasterResult();
    var AbstractSqliteQueryRunner_1 = require_AbstractSqliteQueryRunner();
    var ReactNativeQueryRunner = class extends AbstractSqliteQueryRunner_1.AbstractSqliteQueryRunner {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(driver) {
        super();
        this.driver = driver;
        this.connection = driver.connection;
        this.broadcaster = new Broadcaster_1.Broadcaster(this);
      }
      /**
       * Called before migrations are run.
       */
      async beforeMigration() {
        await this.query(`PRAGMA foreign_keys = OFF`);
      }
      /**
       * Called after migrations are run.
       */
      async afterMigration() {
        await this.query(`PRAGMA foreign_keys = ON`);
      }
      /**
       * Executes a given SQL query.
       */
      async query(query, parameters, useStructuredResult = false) {
        if (this.isReleased)
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        const databaseConnection = await this.connect();
        this.driver.connection.logger.logQuery(query, parameters, this);
        await this.broadcaster.broadcast("BeforeQuery", query, parameters);
        const broadcasterResult = new BroadcasterResult_1.BroadcasterResult();
        const queryStartTime = Date.now();
        return new Promise(async (ok, fail) => {
          try {
            databaseConnection.executeSql(query, parameters, async (raw) => {
              const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
              const queryEndTime = Date.now();
              const queryExecutionTime = queryEndTime - queryStartTime;
              this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, raw, void 0);
              if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime)
                this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
              if (broadcasterResult.promises.length > 0)
                await Promise.all(broadcasterResult.promises);
              const result = new QueryResult_1.QueryResult();
              if (raw?.hasOwnProperty("rowsAffected")) {
                result.affected = raw.rowsAffected;
              }
              if (raw?.hasOwnProperty("rows")) {
                const records = [];
                for (let i = 0; i < raw.rows.length; i++) {
                  records.push(raw.rows.item(i));
                }
                result.raw = records;
                result.records = records;
              }
              if (query.substr(0, 11) === "INSERT INTO") {
                result.raw = raw.insertId;
              }
              if (useStructuredResult) {
                ok(result);
              } else {
                ok(result.raw);
              }
            }, (err) => {
              this.driver.connection.logger.logQueryError(err, query, parameters, this);
              this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, void 0, void 0, err);
              fail(new QueryFailedError_1.QueryFailedError(query, parameters, err));
            });
          } catch (err) {
            fail(err);
          } finally {
            await broadcasterResult.wait();
          }
        });
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Parametrizes given object of values. Used to create column=value queries.
       */
      parametrize(objectLiteral, startIndex = 0) {
        return Object.keys(objectLiteral).map((key, index) => `"${key}"=?`);
      }
    };
    exports2.ReactNativeQueryRunner = ReactNativeQueryRunner;
  }
});

// node_modules/typeorm/driver/react-native/ReactNativeDriver.js
var require_ReactNativeDriver = __commonJS({
  "node_modules/typeorm/driver/react-native/ReactNativeDriver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReactNativeDriver = void 0;
    var DateUtils_1 = require_DateUtils();
    var RdbmsSchemaBuilder_1 = require_RdbmsSchemaBuilder();
    var OrmUtils_1 = require_OrmUtils();
    var ApplyValueTransformers_1 = require_ApplyValueTransformers();
    var error_1 = require_error();
    var InstanceChecker_1 = require_InstanceChecker();
    var ReactNativeQueryRunner_1 = require_ReactNativeQueryRunner();
    var ReactNativeDriver = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection) {
        this.isReplicated = false;
        this.treeSupport = true;
        this.transactionSupport = "nested";
        this.supportedDataTypes = [
          "int",
          "integer",
          "tinyint",
          "smallint",
          "mediumint",
          "bigint",
          "unsigned big int",
          "int2",
          "int8",
          "integer",
          "character",
          "varchar",
          "varying character",
          "nchar",
          "native character",
          "nvarchar",
          "text",
          "clob",
          "text",
          "blob",
          "real",
          "double",
          "double precision",
          "float",
          "real",
          "numeric",
          "decimal",
          "boolean",
          "date",
          "time",
          "datetime"
        ];
        this.supportedUpsertTypes = ["on-conflict-do-update"];
        this.withLengthColumnTypes = [
          "character",
          "varchar",
          "varying character",
          "nchar",
          "native character",
          "nvarchar",
          "text",
          "blob",
          "clob"
        ];
        this.spatialTypes = [];
        this.withPrecisionColumnTypes = [
          "real",
          "double",
          "double precision",
          "float",
          "real",
          "numeric",
          "decimal",
          "date",
          "time",
          "datetime"
        ];
        this.withScaleColumnTypes = [
          "real",
          "double",
          "double precision",
          "float",
          "real",
          "numeric",
          "decimal"
        ];
        this.mappedDataTypes = {
          createDate: "datetime",
          createDateDefault: "datetime('now')",
          updateDate: "datetime",
          updateDateDefault: "datetime('now')",
          deleteDate: "datetime",
          deleteDateNullable: true,
          version: "integer",
          treeLevel: "integer",
          migrationId: "integer",
          migrationName: "varchar",
          migrationTimestamp: "bigint",
          cacheId: "int",
          cacheIdentifier: "varchar",
          cacheTime: "bigint",
          cacheDuration: "int",
          cacheQuery: "text",
          cacheResult: "text",
          metadataType: "varchar",
          metadataDatabase: "varchar",
          metadataSchema: "varchar",
          metadataTable: "varchar",
          metadataName: "varchar",
          metadataValue: "text"
        };
        this.cteCapabilities = {
          enabled: true,
          requiresRecursiveHint: true
        };
        this.attachedDatabases = {};
        this.connection = connection;
        this.options = connection.options;
        this.database = this.options.database;
        this.loadDependencies();
      }
      // -------------------------------------------------------------------------
      // Public Abstract
      // -------------------------------------------------------------------------
      /**
       * Creates a query runner used to execute database queries.
       */
      createQueryRunner(mode) {
        if (!this.queryRunner)
          this.queryRunner = new ReactNativeQueryRunner_1.ReactNativeQueryRunner(this);
        return this.queryRunner;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Performs connection to the database.
       */
      async connect() {
        this.databaseConnection = await this.createDatabaseConnection();
      }
      /**
       * Makes any action after connection (e.g. create extensions in Postgres driver).
       */
      afterConnect() {
        return Promise.resolve();
      }
      /**
       * Closes connection with database.
       */
      async disconnect() {
        return new Promise((ok, fail) => {
          this.queryRunner = void 0;
          this.databaseConnection.close(ok, fail);
        });
      }
      hasAttachedDatabases() {
        return !!Object.keys(this.attachedDatabases).length;
      }
      getAttachedDatabaseHandleByRelativePath(path) {
        return this.attachedDatabases?.[path]?.attachHandle;
      }
      getAttachedDatabasePathRelativeByHandle(handle) {
        return Object.values(this.attachedDatabases).find(({ attachHandle }) => handle === attachHandle)?.attachFilepathRelative;
      }
      /**
       * Creates a schema builder used to build and sync a schema.
       */
      createSchemaBuilder() {
        return new RdbmsSchemaBuilder_1.RdbmsSchemaBuilder(this.connection);
      }
      /**
       * Prepares given value to a value to be persisted, based on its column type and metadata.
       */
      preparePersistentValue(value, columnMetadata) {
        if (columnMetadata.transformer)
          value = ApplyValueTransformers_1.ApplyValueTransformers.transformTo(columnMetadata.transformer, value);
        if (value === null || value === void 0)
          return value;
        if (columnMetadata.type === Boolean || columnMetadata.type === "boolean") {
          return value === true ? 1 : 0;
        } else if (columnMetadata.type === "date") {
          return DateUtils_1.DateUtils.mixedDateToDateString(value);
        } else if (columnMetadata.type === "time") {
          return DateUtils_1.DateUtils.mixedDateToTimeString(value);
        } else if (columnMetadata.type === "datetime" || columnMetadata.type === Date) {
          return DateUtils_1.DateUtils.mixedDateToUtcDatetimeString(value);
        } else if (columnMetadata.type === "simple-array") {
          return DateUtils_1.DateUtils.simpleArrayToString(value);
        } else if (columnMetadata.type === "simple-json") {
          return DateUtils_1.DateUtils.simpleJsonToString(value);
        } else if (columnMetadata.type === "simple-enum") {
          return DateUtils_1.DateUtils.simpleEnumToString(value);
        }
        return value;
      }
      /**
       * Prepares given value to a value to be hydrated, based on its column type or metadata.
       */
      prepareHydratedValue(value, columnMetadata) {
        if (value === null || value === void 0)
          return columnMetadata.transformer ? ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value) : value;
        if (columnMetadata.type === Boolean || columnMetadata.type === "boolean") {
          value = value ? true : false;
        } else if (columnMetadata.type === "datetime" || columnMetadata.type === Date) {
          if (value && typeof value === "string") {
            if (/^\d\d\d\d-\d\d-\d\d \d\d:\d\d/.test(value)) {
              value = value.replace(" ", "T");
            }
            if (/^\d\d\d\d-\d\d-\d\dT\d\d:\d\d(:\d\d(\.\d\d\d)?)?$/.test(value)) {
              value += "Z";
            }
          }
          value = DateUtils_1.DateUtils.normalizeHydratedDate(value);
        } else if (columnMetadata.type === "date") {
          value = DateUtils_1.DateUtils.mixedDateToDateString(value);
        } else if (columnMetadata.type === "time") {
          value = DateUtils_1.DateUtils.mixedTimeToString(value);
        } else if (columnMetadata.type === "simple-array") {
          value = DateUtils_1.DateUtils.stringToSimpleArray(value);
        } else if (columnMetadata.type === "simple-json") {
          value = DateUtils_1.DateUtils.stringToSimpleJson(value);
        } else if (columnMetadata.type === "simple-enum") {
          value = DateUtils_1.DateUtils.stringToSimpleEnum(value, columnMetadata);
        } else if (columnMetadata.type === Number) {
          value = !isNaN(+value) ? parseInt(value) : value;
        }
        if (columnMetadata.transformer)
          value = ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);
        return value;
      }
      /**
       * Replaces parameters in the given sql with special escaping character
       * and an array of parameter names to be passed to a query.
       */
      escapeQueryWithParameters(sql, parameters, nativeParameters) {
        const escapedParameters = Object.keys(nativeParameters).map((key) => {
          if (typeof nativeParameters[key] === "boolean") {
            return nativeParameters[key] === true ? 1 : 0;
          }
          if (nativeParameters[key] instanceof Date) {
            return DateUtils_1.DateUtils.mixedDateToUtcDatetimeString(nativeParameters[key]);
          }
          return nativeParameters[key];
        });
        if (!parameters || !Object.keys(parameters).length)
          return [sql, escapedParameters];
        sql = sql.replace(/:(\.\.\.)?([A-Za-z0-9_.]+)/g, (full, isArray, key) => {
          if (!parameters.hasOwnProperty(key)) {
            return full;
          }
          const value = parameters[key];
          if (isArray) {
            return value.map((v) => {
              escapedParameters.push(v);
              return this.createParameter(key, escapedParameters.length - 1);
            }).join(", ");
          }
          if (typeof value === "function") {
            return value();
          } else if (typeof value === "number") {
            return String(value);
          }
          if (typeof value === "boolean") {
            escapedParameters.push(+value);
            return this.createParameter(key, escapedParameters.length - 1);
          }
          if (value instanceof Date) {
            escapedParameters.push(DateUtils_1.DateUtils.mixedDateToUtcDatetimeString(value));
            return this.createParameter(key, escapedParameters.length - 1);
          }
          escapedParameters.push(value);
          return this.createParameter(key, escapedParameters.length - 1);
        });
        return [sql, escapedParameters];
      }
      /**
       * Escapes a column name.
       */
      escape(columnName) {
        return '"' + columnName + '"';
      }
      /**
       * Build full table name with database name, schema name and table name.
       * E.g. myDB.mySchema.myTable
       *
       * Returns only simple table name because all inherited drivers does not supports schema and database.
       */
      buildTableName(tableName, schema, database) {
        return tableName;
      }
      /**
       * Parse a target table name or other types and return a normalized table definition.
       */
      parseTableName(target) {
        const driverDatabase = this.database;
        const driverSchema = void 0;
        if (InstanceChecker_1.InstanceChecker.isTable(target) || InstanceChecker_1.InstanceChecker.isView(target)) {
          const parsed = this.parseTableName(target.schema ? `"${target.schema}"."${target.name}"` : target.name);
          return {
            database: target.database || parsed.database || driverDatabase,
            schema: target.schema || parsed.schema || driverSchema,
            tableName: parsed.tableName
          };
        }
        if (InstanceChecker_1.InstanceChecker.isTableForeignKey(target)) {
          const parsed = this.parseTableName(target.referencedTableName);
          return {
            database: target.referencedDatabase || parsed.database || driverDatabase,
            schema: target.referencedSchema || parsed.schema || driverSchema,
            tableName: parsed.tableName
          };
        }
        if (InstanceChecker_1.InstanceChecker.isEntityMetadata(target)) {
          return {
            database: target.database || driverDatabase,
            schema: target.schema || driverSchema,
            tableName: target.tableName
          };
        }
        const parts = target.split(".");
        if (parts.length === 3) {
          return {
            database: parts[0] || driverDatabase,
            schema: parts[1] || driverSchema,
            tableName: parts[2]
          };
        } else if (parts.length === 2) {
          const database = this.getAttachedDatabasePathRelativeByHandle(parts[0]) ?? driverDatabase;
          return {
            database,
            schema: parts[0],
            tableName: parts[1]
          };
        } else {
          return {
            database: driverDatabase,
            schema: driverSchema,
            tableName: target
          };
        }
      }
      /**
       * Creates a database type from a given column metadata.
       */
      normalizeType(column) {
        if (column.type === Number || column.type === "int") {
          return "integer";
        } else if (column.type === String) {
          return "varchar";
        } else if (column.type === Date) {
          return "datetime";
        } else if (column.type === Boolean) {
          return "boolean";
        } else if (column.type === "uuid") {
          return "varchar";
        } else if (column.type === "simple-array") {
          return "text";
        } else if (column.type === "simple-json") {
          return "text";
        } else if (column.type === "simple-enum") {
          return "varchar";
        } else {
          return column.type || "";
        }
      }
      /**
       * Normalizes "default" value of the column.
       */
      normalizeDefault(columnMetadata) {
        const defaultValue = columnMetadata.default;
        if (typeof defaultValue === "number") {
          return "" + defaultValue;
        }
        if (typeof defaultValue === "boolean") {
          return defaultValue ? "1" : "0";
        }
        if (typeof defaultValue === "function") {
          return defaultValue();
        }
        if (typeof defaultValue === "string") {
          return `'${defaultValue}'`;
        }
        if (defaultValue === null || defaultValue === void 0) {
          return void 0;
        }
        return `${defaultValue}`;
      }
      /**
       * Normalizes "isUnique" value of the column.
       */
      normalizeIsUnique(column) {
        return column.entityMetadata.uniques.some((uq) => uq.columns.length === 1 && uq.columns[0] === column);
      }
      /**
       * Calculates column length taking into account the default length values.
       */
      getColumnLength(column) {
        return column.length ? column.length.toString() : "";
      }
      /**
       * Normalizes "default" value of the column.
       */
      createFullType(column) {
        let type = column.type;
        if (column.enum) {
          return "varchar";
        }
        if (column.length) {
          type += "(" + column.length + ")";
        } else if (column.precision !== null && column.precision !== void 0 && column.scale !== null && column.scale !== void 0) {
          type += "(" + column.precision + "," + column.scale + ")";
        } else if (column.precision !== null && column.precision !== void 0) {
          type += "(" + column.precision + ")";
        }
        if (column.isArray)
          type += " array";
        return type;
      }
      /**
       * Obtains a new database connection to a master server.
       * Used for replication.
       * If replication is not setup then returns default connection's database connection.
       */
      obtainMasterConnection() {
        return Promise.resolve();
      }
      /**
       * Obtains a new database connection to a slave server.
       * Used for replication.
       * If replication is not setup then returns master (default) connection's database connection.
       */
      obtainSlaveConnection() {
        return Promise.resolve();
      }
      /**
       * Creates generated map of values generated or returned by database after INSERT query.
       */
      createGeneratedMap(metadata, insertResult, entityIndex, entityNum) {
        const generatedMap = metadata.generatedColumns.reduce((map, generatedColumn) => {
          let value;
          if (generatedColumn.generationStrategy === "increment" && insertResult) {
            value = insertResult - entityNum + entityIndex + 1;
          }
          if (!value)
            return map;
          return OrmUtils_1.OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));
        }, {});
        return Object.keys(generatedMap).length > 0 ? generatedMap : void 0;
      }
      /**
       * Differentiate columns of this table and columns from the given column metadatas columns
       * and returns only changed.
       */
      findChangedColumns(tableColumns, columnMetadatas) {
        return columnMetadatas.filter((columnMetadata) => {
          const tableColumn = tableColumns.find((c) => c.name === columnMetadata.databaseName);
          if (!tableColumn)
            return false;
          const isColumnChanged = tableColumn.name !== columnMetadata.databaseName || tableColumn.type !== this.normalizeType(columnMetadata) || tableColumn.length !== columnMetadata.length || tableColumn.precision !== columnMetadata.precision || tableColumn.scale !== columnMetadata.scale || this.normalizeDefault(columnMetadata) !== tableColumn.default || tableColumn.isPrimary !== columnMetadata.isPrimary || tableColumn.isNullable !== columnMetadata.isNullable || tableColumn.generatedType !== columnMetadata.generatedType || tableColumn.asExpression !== columnMetadata.asExpression || tableColumn.isUnique !== this.normalizeIsUnique(columnMetadata) || tableColumn.enum && columnMetadata.enum && !OrmUtils_1.OrmUtils.isArraysEqual(tableColumn.enum, columnMetadata.enum.map((val) => val + "")) || columnMetadata.generationStrategy !== "uuid" && tableColumn.isGenerated !== columnMetadata.isGenerated;
          return isColumnChanged;
        });
      }
      /**
       * Returns true if driver supports RETURNING / OUTPUT statement.
       */
      isReturningSqlSupported() {
        return false;
      }
      /**
       * Returns true if driver supports uuid values generation on its own.
       */
      isUUIDGenerationSupported() {
        return false;
      }
      /**
       * Returns true if driver supports fulltext indices.
       */
      isFullTextColumnTypeSupported() {
        return false;
      }
      /**
       * Creates an escaped parameter.
       */
      createParameter(parameterName, index) {
        return "?";
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Creates connection with the database.
       */
      createDatabaseConnection() {
        return new Promise((ok, fail) => {
          const options = Object.assign({}, {
            name: this.options.database,
            location: this.options.location
          }, this.options.extra || {});
          this.sqlite.openDatabase(options, (db) => {
            const databaseConnection = db;
            databaseConnection.executeSql(`PRAGMA foreign_keys = ON`, [], (result) => {
              ok(databaseConnection);
            }, (error) => {
              fail(error);
            });
          }, (error) => {
            fail(error);
          });
        });
      }
      /**
       * If driver dependency is not given explicitly, then try to load it via "require".
       */
      loadDependencies() {
        try {
          const sqlite = this.options.driver || require("react-native-sqlite-storage");
          this.sqlite = sqlite;
        } catch (e) {
          throw new error_1.DriverPackageNotInstalledError("React-Native", "react-native-sqlite-storage");
        }
      }
    };
    exports2.ReactNativeDriver = ReactNativeDriver;
  }
});

// node_modules/typeorm/driver/nativescript/NativescriptQueryRunner.js
var require_NativescriptQueryRunner = __commonJS({
  "node_modules/typeorm/driver/nativescript/NativescriptQueryRunner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NativescriptQueryRunner = void 0;
    var QueryFailedError_1 = require_QueryFailedError();
    var QueryRunnerAlreadyReleasedError_1 = require_QueryRunnerAlreadyReleasedError();
    var QueryResult_1 = require_QueryResult();
    var Broadcaster_1 = require_Broadcaster();
    var AbstractSqliteQueryRunner_1 = require_AbstractSqliteQueryRunner();
    var NativescriptQueryRunner = class extends AbstractSqliteQueryRunner_1.AbstractSqliteQueryRunner {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(driver) {
        super();
        this.driver = driver;
        this.connection = driver.connection;
        this.broadcaster = new Broadcaster_1.Broadcaster(this);
      }
      /**
       * Called before migrations are run.
       */
      async beforeMigration() {
        await this.query(`PRAGMA foreign_keys = OFF`);
      }
      /**
       * Called after migrations are run.
       */
      async afterMigration() {
        await this.query(`PRAGMA foreign_keys = ON`);
      }
      /**
       * Executes a given SQL query.
       */
      async query(query, parameters, useStructuredResult = false) {
        if (this.isReleased) {
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        }
        const connection = this.driver.connection;
        const databaseConnection = await this.connect();
        return new Promise((ok, fail) => {
          const isInsertQuery = query.substr(0, 11) === "INSERT INTO";
          connection.logger.logQuery(query, parameters, this);
          const handler2 = (err, raw) => {
            const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
            const queryEndTime = Date.now();
            const queryExecutionTime = queryEndTime - queryStartTime;
            if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) {
              connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
            }
            if (err) {
              connection.logger.logQueryError(err, query, parameters, this);
              fail(new QueryFailedError_1.QueryFailedError(query, parameters, err));
            }
            const result = new QueryResult_1.QueryResult();
            result.raw = raw;
            if (!isInsertQuery && Array.isArray(raw)) {
              result.records = raw;
            }
            if (useStructuredResult) {
              ok(result);
            } else {
              ok(result.raw);
            }
          };
          const queryStartTime = Date.now();
          if (isInsertQuery) {
            databaseConnection.execSQL(query, parameters, handler2);
          } else {
            databaseConnection.all(query, parameters, handler2);
          }
        });
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Parametrizes given object of values. Used to create column=value queries.
       */
      parametrize(objectLiteral, startIndex = 0) {
        return Object.keys(objectLiteral).map((key, index) => `"${key}"=?`);
      }
    };
    exports2.NativescriptQueryRunner = NativescriptQueryRunner;
  }
});

// node_modules/typeorm/driver/nativescript/NativescriptDriver.js
var require_NativescriptDriver = __commonJS({
  "node_modules/typeorm/driver/nativescript/NativescriptDriver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NativescriptDriver = void 0;
    var AbstractSqliteDriver_1 = require_AbstractSqliteDriver();
    var NativescriptQueryRunner_1 = require_NativescriptQueryRunner();
    var DriverPackageNotInstalledError_1 = require_DriverPackageNotInstalledError();
    var NativescriptDriver = class extends AbstractSqliteDriver_1.AbstractSqliteDriver {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection) {
        super(connection);
        this.connection = connection;
        this.options = connection.options;
        this.database = this.options.database;
        this.driver = this.options.driver;
        this.loadDependencies();
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Closes connection with database.
       */
      async disconnect() {
        return new Promise((ok, fail) => {
          this.queryRunner = void 0;
          this.databaseConnection.close().then(ok).catch(fail);
        });
      }
      /**
       * Creates a query runner used to execute database queries.
       */
      createQueryRunner(mode) {
        if (!this.queryRunner) {
          this.queryRunner = new NativescriptQueryRunner_1.NativescriptQueryRunner(this);
        }
        return this.queryRunner;
      }
      normalizeType(column) {
        if (column.type === Buffer) {
          return "blob";
        }
        return super.normalizeType(column);
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Creates connection with the database.
       */
      createDatabaseConnection() {
        return new Promise((ok, fail) => {
          const options = Object.assign({}, {
            readOnly: this.options.readOnly,
            key: this.options.key,
            multithreading: this.options.multithreading,
            migrate: this.options.migrate,
            iosFlags: this.options.iosFlags,
            androidFlags: this.options.androidFlags
          }, this.options.extra || {});
          new this.sqlite(this.options.database, options, (err, db) => {
            if (err)
              return fail(err);
            db.resultType(this.sqlite.RESULTSASOBJECT);
            db.execSQL(`PRAGMA foreign_keys = ON`, [], (err2, result) => {
              if (err2)
                return fail(err2);
              ok(db);
            });
          });
        });
      }
      /**
       * If driver dependency is not given explicitly, then try to load it via "require".
       */
      loadDependencies() {
        this.sqlite = this.driver;
        if (!this.driver) {
          throw new DriverPackageNotInstalledError_1.DriverPackageNotInstalledError("Nativescript", "nativescript-sqlite");
        }
      }
    };
    exports2.NativescriptDriver = NativescriptDriver;
  }
});

// node_modules/typeorm/driver/sqljs/SqljsQueryRunner.js
var require_SqljsQueryRunner = __commonJS({
  "node_modules/typeorm/driver/sqljs/SqljsQueryRunner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SqljsQueryRunner = void 0;
    var QueryFailedError_1 = require_QueryFailedError();
    var QueryRunnerAlreadyReleasedError_1 = require_QueryRunnerAlreadyReleasedError();
    var QueryResult_1 = require_QueryResult();
    var Broadcaster_1 = require_Broadcaster();
    var BroadcasterResult_1 = require_BroadcasterResult();
    var AbstractSqliteQueryRunner_1 = require_AbstractSqliteQueryRunner();
    var SqljsQueryRunner = class extends AbstractSqliteQueryRunner_1.AbstractSqliteQueryRunner {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(driver) {
        super();
        this.isDirty = false;
        this.driver = driver;
        this.connection = driver.connection;
        this.broadcaster = new Broadcaster_1.Broadcaster(this);
      }
      // -------------------------------------------------------------------------
      // Public methods
      // -------------------------------------------------------------------------
      /**
       * Called before migrations are run.
       */
      async beforeMigration() {
        await this.query(`PRAGMA foreign_keys = OFF`);
      }
      /**
       * Called after migrations are run.
       */
      async afterMigration() {
        await this.query(`PRAGMA foreign_keys = ON`);
      }
      async flush() {
        if (this.isDirty) {
          await this.driver.autoSave();
          this.isDirty = false;
        }
      }
      async release() {
        await this.flush();
        return super.release();
      }
      /**
       * Commits transaction.
       * Error will be thrown if transaction was not started.
       */
      async commitTransaction() {
        await super.commitTransaction();
        if (!this.isTransactionActive) {
          await this.flush();
        }
      }
      /**
       * Executes a given SQL query.
       */
      async query(query, parameters = [], useStructuredResult = false) {
        if (this.isReleased)
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        const command = query.trim().split(" ", 1)[0];
        const databaseConnection = this.driver.databaseConnection;
        this.driver.connection.logger.logQuery(query, parameters, this);
        await this.broadcaster.broadcast("BeforeQuery", query, parameters);
        const broadcasterResult = new BroadcasterResult_1.BroadcasterResult();
        const queryStartTime = Date.now();
        let statement;
        try {
          statement = databaseConnection.prepare(query);
          if (parameters) {
            parameters = parameters.map((p) => typeof p !== "undefined" ? p : null);
            statement.bind(parameters);
          }
          const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
          const queryEndTime = Date.now();
          const queryExecutionTime = queryEndTime - queryStartTime;
          if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime)
            this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
          const records = [];
          while (statement.step()) {
            records.push(statement.getAsObject());
          }
          this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, records, void 0);
          const result = new QueryResult_1.QueryResult();
          result.affected = databaseConnection.getRowsModified();
          result.records = records;
          result.raw = records;
          statement.free();
          if (command !== "SELECT") {
            this.isDirty = true;
          }
          if (useStructuredResult) {
            return result;
          } else {
            return result.raw;
          }
        } catch (err) {
          if (statement) {
            statement.free();
          }
          this.driver.connection.logger.logQueryError(err, query, parameters, this);
          this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, void 0, void 0, err);
          throw new QueryFailedError_1.QueryFailedError(query, parameters, err);
        } finally {
          await broadcasterResult.wait();
        }
      }
    };
    exports2.SqljsQueryRunner = SqljsQueryRunner;
  }
});

// node_modules/typeorm/driver/sqljs/SqljsDriver.js
var require_SqljsDriver = __commonJS({
  "node_modules/typeorm/driver/sqljs/SqljsDriver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SqljsDriver = void 0;
    var AbstractSqliteDriver_1 = require_AbstractSqliteDriver();
    var SqljsQueryRunner_1 = require_SqljsQueryRunner();
    var DriverPackageNotInstalledError_1 = require_DriverPackageNotInstalledError();
    var DriverOptionNotSetError_1 = require_DriverOptionNotSetError();
    var PlatformTools_1 = require_PlatformTools();
    var OrmUtils_1 = require_OrmUtils();
    var error_1 = require_error();
    var SqljsDriver = class extends AbstractSqliteDriver_1.AbstractSqliteDriver {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection) {
        super(connection);
        if (this.options.autoSave && !this.options.location && !this.options.autoSaveCallback) {
          throw new DriverOptionNotSetError_1.DriverOptionNotSetError(`location or autoSaveCallback`);
        }
        this.loadDependencies();
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Performs connection to the database.
       */
      async connect() {
        this.databaseConnection = await this.createDatabaseConnection();
      }
      /**
       * Closes connection with database.
       */
      async disconnect() {
        this.queryRunner = void 0;
        this.databaseConnection.close();
      }
      /**
       * Creates a query runner used to execute database queries.
       */
      createQueryRunner(mode) {
        if (!this.queryRunner)
          this.queryRunner = new SqljsQueryRunner_1.SqljsQueryRunner(this);
        return this.queryRunner;
      }
      /**
       * Loads a database from a given file (Node.js), local storage key (browser) or array.
       * This will delete the current database!
       */
      async load(fileNameOrLocalStorageOrData, checkIfFileOrLocalStorageExists = true) {
        if (typeof fileNameOrLocalStorageOrData === "string") {
          if (PlatformTools_1.PlatformTools.type === "node") {
            if (PlatformTools_1.PlatformTools.fileExist(fileNameOrLocalStorageOrData)) {
              const database = PlatformTools_1.PlatformTools.readFileSync(fileNameOrLocalStorageOrData);
              return this.createDatabaseConnectionWithImport(database);
            } else if (checkIfFileOrLocalStorageExists) {
              throw new error_1.TypeORMError(`File ${fileNameOrLocalStorageOrData} does not exist`);
            } else {
              return this.createDatabaseConnectionWithImport();
            }
          } else {
            let localStorageContent = null;
            if (this.options.useLocalForage) {
              if (window.localforage) {
                localStorageContent = await window.localforage.getItem(fileNameOrLocalStorageOrData);
              } else {
                throw new error_1.TypeORMError(`localforage is not defined - please import localforage.js into your site`);
              }
            } else {
              localStorageContent = PlatformTools_1.PlatformTools.getGlobalVariable().localStorage.getItem(fileNameOrLocalStorageOrData);
            }
            if (localStorageContent != null) {
              return this.createDatabaseConnectionWithImport(JSON.parse(localStorageContent));
            } else if (checkIfFileOrLocalStorageExists) {
              throw new error_1.TypeORMError(`File ${fileNameOrLocalStorageOrData} does not exist`);
            } else {
              return this.createDatabaseConnectionWithImport();
            }
          }
        } else {
          return this.createDatabaseConnectionWithImport(fileNameOrLocalStorageOrData);
        }
      }
      /**
       * Saved the current database to the given file (Node.js), local storage key (browser) or
       * indexedDB key (browser with enabled useLocalForage option).
       * If no location path is given, the location path in the options (if specified) will be used.
       */
      async save(location) {
        if (!location && !this.options.location) {
          throw new error_1.TypeORMError(`No location is set, specify a location parameter or add the location option to your configuration`);
        }
        let path = "";
        if (location) {
          path = location;
        } else if (this.options.location) {
          path = this.options.location;
        }
        if (PlatformTools_1.PlatformTools.type === "node") {
          try {
            const content = Buffer.from(this.databaseConnection.export());
            await PlatformTools_1.PlatformTools.writeFile(path, content);
          } catch (e) {
            throw new error_1.TypeORMError(`Could not save database, error: ${e}`);
          }
        } else {
          const database = this.databaseConnection.export();
          const databaseArray = [].slice.call(database);
          if (this.options.useLocalForage) {
            if (window.localforage) {
              await window.localforage.setItem(path, JSON.stringify(databaseArray));
            } else {
              throw new error_1.TypeORMError(`localforage is not defined - please import localforage.js into your site`);
            }
          } else {
            PlatformTools_1.PlatformTools.getGlobalVariable().localStorage.setItem(path, JSON.stringify(databaseArray));
          }
        }
      }
      /**
       * This gets called by the QueryRunner when a change to the database is made.
       * If a custom autoSaveCallback is specified, it get's called with the database as Uint8Array,
       * otherwise the save method is called which saves it to file (Node.js), local storage (browser)
       * or indexedDB (browser with enabled useLocalForage option).
       * Don't auto-save when in transaction as the call to export will end the current transaction
       */
      async autoSave() {
        if (this.options.autoSave && !this.queryRunner?.isTransactionActive) {
          if (this.options.autoSaveCallback) {
            await this.options.autoSaveCallback(this.export());
          } else {
            await this.save();
          }
        }
      }
      /**
       * Returns the current database as Uint8Array.
       */
      export() {
        return this.databaseConnection.export();
      }
      /**
       * Creates generated map of values generated or returned by database after INSERT query.
       */
      createGeneratedMap(metadata, insertResult) {
        const generatedMap = metadata.generatedColumns.reduce((map, generatedColumn) => {
          if (generatedColumn.isPrimary && generatedColumn.generationStrategy === "increment") {
            const query = "SELECT last_insert_rowid()";
            try {
              const result = this.databaseConnection.exec(query);
              this.connection.logger.logQuery(query);
              return OrmUtils_1.OrmUtils.mergeDeep(map, generatedColumn.createValueMap(result[0].values[0][0]));
            } catch (e) {
              this.connection.logger.logQueryError(e, query, []);
            }
          }
          return map;
        }, {});
        return Object.keys(generatedMap).length > 0 ? generatedMap : void 0;
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Creates connection with the database.
       * If the location option is set, the database is loaded first.
       */
      createDatabaseConnection() {
        if (this.options.location) {
          return this.load(this.options.location, false);
        }
        return this.createDatabaseConnectionWithImport(this.options.database);
      }
      /**
       * Creates connection with an optional database.
       * If database is specified it is loaded, otherwise a new empty database is created.
       */
      async createDatabaseConnectionWithImport(database) {
        const isLegacyVersion = typeof this.sqlite.Database === "function";
        const sqlite = isLegacyVersion ? this.sqlite : await this.sqlite(this.options.sqlJsConfig);
        if (database && database.length > 0) {
          this.databaseConnection = new sqlite.Database(database);
        } else {
          this.databaseConnection = new sqlite.Database();
        }
        this.databaseConnection.exec(`PRAGMA foreign_keys = ON`);
        return this.databaseConnection;
      }
      /**
       * If driver dependency is not given explicitly, then try to load it via "require".
       */
      loadDependencies() {
        if (PlatformTools_1.PlatformTools.type === "browser") {
          const sqlite = this.options.driver || window.SQL;
          this.sqlite = sqlite;
        } else {
          try {
            const sqlite = this.options.driver || PlatformTools_1.PlatformTools.load("sql.js");
            this.sqlite = sqlite;
          } catch (e) {
            throw new DriverPackageNotInstalledError_1.DriverPackageNotInstalledError("sql.js", "sql.js");
          }
        }
      }
    };
    exports2.SqljsDriver = SqljsDriver;
  }
});

// node_modules/typeorm/driver/mysql/MysqlQueryRunner.js
var require_MysqlQueryRunner = __commonJS({
  "node_modules/typeorm/driver/mysql/MysqlQueryRunner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MysqlQueryRunner = void 0;
    var error_1 = require_error();
    var QueryFailedError_1 = require_QueryFailedError();
    var QueryRunnerAlreadyReleasedError_1 = require_QueryRunnerAlreadyReleasedError();
    var TransactionNotStartedError_1 = require_TransactionNotStartedError();
    var BaseQueryRunner_1 = require_BaseQueryRunner();
    var QueryResult_1 = require_QueryResult();
    var Table_1 = require_Table();
    var TableColumn_1 = require_TableColumn();
    var TableForeignKey_1 = require_TableForeignKey();
    var TableIndex_1 = require_TableIndex();
    var TableUnique_1 = require_TableUnique();
    var View_1 = require_View();
    var Broadcaster_1 = require_Broadcaster();
    var BroadcasterResult_1 = require_BroadcasterResult();
    var InstanceChecker_1 = require_InstanceChecker();
    var OrmUtils_1 = require_OrmUtils();
    var VersionUtils_1 = require_VersionUtils();
    var Query_1 = require_Query();
    var MetadataTableType_1 = require_MetadataTableType();
    var MysqlQueryRunner = class extends BaseQueryRunner_1.BaseQueryRunner {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(driver, mode) {
        super();
        this.driver = driver;
        this.connection = driver.connection;
        this.broadcaster = new Broadcaster_1.Broadcaster(this);
        this.mode = mode;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Creates/uses database connection from the connection pool to perform further operations.
       * Returns obtained database connection.
       */
      connect() {
        if (this.databaseConnection)
          return Promise.resolve(this.databaseConnection);
        if (this.databaseConnectionPromise)
          return this.databaseConnectionPromise;
        if (this.mode === "slave" && this.driver.isReplicated) {
          this.databaseConnectionPromise = this.driver.obtainSlaveConnection().then((connection) => {
            this.databaseConnection = connection;
            return this.databaseConnection;
          });
        } else {
          this.databaseConnectionPromise = this.driver.obtainMasterConnection().then((connection) => {
            this.databaseConnection = connection;
            return this.databaseConnection;
          });
        }
        return this.databaseConnectionPromise;
      }
      /**
       * Releases used database connection.
       * You cannot use query runner methods once its released.
       */
      release() {
        this.isReleased = true;
        if (this.databaseConnection)
          this.databaseConnection.release();
        return Promise.resolve();
      }
      /**
       * Starts transaction on the current connection.
       */
      async startTransaction(isolationLevel) {
        this.isTransactionActive = true;
        try {
          await this.broadcaster.broadcast("BeforeTransactionStart");
        } catch (err) {
          this.isTransactionActive = false;
          throw err;
        }
        if (this.transactionDepth === 0) {
          if (isolationLevel) {
            await this.query("SET TRANSACTION ISOLATION LEVEL " + isolationLevel);
          }
          await this.query("START TRANSACTION");
        } else {
          await this.query(`SAVEPOINT typeorm_${this.transactionDepth}`);
        }
        this.transactionDepth += 1;
        await this.broadcaster.broadcast("AfterTransactionStart");
      }
      /**
       * Commits transaction.
       * Error will be thrown if transaction was not started.
       */
      async commitTransaction() {
        if (!this.isTransactionActive)
          throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionCommit");
        if (this.transactionDepth > 1) {
          await this.query(`RELEASE SAVEPOINT typeorm_${this.transactionDepth - 1}`);
        } else {
          await this.query("COMMIT");
          this.isTransactionActive = false;
        }
        this.transactionDepth -= 1;
        await this.broadcaster.broadcast("AfterTransactionCommit");
      }
      /**
       * Rollbacks transaction.
       * Error will be thrown if transaction was not started.
       */
      async rollbackTransaction() {
        if (!this.isTransactionActive)
          throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionRollback");
        if (this.transactionDepth > 1) {
          await this.query(`ROLLBACK TO SAVEPOINT typeorm_${this.transactionDepth - 1}`);
        } else {
          await this.query("ROLLBACK");
          this.isTransactionActive = false;
        }
        this.transactionDepth -= 1;
        await this.broadcaster.broadcast("AfterTransactionRollback");
      }
      /**
       * Executes a raw SQL query.
       */
      async query(query, parameters, useStructuredResult = false) {
        if (this.isReleased)
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        const databaseConnection = await this.connect();
        this.driver.connection.logger.logQuery(query, parameters, this);
        await this.broadcaster.broadcast("BeforeQuery", query, parameters);
        const broadcasterResult = new BroadcasterResult_1.BroadcasterResult();
        const queryStartTime = Date.now();
        return new Promise(async (ok, fail) => {
          try {
            const enableQueryTimeout = this.driver.options.enableQueryTimeout;
            const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
            const queryPayload = enableQueryTimeout && maxQueryExecutionTime ? { sql: query, timeout: maxQueryExecutionTime } : query;
            databaseConnection.query(queryPayload, parameters, (err, raw) => {
              const maxQueryExecutionTime2 = this.driver.options.maxQueryExecutionTime;
              const queryEndTime = Date.now();
              const queryExecutionTime = queryEndTime - queryStartTime;
              if (maxQueryExecutionTime2 && queryExecutionTime > maxQueryExecutionTime2)
                this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
              if (err) {
                this.driver.connection.logger.logQueryError(err, query, parameters, this);
                this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, void 0, void 0, err);
                return fail(new QueryFailedError_1.QueryFailedError(query, parameters, err));
              }
              this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, raw, void 0);
              const result = new QueryResult_1.QueryResult();
              result.raw = raw;
              try {
                result.records = Array.from(raw);
              } catch {
              }
              if (raw?.hasOwnProperty("affectedRows")) {
                result.affected = raw.affectedRows;
              }
              if (useStructuredResult) {
                ok(result);
              } else {
                ok(result.raw);
              }
            });
          } catch (err) {
            fail(err);
          } finally {
            await broadcasterResult.wait();
          }
        });
      }
      /**
       * Returns raw data stream.
       */
      stream(query, parameters, onEnd, onError) {
        if (this.isReleased)
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        return new Promise(async (ok, fail) => {
          try {
            const databaseConnection = await this.connect();
            this.driver.connection.logger.logQuery(query, parameters, this);
            const databaseQuery = databaseConnection.query(query, parameters);
            if (onEnd)
              databaseQuery.on("end", onEnd);
            if (onError)
              databaseQuery.on("error", onError);
            ok(databaseQuery.stream());
          } catch (err) {
            fail(err);
          }
        });
      }
      /**
       * Returns all available database names including system databases.
       */
      async getDatabases() {
        return Promise.resolve([]);
      }
      /**
       * Returns all available schema names including system schemas.
       * If database parameter specified, returns schemas of that database.
       */
      async getSchemas(database) {
        throw new error_1.TypeORMError(`MySql driver does not support table schemas`);
      }
      /**
       * Checks if database with the given name exist.
       */
      async hasDatabase(database) {
        const result = await this.query(`SELECT * FROM \`INFORMATION_SCHEMA\`.\`SCHEMATA\` WHERE \`SCHEMA_NAME\` = '${database}'`);
        return result.length ? true : false;
      }
      /**
       * Loads currently using database
       */
      async getCurrentDatabase() {
        const query = await this.query(`SELECT DATABASE() AS \`db_name\``);
        return query[0]["db_name"];
      }
      /**
       * Checks if schema with the given name exist.
       */
      async hasSchema(schema) {
        throw new error_1.TypeORMError(`MySql driver does not support table schemas`);
      }
      /**
       * Loads currently using database schema
       */
      async getCurrentSchema() {
        const query = await this.query(`SELECT SCHEMA() AS \`schema_name\``);
        return query[0]["schema_name"];
      }
      /**
       * Checks if table with the given name exist in the database.
       */
      async hasTable(tableOrName) {
        const parsedTableName = this.driver.parseTableName(tableOrName);
        const sql = `SELECT * FROM \`INFORMATION_SCHEMA\`.\`COLUMNS\` WHERE \`TABLE_SCHEMA\` = '${parsedTableName.database}' AND \`TABLE_NAME\` = '${parsedTableName.tableName}'`;
        const result = await this.query(sql);
        return result.length ? true : false;
      }
      /**
       * Checks if column with the given name exist in the given table.
       */
      async hasColumn(tableOrName, column) {
        const parsedTableName = this.driver.parseTableName(tableOrName);
        const columnName = InstanceChecker_1.InstanceChecker.isTableColumn(column) ? column.name : column;
        const sql = `SELECT * FROM \`INFORMATION_SCHEMA\`.\`COLUMNS\` WHERE \`TABLE_SCHEMA\` = '${parsedTableName.database}' AND \`TABLE_NAME\` = '${parsedTableName.tableName}' AND \`COLUMN_NAME\` = '${columnName}'`;
        const result = await this.query(sql);
        return result.length ? true : false;
      }
      /**
       * Creates a new database.
       */
      async createDatabase(database, ifNotExist) {
        const up = ifNotExist ? `CREATE DATABASE IF NOT EXISTS \`${database}\`` : `CREATE DATABASE \`${database}\``;
        const down = `DROP DATABASE \`${database}\``;
        await this.executeQueries(new Query_1.Query(up), new Query_1.Query(down));
      }
      /**
       * Drops database.
       */
      async dropDatabase(database, ifExist) {
        const up = ifExist ? `DROP DATABASE IF EXISTS \`${database}\`` : `DROP DATABASE \`${database}\``;
        const down = `CREATE DATABASE \`${database}\``;
        await this.executeQueries(new Query_1.Query(up), new Query_1.Query(down));
      }
      /**
       * Creates a new table schema.
       */
      async createSchema(schemaPath, ifNotExist) {
        throw new error_1.TypeORMError(`Schema create queries are not supported by MySql driver.`);
      }
      /**
       * Drops table schema.
       */
      async dropSchema(schemaPath, ifExist) {
        throw new error_1.TypeORMError(`Schema drop queries are not supported by MySql driver.`);
      }
      /**
       * Creates a new table.
       */
      async createTable(table, ifNotExist = false, createForeignKeys = true) {
        if (ifNotExist) {
          const isTableExist = await this.hasTable(table);
          if (isTableExist)
            return Promise.resolve();
        }
        const upQueries = [];
        const downQueries = [];
        upQueries.push(this.createTableSql(table, createForeignKeys));
        downQueries.push(this.dropTableSql(table));
        table.indices.forEach((index) => downQueries.push(this.dropIndexSql(table, index)));
        if (createForeignKeys)
          table.foreignKeys.forEach((foreignKey) => downQueries.push(this.dropForeignKeySql(table, foreignKey)));
        const generatedColumns = table.columns.filter((column) => column.generatedType && column.asExpression);
        for (const column of generatedColumns) {
          const currentDatabase = await this.getCurrentDatabase();
          const insertQuery = this.insertTypeormMetadataSql({
            schema: currentDatabase,
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name,
            value: column.asExpression
          });
          const deleteQuery = this.deleteTypeormMetadataSql({
            schema: currentDatabase,
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name
          });
          upQueries.push(insertQuery);
          downQueries.push(deleteQuery);
        }
        return this.executeQueries(upQueries, downQueries);
      }
      /**
       * Drop the table.
       */
      async dropTable(target, ifExist, dropForeignKeys = true) {
        if (ifExist) {
          const isTableExist = await this.hasTable(target);
          if (!isTableExist)
            return Promise.resolve();
        }
        const createForeignKeys = dropForeignKeys;
        const tablePath = this.getTablePath(target);
        const table = await this.getCachedTable(tablePath);
        const upQueries = [];
        const downQueries = [];
        if (dropForeignKeys)
          table.foreignKeys.forEach((foreignKey) => upQueries.push(this.dropForeignKeySql(table, foreignKey)));
        table.indices.forEach((index) => upQueries.push(this.dropIndexSql(table, index)));
        upQueries.push(this.dropTableSql(table));
        downQueries.push(this.createTableSql(table, createForeignKeys));
        const generatedColumns = table.columns.filter((column) => column.generatedType && column.asExpression);
        for (const column of generatedColumns) {
          const currentDatabase = await this.getCurrentDatabase();
          const deleteQuery = this.deleteTypeormMetadataSql({
            schema: currentDatabase,
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name
          });
          const insertQuery = this.insertTypeormMetadataSql({
            schema: currentDatabase,
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name,
            value: column.asExpression
          });
          upQueries.push(deleteQuery);
          downQueries.push(insertQuery);
        }
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Creates a new view.
       */
      async createView(view, syncWithMetadata = false) {
        const upQueries = [];
        const downQueries = [];
        upQueries.push(this.createViewSql(view));
        if (syncWithMetadata)
          upQueries.push(await this.insertViewDefinitionSql(view));
        downQueries.push(this.dropViewSql(view));
        if (syncWithMetadata)
          downQueries.push(await this.deleteViewDefinitionSql(view));
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Drops the view.
       */
      async dropView(target) {
        const viewName = InstanceChecker_1.InstanceChecker.isView(target) ? target.name : target;
        const view = await this.getCachedView(viewName);
        const upQueries = [];
        const downQueries = [];
        upQueries.push(await this.deleteViewDefinitionSql(view));
        upQueries.push(this.dropViewSql(view));
        downQueries.push(await this.insertViewDefinitionSql(view));
        downQueries.push(this.createViewSql(view));
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Renames a table.
       */
      async renameTable(oldTableOrName, newTableName) {
        const upQueries = [];
        const downQueries = [];
        const oldTable = InstanceChecker_1.InstanceChecker.isTable(oldTableOrName) ? oldTableOrName : await this.getCachedTable(oldTableOrName);
        const newTable = oldTable.clone();
        const { database } = this.driver.parseTableName(oldTable);
        newTable.name = database ? `${database}.${newTableName}` : newTableName;
        upQueries.push(new Query_1.Query(`RENAME TABLE ${this.escapePath(oldTable)} TO ${this.escapePath(newTable)}`));
        downQueries.push(new Query_1.Query(`RENAME TABLE ${this.escapePath(newTable)} TO ${this.escapePath(oldTable)}`));
        newTable.indices.forEach((index) => {
          const oldIndexName = this.connection.namingStrategy.indexName(oldTable, index.columnNames);
          if (index.name !== oldIndexName)
            return;
          const columnNames = index.columnNames.map((column) => `\`${column}\``).join(", ");
          const newIndexName = this.connection.namingStrategy.indexName(newTable, index.columnNames, index.where);
          let indexType = "";
          if (index.isUnique)
            indexType += "UNIQUE ";
          if (index.isSpatial)
            indexType += "SPATIAL ";
          if (index.isFulltext)
            indexType += "FULLTEXT ";
          const indexParser = index.isFulltext && index.parser ? ` WITH PARSER ${index.parser}` : "";
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} DROP INDEX \`${index.name}\`, ADD ${indexType}INDEX \`${newIndexName}\` (${columnNames})${indexParser}`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} DROP INDEX \`${newIndexName}\`, ADD ${indexType}INDEX \`${index.name}\` (${columnNames})${indexParser}`));
          index.name = newIndexName;
        });
        newTable.foreignKeys.forEach((foreignKey) => {
          const oldForeignKeyName = this.connection.namingStrategy.foreignKeyName(oldTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
          if (foreignKey.name !== oldForeignKeyName)
            return;
          const columnNames = foreignKey.columnNames.map((column) => `\`${column}\``).join(", ");
          const referencedColumnNames = foreignKey.referencedColumnNames.map((column) => `\`${column}\``).join(",");
          const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(newTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
          let up = `ALTER TABLE ${this.escapePath(newTable)} DROP FOREIGN KEY \`${foreignKey.name}\`, ADD CONSTRAINT \`${newForeignKeyName}\` FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;
          if (foreignKey.onDelete)
            up += ` ON DELETE ${foreignKey.onDelete}`;
          if (foreignKey.onUpdate)
            up += ` ON UPDATE ${foreignKey.onUpdate}`;
          let down = `ALTER TABLE ${this.escapePath(newTable)} DROP FOREIGN KEY \`${newForeignKeyName}\`, ADD CONSTRAINT \`${foreignKey.name}\` FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;
          if (foreignKey.onDelete)
            down += ` ON DELETE ${foreignKey.onDelete}`;
          if (foreignKey.onUpdate)
            down += ` ON UPDATE ${foreignKey.onUpdate}`;
          upQueries.push(new Query_1.Query(up));
          downQueries.push(new Query_1.Query(down));
          foreignKey.name = newForeignKeyName;
        });
        await this.executeQueries(upQueries, downQueries);
        oldTable.name = newTable.name;
        this.replaceCachedTable(oldTable, newTable);
      }
      /**
       * Change table comment.
       */
      async changeTableComment(tableOrName, newComment) {
        const upQueries = [];
        const downQueries = [];
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        newComment = this.escapeComment(newComment);
        const comment = this.escapeComment(table.comment);
        if (newComment === comment) {
          return;
        }
        const newTable = table.clone();
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} COMMENT ${newComment}`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} COMMENT ${comment}`));
        await this.executeQueries(upQueries, downQueries);
        table.comment = newTable.comment;
        this.replaceCachedTable(table, newTable);
      }
      /**
       * Creates a new column from the column in the table.
       */
      async addColumn(tableOrName, column) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        const skipColumnLevelPrimary = clonedTable.primaryColumns.length > 0;
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(column, skipColumnLevelPrimary, false)}`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN \`${column.name}\``));
        if (column.isPrimary && skipColumnLevelPrimary) {
          const generatedColumn = clonedTable.columns.find((column2) => column2.isGenerated && column2.generationStrategy === "increment");
          if (generatedColumn) {
            const nonGeneratedColumn = generatedColumn.clone();
            nonGeneratedColumn.isGenerated = false;
            nonGeneratedColumn.generationStrategy = void 0;
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${column.name}\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${nonGeneratedColumn.name}\` ${this.buildCreateColumnSql(column, true)}`));
          }
          const primaryColumns = clonedTable.primaryColumns;
          let columnNames = primaryColumns.map((column2) => `\`${column2.name}\``).join(", ");
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames})`));
          primaryColumns.push(column);
          columnNames = primaryColumns.map((column2) => `\`${column2.name}\``).join(", ");
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames})`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));
          if (generatedColumn) {
            const nonGeneratedColumn = generatedColumn.clone();
            nonGeneratedColumn.isGenerated = false;
            nonGeneratedColumn.generationStrategy = void 0;
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${nonGeneratedColumn.name}\` ${this.buildCreateColumnSql(column, true)}`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${column.name}\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));
          }
        }
        if (column.generatedType && column.asExpression) {
          const currentDatabase = await this.getCurrentDatabase();
          const insertQuery = this.insertTypeormMetadataSql({
            schema: currentDatabase,
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name,
            value: column.asExpression
          });
          const deleteQuery = this.deleteTypeormMetadataSql({
            schema: currentDatabase,
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name
          });
          upQueries.push(insertQuery);
          downQueries.push(deleteQuery);
        }
        const columnIndex = clonedTable.indices.find((index) => index.columnNames.length === 1 && index.columnNames[0] === column.name);
        if (columnIndex) {
          upQueries.push(this.createIndexSql(table, columnIndex));
          downQueries.push(this.dropIndexSql(table, columnIndex));
        } else if (column.isUnique) {
          const uniqueIndex = new TableIndex_1.TableIndex({
            name: this.connection.namingStrategy.indexName(table, [
              column.name
            ]),
            columnNames: [column.name],
            isUnique: true
          });
          clonedTable.indices.push(uniqueIndex);
          clonedTable.uniques.push(new TableUnique_1.TableUnique({
            name: uniqueIndex.name,
            columnNames: uniqueIndex.columnNames
          }));
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD UNIQUE INDEX \`${uniqueIndex.name}\` (\`${column.name}\`)`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \`${uniqueIndex.name}\``));
        }
        await this.executeQueries(upQueries, downQueries);
        clonedTable.addColumn(column);
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Creates a new columns from the column in the table.
       */
      async addColumns(tableOrName, columns) {
        for (const column of columns) {
          await this.addColumn(tableOrName, column);
        }
      }
      /**
       * Renames column in the given table.
       */
      async renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const oldColumn = InstanceChecker_1.InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find((c) => c.name === oldTableColumnOrName);
        if (!oldColumn)
          throw new error_1.TypeORMError(`Column "${oldTableColumnOrName}" was not found in the "${table.name}" table.`);
        let newColumn = void 0;
        if (InstanceChecker_1.InstanceChecker.isTableColumn(newTableColumnOrName)) {
          newColumn = newTableColumnOrName;
        } else {
          newColumn = oldColumn.clone();
          newColumn.name = newTableColumnOrName;
        }
        await this.changeColumn(table, oldColumn, newColumn);
      }
      /**
       * Changes a column in the table.
       */
      async changeColumn(tableOrName, oldColumnOrName, newColumn) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        let clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        const oldColumn = InstanceChecker_1.InstanceChecker.isTableColumn(oldColumnOrName) ? oldColumnOrName : table.columns.find((column) => column.name === oldColumnOrName);
        if (!oldColumn)
          throw new error_1.TypeORMError(`Column "${oldColumnOrName}" was not found in the "${table.name}" table.`);
        if (newColumn.isGenerated !== oldColumn.isGenerated && newColumn.generationStrategy !== "uuid" || oldColumn.type !== newColumn.type || oldColumn.length !== newColumn.length || oldColumn.generatedType && newColumn.generatedType && oldColumn.generatedType !== newColumn.generatedType || !oldColumn.generatedType && newColumn.generatedType === "VIRTUAL" || oldColumn.generatedType === "VIRTUAL" && !newColumn.generatedType) {
          await this.dropColumn(table, oldColumn);
          await this.addColumn(table, newColumn);
          clonedTable = table.clone();
        } else {
          if (newColumn.name !== oldColumn.name) {
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${oldColumn.name}\` \`${newColumn.name}\` ${this.buildCreateColumnSql(oldColumn, true, true)}`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${newColumn.name}\` \`${oldColumn.name}\` ${this.buildCreateColumnSql(oldColumn, true, true)}`));
            clonedTable.findColumnIndices(oldColumn).forEach((index) => {
              const oldUniqueName = this.connection.namingStrategy.indexName(clonedTable, index.columnNames);
              if (index.name !== oldUniqueName)
                return;
              index.columnNames.splice(index.columnNames.indexOf(oldColumn.name), 1);
              index.columnNames.push(newColumn.name);
              const columnNames = index.columnNames.map((column) => `\`${column}\``).join(", ");
              const newIndexName = this.connection.namingStrategy.indexName(clonedTable, index.columnNames, index.where);
              let indexType = "";
              if (index.isUnique)
                indexType += "UNIQUE ";
              if (index.isSpatial)
                indexType += "SPATIAL ";
              if (index.isFulltext)
                indexType += "FULLTEXT ";
              const indexParser = index.isFulltext && index.parser ? ` WITH PARSER ${index.parser}` : "";
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \`${index.name}\`, ADD ${indexType}INDEX \`${newIndexName}\` (${columnNames})${indexParser}`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \`${newIndexName}\`, ADD ${indexType}INDEX \`${index.name}\` (${columnNames})${indexParser}`));
              index.name = newIndexName;
            });
            clonedTable.findColumnForeignKeys(oldColumn).forEach((foreignKey) => {
              const foreignKeyName = this.connection.namingStrategy.foreignKeyName(clonedTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
              if (foreignKey.name !== foreignKeyName)
                return;
              foreignKey.columnNames.splice(foreignKey.columnNames.indexOf(oldColumn.name), 1);
              foreignKey.columnNames.push(newColumn.name);
              const columnNames = foreignKey.columnNames.map((column) => `\`${column}\``).join(", ");
              const referencedColumnNames = foreignKey.referencedColumnNames.map((column) => `\`${column}\``).join(",");
              const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(clonedTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
              let up = `ALTER TABLE ${this.escapePath(table)} DROP FOREIGN KEY \`${foreignKey.name}\`, ADD CONSTRAINT \`${newForeignKeyName}\` FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;
              if (foreignKey.onDelete)
                up += ` ON DELETE ${foreignKey.onDelete}`;
              if (foreignKey.onUpdate)
                up += ` ON UPDATE ${foreignKey.onUpdate}`;
              let down = `ALTER TABLE ${this.escapePath(table)} DROP FOREIGN KEY \`${newForeignKeyName}\`, ADD CONSTRAINT \`${foreignKey.name}\` FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;
              if (foreignKey.onDelete)
                down += ` ON DELETE ${foreignKey.onDelete}`;
              if (foreignKey.onUpdate)
                down += ` ON UPDATE ${foreignKey.onUpdate}`;
              upQueries.push(new Query_1.Query(up));
              downQueries.push(new Query_1.Query(down));
              foreignKey.name = newForeignKeyName;
            });
            const oldTableColumn = clonedTable.columns.find((column) => column.name === oldColumn.name);
            clonedTable.columns[clonedTable.columns.indexOf(oldTableColumn)].name = newColumn.name;
            oldColumn.name = newColumn.name;
          }
          if (this.isColumnChanged(oldColumn, newColumn, true, true)) {
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${oldColumn.name}\` ${this.buildCreateColumnSql(newColumn, true)}`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${newColumn.name}\` ${this.buildCreateColumnSql(oldColumn, true)}`));
            if (oldColumn.generatedType && !newColumn.generatedType) {
              const currentDatabase = await this.getCurrentDatabase();
              const deleteQuery = this.deleteTypeormMetadataSql({
                schema: currentDatabase,
                table: table.name,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: oldColumn.name
              });
              const insertQuery = this.insertTypeormMetadataSql({
                schema: currentDatabase,
                table: table.name,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: oldColumn.name,
                value: oldColumn.asExpression
              });
              upQueries.push(deleteQuery);
              downQueries.push(insertQuery);
            } else if (!oldColumn.generatedType && newColumn.generatedType) {
              const currentDatabase = await this.getCurrentDatabase();
              const insertQuery = this.insertTypeormMetadataSql({
                schema: currentDatabase,
                table: table.name,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: newColumn.name,
                value: newColumn.asExpression
              });
              const deleteQuery = this.deleteTypeormMetadataSql({
                schema: currentDatabase,
                table: table.name,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: newColumn.name
              });
              upQueries.push(insertQuery);
              downQueries.push(deleteQuery);
            } else if (oldColumn.asExpression !== newColumn.asExpression) {
              const currentDatabase = await this.getCurrentDatabase();
              const updateQuery = this.connection.createQueryBuilder().update(this.getTypeormMetadataTableName()).set({ value: newColumn.asExpression }).where("`type` = :type", {
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN
              }).andWhere("`name` = :name", { name: oldColumn.name }).andWhere("`schema` = :schema", {
                schema: currentDatabase
              }).andWhere("`table` = :table", { table: table.name }).getQueryAndParameters();
              const revertUpdateQuery = this.connection.createQueryBuilder().update(this.getTypeormMetadataTableName()).set({ value: oldColumn.asExpression }).where("`type` = :type", {
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN
              }).andWhere("`name` = :name", { name: newColumn.name }).andWhere("`schema` = :schema", {
                schema: currentDatabase
              }).andWhere("`table` = :table", { table: table.name }).getQueryAndParameters();
              upQueries.push(new Query_1.Query(updateQuery[0], updateQuery[1]));
              downQueries.push(new Query_1.Query(revertUpdateQuery[0], revertUpdateQuery[1]));
            }
          }
          if (newColumn.isPrimary !== oldColumn.isPrimary) {
            const generatedColumn = clonedTable.columns.find((column) => column.isGenerated && column.generationStrategy === "increment");
            if (generatedColumn) {
              const nonGeneratedColumn = generatedColumn.clone();
              nonGeneratedColumn.isGenerated = false;
              nonGeneratedColumn.generationStrategy = void 0;
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${generatedColumn.name}\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${nonGeneratedColumn.name}\` ${this.buildCreateColumnSql(generatedColumn, true)}`));
            }
            const primaryColumns = clonedTable.primaryColumns;
            if (primaryColumns.length > 0) {
              const columnNames = primaryColumns.map((column) => `\`${column.name}\``).join(", ");
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames})`));
            }
            if (newColumn.isPrimary === true) {
              primaryColumns.push(newColumn);
              const column = clonedTable.columns.find((column2) => column2.name === newColumn.name);
              column.isPrimary = true;
              const columnNames = primaryColumns.map((column2) => `\`${column2.name}\``).join(", ");
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames})`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));
            } else {
              const primaryColumn = primaryColumns.find((c) => c.name === newColumn.name);
              primaryColumns.splice(primaryColumns.indexOf(primaryColumn), 1);
              const column = clonedTable.columns.find((column2) => column2.name === newColumn.name);
              column.isPrimary = false;
              if (primaryColumns.length > 0) {
                const columnNames = primaryColumns.map((column2) => `\`${column2.name}\``).join(", ");
                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames})`));
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));
              }
            }
            if (generatedColumn) {
              const nonGeneratedColumn = generatedColumn.clone();
              nonGeneratedColumn.isGenerated = false;
              nonGeneratedColumn.generationStrategy = void 0;
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${nonGeneratedColumn.name}\` ${this.buildCreateColumnSql(generatedColumn, true)}`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${generatedColumn.name}\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));
            }
          }
          if (newColumn.isUnique !== oldColumn.isUnique) {
            if (newColumn.isUnique === true) {
              const uniqueIndex = new TableIndex_1.TableIndex({
                name: this.connection.namingStrategy.indexName(table, [
                  newColumn.name
                ]),
                columnNames: [newColumn.name],
                isUnique: true
              });
              clonedTable.indices.push(uniqueIndex);
              clonedTable.uniques.push(new TableUnique_1.TableUnique({
                name: uniqueIndex.name,
                columnNames: uniqueIndex.columnNames
              }));
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD UNIQUE INDEX \`${uniqueIndex.name}\` (\`${newColumn.name}\`)`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \`${uniqueIndex.name}\``));
            } else {
              const uniqueIndex = clonedTable.indices.find((index) => {
                return index.columnNames.length === 1 && index.isUnique === true && !!index.columnNames.find((columnName) => columnName === newColumn.name);
              });
              clonedTable.indices.splice(clonedTable.indices.indexOf(uniqueIndex), 1);
              const tableUnique = clonedTable.uniques.find((unique) => unique.name === uniqueIndex.name);
              clonedTable.uniques.splice(clonedTable.uniques.indexOf(tableUnique), 1);
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \`${uniqueIndex.name}\``));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD UNIQUE INDEX \`${uniqueIndex.name}\` (\`${newColumn.name}\`)`));
            }
          }
        }
        await this.executeQueries(upQueries, downQueries);
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Changes a column in the table.
       */
      async changeColumns(tableOrName, changedColumns) {
        for (const { oldColumn, newColumn } of changedColumns) {
          await this.changeColumn(tableOrName, oldColumn, newColumn);
        }
      }
      /**
       * Drops column in the table.
       */
      async dropColumn(tableOrName, columnOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const column = InstanceChecker_1.InstanceChecker.isTableColumn(columnOrName) ? columnOrName : table.findColumnByName(columnOrName);
        if (!column)
          throw new error_1.TypeORMError(`Column "${columnOrName}" was not found in table "${table.name}"`);
        const clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        if (column.isPrimary) {
          const generatedColumn = clonedTable.columns.find((column2) => column2.isGenerated && column2.generationStrategy === "increment");
          if (generatedColumn) {
            const nonGeneratedColumn = generatedColumn.clone();
            nonGeneratedColumn.isGenerated = false;
            nonGeneratedColumn.generationStrategy = void 0;
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${generatedColumn.name}\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${nonGeneratedColumn.name}\` ${this.buildCreateColumnSql(generatedColumn, true)}`));
          }
          const columnNames = clonedTable.primaryColumns.map((primaryColumn) => `\`${primaryColumn.name}\``).join(", ");
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP PRIMARY KEY`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD PRIMARY KEY (${columnNames})`));
          const tableColumn = clonedTable.findColumnByName(column.name);
          tableColumn.isPrimary = false;
          if (clonedTable.primaryColumns.length > 0) {
            const columnNames2 = clonedTable.primaryColumns.map((primaryColumn) => `\`${primaryColumn.name}\``).join(", ");
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD PRIMARY KEY (${columnNames2})`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP PRIMARY KEY`));
          }
          if (generatedColumn && generatedColumn.name !== column.name) {
            const nonGeneratedColumn = generatedColumn.clone();
            nonGeneratedColumn.isGenerated = false;
            nonGeneratedColumn.generationStrategy = void 0;
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${nonGeneratedColumn.name}\` ${this.buildCreateColumnSql(generatedColumn, true)}`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${generatedColumn.name}\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));
          }
        }
        const columnIndex = clonedTable.indices.find((index) => index.columnNames.length === 1 && index.columnNames[0] === column.name);
        if (columnIndex) {
          clonedTable.indices.splice(clonedTable.indices.indexOf(columnIndex), 1);
          upQueries.push(this.dropIndexSql(table, columnIndex));
          downQueries.push(this.createIndexSql(table, columnIndex));
        } else if (column.isUnique) {
          const uniqueName = this.connection.namingStrategy.uniqueConstraintName(table, [
            column.name
          ]);
          const foundUnique = clonedTable.uniques.find((unique) => unique.name === uniqueName);
          if (foundUnique)
            clonedTable.uniques.splice(clonedTable.uniques.indexOf(foundUnique), 1);
          const indexName = this.connection.namingStrategy.indexName(table, [
            column.name
          ]);
          const foundIndex = clonedTable.indices.find((index) => index.name === indexName);
          if (foundIndex)
            clonedTable.indices.splice(clonedTable.indices.indexOf(foundIndex), 1);
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \`${indexName}\``));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD UNIQUE INDEX \`${indexName}\` (\`${column.name}\`)`));
        }
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN \`${column.name}\``));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(column, true)}`));
        if (column.generatedType && column.asExpression) {
          const currentDatabase = await this.getCurrentDatabase();
          const deleteQuery = this.deleteTypeormMetadataSql({
            schema: currentDatabase,
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name
          });
          const insertQuery = this.insertTypeormMetadataSql({
            schema: currentDatabase,
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name,
            value: column.asExpression
          });
          upQueries.push(deleteQuery);
          downQueries.push(insertQuery);
        }
        await this.executeQueries(upQueries, downQueries);
        clonedTable.removeColumn(column);
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Drops the columns in the table.
       */
      async dropColumns(tableOrName, columns) {
        for (const column of [...columns]) {
          await this.dropColumn(tableOrName, column);
        }
      }
      /**
       * Creates a new primary key.
       */
      async createPrimaryKey(tableOrName, columnNames) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const clonedTable = table.clone();
        const up = this.createPrimaryKeySql(table, columnNames);
        const down = this.dropPrimaryKeySql(table);
        await this.executeQueries(up, down);
        clonedTable.columns.forEach((column) => {
          if (columnNames.find((columnName) => columnName === column.name))
            column.isPrimary = true;
        });
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Updates composite primary keys.
       */
      async updatePrimaryKeys(tableOrName, columns) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const clonedTable = table.clone();
        const columnNames = columns.map((column) => column.name);
        const upQueries = [];
        const downQueries = [];
        const generatedColumn = clonedTable.columns.find((column) => column.isGenerated && column.generationStrategy === "increment");
        if (generatedColumn) {
          const nonGeneratedColumn = generatedColumn.clone();
          nonGeneratedColumn.isGenerated = false;
          nonGeneratedColumn.generationStrategy = void 0;
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${generatedColumn.name}\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${nonGeneratedColumn.name}\` ${this.buildCreateColumnSql(generatedColumn, true)}`));
        }
        const primaryColumns = clonedTable.primaryColumns;
        if (primaryColumns.length > 0) {
          const columnNames2 = primaryColumns.map((column) => `\`${column.name}\``).join(", ");
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames2})`));
        }
        clonedTable.columns.filter((column) => columnNames.indexOf(column.name) !== -1).forEach((column) => column.isPrimary = true);
        const columnNamesString = columnNames.map((columnName) => `\`${columnName}\``).join(", ");
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNamesString})`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));
        const newOrExistGeneratedColumn = generatedColumn ? generatedColumn : columns.find((column) => column.isGenerated && column.generationStrategy === "increment");
        if (newOrExistGeneratedColumn) {
          const nonGeneratedColumn = newOrExistGeneratedColumn.clone();
          nonGeneratedColumn.isGenerated = false;
          nonGeneratedColumn.generationStrategy = void 0;
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${nonGeneratedColumn.name}\` ${this.buildCreateColumnSql(newOrExistGeneratedColumn, true)}`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${newOrExistGeneratedColumn.name}\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));
          const changedGeneratedColumn = clonedTable.columns.find((column) => column.name === newOrExistGeneratedColumn.name);
          changedGeneratedColumn.isGenerated = true;
          changedGeneratedColumn.generationStrategy = "increment";
        }
        await this.executeQueries(upQueries, downQueries);
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Drops a primary key.
       */
      async dropPrimaryKey(tableOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const up = this.dropPrimaryKeySql(table);
        const down = this.createPrimaryKeySql(table, table.primaryColumns.map((column) => column.name));
        await this.executeQueries(up, down);
        table.primaryColumns.forEach((column) => {
          column.isPrimary = false;
        });
      }
      /**
       * Creates a new unique constraint.
       */
      async createUniqueConstraint(tableOrName, uniqueConstraint) {
        throw new error_1.TypeORMError(`MySql does not support unique constraints. Use unique index instead.`);
      }
      /**
       * Creates a new unique constraints.
       */
      async createUniqueConstraints(tableOrName, uniqueConstraints) {
        throw new error_1.TypeORMError(`MySql does not support unique constraints. Use unique index instead.`);
      }
      /**
       * Drops an unique constraint.
       */
      async dropUniqueConstraint(tableOrName, uniqueOrName) {
        throw new error_1.TypeORMError(`MySql does not support unique constraints. Use unique index instead.`);
      }
      /**
       * Drops an unique constraints.
       */
      async dropUniqueConstraints(tableOrName, uniqueConstraints) {
        throw new error_1.TypeORMError(`MySql does not support unique constraints. Use unique index instead.`);
      }
      /**
       * Creates a new check constraint.
       */
      async createCheckConstraint(tableOrName, checkConstraint) {
        throw new error_1.TypeORMError(`MySql does not support check constraints.`);
      }
      /**
       * Creates a new check constraints.
       */
      async createCheckConstraints(tableOrName, checkConstraints) {
        throw new error_1.TypeORMError(`MySql does not support check constraints.`);
      }
      /**
       * Drops check constraint.
       */
      async dropCheckConstraint(tableOrName, checkOrName) {
        throw new error_1.TypeORMError(`MySql does not support check constraints.`);
      }
      /**
       * Drops check constraints.
       */
      async dropCheckConstraints(tableOrName, checkConstraints) {
        throw new error_1.TypeORMError(`MySql does not support check constraints.`);
      }
      /**
       * Creates a new exclusion constraint.
       */
      async createExclusionConstraint(tableOrName, exclusionConstraint) {
        throw new error_1.TypeORMError(`MySql does not support exclusion constraints.`);
      }
      /**
       * Creates a new exclusion constraints.
       */
      async createExclusionConstraints(tableOrName, exclusionConstraints) {
        throw new error_1.TypeORMError(`MySql does not support exclusion constraints.`);
      }
      /**
       * Drops exclusion constraint.
       */
      async dropExclusionConstraint(tableOrName, exclusionOrName) {
        throw new error_1.TypeORMError(`MySql does not support exclusion constraints.`);
      }
      /**
       * Drops exclusion constraints.
       */
      async dropExclusionConstraints(tableOrName, exclusionConstraints) {
        throw new error_1.TypeORMError(`MySql does not support exclusion constraints.`);
      }
      /**
       * Creates a new foreign key.
       */
      async createForeignKey(tableOrName, foreignKey) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        if (!foreignKey.name)
          foreignKey.name = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
        const up = this.createForeignKeySql(table, foreignKey);
        const down = this.dropForeignKeySql(table, foreignKey);
        await this.executeQueries(up, down);
        table.addForeignKey(foreignKey);
      }
      /**
       * Creates a new foreign keys.
       */
      async createForeignKeys(tableOrName, foreignKeys) {
        const promises = foreignKeys.map((foreignKey) => this.createForeignKey(tableOrName, foreignKey));
        await Promise.all(promises);
      }
      /**
       * Drops a foreign key.
       */
      async dropForeignKey(tableOrName, foreignKeyOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const foreignKey = InstanceChecker_1.InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName : table.foreignKeys.find((fk) => fk.name === foreignKeyOrName);
        if (!foreignKey)
          throw new error_1.TypeORMError(`Supplied foreign key was not found in table ${table.name}`);
        const up = this.dropForeignKeySql(table, foreignKey);
        const down = this.createForeignKeySql(table, foreignKey);
        await this.executeQueries(up, down);
        table.removeForeignKey(foreignKey);
      }
      /**
       * Drops a foreign keys from the table.
       */
      async dropForeignKeys(tableOrName, foreignKeys) {
        const promises = foreignKeys.map((foreignKey) => this.dropForeignKey(tableOrName, foreignKey));
        await Promise.all(promises);
      }
      /**
       * Creates a new index.
       */
      async createIndex(tableOrName, index) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        if (!index.name)
          index.name = this.generateIndexName(table, index);
        const up = this.createIndexSql(table, index);
        const down = this.dropIndexSql(table, index);
        await this.executeQueries(up, down);
        table.addIndex(index, true);
      }
      /**
       * Creates a new indices
       */
      async createIndices(tableOrName, indices) {
        const promises = indices.map((index) => this.createIndex(tableOrName, index));
        await Promise.all(promises);
      }
      /**
       * Drops an index.
       */
      async dropIndex(tableOrName, indexOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const index = InstanceChecker_1.InstanceChecker.isTableIndex(indexOrName) ? indexOrName : table.indices.find((i) => i.name === indexOrName);
        if (!index)
          throw new error_1.TypeORMError(`Supplied index ${indexOrName} was not found in table ${table.name}`);
        if (!index.name)
          index.name = this.generateIndexName(table, index);
        const up = this.dropIndexSql(table, index);
        const down = this.createIndexSql(table, index);
        await this.executeQueries(up, down);
        table.removeIndex(index, true);
      }
      /**
       * Drops an indices from the table.
       */
      async dropIndices(tableOrName, indices) {
        const promises = indices.map((index) => this.dropIndex(tableOrName, index));
        await Promise.all(promises);
      }
      /**
       * Clears all table contents.
       * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.
       */
      async clearTable(tableOrName) {
        await this.query(`TRUNCATE TABLE ${this.escapePath(tableOrName)}`);
      }
      /**
       * Removes all tables from the currently connected database.
       * Be careful using this method and avoid using it in production or migrations
       * (because it can clear all your database).
       */
      async clearDatabase(database) {
        const dbName = database ? database : this.driver.database;
        if (dbName) {
          const isDatabaseExist = await this.hasDatabase(dbName);
          if (!isDatabaseExist)
            return Promise.resolve();
        } else {
          throw new error_1.TypeORMError(`Can not clear database. No database is specified`);
        }
        const isAnotherTransactionActive = this.isTransactionActive;
        if (!isAnotherTransactionActive)
          await this.startTransaction();
        try {
          const selectViewDropsQuery = `SELECT concat('DROP VIEW IF EXISTS \`', table_schema, '\`.\`', table_name, '\`') AS \`query\` FROM \`INFORMATION_SCHEMA\`.\`VIEWS\` WHERE \`TABLE_SCHEMA\` = '${dbName}'`;
          const dropViewQueries = await this.query(selectViewDropsQuery);
          await Promise.all(dropViewQueries.map((q) => this.query(q["query"])));
          const disableForeignKeysCheckQuery = `SET FOREIGN_KEY_CHECKS = 0;`;
          const dropTablesQuery = `SELECT concat('DROP TABLE IF EXISTS \`', table_schema, '\`.\`', table_name, '\`') AS \`query\` FROM \`INFORMATION_SCHEMA\`.\`TABLES\` WHERE \`TABLE_SCHEMA\` = '${dbName}'`;
          const enableForeignKeysCheckQuery = `SET FOREIGN_KEY_CHECKS = 1;`;
          await this.query(disableForeignKeysCheckQuery);
          const dropQueries = await this.query(dropTablesQuery);
          await Promise.all(dropQueries.map((query) => this.query(query["query"])));
          await this.query(enableForeignKeysCheckQuery);
          if (!isAnotherTransactionActive)
            await this.commitTransaction();
        } catch (error) {
          try {
            if (!isAnotherTransactionActive)
              await this.rollbackTransaction();
          } catch (rollbackError) {
          }
          throw error;
        }
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      async loadViews(viewNames) {
        const hasTable = await this.hasTable(this.getTypeormMetadataTableName());
        if (!hasTable) {
          return [];
        }
        if (!viewNames) {
          viewNames = [];
        }
        const currentDatabase = await this.getCurrentDatabase();
        const viewsCondition = viewNames.map((tableName) => {
          let { database, tableName: name } = this.driver.parseTableName(tableName);
          if (!database) {
            database = currentDatabase;
          }
          return `(\`t\`.\`schema\` = '${database}' AND \`t\`.\`name\` = '${name}')`;
        }).join(" OR ");
        const query = `SELECT \`t\`.*, \`v\`.\`check_option\` FROM ${this.escapePath(this.getTypeormMetadataTableName())} \`t\` INNER JOIN \`information_schema\`.\`views\` \`v\` ON \`v\`.\`table_schema\` = \`t\`.\`schema\` AND \`v\`.\`table_name\` = \`t\`.\`name\` WHERE \`t\`.\`type\` = '${MetadataTableType_1.MetadataTableType.VIEW}' ${viewsCondition ? `AND (${viewsCondition})` : ""}`;
        const dbViews = await this.query(query);
        return dbViews.map((dbView) => {
          const view = new View_1.View();
          const db = dbView["schema"] === currentDatabase ? void 0 : dbView["schema"];
          view.database = dbView["schema"];
          view.name = this.driver.buildTableName(dbView["name"], void 0, db);
          view.expression = dbView["value"];
          return view;
        });
      }
      /**
       * Loads all tables (with given names) from the database and creates a Table from them.
       */
      async loadTables(tableNames) {
        if (tableNames && tableNames.length === 0) {
          return [];
        }
        const currentDatabase = await this.getCurrentDatabase();
        const dbTables = [];
        if (!tableNames) {
          const tablesSql = `SELECT \`TABLE_SCHEMA\`, \`TABLE_NAME\`, \`TABLE_COMMENT\` FROM \`INFORMATION_SCHEMA\`.\`TABLES\``;
          dbTables.push(...await this.query(tablesSql));
        } else {
          const tablesSql = tableNames.filter((tableName) => tableName).map((tableName) => {
            let { database, tableName: name } = this.driver.parseTableName(tableName);
            if (!database) {
              database = currentDatabase;
            }
            return `SELECT \`TABLE_SCHEMA\`, \`TABLE_NAME\`, \`TABLE_COMMENT\` FROM \`INFORMATION_SCHEMA\`.\`TABLES\` WHERE \`TABLE_SCHEMA\` = '${database}' AND \`TABLE_NAME\` = '${name}'`;
          }).join(" UNION ");
          dbTables.push(...await this.query(tablesSql));
        }
        if (!dbTables.length)
          return [];
        const statsSubquerySql = dbTables.map(({ TABLE_SCHEMA, TABLE_NAME }) => {
          return `
                SELECT
                    *
                FROM \`INFORMATION_SCHEMA\`.\`STATISTICS\`
                WHERE
                    \`TABLE_SCHEMA\` = '${TABLE_SCHEMA}'
                    AND
                    \`TABLE_NAME\` = '${TABLE_NAME}'
            `;
        }).join(" UNION ");
        const kcuSubquerySql = dbTables.map(({ TABLE_SCHEMA, TABLE_NAME }) => {
          return `
                SELECT
                    *
                FROM \`INFORMATION_SCHEMA\`.\`KEY_COLUMN_USAGE\` \`kcu\`
                WHERE
                    \`kcu\`.\`TABLE_SCHEMA\` = '${TABLE_SCHEMA}'
                    AND
                    \`kcu\`.\`TABLE_NAME\` = '${TABLE_NAME}'
            `;
        }).join(" UNION ");
        const rcSubquerySql = dbTables.map(({ TABLE_SCHEMA, TABLE_NAME }) => {
          return `
                SELECT
                    *
                FROM \`INFORMATION_SCHEMA\`.\`REFERENTIAL_CONSTRAINTS\`
                WHERE
                    \`CONSTRAINT_SCHEMA\` = '${TABLE_SCHEMA}'
                    AND
                    \`TABLE_NAME\` = '${TABLE_NAME}'
            `;
        }).join(" UNION ");
        const columnsSql = dbTables.map(({ TABLE_SCHEMA, TABLE_NAME }) => {
          return `
                SELECT
                    *
                FROM
                    \`INFORMATION_SCHEMA\`.\`COLUMNS\`
                WHERE
                    \`TABLE_SCHEMA\` = '${TABLE_SCHEMA}'
                    AND
                    \`TABLE_NAME\` = '${TABLE_NAME}'
                `;
        }).join(" UNION ");
        const collationsSql = `
            SELECT
                \`SCHEMA_NAME\`,
                \`DEFAULT_CHARACTER_SET_NAME\` as \`CHARSET\`,
                \`DEFAULT_COLLATION_NAME\` AS \`COLLATION\`
            FROM \`INFORMATION_SCHEMA\`.\`SCHEMATA\`
            `;
        const primaryKeySql = `SELECT * FROM (${kcuSubquerySql}) \`kcu\` WHERE \`CONSTRAINT_NAME\` = 'PRIMARY'`;
        const indicesSql = `
            SELECT
                \`s\`.*
            FROM (${statsSubquerySql}) \`s\`
            LEFT JOIN (${rcSubquerySql}) \`rc\`
                ON
                    \`s\`.\`INDEX_NAME\` = \`rc\`.\`CONSTRAINT_NAME\`
                    AND
                    \`s\`.\`TABLE_SCHEMA\` = \`rc\`.\`CONSTRAINT_SCHEMA\`
            WHERE
                \`s\`.\`INDEX_NAME\` != 'PRIMARY'
                AND
                \`rc\`.\`CONSTRAINT_NAME\` IS NULL
            `;
        const foreignKeysSql = `
            SELECT
                \`kcu\`.\`TABLE_SCHEMA\`,
                \`kcu\`.\`TABLE_NAME\`,
                \`kcu\`.\`CONSTRAINT_NAME\`,
                \`kcu\`.\`COLUMN_NAME\`,
                \`kcu\`.\`REFERENCED_TABLE_SCHEMA\`,
                \`kcu\`.\`REFERENCED_TABLE_NAME\`,
                \`kcu\`.\`REFERENCED_COLUMN_NAME\`,
                \`rc\`.\`DELETE_RULE\` \`ON_DELETE\`,
                \`rc\`.\`UPDATE_RULE\` \`ON_UPDATE\`
            FROM (${kcuSubquerySql}) \`kcu\`
            INNER JOIN (${rcSubquerySql}) \`rc\`
                ON
                    \`rc\`.\`CONSTRAINT_SCHEMA\` = \`kcu\`.\`CONSTRAINT_SCHEMA\`
                    AND
                    \`rc\`.\`TABLE_NAME\` = \`kcu\`.\`TABLE_NAME\`
                    AND
                    \`rc\`.\`CONSTRAINT_NAME\` = \`kcu\`.\`CONSTRAINT_NAME\`
            `;
        const [dbColumns, dbPrimaryKeys, dbCollations, dbIndices, dbForeignKeys] = await Promise.all([
          this.query(columnsSql),
          this.query(primaryKeySql),
          this.query(collationsSql),
          this.query(indicesSql),
          this.query(foreignKeysSql)
        ]);
        const isMariaDb = this.driver.options.type === "mariadb";
        const dbVersion = this.driver.version;
        return Promise.all(dbTables.map(async (dbTable) => {
          const table = new Table_1.Table();
          const dbCollation = dbCollations.find((coll) => coll["SCHEMA_NAME"] === dbTable["TABLE_SCHEMA"]);
          const defaultCollation = dbCollation["COLLATION"];
          const defaultCharset = dbCollation["CHARSET"];
          const db = dbTable["TABLE_SCHEMA"] === currentDatabase ? void 0 : dbTable["TABLE_SCHEMA"];
          table.database = dbTable["TABLE_SCHEMA"];
          table.name = this.driver.buildTableName(dbTable["TABLE_NAME"], void 0, db);
          table.columns = await Promise.all(dbColumns.filter((dbColumn) => dbColumn["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbColumn["TABLE_SCHEMA"] === dbTable["TABLE_SCHEMA"]).map(async (dbColumn) => {
            const columnUniqueIndices = dbIndices.filter((dbIndex) => {
              return dbIndex["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbIndex["TABLE_SCHEMA"] === dbTable["TABLE_SCHEMA"] && dbIndex["COLUMN_NAME"] === dbColumn["COLUMN_NAME"] && parseInt(dbIndex["NON_UNIQUE"], 10) === 0;
            });
            const tableMetadata = this.connection.entityMetadatas.find((metadata) => this.getTablePath(table) === this.getTablePath(metadata));
            const hasIgnoredIndex = columnUniqueIndices.length > 0 && tableMetadata && tableMetadata.indices.some((index) => {
              return columnUniqueIndices.some((uniqueIndex) => {
                return index.name === uniqueIndex["INDEX_NAME"] && index.synchronize === false;
              });
            });
            const isConstraintComposite = columnUniqueIndices.every((uniqueIndex) => {
              return dbIndices.some((dbIndex) => dbIndex["INDEX_NAME"] === uniqueIndex["INDEX_NAME"] && dbIndex["COLUMN_NAME"] !== dbColumn["COLUMN_NAME"]);
            });
            const tableColumn = new TableColumn_1.TableColumn();
            tableColumn.name = dbColumn["COLUMN_NAME"];
            tableColumn.type = dbColumn["DATA_TYPE"].toLowerCase();
            if (tableColumn.type === "geomcollection") {
              tableColumn.type = "geometrycollection";
            }
            tableColumn.zerofill = dbColumn["COLUMN_TYPE"].indexOf("zerofill") !== -1;
            tableColumn.unsigned = tableColumn.zerofill ? true : dbColumn["COLUMN_TYPE"].indexOf("unsigned") !== -1;
            if (this.driver.withWidthColumnTypes.indexOf(tableColumn.type) !== -1) {
              const width = dbColumn["COLUMN_TYPE"].substring(dbColumn["COLUMN_TYPE"].indexOf("(") + 1, dbColumn["COLUMN_TYPE"].indexOf(")"));
              tableColumn.width = width && !this.isDefaultColumnWidth(table, tableColumn, parseInt(width)) ? parseInt(width) : void 0;
            }
            if (dbColumn["COLUMN_DEFAULT"] === null || dbColumn["COLUMN_DEFAULT"] === void 0 || isMariaDb && dbColumn["COLUMN_DEFAULT"] === "NULL") {
              tableColumn.default = void 0;
            } else if (/^CURRENT_TIMESTAMP(\([0-9]*\))?$/i.test(dbColumn["COLUMN_DEFAULT"])) {
              tableColumn.default = dbColumn["COLUMN_DEFAULT"].toUpperCase();
            } else if (isMariaDb && VersionUtils_1.VersionUtils.isGreaterOrEqual(dbVersion, "10.2.7")) {
              tableColumn.default = dbColumn["COLUMN_DEFAULT"];
            } else {
              tableColumn.default = `'${dbColumn["COLUMN_DEFAULT"]}'`;
            }
            if (dbColumn["EXTRA"].indexOf("on update") !== -1) {
              tableColumn.onUpdate = dbColumn["EXTRA"].substring(dbColumn["EXTRA"].indexOf("on update") + 10).toUpperCase();
            }
            if (dbColumn["GENERATION_EXPRESSION"]) {
              tableColumn.generatedType = dbColumn["EXTRA"].indexOf("VIRTUAL") !== -1 ? "VIRTUAL" : "STORED";
              const asExpressionQuery = this.selectTypeormMetadataSql({
                schema: dbTable["TABLE_SCHEMA"],
                table: dbTable["TABLE_NAME"],
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: tableColumn.name
              });
              const results = await this.query(asExpressionQuery.query, asExpressionQuery.parameters);
              if (results[0] && results[0].value) {
                tableColumn.asExpression = results[0].value;
              } else {
                tableColumn.asExpression = "";
              }
            }
            tableColumn.isUnique = columnUniqueIndices.length > 0 && !hasIgnoredIndex && !isConstraintComposite;
            if (isMariaDb && tableColumn.generatedType) {
            } else {
              tableColumn.isNullable = dbColumn["IS_NULLABLE"] === "YES";
            }
            tableColumn.isPrimary = dbPrimaryKeys.some((dbPrimaryKey) => {
              return dbPrimaryKey["TABLE_NAME"] === dbColumn["TABLE_NAME"] && dbPrimaryKey["TABLE_SCHEMA"] === dbColumn["TABLE_SCHEMA"] && dbPrimaryKey["COLUMN_NAME"] === dbColumn["COLUMN_NAME"];
            });
            tableColumn.isGenerated = dbColumn["EXTRA"].indexOf("auto_increment") !== -1;
            if (tableColumn.isGenerated)
              tableColumn.generationStrategy = "increment";
            tableColumn.comment = typeof dbColumn["COLUMN_COMMENT"] === "string" && dbColumn["COLUMN_COMMENT"].length === 0 ? void 0 : dbColumn["COLUMN_COMMENT"];
            if (dbColumn["CHARACTER_SET_NAME"])
              tableColumn.charset = dbColumn["CHARACTER_SET_NAME"] === defaultCharset ? void 0 : dbColumn["CHARACTER_SET_NAME"];
            if (dbColumn["COLLATION_NAME"])
              tableColumn.collation = dbColumn["COLLATION_NAME"] === defaultCollation ? void 0 : dbColumn["COLLATION_NAME"];
            if (this.driver.withLengthColumnTypes.indexOf(tableColumn.type) !== -1 && dbColumn["CHARACTER_MAXIMUM_LENGTH"]) {
              const length = dbColumn["CHARACTER_MAXIMUM_LENGTH"].toString();
              tableColumn.length = !this.isDefaultColumnLength(table, tableColumn, length) ? length : "";
            }
            if (tableColumn.type === "decimal" || tableColumn.type === "double" || tableColumn.type === "float") {
              if (dbColumn["NUMERIC_PRECISION"] !== null && !this.isDefaultColumnPrecision(table, tableColumn, dbColumn["NUMERIC_PRECISION"]))
                tableColumn.precision = parseInt(dbColumn["NUMERIC_PRECISION"]);
              if (dbColumn["NUMERIC_SCALE"] !== null && !this.isDefaultColumnScale(table, tableColumn, dbColumn["NUMERIC_SCALE"]))
                tableColumn.scale = parseInt(dbColumn["NUMERIC_SCALE"]);
            }
            if (tableColumn.type === "enum" || tableColumn.type === "simple-enum" || tableColumn.type === "set") {
              const colType = dbColumn["COLUMN_TYPE"];
              const items = colType.substring(colType.indexOf("(") + 1, colType.lastIndexOf(")")).split(",");
              tableColumn.enum = items.map((item) => {
                return item.substring(1, item.length - 1);
              });
              tableColumn.length = "";
            }
            if ((tableColumn.type === "datetime" || tableColumn.type === "time" || tableColumn.type === "timestamp") && dbColumn["DATETIME_PRECISION"] !== null && dbColumn["DATETIME_PRECISION"] !== void 0 && !this.isDefaultColumnPrecision(table, tableColumn, parseInt(dbColumn["DATETIME_PRECISION"]))) {
              tableColumn.precision = parseInt(dbColumn["DATETIME_PRECISION"]);
            }
            return tableColumn;
          }));
          const tableForeignKeyConstraints = OrmUtils_1.OrmUtils.uniq(dbForeignKeys.filter((dbForeignKey) => {
            return dbForeignKey["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbForeignKey["TABLE_SCHEMA"] === dbTable["TABLE_SCHEMA"];
          }), (dbForeignKey) => dbForeignKey["CONSTRAINT_NAME"]);
          table.foreignKeys = tableForeignKeyConstraints.map((dbForeignKey) => {
            const foreignKeys = dbForeignKeys.filter((dbFk) => dbFk["CONSTRAINT_NAME"] === dbForeignKey["CONSTRAINT_NAME"]);
            const database = dbForeignKey["REFERENCED_TABLE_SCHEMA"] === currentDatabase ? void 0 : dbForeignKey["REFERENCED_TABLE_SCHEMA"];
            const referencedTableName = this.driver.buildTableName(dbForeignKey["REFERENCED_TABLE_NAME"], void 0, database);
            return new TableForeignKey_1.TableForeignKey({
              name: dbForeignKey["CONSTRAINT_NAME"],
              columnNames: foreignKeys.map((dbFk) => dbFk["COLUMN_NAME"]),
              referencedDatabase: dbForeignKey["REFERENCED_TABLE_SCHEMA"],
              referencedTableName,
              referencedColumnNames: foreignKeys.map((dbFk) => dbFk["REFERENCED_COLUMN_NAME"]),
              onDelete: dbForeignKey["ON_DELETE"],
              onUpdate: dbForeignKey["ON_UPDATE"]
            });
          });
          const tableIndexConstraints = OrmUtils_1.OrmUtils.uniq(dbIndices.filter((dbIndex) => dbIndex["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbIndex["TABLE_SCHEMA"] === dbTable["TABLE_SCHEMA"]), (dbIndex) => dbIndex["INDEX_NAME"]);
          table.indices = tableIndexConstraints.map((constraint) => {
            const indices = dbIndices.filter((index) => {
              return index["TABLE_SCHEMA"] === constraint["TABLE_SCHEMA"] && index["TABLE_NAME"] === constraint["TABLE_NAME"] && index["INDEX_NAME"] === constraint["INDEX_NAME"];
            });
            const nonUnique = parseInt(constraint["NON_UNIQUE"], 10);
            return new TableIndex_1.TableIndex({
              table,
              name: constraint["INDEX_NAME"],
              columnNames: indices.map((i) => i["COLUMN_NAME"]),
              isUnique: nonUnique === 0,
              isSpatial: constraint["INDEX_TYPE"] === "SPATIAL",
              isFulltext: constraint["INDEX_TYPE"] === "FULLTEXT"
            });
          });
          table.comment = dbTable["TABLE_COMMENT"];
          return table;
        }));
      }
      /**
       * Builds create table sql
       */
      createTableSql(table, createForeignKeys) {
        const columnDefinitions = table.columns.map((column) => this.buildCreateColumnSql(column, true)).join(", ");
        let sql = `CREATE TABLE ${this.escapePath(table)} (${columnDefinitions}`;
        table.columns.filter((column) => column.isUnique).forEach((column) => {
          const isUniqueIndexExist = table.indices.some((index) => {
            return index.columnNames.length === 1 && !!index.isUnique && index.columnNames.indexOf(column.name) !== -1;
          });
          const isUniqueConstraintExist = table.uniques.some((unique) => {
            return unique.columnNames.length === 1 && unique.columnNames.indexOf(column.name) !== -1;
          });
          if (!isUniqueIndexExist && !isUniqueConstraintExist)
            table.indices.push(new TableIndex_1.TableIndex({
              name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),
              columnNames: [column.name],
              isUnique: true
            }));
        });
        if (table.uniques.length > 0) {
          table.uniques.forEach((unique) => {
            const uniqueExist = table.indices.some((index) => index.name === unique.name);
            if (!uniqueExist) {
              table.indices.push(new TableIndex_1.TableIndex({
                name: unique.name,
                columnNames: unique.columnNames,
                isUnique: true
              }));
            }
          });
        }
        if (table.indices.length > 0) {
          const indicesSql = table.indices.map((index) => {
            const columnNames = index.columnNames.map((columnName) => `\`${columnName}\``).join(", ");
            if (!index.name)
              index.name = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);
            let indexType = "";
            if (index.isUnique)
              indexType += "UNIQUE ";
            if (index.isSpatial)
              indexType += "SPATIAL ";
            if (index.isFulltext)
              indexType += "FULLTEXT ";
            const indexParser = index.isFulltext && index.parser ? ` WITH PARSER ${index.parser}` : "";
            return `${indexType}INDEX \`${index.name}\` (${columnNames})${indexParser}`;
          }).join(", ");
          sql += `, ${indicesSql}`;
        }
        if (table.foreignKeys.length > 0 && createForeignKeys) {
          const foreignKeysSql = table.foreignKeys.map((fk) => {
            const columnNames = fk.columnNames.map((columnName) => `\`${columnName}\``).join(", ");
            if (!fk.name)
              fk.name = this.connection.namingStrategy.foreignKeyName(table, fk.columnNames, this.getTablePath(fk), fk.referencedColumnNames);
            const referencedColumnNames = fk.referencedColumnNames.map((columnName) => `\`${columnName}\``).join(", ");
            let constraint = `CONSTRAINT \`${fk.name}\` FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(fk))} (${referencedColumnNames})`;
            if (fk.onDelete)
              constraint += ` ON DELETE ${fk.onDelete}`;
            if (fk.onUpdate)
              constraint += ` ON UPDATE ${fk.onUpdate}`;
            return constraint;
          }).join(", ");
          sql += `, ${foreignKeysSql}`;
        }
        if (table.primaryColumns.length > 0) {
          const columnNames = table.primaryColumns.map((column) => `\`${column.name}\``).join(", ");
          sql += `, PRIMARY KEY (${columnNames})`;
        }
        sql += `) ENGINE=${table.engine || "InnoDB"}`;
        if (table.comment) {
          sql += ` COMMENT="${table.comment}"`;
        }
        return new Query_1.Query(sql);
      }
      /**
       * Builds drop table sql
       */
      dropTableSql(tableOrName) {
        return new Query_1.Query(`DROP TABLE ${this.escapePath(tableOrName)}`);
      }
      createViewSql(view) {
        if (typeof view.expression === "string") {
          return new Query_1.Query(`CREATE VIEW ${this.escapePath(view)} AS ${view.expression}`);
        } else {
          return new Query_1.Query(`CREATE VIEW ${this.escapePath(view)} AS ${view.expression(this.connection).getQuery()}`);
        }
      }
      async insertViewDefinitionSql(view) {
        const currentDatabase = await this.getCurrentDatabase();
        const expression = typeof view.expression === "string" ? view.expression.trim() : view.expression(this.connection).getQuery();
        return this.insertTypeormMetadataSql({
          type: MetadataTableType_1.MetadataTableType.VIEW,
          schema: currentDatabase,
          name: view.name,
          value: expression
        });
      }
      /**
       * Builds drop view sql.
       */
      dropViewSql(viewOrPath) {
        return new Query_1.Query(`DROP VIEW ${this.escapePath(viewOrPath)}`);
      }
      /**
       * Builds remove view sql.
       */
      async deleteViewDefinitionSql(viewOrPath) {
        const currentDatabase = await this.getCurrentDatabase();
        const viewName = InstanceChecker_1.InstanceChecker.isView(viewOrPath) ? viewOrPath.name : viewOrPath;
        return this.deleteTypeormMetadataSql({
          type: MetadataTableType_1.MetadataTableType.VIEW,
          schema: currentDatabase,
          name: viewName
        });
      }
      /**
       * Builds create index sql.
       */
      createIndexSql(table, index) {
        const columns = index.columnNames.map((columnName) => `\`${columnName}\``).join(", ");
        let indexType = "";
        if (index.isUnique)
          indexType += "UNIQUE ";
        if (index.isSpatial)
          indexType += "SPATIAL ";
        if (index.isFulltext)
          indexType += "FULLTEXT ";
        const indexParser = index.isFulltext && index.parser ? ` WITH PARSER ${index.parser}` : "";
        return new Query_1.Query(`CREATE ${indexType}INDEX \`${index.name}\` ON ${this.escapePath(table)} (${columns})${indexParser}`);
      }
      /**
       * Builds drop index sql.
       */
      dropIndexSql(table, indexOrName) {
        const indexName = InstanceChecker_1.InstanceChecker.isTableIndex(indexOrName) ? indexOrName.name : indexOrName;
        return new Query_1.Query(`DROP INDEX \`${indexName}\` ON ${this.escapePath(table)}`);
      }
      /**
       * Builds create primary key sql.
       */
      createPrimaryKeySql(table, columnNames) {
        const columnNamesString = columnNames.map((columnName) => `\`${columnName}\``).join(", ");
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNamesString})`);
      }
      /**
       * Builds drop primary key sql.
       */
      dropPrimaryKeySql(table) {
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`);
      }
      /**
       * Builds create foreign key sql.
       */
      createForeignKeySql(table, foreignKey) {
        const columnNames = foreignKey.columnNames.map((column) => `\`${column}\``).join(", ");
        const referencedColumnNames = foreignKey.referencedColumnNames.map((column) => `\`${column}\``).join(",");
        let sql = `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \`${foreignKey.name}\` FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;
        if (foreignKey.onDelete)
          sql += ` ON DELETE ${foreignKey.onDelete}`;
        if (foreignKey.onUpdate)
          sql += ` ON UPDATE ${foreignKey.onUpdate}`;
        return new Query_1.Query(sql);
      }
      /**
       * Builds drop foreign key sql.
       */
      dropForeignKeySql(table, foreignKeyOrName) {
        const foreignKeyName = InstanceChecker_1.InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName.name : foreignKeyOrName;
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP FOREIGN KEY \`${foreignKeyName}\``);
      }
      /**
       * Escapes a given comment so it's safe to include in a query.
       */
      escapeComment(comment) {
        if (!comment || comment.length === 0) {
          return `''`;
        }
        comment = comment.replace(/\\/g, "\\\\").replace(/'/g, "''").replace(/\u0000/g, "");
        return `'${comment}'`;
      }
      /**
       * Escapes given table or view path.
       */
      escapePath(target) {
        const { database, tableName } = this.driver.parseTableName(target);
        if (database && database !== this.driver.database) {
          return `\`${database}\`.\`${tableName}\``;
        }
        return `\`${tableName}\``;
      }
      /**
       * Builds a part of query to create/change a column.
       */
      buildCreateColumnSql(column, skipPrimary, skipName = false) {
        let c = "";
        if (skipName) {
          c = this.connection.driver.createFullType(column);
        } else {
          c = `\`${column.name}\` ${this.connection.driver.createFullType(column)}`;
        }
        if (column.charset)
          c += ` CHARACTER SET "${column.charset}"`;
        if (column.collation)
          c += ` COLLATE "${column.collation}"`;
        if (column.asExpression)
          c += ` AS (${column.asExpression}) ${column.generatedType ? column.generatedType : "VIRTUAL"}`;
        if (column.zerofill) {
          c += " ZEROFILL";
        } else if (column.unsigned) {
          c += " UNSIGNED";
        }
        if (column.enum)
          c += ` (${column.enum.map((value) => "'" + value.replace(/'/g, "''") + "'").join(", ")})`;
        const isMariaDb = this.driver.options.type === "mariadb";
        if (isMariaDb && column.asExpression && ["VIRTUAL", "STORED"].includes(column.generatedType || "VIRTUAL")) {
        } else {
          if (!column.isNullable)
            c += " NOT NULL";
          if (column.isNullable)
            c += " NULL";
        }
        if (column.isPrimary && !skipPrimary)
          c += " PRIMARY KEY";
        if (column.isGenerated && column.generationStrategy === "increment")
          c += " AUTO_INCREMENT";
        if (column.comment && column.comment.length > 0)
          c += ` COMMENT ${this.escapeComment(column.comment)}`;
        if (column.default !== void 0 && column.default !== null)
          c += ` DEFAULT ${column.default}`;
        if (column.onUpdate)
          c += ` ON UPDATE ${column.onUpdate}`;
        return c;
      }
      async getVersion() {
        const result = await this.query("SELECT version()");
        const versionString = result[0]["version()"];
        return versionString.replace(/^([\d.]+).*$/, "$1");
      }
      /**
       * Checks if column display width is by default.
       */
      isDefaultColumnWidth(table, column, width) {
        if (this.connection.hasMetadata(table.name)) {
          const metadata = this.connection.getMetadata(table.name);
          const columnMetadata = metadata.findColumnWithDatabaseName(column.name);
          if (columnMetadata && columnMetadata.width)
            return false;
        }
        const defaultWidthForType = this.connection.driver.dataTypeDefaults && this.connection.driver.dataTypeDefaults[column.type] && this.connection.driver.dataTypeDefaults[column.type].width;
        if (defaultWidthForType) {
          const typesWithReducedUnsignedDefault = [
            "int",
            "tinyint",
            "smallint",
            "mediumint"
          ];
          const needsAdjustment = typesWithReducedUnsignedDefault.indexOf(column.type) !== -1;
          if (column.unsigned && needsAdjustment) {
            return defaultWidthForType - 1 === width;
          } else {
            return defaultWidthForType === width;
          }
        }
        return false;
      }
    };
    exports2.MysqlQueryRunner = MysqlQueryRunner;
  }
});

// node_modules/typeorm/driver/mysql/MysqlDriver.js
var require_MysqlDriver = __commonJS({
  "node_modules/typeorm/driver/mysql/MysqlDriver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MysqlDriver = void 0;
    var ConnectionIsNotSetError_1 = require_ConnectionIsNotSetError();
    var DriverPackageNotInstalledError_1 = require_DriverPackageNotInstalledError();
    var DriverUtils_1 = require_DriverUtils();
    var MysqlQueryRunner_1 = require_MysqlQueryRunner();
    var DateUtils_1 = require_DateUtils();
    var PlatformTools_1 = require_PlatformTools();
    var RdbmsSchemaBuilder_1 = require_RdbmsSchemaBuilder();
    var OrmUtils_1 = require_OrmUtils();
    var ApplyValueTransformers_1 = require_ApplyValueTransformers();
    var error_1 = require_error();
    var VersionUtils_1 = require_VersionUtils();
    var InstanceChecker_1 = require_InstanceChecker();
    var MysqlDriver = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection) {
        this.isReplicated = false;
        this.treeSupport = true;
        this.transactionSupport = "nested";
        this.supportedDataTypes = [
          // numeric types
          "bit",
          "int",
          "integer",
          // synonym for int
          "tinyint",
          "smallint",
          "mediumint",
          "bigint",
          "float",
          "double",
          "double precision",
          // synonym for double
          "real",
          // synonym for double
          "decimal",
          "dec",
          // synonym for decimal
          "numeric",
          // synonym for decimal
          "fixed",
          // synonym for decimal
          "bool",
          // synonym for tinyint
          "boolean",
          // synonym for tinyint
          // date and time types
          "date",
          "datetime",
          "timestamp",
          "time",
          "year",
          // string types
          "char",
          "nchar",
          // synonym for national char
          "national char",
          "varchar",
          "nvarchar",
          // synonym for national varchar
          "national varchar",
          "blob",
          "text",
          "tinyblob",
          "tinytext",
          "mediumblob",
          "mediumtext",
          "longblob",
          "longtext",
          "enum",
          "set",
          "binary",
          "varbinary",
          // json data type
          "json",
          // spatial data types
          "geometry",
          "point",
          "linestring",
          "polygon",
          "multipoint",
          "multilinestring",
          "multipolygon",
          "geometrycollection",
          // additional data types for mariadb
          "uuid",
          "inet4",
          "inet6"
        ];
        this.supportedUpsertTypes = ["on-duplicate-key-update"];
        this.spatialTypes = [
          "geometry",
          "point",
          "linestring",
          "polygon",
          "multipoint",
          "multilinestring",
          "multipolygon",
          "geometrycollection"
        ];
        this.withLengthColumnTypes = [
          "char",
          "varchar",
          "nvarchar",
          "binary",
          "varbinary"
        ];
        this.withWidthColumnTypes = [
          "bit",
          "tinyint",
          "smallint",
          "mediumint",
          "int",
          "integer",
          "bigint"
        ];
        this.withPrecisionColumnTypes = [
          "decimal",
          "dec",
          "numeric",
          "fixed",
          "float",
          "double",
          "double precision",
          "real",
          "time",
          "datetime",
          "timestamp"
        ];
        this.withScaleColumnTypes = [
          "decimal",
          "dec",
          "numeric",
          "fixed",
          "float",
          "double",
          "double precision",
          "real"
        ];
        this.unsignedAndZerofillTypes = [
          "int",
          "integer",
          "smallint",
          "tinyint",
          "mediumint",
          "bigint",
          "decimal",
          "dec",
          "numeric",
          "fixed",
          "float",
          "double",
          "double precision",
          "real"
        ];
        this.mappedDataTypes = {
          createDate: "datetime",
          createDatePrecision: 6,
          createDateDefault: "CURRENT_TIMESTAMP(6)",
          updateDate: "datetime",
          updateDatePrecision: 6,
          updateDateDefault: "CURRENT_TIMESTAMP(6)",
          deleteDate: "datetime",
          deleteDatePrecision: 6,
          deleteDateNullable: true,
          version: "int",
          treeLevel: "int",
          migrationId: "int",
          migrationName: "varchar",
          migrationTimestamp: "bigint",
          cacheId: "int",
          cacheIdentifier: "varchar",
          cacheTime: "bigint",
          cacheDuration: "int",
          cacheQuery: "text",
          cacheResult: "text",
          metadataType: "varchar",
          metadataDatabase: "varchar",
          metadataSchema: "varchar",
          metadataTable: "varchar",
          metadataName: "varchar",
          metadataValue: "text"
        };
        this.dataTypeDefaults = {
          varchar: { length: 255 },
          nvarchar: { length: 255 },
          "national varchar": { length: 255 },
          char: { length: 1 },
          binary: { length: 1 },
          varbinary: { length: 255 },
          decimal: { precision: 10, scale: 0 },
          dec: { precision: 10, scale: 0 },
          numeric: { precision: 10, scale: 0 },
          fixed: { precision: 10, scale: 0 },
          float: { precision: 12 },
          double: { precision: 22 },
          time: { precision: 0 },
          datetime: { precision: 0 },
          timestamp: { precision: 0 },
          bit: { width: 1 },
          int: { width: 11 },
          integer: { width: 11 },
          tinyint: { width: 4 },
          smallint: { width: 6 },
          mediumint: { width: 9 },
          bigint: { width: 20 }
        };
        this.maxAliasLength = 63;
        this.cteCapabilities = {
          enabled: false,
          requiresRecursiveHint: true
        };
        this._isReturningSqlSupported = {
          delete: false,
          insert: false,
          update: false
        };
        this.uuidColumnTypeSuported = false;
        this.connection = connection;
        this.options = {
          legacySpatialSupport: true,
          ...connection.options
        };
        this.isReplicated = this.options.replication ? true : false;
        this.loadDependencies();
        this.database = DriverUtils_1.DriverUtils.buildDriverOptions(this.options.replication ? this.options.replication.master : this.options).database;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Performs connection to the database.
       */
      async connect() {
        if (this.options.replication) {
          this.poolCluster = this.mysql.createPoolCluster(this.options.replication);
          this.options.replication.slaves.forEach((slave, index) => {
            this.poolCluster.add("SLAVE" + index, this.createConnectionOptions(this.options, slave));
          });
          this.poolCluster.add("MASTER", this.createConnectionOptions(this.options, this.options.replication.master));
        } else {
          this.pool = await this.createPool(this.createConnectionOptions(this.options, this.options));
        }
        if (!this.database) {
          const queryRunner2 = this.createQueryRunner("master");
          this.database = await queryRunner2.getCurrentDatabase();
          await queryRunner2.release();
        }
        const queryRunner = this.createQueryRunner("master");
        this.version = await queryRunner.getVersion();
        await queryRunner.release();
        if (this.options.type === "mariadb") {
          if (VersionUtils_1.VersionUtils.isGreaterOrEqual(this.version, "10.0.5")) {
            this._isReturningSqlSupported.delete = true;
          }
          if (VersionUtils_1.VersionUtils.isGreaterOrEqual(this.version, "10.5.0")) {
            this._isReturningSqlSupported.insert = true;
          }
          if (VersionUtils_1.VersionUtils.isGreaterOrEqual(this.version, "10.2.0")) {
            this.cteCapabilities.enabled = true;
          }
          if (VersionUtils_1.VersionUtils.isGreaterOrEqual(this.version, "10.7.0")) {
            this.uuidColumnTypeSuported = true;
          }
        } else if (this.options.type === "mysql") {
          if (VersionUtils_1.VersionUtils.isGreaterOrEqual(this.version, "8.0.0")) {
            this.cteCapabilities.enabled = true;
          }
        }
      }
      /**
       * Makes any action after connection (e.g. create extensions in Postgres driver).
       */
      afterConnect() {
        return Promise.resolve();
      }
      /**
       * Closes connection with the database.
       */
      async disconnect() {
        if (!this.poolCluster && !this.pool) {
          throw new ConnectionIsNotSetError_1.ConnectionIsNotSetError("mysql");
        }
        if (this.poolCluster) {
          return new Promise((ok, fail) => {
            this.poolCluster.end((err) => err ? fail(err) : ok());
            this.poolCluster = void 0;
          });
        }
        if (this.pool) {
          return new Promise((ok, fail) => {
            this.pool.end((err) => {
              if (err)
                return fail(err);
              this.pool = void 0;
              ok();
            });
          });
        }
      }
      /**
       * Creates a schema builder used to build and sync a schema.
       */
      createSchemaBuilder() {
        return new RdbmsSchemaBuilder_1.RdbmsSchemaBuilder(this.connection);
      }
      /**
       * Creates a query runner used to execute database queries.
       */
      createQueryRunner(mode) {
        return new MysqlQueryRunner_1.MysqlQueryRunner(this, mode);
      }
      /**
       * Replaces parameters in the given sql with special escaping character
       * and an array of parameter names to be passed to a query.
       */
      escapeQueryWithParameters(sql, parameters, nativeParameters) {
        const escapedParameters = Object.keys(nativeParameters).map((key) => nativeParameters[key]);
        if (!parameters || !Object.keys(parameters).length)
          return [sql, escapedParameters];
        sql = sql.replace(/:(\.\.\.)?([A-Za-z0-9_.]+)/g, (full, isArray, key) => {
          if (!parameters.hasOwnProperty(key)) {
            return full;
          }
          const value = parameters[key];
          if (isArray) {
            return value.map((v) => {
              escapedParameters.push(v);
              return this.createParameter(key, escapedParameters.length - 1);
            }).join(", ");
          }
          if (typeof value === "function") {
            return value();
          }
          escapedParameters.push(value);
          return this.createParameter(key, escapedParameters.length - 1);
        });
        return [sql, escapedParameters];
      }
      /**
       * Escapes a column name.
       */
      escape(columnName) {
        return "`" + columnName + "`";
      }
      /**
       * Build full table name with database name, schema name and table name.
       * E.g. myDB.mySchema.myTable
       */
      buildTableName(tableName, schema, database) {
        const tablePath = [tableName];
        if (database) {
          tablePath.unshift(database);
        }
        return tablePath.join(".");
      }
      /**
       * Parse a target table name or other types and return a normalized table definition.
       */
      parseTableName(target) {
        const driverDatabase = this.database;
        const driverSchema = void 0;
        if (InstanceChecker_1.InstanceChecker.isTable(target) || InstanceChecker_1.InstanceChecker.isView(target)) {
          const parsed = this.parseTableName(target.name);
          return {
            database: target.database || parsed.database || driverDatabase,
            schema: target.schema || parsed.schema || driverSchema,
            tableName: parsed.tableName
          };
        }
        if (InstanceChecker_1.InstanceChecker.isTableForeignKey(target)) {
          const parsed = this.parseTableName(target.referencedTableName);
          return {
            database: target.referencedDatabase || parsed.database || driverDatabase,
            schema: target.referencedSchema || parsed.schema || driverSchema,
            tableName: parsed.tableName
          };
        }
        if (InstanceChecker_1.InstanceChecker.isEntityMetadata(target)) {
          return {
            database: target.database || driverDatabase,
            schema: target.schema || driverSchema,
            tableName: target.tableName
          };
        }
        const parts = target.split(".");
        return {
          database: (parts.length > 1 ? parts[0] : void 0) || driverDatabase,
          schema: driverSchema,
          tableName: parts.length > 1 ? parts[1] : parts[0]
        };
      }
      /**
       * Prepares given value to a value to be persisted, based on its column type and metadata.
       */
      preparePersistentValue(value, columnMetadata) {
        if (columnMetadata.transformer)
          value = ApplyValueTransformers_1.ApplyValueTransformers.transformTo(columnMetadata.transformer, value);
        if (value === null || value === void 0)
          return value;
        if (columnMetadata.type === Boolean) {
          return value === true ? 1 : 0;
        } else if (columnMetadata.type === "date") {
          return DateUtils_1.DateUtils.mixedDateToDateString(value);
        } else if (columnMetadata.type === "time") {
          return DateUtils_1.DateUtils.mixedDateToTimeString(value);
        } else if (columnMetadata.type === "json") {
          return JSON.stringify(value);
        } else if (columnMetadata.type === "timestamp" || columnMetadata.type === "datetime" || columnMetadata.type === Date) {
          return DateUtils_1.DateUtils.mixedDateToDate(value);
        } else if (columnMetadata.type === "simple-array") {
          return DateUtils_1.DateUtils.simpleArrayToString(value);
        } else if (columnMetadata.type === "simple-json") {
          return DateUtils_1.DateUtils.simpleJsonToString(value);
        } else if (columnMetadata.type === "enum" || columnMetadata.type === "simple-enum") {
          return "" + value;
        } else if (columnMetadata.type === "set") {
          return DateUtils_1.DateUtils.simpleArrayToString(value);
        } else if (columnMetadata.type === Number) {
          value = !isNaN(+value) ? parseInt(value) : value;
        }
        return value;
      }
      /**
       * Prepares given value to a value to be persisted, based on its column type or metadata.
       */
      prepareHydratedValue(value, columnMetadata) {
        if (value === null || value === void 0)
          return columnMetadata.transformer ? ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value) : value;
        if (columnMetadata.type === Boolean || columnMetadata.type === "bool" || columnMetadata.type === "boolean") {
          value = value ? true : false;
        } else if (columnMetadata.type === "datetime" || columnMetadata.type === Date) {
          value = DateUtils_1.DateUtils.normalizeHydratedDate(value);
        } else if (columnMetadata.type === "date") {
          value = DateUtils_1.DateUtils.mixedDateToDateString(value);
        } else if (columnMetadata.type === "json") {
          value = typeof value === "string" ? JSON.parse(value) : value;
        } else if (columnMetadata.type === "time") {
          value = DateUtils_1.DateUtils.mixedTimeToString(value);
        } else if (columnMetadata.type === "simple-array") {
          value = DateUtils_1.DateUtils.stringToSimpleArray(value);
        } else if (columnMetadata.type === "simple-json") {
          value = DateUtils_1.DateUtils.stringToSimpleJson(value);
        } else if ((columnMetadata.type === "enum" || columnMetadata.type === "simple-enum") && columnMetadata.enum && !isNaN(value) && columnMetadata.enum.indexOf(parseInt(value)) >= 0) {
          value = parseInt(value);
        } else if (columnMetadata.type === "set") {
          value = DateUtils_1.DateUtils.stringToSimpleArray(value);
        } else if (columnMetadata.type === Number) {
          value = !isNaN(+value) ? parseInt(value) : value;
        }
        if (columnMetadata.transformer)
          value = ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);
        return value;
      }
      /**
       * Creates a database type from a given column metadata.
       */
      normalizeType(column) {
        if (column.type === Number || column.type === "integer") {
          return "int";
        } else if (column.type === String) {
          return "varchar";
        } else if (column.type === Date) {
          return "datetime";
        } else if (column.type === Buffer) {
          return "blob";
        } else if (column.type === Boolean) {
          return "tinyint";
        } else if (column.type === "uuid" && !this.uuidColumnTypeSuported) {
          return "varchar";
        } else if (column.type === "json" && this.options.type === "mariadb" && !VersionUtils_1.VersionUtils.isGreaterOrEqual(this.version, "10.4.3")) {
          return "longtext";
        } else if (column.type === "simple-array" || column.type === "simple-json") {
          return "text";
        } else if (column.type === "simple-enum") {
          return "enum";
        } else if (column.type === "double precision" || column.type === "real") {
          return "double";
        } else if (column.type === "dec" || column.type === "numeric" || column.type === "fixed") {
          return "decimal";
        } else if (column.type === "bool" || column.type === "boolean") {
          return "tinyint";
        } else if (column.type === "nvarchar" || column.type === "national varchar") {
          return "varchar";
        } else if (column.type === "nchar" || column.type === "national char") {
          return "char";
        } else {
          return column.type || "";
        }
      }
      /**
       * Normalizes "default" value of the column.
       */
      normalizeDefault(columnMetadata) {
        const defaultValue = columnMetadata.default;
        if (defaultValue === null) {
          return void 0;
        }
        if ((columnMetadata.type === "enum" || columnMetadata.type === "simple-enum" || typeof defaultValue === "string") && defaultValue !== void 0) {
          return `'${defaultValue}'`;
        }
        if (columnMetadata.type === "set" && defaultValue !== void 0) {
          return `'${DateUtils_1.DateUtils.simpleArrayToString(defaultValue)}'`;
        }
        if (typeof defaultValue === "number") {
          return `'${defaultValue.toFixed(columnMetadata.scale)}'`;
        }
        if (typeof defaultValue === "boolean") {
          return defaultValue ? "1" : "0";
        }
        if (typeof defaultValue === "function") {
          const value = defaultValue();
          return this.normalizeDatetimeFunction(value);
        }
        if (defaultValue === void 0) {
          return void 0;
        }
        return `${defaultValue}`;
      }
      /**
       * Normalizes "isUnique" value of the column.
       */
      normalizeIsUnique(column) {
        return column.entityMetadata.indices.some((idx) => idx.isUnique && idx.columns.length === 1 && idx.columns[0] === column);
      }
      /**
       * Returns default column lengths, which is required on column creation.
       */
      getColumnLength(column) {
        if (column.length)
          return column.length.toString();
        if (column.generationStrategy === "uuid" && !this.uuidColumnTypeSuported)
          return "36";
        switch (column.type) {
          case String:
          case "varchar":
          case "nvarchar":
          case "national varchar":
            return "255";
          case "varbinary":
            return "255";
          default:
            return "";
        }
      }
      /**
       * Creates column type definition including length, precision and scale
       */
      createFullType(column) {
        let type = column.type;
        if (this.getColumnLength(column)) {
          type += `(${this.getColumnLength(column)})`;
        } else if (column.width) {
          type += `(${column.width})`;
        } else if (column.precision !== null && column.precision !== void 0 && column.scale !== null && column.scale !== void 0) {
          type += `(${column.precision},${column.scale})`;
        } else if (column.precision !== null && column.precision !== void 0) {
          type += `(${column.precision})`;
        }
        if (column.isArray)
          type += " array";
        return type;
      }
      /**
       * Obtains a new database connection to a master server.
       * Used for replication.
       * If replication is not setup then returns default connection's database connection.
       */
      obtainMasterConnection() {
        return new Promise((ok, fail) => {
          if (this.poolCluster) {
            this.poolCluster.getConnection("MASTER", (err, dbConnection) => {
              err ? fail(err) : ok(this.prepareDbConnection(dbConnection));
            });
          } else if (this.pool) {
            this.pool.getConnection((err, dbConnection) => {
              err ? fail(err) : ok(this.prepareDbConnection(dbConnection));
            });
          } else {
            fail(new error_1.TypeORMError(`Connection is not established with mysql database`));
          }
        });
      }
      /**
       * Obtains a new database connection to a slave server.
       * Used for replication.
       * If replication is not setup then returns master (default) connection's database connection.
       */
      obtainSlaveConnection() {
        if (!this.poolCluster)
          return this.obtainMasterConnection();
        return new Promise((ok, fail) => {
          this.poolCluster.getConnection("SLAVE*", (err, dbConnection) => {
            err ? fail(err) : ok(this.prepareDbConnection(dbConnection));
          });
        });
      }
      /**
       * Creates generated map of values generated or returned by database after INSERT query.
       */
      createGeneratedMap(metadata, insertResult, entityIndex) {
        if (!insertResult) {
          return void 0;
        }
        if (insertResult.insertId === void 0) {
          return Object.keys(insertResult).reduce((map, key) => {
            const column = metadata.findColumnWithDatabaseName(key);
            if (column) {
              OrmUtils_1.OrmUtils.mergeDeep(map, column.createValueMap(insertResult[key]));
            }
            return map;
          }, {});
        }
        const generatedMap = metadata.generatedColumns.reduce((map, generatedColumn) => {
          let value;
          if (generatedColumn.generationStrategy === "increment" && insertResult.insertId) {
            value = insertResult.insertId + entityIndex;
          }
          return OrmUtils_1.OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));
        }, {});
        return Object.keys(generatedMap).length > 0 ? generatedMap : void 0;
      }
      /**
       * Differentiate columns of this table and columns from the given column metadatas columns
       * and returns only changed.
       */
      findChangedColumns(tableColumns, columnMetadatas) {
        return columnMetadatas.filter((columnMetadata) => {
          const tableColumn = tableColumns.find((c) => c.name === columnMetadata.databaseName);
          if (!tableColumn)
            return false;
          const isColumnChanged = tableColumn.name !== columnMetadata.databaseName || this.isColumnDataTypeChanged(tableColumn, columnMetadata) || tableColumn.length !== this.getColumnLength(columnMetadata) || tableColumn.width !== columnMetadata.width || columnMetadata.precision !== void 0 && tableColumn.precision !== columnMetadata.precision || columnMetadata.scale !== void 0 && tableColumn.scale !== columnMetadata.scale || tableColumn.zerofill !== columnMetadata.zerofill || tableColumn.unsigned !== columnMetadata.unsigned || tableColumn.asExpression !== columnMetadata.asExpression || tableColumn.generatedType !== columnMetadata.generatedType || tableColumn.comment !== this.escapeComment(columnMetadata.comment) || !this.compareDefaultValues(this.normalizeDefault(columnMetadata), tableColumn.default) || tableColumn.enum && columnMetadata.enum && !OrmUtils_1.OrmUtils.isArraysEqual(tableColumn.enum, columnMetadata.enum.map((val) => val + "")) || tableColumn.onUpdate !== this.normalizeDatetimeFunction(columnMetadata.onUpdate) || tableColumn.isPrimary !== columnMetadata.isPrimary || !this.compareNullableValues(columnMetadata, tableColumn) || tableColumn.isUnique !== this.normalizeIsUnique(columnMetadata) || columnMetadata.generationStrategy !== "uuid" && tableColumn.isGenerated !== columnMetadata.isGenerated;
          return isColumnChanged;
        });
      }
      /**
       * Returns true if driver supports RETURNING / OUTPUT statement.
       */
      isReturningSqlSupported(returningType) {
        return this._isReturningSqlSupported[returningType];
      }
      /**
       * Returns true if driver supports uuid values generation on its own.
       */
      isUUIDGenerationSupported() {
        return false;
      }
      /**
       * Returns true if driver supports fulltext indices.
       */
      isFullTextColumnTypeSupported() {
        return true;
      }
      /**
       * Creates an escaped parameter.
       */
      createParameter(parameterName, index) {
        return "?";
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Loads all driver dependencies.
       */
      loadDependencies() {
        const connectorPackage = this.options.connectorPackage ?? "mysql";
        const fallbackConnectorPackage = connectorPackage === "mysql" ? "mysql2" : "mysql";
        try {
          const mysql = this.options.driver || PlatformTools_1.PlatformTools.load(connectorPackage);
          this.mysql = mysql;
          if (Object.keys(this.mysql).length === 0) {
            throw new error_1.TypeORMError(`'${connectorPackage}' was found but it is empty. Falling back to '${fallbackConnectorPackage}'.`);
          }
        } catch (e) {
          try {
            this.mysql = PlatformTools_1.PlatformTools.load(fallbackConnectorPackage);
          } catch (e2) {
            throw new DriverPackageNotInstalledError_1.DriverPackageNotInstalledError("Mysql", connectorPackage);
          }
        }
      }
      /**
       * Creates a new connection pool for a given database credentials.
       */
      createConnectionOptions(options, credentials) {
        credentials = Object.assign({}, credentials, DriverUtils_1.DriverUtils.buildDriverOptions(credentials));
        return Object.assign({}, {
          charset: options.charset,
          timezone: options.timezone,
          connectTimeout: options.connectTimeout,
          insecureAuth: options.insecureAuth,
          supportBigNumbers: options.supportBigNumbers !== void 0 ? options.supportBigNumbers : true,
          bigNumberStrings: options.bigNumberStrings !== void 0 ? options.bigNumberStrings : true,
          dateStrings: options.dateStrings,
          debug: options.debug,
          trace: options.trace,
          multipleStatements: options.multipleStatements,
          flags: options.flags,
          stringifyObjects: true
        }, {
          host: credentials.host,
          user: credentials.username,
          password: credentials.password,
          database: credentials.database,
          port: credentials.port,
          ssl: options.ssl,
          socketPath: credentials.socketPath,
          connectionLimit: options.poolSize
        }, options.acquireTimeout === void 0 ? {} : { acquireTimeout: options.acquireTimeout }, options.extra || {});
      }
      /**
       * Creates a new connection pool for a given database credentials.
       */
      createPool(connectionOptions) {
        const pool = this.mysql.createPool(connectionOptions);
        return new Promise((ok, fail) => {
          pool.getConnection((err, connection) => {
            if (err)
              return pool.end(() => fail(err));
            connection.release();
            ok(pool);
          });
        });
      }
      /**
       * Attaches all required base handlers to a database connection, such as the unhandled error handler.
       */
      prepareDbConnection(connection) {
        const { logger } = this.connection;
        if (connection.listeners("error").length === 0) {
          connection.on("error", (error) => logger.log("warn", `MySQL connection raised an error. ${error}`));
        }
        return connection;
      }
      /**
       * Checks if "DEFAULT" values in the column metadata and in the database are equal.
       */
      compareDefaultValues(columnMetadataValue, databaseValue) {
        if (typeof columnMetadataValue === "string" && typeof databaseValue === "string") {
          columnMetadataValue = columnMetadataValue.replace(/^'+|'+$/g, "");
          databaseValue = databaseValue.replace(/^'+|'+$/g, "");
        }
        return columnMetadataValue === databaseValue;
      }
      compareNullableValues(columnMetadata, tableColumn) {
        const isMariaDb = this.options.type === "mariadb";
        if (isMariaDb && columnMetadata.generatedType) {
          return true;
        }
        return columnMetadata.isNullable === tableColumn.isNullable;
      }
      /**
       * If parameter is a datetime function, e.g. "CURRENT_TIMESTAMP", normalizes it.
       * Otherwise returns original input.
       */
      normalizeDatetimeFunction(value) {
        if (!value)
          return value;
        const isDatetimeFunction = value.toUpperCase().indexOf("CURRENT_TIMESTAMP") !== -1 || value.toUpperCase().indexOf("NOW") !== -1;
        if (isDatetimeFunction) {
          const precision = value.match(/\(\d+\)/);
          if (this.options.type === "mariadb") {
            return precision ? `CURRENT_TIMESTAMP${precision[0]}` : "CURRENT_TIMESTAMP()";
          } else {
            return precision ? `CURRENT_TIMESTAMP${precision[0]}` : "CURRENT_TIMESTAMP";
          }
        } else {
          return value;
        }
      }
      /**
       * Escapes a given comment.
       */
      escapeComment(comment) {
        if (!comment)
          return comment;
        comment = comment.replace(/\u0000/g, "");
        return comment;
      }
      /**
       * A helper to check if column data types have changed
       * This can be used to manage checking any types the
       * database may alias
       */
      isColumnDataTypeChanged(tableColumn, columnMetadata) {
        if (this.normalizeType(columnMetadata) === "json" && tableColumn.type.toLowerCase() === "longtext")
          return false;
        return tableColumn.type !== this.normalizeType(columnMetadata);
      }
    };
    exports2.MysqlDriver = MysqlDriver;
  }
});

// node_modules/typeorm/driver/postgres/PostgresQueryRunner.js
var require_PostgresQueryRunner = __commonJS({
  "node_modules/typeorm/driver/postgres/PostgresQueryRunner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PostgresQueryRunner = void 0;
    var error_1 = require_error();
    var QueryFailedError_1 = require_QueryFailedError();
    var QueryRunnerAlreadyReleasedError_1 = require_QueryRunnerAlreadyReleasedError();
    var TransactionNotStartedError_1 = require_TransactionNotStartedError();
    var BaseQueryRunner_1 = require_BaseQueryRunner();
    var QueryResult_1 = require_QueryResult();
    var Table_1 = require_Table();
    var TableCheck_1 = require_TableCheck();
    var TableColumn_1 = require_TableColumn();
    var TableExclusion_1 = require_TableExclusion();
    var TableForeignKey_1 = require_TableForeignKey();
    var TableIndex_1 = require_TableIndex();
    var TableUnique_1 = require_TableUnique();
    var View_1 = require_View();
    var Broadcaster_1 = require_Broadcaster();
    var BroadcasterResult_1 = require_BroadcasterResult();
    var InstanceChecker_1 = require_InstanceChecker();
    var OrmUtils_1 = require_OrmUtils();
    var DriverUtils_1 = require_DriverUtils();
    var Query_1 = require_Query();
    var MetadataTableType_1 = require_MetadataTableType();
    var PostgresQueryRunner = class extends BaseQueryRunner_1.BaseQueryRunner {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(driver, mode) {
        super();
        this.driver = driver;
        this.connection = driver.connection;
        this.mode = mode;
        this.broadcaster = new Broadcaster_1.Broadcaster(this);
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Creates/uses database connection from the connection pool to perform further operations.
       * Returns obtained database connection.
       */
      connect() {
        if (this.databaseConnection)
          return Promise.resolve(this.databaseConnection);
        if (this.databaseConnectionPromise)
          return this.databaseConnectionPromise;
        if (this.mode === "slave" && this.driver.isReplicated) {
          this.databaseConnectionPromise = this.driver.obtainSlaveConnection().then(([connection, release]) => {
            this.driver.connectedQueryRunners.push(this);
            this.databaseConnection = connection;
            const onErrorCallback = (err) => this.releasePostgresConnection(err);
            this.releaseCallback = (err) => {
              this.databaseConnection.removeListener("error", onErrorCallback);
              release(err);
            };
            this.databaseConnection.on("error", onErrorCallback);
            return this.databaseConnection;
          });
        } else {
          this.databaseConnectionPromise = this.driver.obtainMasterConnection().then(([connection, release]) => {
            this.driver.connectedQueryRunners.push(this);
            this.databaseConnection = connection;
            const onErrorCallback = (err) => this.releasePostgresConnection(err);
            this.releaseCallback = (err) => {
              this.databaseConnection.removeListener("error", onErrorCallback);
              release(err);
            };
            this.databaseConnection.on("error", onErrorCallback);
            return this.databaseConnection;
          });
        }
        return this.databaseConnectionPromise;
      }
      /**
       * Release a connection back to the pool, optionally specifying an Error to release with.
       * Per pg-pool documentation this will prevent the pool from re-using the broken connection.
       */
      async releasePostgresConnection(err) {
        if (this.isReleased) {
          return;
        }
        this.isReleased = true;
        if (this.releaseCallback) {
          this.releaseCallback(err);
          this.releaseCallback = void 0;
        }
        const index = this.driver.connectedQueryRunners.indexOf(this);
        if (index !== -1) {
          this.driver.connectedQueryRunners.splice(index, 1);
        }
      }
      /**
       * Releases used database connection.
       * You cannot use query runner methods once its released.
       */
      release() {
        return this.releasePostgresConnection();
      }
      /**
       * Starts transaction.
       */
      async startTransaction(isolationLevel) {
        this.isTransactionActive = true;
        try {
          await this.broadcaster.broadcast("BeforeTransactionStart");
        } catch (err) {
          this.isTransactionActive = false;
          throw err;
        }
        if (this.transactionDepth === 0) {
          await this.query("START TRANSACTION");
          if (isolationLevel) {
            await this.query("SET TRANSACTION ISOLATION LEVEL " + isolationLevel);
          }
        } else {
          await this.query(`SAVEPOINT typeorm_${this.transactionDepth}`);
        }
        this.transactionDepth += 1;
        await this.broadcaster.broadcast("AfterTransactionStart");
      }
      /**
       * Commits transaction.
       * Error will be thrown if transaction was not started.
       */
      async commitTransaction() {
        if (!this.isTransactionActive)
          throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionCommit");
        if (this.transactionDepth > 1) {
          await this.query(`RELEASE SAVEPOINT typeorm_${this.transactionDepth - 1}`);
        } else {
          await this.query("COMMIT");
          this.isTransactionActive = false;
        }
        this.transactionDepth -= 1;
        await this.broadcaster.broadcast("AfterTransactionCommit");
      }
      /**
       * Rollbacks transaction.
       * Error will be thrown if transaction was not started.
       */
      async rollbackTransaction() {
        if (!this.isTransactionActive)
          throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionRollback");
        if (this.transactionDepth > 1) {
          await this.query(`ROLLBACK TO SAVEPOINT typeorm_${this.transactionDepth - 1}`);
        } else {
          await this.query("ROLLBACK");
          this.isTransactionActive = false;
        }
        this.transactionDepth -= 1;
        await this.broadcaster.broadcast("AfterTransactionRollback");
      }
      /**
       * Executes a given SQL query.
       */
      async query(query, parameters, useStructuredResult = false) {
        if (this.isReleased)
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        const databaseConnection = await this.connect();
        this.driver.connection.logger.logQuery(query, parameters, this);
        await this.broadcaster.broadcast("BeforeQuery", query, parameters);
        const broadcasterResult = new BroadcasterResult_1.BroadcasterResult();
        try {
          const queryStartTime = Date.now();
          const raw = await databaseConnection.query(query, parameters);
          const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
          const queryEndTime = Date.now();
          const queryExecutionTime = queryEndTime - queryStartTime;
          this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, raw, void 0);
          if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime)
            this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
          const result = new QueryResult_1.QueryResult();
          if (raw) {
            if (raw.hasOwnProperty("rows")) {
              result.records = raw.rows;
            }
            if (raw.hasOwnProperty("rowCount")) {
              result.affected = raw.rowCount;
            }
            switch (raw.command) {
              case "DELETE":
              case "UPDATE":
                result.raw = [raw.rows, raw.rowCount];
                break;
              default:
                result.raw = raw.rows;
            }
            if (!useStructuredResult) {
              return result.raw;
            }
          }
          return result;
        } catch (err) {
          this.driver.connection.logger.logQueryError(err, query, parameters, this);
          this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, void 0, void 0, err);
          throw new QueryFailedError_1.QueryFailedError(query, parameters, err);
        } finally {
          await broadcasterResult.wait();
        }
      }
      /**
       * Returns raw data stream.
       */
      async stream(query, parameters, onEnd, onError) {
        const QueryStream = this.driver.loadStreamDependency();
        if (this.isReleased)
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        const databaseConnection = await this.connect();
        this.driver.connection.logger.logQuery(query, parameters, this);
        const stream = databaseConnection.query(new QueryStream(query, parameters));
        if (onEnd)
          stream.on("end", onEnd);
        if (onError)
          stream.on("error", onError);
        return stream;
      }
      /**
       * Returns all available database names including system databases.
       */
      async getDatabases() {
        return Promise.resolve([]);
      }
      /**
       * Returns all available schema names including system schemas.
       * If database parameter specified, returns schemas of that database.
       */
      async getSchemas(database) {
        return Promise.resolve([]);
      }
      /**
       * Checks if database with the given name exist.
       */
      async hasDatabase(database) {
        const result = await this.query(`SELECT * FROM pg_database WHERE datname='${database}';`);
        return result.length ? true : false;
      }
      /**
       * Loads currently using database
       */
      async getCurrentDatabase() {
        const query = await this.query(`SELECT * FROM current_database()`);
        return query[0]["current_database"];
      }
      /**
       * Checks if schema with the given name exist.
       */
      async hasSchema(schema) {
        const result = await this.query(`SELECT * FROM "information_schema"."schemata" WHERE "schema_name" = '${schema}'`);
        return result.length ? true : false;
      }
      /**
       * Loads currently using database schema
       */
      async getCurrentSchema() {
        const query = await this.query(`SELECT * FROM current_schema()`);
        return query[0]["current_schema"];
      }
      /**
       * Checks if table with the given name exist in the database.
       */
      async hasTable(tableOrName) {
        const parsedTableName = this.driver.parseTableName(tableOrName);
        if (!parsedTableName.schema) {
          parsedTableName.schema = await this.getCurrentSchema();
        }
        const sql = `SELECT * FROM "information_schema"."tables" WHERE "table_schema" = '${parsedTableName.schema}' AND "table_name" = '${parsedTableName.tableName}'`;
        const result = await this.query(sql);
        return result.length ? true : false;
      }
      /**
       * Checks if column with the given name exist in the given table.
       */
      async hasColumn(tableOrName, columnName) {
        const parsedTableName = this.driver.parseTableName(tableOrName);
        if (!parsedTableName.schema) {
          parsedTableName.schema = await this.getCurrentSchema();
        }
        const sql = `SELECT * FROM "information_schema"."columns" WHERE "table_schema" = '${parsedTableName.schema}' AND "table_name" = '${parsedTableName.tableName}' AND "column_name" = '${columnName}'`;
        const result = await this.query(sql);
        return result.length ? true : false;
      }
      /**
       * Creates a new database.
       * Note: Postgres does not support database creation inside a transaction block.
       */
      async createDatabase(database, ifNotExist) {
        if (ifNotExist) {
          const databaseAlreadyExists = await this.hasDatabase(database);
          if (databaseAlreadyExists)
            return Promise.resolve();
        }
        const up = `CREATE DATABASE "${database}"`;
        const down = `DROP DATABASE "${database}"`;
        await this.executeQueries(new Query_1.Query(up), new Query_1.Query(down));
      }
      /**
       * Drops database.
       * Note: Postgres does not support database dropping inside a transaction block.
       */
      async dropDatabase(database, ifExist) {
        const up = ifExist ? `DROP DATABASE IF EXISTS "${database}"` : `DROP DATABASE "${database}"`;
        const down = `CREATE DATABASE "${database}"`;
        await this.executeQueries(new Query_1.Query(up), new Query_1.Query(down));
      }
      /**
       * Creates a new table schema.
       */
      async createSchema(schemaPath, ifNotExist) {
        const schema = schemaPath.indexOf(".") === -1 ? schemaPath : schemaPath.split(".")[1];
        const up = ifNotExist ? `CREATE SCHEMA IF NOT EXISTS "${schema}"` : `CREATE SCHEMA "${schema}"`;
        const down = `DROP SCHEMA "${schema}" CASCADE`;
        await this.executeQueries(new Query_1.Query(up), new Query_1.Query(down));
      }
      /**
       * Drops table schema.
       */
      async dropSchema(schemaPath, ifExist, isCascade) {
        const schema = schemaPath.indexOf(".") === -1 ? schemaPath : schemaPath.split(".")[1];
        const up = ifExist ? `DROP SCHEMA IF EXISTS "${schema}" ${isCascade ? "CASCADE" : ""}` : `DROP SCHEMA "${schema}" ${isCascade ? "CASCADE" : ""}`;
        const down = `CREATE SCHEMA "${schema}"`;
        await this.executeQueries(new Query_1.Query(up), new Query_1.Query(down));
      }
      /**
       * Creates a new table.
       */
      async createTable(table, ifNotExist = false, createForeignKeys = true, createIndices = true) {
        if (ifNotExist) {
          const isTableExist = await this.hasTable(table);
          if (isTableExist)
            return Promise.resolve();
        }
        const upQueries = [];
        const downQueries = [];
        const enumColumns = table.columns.filter((column) => column.type === "enum" || column.type === "simple-enum");
        const createdEnumTypes = [];
        for (const column of enumColumns) {
          const hasEnum = await this.hasEnumType(table, column);
          const enumName = this.buildEnumName(table, column);
          if (!hasEnum && createdEnumTypes.indexOf(enumName) === -1) {
            createdEnumTypes.push(enumName);
            upQueries.push(this.createEnumTypeSql(table, column, enumName));
            downQueries.push(this.dropEnumTypeSql(table, column, enumName));
          }
        }
        const generatedColumns = table.columns.filter((column) => column.generatedType === "STORED" && column.asExpression);
        for (const column of generatedColumns) {
          const tableNameWithSchema = (await this.getTableNameWithSchema(table.name)).split(".");
          const tableName = tableNameWithSchema[1];
          const schema = tableNameWithSchema[0];
          const insertQuery = this.insertTypeormMetadataSql({
            database: this.driver.database,
            schema,
            table: tableName,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name,
            value: column.asExpression
          });
          const deleteQuery = this.deleteTypeormMetadataSql({
            database: this.driver.database,
            schema,
            table: tableName,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name
          });
          upQueries.push(insertQuery);
          downQueries.push(deleteQuery);
        }
        upQueries.push(this.createTableSql(table, createForeignKeys));
        downQueries.push(this.dropTableSql(table));
        if (createForeignKeys)
          table.foreignKeys.forEach((foreignKey) => downQueries.push(this.dropForeignKeySql(table, foreignKey)));
        if (createIndices) {
          table.indices.forEach((index) => {
            if (!index.name)
              index.name = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);
            upQueries.push(this.createIndexSql(table, index));
            downQueries.push(this.dropIndexSql(table, index));
          });
        }
        if (table.comment) {
          upQueries.push(new Query_1.Query("COMMENT ON TABLE " + this.escapePath(table) + " IS '" + table.comment + "'"));
          downQueries.push(new Query_1.Query("COMMENT ON TABLE " + this.escapePath(table) + " IS NULL"));
        }
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Drops the table.
       */
      async dropTable(target, ifExist, dropForeignKeys = true, dropIndices = true) {
        if (ifExist) {
          const isTableExist = await this.hasTable(target);
          if (!isTableExist)
            return Promise.resolve();
        }
        const createForeignKeys = dropForeignKeys;
        const tablePath = this.getTablePath(target);
        const table = await this.getCachedTable(tablePath);
        const upQueries = [];
        const downQueries = [];
        if (dropIndices) {
          table.indices.forEach((index) => {
            upQueries.push(this.dropIndexSql(table, index));
            downQueries.push(this.createIndexSql(table, index));
          });
        }
        if (dropForeignKeys)
          table.foreignKeys.forEach((foreignKey) => upQueries.push(this.dropForeignKeySql(table, foreignKey)));
        upQueries.push(this.dropTableSql(table));
        downQueries.push(this.createTableSql(table, createForeignKeys));
        const generatedColumns = table.columns.filter((column) => column.generatedType && column.asExpression);
        for (const column of generatedColumns) {
          const tableNameWithSchema = (await this.getTableNameWithSchema(table.name)).split(".");
          const tableName = tableNameWithSchema[1];
          const schema = tableNameWithSchema[0];
          const deleteQuery = this.deleteTypeormMetadataSql({
            database: this.driver.database,
            schema,
            table: tableName,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name
          });
          const insertQuery = this.insertTypeormMetadataSql({
            database: this.driver.database,
            schema,
            table: tableName,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name,
            value: column.asExpression
          });
          upQueries.push(deleteQuery);
          downQueries.push(insertQuery);
        }
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Creates a new view.
       */
      async createView(view, syncWithMetadata = false) {
        const upQueries = [];
        const downQueries = [];
        upQueries.push(this.createViewSql(view));
        if (syncWithMetadata)
          upQueries.push(await this.insertViewDefinitionSql(view));
        downQueries.push(this.dropViewSql(view));
        if (syncWithMetadata)
          downQueries.push(await this.deleteViewDefinitionSql(view));
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Drops the view.
       */
      async dropView(target) {
        const viewName = InstanceChecker_1.InstanceChecker.isView(target) ? target.name : target;
        const view = await this.getCachedView(viewName);
        const upQueries = [];
        const downQueries = [];
        upQueries.push(await this.deleteViewDefinitionSql(view));
        upQueries.push(this.dropViewSql(view));
        downQueries.push(await this.insertViewDefinitionSql(view));
        downQueries.push(this.createViewSql(view));
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Renames the given table.
       */
      async renameTable(oldTableOrName, newTableName) {
        const upQueries = [];
        const downQueries = [];
        const oldTable = InstanceChecker_1.InstanceChecker.isTable(oldTableOrName) ? oldTableOrName : await this.getCachedTable(oldTableOrName);
        const newTable = oldTable.clone();
        const { schema: schemaName, tableName: oldTableName } = this.driver.parseTableName(oldTable);
        newTable.name = schemaName ? `${schemaName}.${newTableName}` : newTableName;
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(oldTable)} RENAME TO "${newTableName}"`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME TO "${oldTableName}"`));
        if (newTable.primaryColumns.length > 0 && !newTable.primaryColumns[0].primaryKeyConstraintName) {
          const columnNames = newTable.primaryColumns.map((column) => column.name);
          const oldPkName = this.connection.namingStrategy.primaryKeyName(oldTable, columnNames);
          const newPkName = this.connection.namingStrategy.primaryKeyName(newTable, columnNames);
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${oldPkName}" TO "${newPkName}"`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${newPkName}" TO "${oldPkName}"`));
        }
        newTable.columns.map((col) => {
          if (col.isGenerated && col.generationStrategy === "increment") {
            const sequencePath = this.buildSequencePath(oldTable, col.name);
            const sequenceName = this.buildSequenceName(oldTable, col.name);
            const newSequencePath = this.buildSequencePath(newTable, col.name);
            const newSequenceName = this.buildSequenceName(newTable, col.name);
            const up = `ALTER SEQUENCE ${this.escapePath(sequencePath)} RENAME TO "${newSequenceName}"`;
            const down = `ALTER SEQUENCE ${this.escapePath(newSequencePath)} RENAME TO "${sequenceName}"`;
            upQueries.push(new Query_1.Query(up));
            downQueries.push(new Query_1.Query(down));
          }
        });
        newTable.uniques.forEach((unique) => {
          const oldUniqueName = this.connection.namingStrategy.uniqueConstraintName(oldTable, unique.columnNames);
          if (unique.name !== oldUniqueName)
            return;
          const newUniqueName = this.connection.namingStrategy.uniqueConstraintName(newTable, unique.columnNames);
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${unique.name}" TO "${newUniqueName}"`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${newUniqueName}" TO "${unique.name}"`));
          unique.name = newUniqueName;
        });
        newTable.indices.forEach((index) => {
          const oldIndexName = this.connection.namingStrategy.indexName(oldTable, index.columnNames, index.where);
          if (index.name !== oldIndexName)
            return;
          const { schema } = this.driver.parseTableName(newTable);
          const newIndexName = this.connection.namingStrategy.indexName(newTable, index.columnNames, index.where);
          const up = schema ? `ALTER INDEX "${schema}"."${index.name}" RENAME TO "${newIndexName}"` : `ALTER INDEX "${index.name}" RENAME TO "${newIndexName}"`;
          const down = schema ? `ALTER INDEX "${schema}"."${newIndexName}" RENAME TO "${index.name}"` : `ALTER INDEX "${newIndexName}" RENAME TO "${index.name}"`;
          upQueries.push(new Query_1.Query(up));
          downQueries.push(new Query_1.Query(down));
          index.name = newIndexName;
        });
        newTable.foreignKeys.forEach((foreignKey) => {
          const oldForeignKeyName = this.connection.namingStrategy.foreignKeyName(oldTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
          if (foreignKey.name !== oldForeignKeyName)
            return;
          const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(newTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${foreignKey.name}" TO "${newForeignKeyName}"`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${newForeignKeyName}" TO "${foreignKey.name}"`));
          foreignKey.name = newForeignKeyName;
        });
        const enumColumns = newTable.columns.filter((column) => column.type === "enum" || column.type === "simple-enum");
        for (const column of enumColumns) {
          if (column.enumName)
            continue;
          const oldEnumType = await this.getUserDefinedTypeName(oldTable, column);
          upQueries.push(new Query_1.Query(`ALTER TYPE "${oldEnumType.schema}"."${oldEnumType.name}" RENAME TO ${this.buildEnumName(newTable, column, false)}`));
          downQueries.push(new Query_1.Query(`ALTER TYPE ${this.buildEnumName(newTable, column)} RENAME TO "${oldEnumType.name}"`));
        }
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Creates a new column from the column in the table.
       */
      async addColumn(tableOrName, column) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        if (column.type === "enum" || column.type === "simple-enum") {
          const hasEnum = await this.hasEnumType(table, column);
          if (!hasEnum) {
            upQueries.push(this.createEnumTypeSql(table, column));
            downQueries.push(this.dropEnumTypeSql(table, column));
          }
        }
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(table, column)}`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN "${column.name}"`));
        if (column.isPrimary) {
          const primaryColumns = clonedTable.primaryColumns;
          if (primaryColumns.length > 0) {
            const pkName2 = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column2) => column2.name));
            const columnNames2 = primaryColumns.map((column2) => `"${column2.name}"`).join(", ");
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName2}"`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName2}" PRIMARY KEY (${columnNames2})`));
          }
          primaryColumns.push(column);
          const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column2) => column2.name));
          const columnNames = primaryColumns.map((column2) => `"${column2.name}"`).join(", ");
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
        }
        const columnIndex = clonedTable.indices.find((index) => index.columnNames.length === 1 && index.columnNames[0] === column.name);
        if (columnIndex) {
          upQueries.push(this.createIndexSql(table, columnIndex));
          downQueries.push(this.dropIndexSql(table, columnIndex));
        }
        if (column.isUnique) {
          const uniqueConstraint = new TableUnique_1.TableUnique({
            name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),
            columnNames: [column.name]
          });
          clonedTable.uniques.push(uniqueConstraint);
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${uniqueConstraint.name}" UNIQUE ("${column.name}")`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${uniqueConstraint.name}"`));
        }
        if (column.generatedType === "STORED" && column.asExpression) {
          const tableNameWithSchema = (await this.getTableNameWithSchema(table.name)).split(".");
          const tableName = tableNameWithSchema[1];
          const schema = tableNameWithSchema[0];
          const insertQuery = this.insertTypeormMetadataSql({
            database: this.driver.database,
            schema,
            table: tableName,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name,
            value: column.asExpression
          });
          const deleteQuery = this.deleteTypeormMetadataSql({
            database: this.driver.database,
            schema,
            table: tableName,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name
          });
          upQueries.push(insertQuery);
          downQueries.push(deleteQuery);
        }
        if (column.comment) {
          upQueries.push(new Query_1.Query(`COMMENT ON COLUMN ${this.escapePath(table)}."${column.name}" IS ${this.escapeComment(column.comment)}`));
          downQueries.push(new Query_1.Query(`COMMENT ON COLUMN ${this.escapePath(table)}."${column.name}" IS ${this.escapeComment(column.comment)}`));
        }
        await this.executeQueries(upQueries, downQueries);
        clonedTable.addColumn(column);
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Creates a new columns from the column in the table.
       */
      async addColumns(tableOrName, columns) {
        for (const column of columns) {
          await this.addColumn(tableOrName, column);
        }
      }
      /**
       * Renames column in the given table.
       */
      async renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const oldColumn = InstanceChecker_1.InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find((c) => c.name === oldTableColumnOrName);
        if (!oldColumn)
          throw new error_1.TypeORMError(`Column "${oldTableColumnOrName}" was not found in the "${table.name}" table.`);
        let newColumn;
        if (InstanceChecker_1.InstanceChecker.isTableColumn(newTableColumnOrName)) {
          newColumn = newTableColumnOrName;
        } else {
          newColumn = oldColumn.clone();
          newColumn.name = newTableColumnOrName;
        }
        return this.changeColumn(table, oldColumn, newColumn);
      }
      /**
       * Changes a column in the table.
       */
      async changeColumn(tableOrName, oldTableColumnOrName, newColumn) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        let clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        let defaultValueChanged = false;
        const oldColumn = InstanceChecker_1.InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find((column) => column.name === oldTableColumnOrName);
        if (!oldColumn)
          throw new error_1.TypeORMError(`Column "${oldTableColumnOrName}" was not found in the "${table.name}" table.`);
        if (oldColumn.type !== newColumn.type || oldColumn.length !== newColumn.length || newColumn.isArray !== oldColumn.isArray || !oldColumn.generatedType && newColumn.generatedType === "STORED" || oldColumn.asExpression !== newColumn.asExpression && newColumn.generatedType === "STORED") {
          await this.dropColumn(table, oldColumn);
          await this.addColumn(table, newColumn);
          clonedTable = table.clone();
        } else {
          if (oldColumn.name !== newColumn.name) {
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME COLUMN "${oldColumn.name}" TO "${newColumn.name}"`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME COLUMN "${newColumn.name}" TO "${oldColumn.name}"`));
            if (oldColumn.type === "enum" || oldColumn.type === "simple-enum") {
              const oldEnumType = await this.getUserDefinedTypeName(table, oldColumn);
              upQueries.push(new Query_1.Query(`ALTER TYPE "${oldEnumType.schema}"."${oldEnumType.name}" RENAME TO ${this.buildEnumName(table, newColumn, false)}`));
              downQueries.push(new Query_1.Query(`ALTER TYPE ${this.buildEnumName(table, newColumn)} RENAME TO "${oldEnumType.name}"`));
            }
            if (oldColumn.isPrimary === true && !oldColumn.primaryKeyConstraintName) {
              const primaryColumns = clonedTable.primaryColumns;
              const columnNames = primaryColumns.map((column) => column.name);
              const oldPkName = this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);
              columnNames.splice(columnNames.indexOf(oldColumn.name), 1);
              columnNames.push(newColumn.name);
              const newPkName = this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${oldPkName}" TO "${newPkName}"`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${newPkName}" TO "${oldPkName}"`));
            }
            if (oldColumn.isGenerated === true && newColumn.generationStrategy === "increment") {
              const sequencePath = this.buildSequencePath(table, oldColumn.name);
              const sequenceName = this.buildSequenceName(table, oldColumn.name);
              const newSequencePath = this.buildSequencePath(table, newColumn.name);
              const newSequenceName = this.buildSequenceName(table, newColumn.name);
              const up = `ALTER SEQUENCE ${this.escapePath(sequencePath)} RENAME TO "${newSequenceName}"`;
              const down = `ALTER SEQUENCE ${this.escapePath(newSequencePath)} RENAME TO "${sequenceName}"`;
              upQueries.push(new Query_1.Query(up));
              downQueries.push(new Query_1.Query(down));
            }
            clonedTable.findColumnUniques(oldColumn).forEach((unique) => {
              const oldUniqueName = this.connection.namingStrategy.uniqueConstraintName(clonedTable, unique.columnNames);
              if (unique.name !== oldUniqueName)
                return;
              unique.columnNames.splice(unique.columnNames.indexOf(oldColumn.name), 1);
              unique.columnNames.push(newColumn.name);
              const newUniqueName = this.connection.namingStrategy.uniqueConstraintName(clonedTable, unique.columnNames);
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${unique.name}" TO "${newUniqueName}"`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${newUniqueName}" TO "${unique.name}"`));
              unique.name = newUniqueName;
            });
            clonedTable.findColumnIndices(oldColumn).forEach((index) => {
              const oldIndexName = this.connection.namingStrategy.indexName(clonedTable, index.columnNames, index.where);
              if (index.name !== oldIndexName)
                return;
              index.columnNames.splice(index.columnNames.indexOf(oldColumn.name), 1);
              index.columnNames.push(newColumn.name);
              const { schema } = this.driver.parseTableName(table);
              const newIndexName = this.connection.namingStrategy.indexName(clonedTable, index.columnNames, index.where);
              const up = schema ? `ALTER INDEX "${schema}"."${index.name}" RENAME TO "${newIndexName}"` : `ALTER INDEX "${index.name}" RENAME TO "${newIndexName}"`;
              const down = schema ? `ALTER INDEX "${schema}"."${newIndexName}" RENAME TO "${index.name}"` : `ALTER INDEX "${newIndexName}" RENAME TO "${index.name}"`;
              upQueries.push(new Query_1.Query(up));
              downQueries.push(new Query_1.Query(down));
              index.name = newIndexName;
            });
            clonedTable.findColumnForeignKeys(oldColumn).forEach((foreignKey) => {
              const foreignKeyName = this.connection.namingStrategy.foreignKeyName(clonedTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
              if (foreignKey.name !== foreignKeyName)
                return;
              foreignKey.columnNames.splice(foreignKey.columnNames.indexOf(oldColumn.name), 1);
              foreignKey.columnNames.push(newColumn.name);
              const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(clonedTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${foreignKey.name}" TO "${newForeignKeyName}"`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${newForeignKeyName}" TO "${foreignKey.name}"`));
              foreignKey.name = newForeignKeyName;
            });
            const oldTableColumn = clonedTable.columns.find((column) => column.name === oldColumn.name);
            clonedTable.columns[clonedTable.columns.indexOf(oldTableColumn)].name = newColumn.name;
            oldColumn.name = newColumn.name;
          }
          if (newColumn.precision !== oldColumn.precision || newColumn.scale !== oldColumn.scale) {
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" TYPE ${this.driver.createFullType(newColumn)}`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" TYPE ${this.driver.createFullType(oldColumn)}`));
          }
          if ((newColumn.type === "enum" || newColumn.type === "simple-enum") && (oldColumn.type === "enum" || oldColumn.type === "simple-enum") && (!OrmUtils_1.OrmUtils.isArraysEqual(newColumn.enum, oldColumn.enum) || newColumn.enumName !== oldColumn.enumName)) {
            const arraySuffix = newColumn.isArray ? "[]" : "";
            const newEnumName = this.buildEnumName(table, newColumn);
            const oldEnumName = this.buildEnumName(table, oldColumn);
            const oldEnumNameWithoutSchema = this.buildEnumName(table, oldColumn, false);
            const oldEnumNameWithSchema_old = this.buildEnumName(table, oldColumn, true, false, true);
            const oldEnumNameWithoutSchema_old = this.buildEnumName(table, oldColumn, false, false, true);
            upQueries.push(new Query_1.Query(`ALTER TYPE ${oldEnumName} RENAME TO ${oldEnumNameWithoutSchema_old}`));
            downQueries.push(new Query_1.Query(`ALTER TYPE ${oldEnumNameWithSchema_old} RENAME TO ${oldEnumNameWithoutSchema}`));
            upQueries.push(this.createEnumTypeSql(table, newColumn, newEnumName));
            downQueries.push(this.dropEnumTypeSql(table, newColumn, newEnumName));
            if (oldColumn.default !== null && oldColumn.default !== void 0) {
              defaultValueChanged = true;
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" DROP DEFAULT`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" SET DEFAULT ${oldColumn.default}`));
            }
            const upType = `${newEnumName}${arraySuffix} USING "${newColumn.name}"::"text"::${newEnumName}${arraySuffix}`;
            const downType = `${oldEnumNameWithSchema_old}${arraySuffix} USING "${newColumn.name}"::"text"::${oldEnumNameWithSchema_old}${arraySuffix}`;
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" TYPE ${upType}`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" TYPE ${downType}`));
            if (newColumn.default !== null && newColumn.default !== void 0) {
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" SET DEFAULT ${newColumn.default}`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" DROP DEFAULT`));
            }
            upQueries.push(this.dropEnumTypeSql(table, oldColumn, oldEnumNameWithSchema_old));
            downQueries.push(this.createEnumTypeSql(table, oldColumn, oldEnumNameWithSchema_old));
          }
          if (oldColumn.isNullable !== newColumn.isNullable) {
            if (newColumn.isNullable) {
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" DROP NOT NULL`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" SET NOT NULL`));
            } else {
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" SET NOT NULL`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" DROP NOT NULL`));
            }
          }
          if (oldColumn.comment !== newColumn.comment) {
            upQueries.push(new Query_1.Query(`COMMENT ON COLUMN ${this.escapePath(table)}."${oldColumn.name}" IS ${this.escapeComment(newColumn.comment)}`));
            downQueries.push(new Query_1.Query(`COMMENT ON COLUMN ${this.escapePath(table)}."${newColumn.name}" IS ${this.escapeComment(oldColumn.comment)}`));
          }
          if (newColumn.isPrimary !== oldColumn.isPrimary) {
            const primaryColumns = clonedTable.primaryColumns;
            if (primaryColumns.length > 0) {
              const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column) => column.name));
              const columnNames = primaryColumns.map((column) => `"${column.name}"`).join(", ");
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
            }
            if (newColumn.isPrimary === true) {
              primaryColumns.push(newColumn);
              const column = clonedTable.columns.find((column2) => column2.name === newColumn.name);
              column.isPrimary = true;
              const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column2) => column2.name));
              const columnNames = primaryColumns.map((column2) => `"${column2.name}"`).join(", ");
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
            } else {
              const primaryColumn = primaryColumns.find((c) => c.name === newColumn.name);
              primaryColumns.splice(primaryColumns.indexOf(primaryColumn), 1);
              const column = clonedTable.columns.find((column2) => column2.name === newColumn.name);
              column.isPrimary = false;
              if (primaryColumns.length > 0) {
                const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column2) => column2.name));
                const columnNames = primaryColumns.map((column2) => `"${column2.name}"`).join(", ");
                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
              }
            }
          }
          if (newColumn.isUnique !== oldColumn.isUnique) {
            if (newColumn.isUnique === true) {
              const uniqueConstraint = new TableUnique_1.TableUnique({
                name: this.connection.namingStrategy.uniqueConstraintName(table, [newColumn.name]),
                columnNames: [newColumn.name]
              });
              clonedTable.uniques.push(uniqueConstraint);
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${uniqueConstraint.name}" UNIQUE ("${newColumn.name}")`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${uniqueConstraint.name}"`));
            } else {
              const uniqueConstraint = clonedTable.uniques.find((unique) => {
                return unique.columnNames.length === 1 && !!unique.columnNames.find((columnName) => columnName === newColumn.name);
              });
              clonedTable.uniques.splice(clonedTable.uniques.indexOf(uniqueConstraint), 1);
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${uniqueConstraint.name}"`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${uniqueConstraint.name}" UNIQUE ("${newColumn.name}")`));
            }
          }
          if (oldColumn.isGenerated !== newColumn.isGenerated) {
            if (oldColumn.isGenerated) {
              if (oldColumn.generationStrategy === "uuid") {
                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" DROP DEFAULT`));
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" SET DEFAULT ${this.driver.uuidGenerator}`));
              } else if (oldColumn.generationStrategy === "increment") {
                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" DROP DEFAULT`));
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" SET DEFAULT nextval('${this.escapePath(this.buildSequencePath(table, newColumn))}')`));
                upQueries.push(new Query_1.Query(`DROP SEQUENCE ${this.escapePath(this.buildSequencePath(table, newColumn))}`));
                downQueries.push(new Query_1.Query(`CREATE SEQUENCE IF NOT EXISTS ${this.escapePath(this.buildSequencePath(table, newColumn))} OWNED BY ${this.escapePath(table)}."${newColumn.name}"`));
              }
            }
            if (newColumn.generationStrategy === "uuid") {
              if (newColumn.isGenerated === true) {
                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" SET DEFAULT ${this.driver.uuidGenerator}`));
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" DROP DEFAULT`));
              } else {
                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" DROP DEFAULT`));
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" SET DEFAULT ${this.driver.uuidGenerator}`));
              }
            } else if (newColumn.generationStrategy === "increment") {
              if (newColumn.isGenerated === true) {
                upQueries.push(new Query_1.Query(`CREATE SEQUENCE IF NOT EXISTS ${this.escapePath(this.buildSequencePath(table, newColumn))} OWNED BY ${this.escapePath(table)}."${newColumn.name}"`));
                downQueries.push(new Query_1.Query(`DROP SEQUENCE ${this.escapePath(this.buildSequencePath(table, newColumn))}`));
                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" SET DEFAULT nextval('${this.escapePath(this.buildSequencePath(table, newColumn))}')`));
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" DROP DEFAULT`));
              } else {
                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" DROP DEFAULT`));
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" SET DEFAULT nextval('${this.escapePath(this.buildSequencePath(table, newColumn))}')`));
                upQueries.push(new Query_1.Query(`DROP SEQUENCE ${this.escapePath(this.buildSequencePath(table, newColumn))}`));
                downQueries.push(new Query_1.Query(`CREATE SEQUENCE IF NOT EXISTS ${this.escapePath(this.buildSequencePath(table, newColumn))} OWNED BY ${this.escapePath(table)}."${newColumn.name}"`));
              }
            }
          }
          if (newColumn.default !== oldColumn.default && !defaultValueChanged) {
            if (newColumn.default !== null && newColumn.default !== void 0) {
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" SET DEFAULT ${newColumn.default}`));
              if (oldColumn.default !== null && oldColumn.default !== void 0) {
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" SET DEFAULT ${oldColumn.default}`));
              } else {
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" DROP DEFAULT`));
              }
            } else if (oldColumn.default !== null && oldColumn.default !== void 0) {
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" DROP DEFAULT`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" SET DEFAULT ${oldColumn.default}`));
            }
          }
          if ((newColumn.spatialFeatureType || "").toLowerCase() !== (oldColumn.spatialFeatureType || "").toLowerCase() || newColumn.srid !== oldColumn.srid) {
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" TYPE ${this.driver.createFullType(newColumn)}`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" TYPE ${this.driver.createFullType(oldColumn)}`));
          }
          if (newColumn.collation !== oldColumn.collation) {
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" TYPE ${newColumn.type} COLLATE "${newColumn.collation}"`));
            const oldCollation = oldColumn.collation ? `"${oldColumn.collation}"` : `pg_catalog."default"`;
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" TYPE ${newColumn.type} COLLATE ${oldCollation}`));
          }
          if (newColumn.generatedType !== oldColumn.generatedType) {
            if (!newColumn.generatedType || newColumn.generatedType === "VIRTUAL") {
              const tableNameWithSchema = (await this.getTableNameWithSchema(table.name)).split(".");
              const tableName = tableNameWithSchema[1];
              const schema = tableNameWithSchema[0];
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME COLUMN "${oldColumn.name}" TO "TEMP_OLD_${oldColumn.name}"`));
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(table, newColumn)}`));
              upQueries.push(new Query_1.Query(`UPDATE ${this.escapePath(table)} SET "${newColumn.name}" = "TEMP_OLD_${oldColumn.name}"`));
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN "TEMP_OLD_${oldColumn.name}"`));
              upQueries.push(this.deleteTypeormMetadataSql({
                database: this.driver.database,
                schema,
                table: tableName,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: oldColumn.name
              }));
              downQueries.push(this.insertTypeormMetadataSql({
                database: this.driver.database,
                schema,
                table: tableName,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: oldColumn.name,
                value: oldColumn.asExpression
              }));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(table, oldColumn)}`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN "${newColumn.name}"`));
            }
          }
        }
        await this.executeQueries(upQueries, downQueries);
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Changes a column in the table.
       */
      async changeColumns(tableOrName, changedColumns) {
        for (const { oldColumn, newColumn } of changedColumns) {
          await this.changeColumn(tableOrName, oldColumn, newColumn);
        }
      }
      /**
       * Drops column in the table.
       */
      async dropColumn(tableOrName, columnOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const column = InstanceChecker_1.InstanceChecker.isTableColumn(columnOrName) ? columnOrName : table.findColumnByName(columnOrName);
        if (!column)
          throw new error_1.TypeORMError(`Column "${columnOrName}" was not found in table "${table.name}"`);
        const clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        if (column.isPrimary) {
          const pkName = column.primaryKeyConstraintName ? column.primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, clonedTable.primaryColumns.map((column2) => column2.name));
          const columnNames = clonedTable.primaryColumns.map((primaryColumn) => `"${primaryColumn.name}"`).join(", ");
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP CONSTRAINT "${pkName}"`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
          const tableColumn = clonedTable.findColumnByName(column.name);
          tableColumn.isPrimary = false;
          if (clonedTable.primaryColumns.length > 0) {
            const pkName2 = clonedTable.primaryColumns[0].primaryKeyConstraintName ? clonedTable.primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, clonedTable.primaryColumns.map((column2) => column2.name));
            const columnNames2 = clonedTable.primaryColumns.map((primaryColumn) => `"${primaryColumn.name}"`).join(", ");
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD CONSTRAINT "${pkName2}" PRIMARY KEY (${columnNames2})`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP CONSTRAINT "${pkName2}"`));
          }
        }
        const columnIndex = clonedTable.indices.find((index) => index.columnNames.length === 1 && index.columnNames[0] === column.name);
        if (columnIndex) {
          clonedTable.indices.splice(clonedTable.indices.indexOf(columnIndex), 1);
          upQueries.push(this.dropIndexSql(table, columnIndex));
          downQueries.push(this.createIndexSql(table, columnIndex));
        }
        const columnCheck = clonedTable.checks.find((check) => !!check.columnNames && check.columnNames.length === 1 && check.columnNames[0] === column.name);
        if (columnCheck) {
          clonedTable.checks.splice(clonedTable.checks.indexOf(columnCheck), 1);
          upQueries.push(this.dropCheckConstraintSql(table, columnCheck));
          downQueries.push(this.createCheckConstraintSql(table, columnCheck));
        }
        const columnUnique = clonedTable.uniques.find((unique) => unique.columnNames.length === 1 && unique.columnNames[0] === column.name);
        if (columnUnique) {
          clonedTable.uniques.splice(clonedTable.uniques.indexOf(columnUnique), 1);
          upQueries.push(this.dropUniqueConstraintSql(table, columnUnique));
          downQueries.push(this.createUniqueConstraintSql(table, columnUnique));
        }
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN "${column.name}"`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(table, column)}`));
        if (column.type === "enum" || column.type === "simple-enum") {
          const hasEnum = await this.hasEnumType(table, column);
          if (hasEnum) {
            const enumType = await this.getUserDefinedTypeName(table, column);
            const escapedEnumName = `"${enumType.schema}"."${enumType.name}"`;
            upQueries.push(this.dropEnumTypeSql(table, column, escapedEnumName));
            downQueries.push(this.createEnumTypeSql(table, column, escapedEnumName));
          }
        }
        if (column.generatedType === "STORED") {
          const tableNameWithSchema = (await this.getTableNameWithSchema(table.name)).split(".");
          const tableName = tableNameWithSchema[1];
          const schema = tableNameWithSchema[0];
          const deleteQuery = this.deleteTypeormMetadataSql({
            database: this.driver.database,
            schema,
            table: tableName,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name
          });
          const insertQuery = this.insertTypeormMetadataSql({
            database: this.driver.database,
            schema,
            table: tableName,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name,
            value: column.asExpression
          });
          upQueries.push(deleteQuery);
          downQueries.push(insertQuery);
        }
        await this.executeQueries(upQueries, downQueries);
        clonedTable.removeColumn(column);
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Drops the columns in the table.
       */
      async dropColumns(tableOrName, columns) {
        for (const column of [...columns]) {
          await this.dropColumn(tableOrName, column);
        }
      }
      /**
       * Creates a new primary key.
       */
      async createPrimaryKey(tableOrName, columnNames, constraintName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const clonedTable = table.clone();
        const up = this.createPrimaryKeySql(table, columnNames, constraintName);
        clonedTable.columns.forEach((column) => {
          if (columnNames.find((columnName) => columnName === column.name))
            column.isPrimary = true;
        });
        const down = this.dropPrimaryKeySql(clonedTable);
        await this.executeQueries(up, down);
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Updates composite primary keys.
       */
      async updatePrimaryKeys(tableOrName, columns) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const clonedTable = table.clone();
        const columnNames = columns.map((column) => column.name);
        const upQueries = [];
        const downQueries = [];
        const primaryColumns = clonedTable.primaryColumns;
        if (primaryColumns.length > 0) {
          const pkName2 = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column) => column.name));
          const columnNamesString2 = primaryColumns.map((column) => `"${column.name}"`).join(", ");
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName2}"`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName2}" PRIMARY KEY (${columnNamesString2})`));
        }
        clonedTable.columns.filter((column) => columnNames.indexOf(column.name) !== -1).forEach((column) => column.isPrimary = true);
        const pkName = primaryColumns[0]?.primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);
        const columnNamesString = columnNames.map((columnName) => `"${columnName}"`).join(", ");
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNamesString})`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
        await this.executeQueries(upQueries, downQueries);
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Drops a primary key.
       */
      async dropPrimaryKey(tableOrName, constraintName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const up = this.dropPrimaryKeySql(table);
        const down = this.createPrimaryKeySql(table, table.primaryColumns.map((column) => column.name), constraintName);
        await this.executeQueries(up, down);
        table.primaryColumns.forEach((column) => {
          column.isPrimary = false;
        });
      }
      /**
       * Creates new unique constraint.
       */
      async createUniqueConstraint(tableOrName, uniqueConstraint) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        if (!uniqueConstraint.name)
          uniqueConstraint.name = this.connection.namingStrategy.uniqueConstraintName(table, uniqueConstraint.columnNames);
        const up = this.createUniqueConstraintSql(table, uniqueConstraint);
        const down = this.dropUniqueConstraintSql(table, uniqueConstraint);
        await this.executeQueries(up, down);
        table.addUniqueConstraint(uniqueConstraint);
      }
      /**
       * Creates new unique constraints.
       */
      async createUniqueConstraints(tableOrName, uniqueConstraints) {
        for (const uniqueConstraint of uniqueConstraints) {
          await this.createUniqueConstraint(tableOrName, uniqueConstraint);
        }
      }
      /**
       * Drops unique constraint.
       */
      async dropUniqueConstraint(tableOrName, uniqueOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const uniqueConstraint = InstanceChecker_1.InstanceChecker.isTableUnique(uniqueOrName) ? uniqueOrName : table.uniques.find((u) => u.name === uniqueOrName);
        if (!uniqueConstraint)
          throw new error_1.TypeORMError(`Supplied unique constraint was not found in table ${table.name}`);
        const up = this.dropUniqueConstraintSql(table, uniqueConstraint);
        const down = this.createUniqueConstraintSql(table, uniqueConstraint);
        await this.executeQueries(up, down);
        table.removeUniqueConstraint(uniqueConstraint);
      }
      /**
       * Drops unique constraints.
       */
      async dropUniqueConstraints(tableOrName, uniqueConstraints) {
        for (const uniqueConstraint of [...uniqueConstraints]) {
          await this.dropUniqueConstraint(tableOrName, uniqueConstraint);
        }
      }
      /**
       * Creates new check constraint.
       */
      async createCheckConstraint(tableOrName, checkConstraint) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        if (!checkConstraint.name)
          checkConstraint.name = this.connection.namingStrategy.checkConstraintName(table, checkConstraint.expression);
        const up = this.createCheckConstraintSql(table, checkConstraint);
        const down = this.dropCheckConstraintSql(table, checkConstraint);
        await this.executeQueries(up, down);
        table.addCheckConstraint(checkConstraint);
      }
      /**
       * Creates new check constraints.
       */
      async createCheckConstraints(tableOrName, checkConstraints) {
        const promises = checkConstraints.map((checkConstraint) => this.createCheckConstraint(tableOrName, checkConstraint));
        await Promise.all(promises);
      }
      /**
       * Drops check constraint.
       */
      async dropCheckConstraint(tableOrName, checkOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const checkConstraint = InstanceChecker_1.InstanceChecker.isTableCheck(checkOrName) ? checkOrName : table.checks.find((c) => c.name === checkOrName);
        if (!checkConstraint)
          throw new error_1.TypeORMError(`Supplied check constraint was not found in table ${table.name}`);
        const up = this.dropCheckConstraintSql(table, checkConstraint);
        const down = this.createCheckConstraintSql(table, checkConstraint);
        await this.executeQueries(up, down);
        table.removeCheckConstraint(checkConstraint);
      }
      /**
       * Drops check constraints.
       */
      async dropCheckConstraints(tableOrName, checkConstraints) {
        const promises = checkConstraints.map((checkConstraint) => this.dropCheckConstraint(tableOrName, checkConstraint));
        await Promise.all(promises);
      }
      /**
       * Creates new exclusion constraint.
       */
      async createExclusionConstraint(tableOrName, exclusionConstraint) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        if (!exclusionConstraint.name)
          exclusionConstraint.name = this.connection.namingStrategy.exclusionConstraintName(table, exclusionConstraint.expression);
        const up = this.createExclusionConstraintSql(table, exclusionConstraint);
        const down = this.dropExclusionConstraintSql(table, exclusionConstraint);
        await this.executeQueries(up, down);
        table.addExclusionConstraint(exclusionConstraint);
      }
      /**
       * Creates new exclusion constraints.
       */
      async createExclusionConstraints(tableOrName, exclusionConstraints) {
        const promises = exclusionConstraints.map((exclusionConstraint) => this.createExclusionConstraint(tableOrName, exclusionConstraint));
        await Promise.all(promises);
      }
      /**
       * Drops exclusion constraint.
       */
      async dropExclusionConstraint(tableOrName, exclusionOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const exclusionConstraint = InstanceChecker_1.InstanceChecker.isTableExclusion(exclusionOrName) ? exclusionOrName : table.exclusions.find((c) => c.name === exclusionOrName);
        if (!exclusionConstraint)
          throw new error_1.TypeORMError(`Supplied exclusion constraint was not found in table ${table.name}`);
        const up = this.dropExclusionConstraintSql(table, exclusionConstraint);
        const down = this.createExclusionConstraintSql(table, exclusionConstraint);
        await this.executeQueries(up, down);
        table.removeExclusionConstraint(exclusionConstraint);
      }
      /**
       * Drops exclusion constraints.
       */
      async dropExclusionConstraints(tableOrName, exclusionConstraints) {
        const promises = exclusionConstraints.map((exclusionConstraint) => this.dropExclusionConstraint(tableOrName, exclusionConstraint));
        await Promise.all(promises);
      }
      /**
       * Creates a new foreign key.
       */
      async createForeignKey(tableOrName, foreignKey) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        if (!foreignKey.name)
          foreignKey.name = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
        const up = this.createForeignKeySql(table, foreignKey);
        const down = this.dropForeignKeySql(table, foreignKey);
        await this.executeQueries(up, down);
        table.addForeignKey(foreignKey);
      }
      /**
       * Creates a new foreign keys.
       */
      async createForeignKeys(tableOrName, foreignKeys) {
        for (const foreignKey of foreignKeys) {
          await this.createForeignKey(tableOrName, foreignKey);
        }
      }
      /**
       * Drops a foreign key from the table.
       */
      async dropForeignKey(tableOrName, foreignKeyOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const foreignKey = InstanceChecker_1.InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName : table.foreignKeys.find((fk) => fk.name === foreignKeyOrName);
        if (!foreignKey)
          throw new error_1.TypeORMError(`Supplied foreign key was not found in table ${table.name}`);
        if (!foreignKey.name) {
          foreignKey.name = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
        }
        const up = this.dropForeignKeySql(table, foreignKey);
        const down = this.createForeignKeySql(table, foreignKey);
        await this.executeQueries(up, down);
        table.removeForeignKey(foreignKey);
      }
      /**
       * Drops a foreign keys from the table.
       */
      async dropForeignKeys(tableOrName, foreignKeys) {
        for (const foreignKey of [...foreignKeys]) {
          await this.dropForeignKey(tableOrName, foreignKey);
        }
      }
      /**
       * Creates a new index.
       */
      async createIndex(tableOrName, index) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        if (!index.name)
          index.name = this.generateIndexName(table, index);
        const up = this.createIndexSql(table, index);
        const down = this.dropIndexSql(table, index);
        await this.executeQueries(up, down);
        table.addIndex(index);
      }
      /**
       * Create a new view index.
       */
      async createViewIndex(viewOrName, index) {
        const view = InstanceChecker_1.InstanceChecker.isView(viewOrName) ? viewOrName : await this.getCachedView(viewOrName);
        if (!index.name)
          index.name = this.generateIndexName(view, index);
        const up = this.createViewIndexSql(view, index);
        const down = this.dropIndexSql(view, index);
        await this.executeQueries(up, down);
        view.addIndex(index);
      }
      /**
       * Creates a new indices
       */
      async createIndices(tableOrName, indices) {
        for (const index of indices) {
          await this.createIndex(tableOrName, index);
        }
      }
      /**
       * Creates new view indices
       */
      async createViewIndices(viewOrName, indices) {
        for (const index of indices) {
          await this.createViewIndex(viewOrName, index);
        }
      }
      /**
       * Drops an index from the table.
       */
      async dropIndex(tableOrName, indexOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const index = InstanceChecker_1.InstanceChecker.isTableIndex(indexOrName) ? indexOrName : table.indices.find((i) => i.name === indexOrName);
        if (!index)
          throw new error_1.TypeORMError(`Supplied index ${indexOrName} was not found in table ${table.name}`);
        if (!index.name)
          index.name = this.generateIndexName(table, index);
        const up = this.dropIndexSql(table, index);
        const down = this.createIndexSql(table, index);
        await this.executeQueries(up, down);
        table.removeIndex(index);
      }
      /**
       * Drops an index from a view.
       */
      async dropViewIndex(viewOrName, indexOrName) {
        const view = InstanceChecker_1.InstanceChecker.isView(viewOrName) ? viewOrName : await this.getCachedView(viewOrName);
        const index = InstanceChecker_1.InstanceChecker.isTableIndex(indexOrName) ? indexOrName : view.indices.find((i) => i.name === indexOrName);
        if (!index)
          throw new error_1.TypeORMError(`Supplied index ${indexOrName} was not found in view ${view.name}`);
        if (!index.name)
          index.name = this.generateIndexName(view, index);
        const up = this.dropIndexSql(view, index);
        const down = this.createViewIndexSql(view, index);
        await this.executeQueries(up, down);
        view.removeIndex(index);
      }
      /**
       * Drops an indices from the table.
       */
      async dropIndices(tableOrName, indices) {
        for (const index of [...indices]) {
          await this.dropIndex(tableOrName, index);
        }
      }
      /**
       * Clears all table contents.
       * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.
       */
      async clearTable(tableName) {
        await this.query(`TRUNCATE TABLE ${this.escapePath(tableName)}`);
      }
      /**
       * Removes all tables from the currently connected database.
       */
      async clearDatabase() {
        const schemas = [];
        this.connection.entityMetadatas.filter((metadata) => metadata.schema).forEach((metadata) => {
          const isSchemaExist = !!schemas.find((schema) => schema === metadata.schema);
          if (!isSchemaExist)
            schemas.push(metadata.schema);
        });
        schemas.push(this.driver.options.schema || "current_schema()");
        const schemaNamesString = schemas.map((name) => {
          return name === "current_schema()" ? name : "'" + name + "'";
        }).join(", ");
        const isAnotherTransactionActive = this.isTransactionActive;
        if (!isAnotherTransactionActive)
          await this.startTransaction();
        try {
          const selectViewDropsQuery = `SELECT 'DROP VIEW IF EXISTS "' || schemaname || '"."' || viewname || '" CASCADE;' as "query" FROM "pg_views" WHERE "schemaname" IN (${schemaNamesString}) AND "viewname" NOT IN ('geography_columns', 'geometry_columns', 'raster_columns', 'raster_overviews')`;
          const dropViewQueries = await this.query(selectViewDropsQuery);
          await Promise.all(dropViewQueries.map((q) => this.query(q["query"])));
          if (DriverUtils_1.DriverUtils.isReleaseVersionOrGreater(this.driver, "9.3")) {
            const selectMatViewDropsQuery = `SELECT 'DROP MATERIALIZED VIEW IF EXISTS "' || schemaname || '"."' || matviewname || '" CASCADE;' as "query" FROM "pg_matviews" WHERE "schemaname" IN (${schemaNamesString})`;
            const dropMatViewQueries = await this.query(selectMatViewDropsQuery);
            await Promise.all(dropMatViewQueries.map((q) => this.query(q["query"])));
          }
          const selectTableDropsQuery = `SELECT 'DROP TABLE IF EXISTS "' || schemaname || '"."' || tablename || '" CASCADE;' as "query" FROM "pg_tables" WHERE "schemaname" IN (${schemaNamesString}) AND "tablename" NOT IN ('spatial_ref_sys')`;
          const dropTableQueries = await this.query(selectTableDropsQuery);
          await Promise.all(dropTableQueries.map((q) => this.query(q["query"])));
          await this.dropEnumTypes(schemaNamesString);
          if (!isAnotherTransactionActive) {
            await this.commitTransaction();
          }
        } catch (error) {
          try {
            if (!isAnotherTransactionActive) {
              await this.rollbackTransaction();
            }
          } catch {
          }
          throw error;
        }
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      async loadViews(viewNames) {
        const hasTable = await this.hasTable(this.getTypeormMetadataTableName());
        if (!hasTable)
          return [];
        if (!viewNames) {
          viewNames = [];
        }
        const currentDatabase = await this.getCurrentDatabase();
        const currentSchema = await this.getCurrentSchema();
        const viewsCondition = viewNames.length === 0 ? "1=1" : viewNames.map((tableName) => this.driver.parseTableName(tableName)).map(({ schema, tableName }) => {
          if (!schema) {
            schema = this.driver.options.schema || currentSchema;
          }
          return `("t"."schema" = '${schema}' AND "t"."name" = '${tableName}')`;
        }).join(" OR ");
        const constraintsCondition = viewNames.length === 0 ? "1=1" : viewNames.map((tableName) => this.driver.parseTableName(tableName)).map(({ schema, tableName }) => {
          if (!schema) {
            schema = this.driver.options.schema || currentSchema;
          }
          return `("ns"."nspname" = '${schema}' AND "t"."relname" = '${tableName}')`;
        }).join(" OR ");
        const indicesSql = `SELECT "ns"."nspname" AS "table_schema", "t"."relname" AS "table_name", "i"."relname" AS "constraint_name", "a"."attname" AS "column_name", CASE "ix"."indisunique" WHEN 't' THEN 'TRUE' ELSE'FALSE' END AS "is_unique", pg_get_expr("ix"."indpred", "ix"."indrelid") AS "condition", "types"."typname" AS "type_name" FROM "pg_class" "t" INNER JOIN "pg_index" "ix" ON "ix"."indrelid" = "t"."oid" INNER JOIN "pg_attribute" "a" ON "a"."attrelid" = "t"."oid"  AND "a"."attnum" = ANY ("ix"."indkey") INNER JOIN "pg_namespace" "ns" ON "ns"."oid" = "t"."relnamespace" INNER JOIN "pg_class" "i" ON "i"."oid" = "ix"."indexrelid" INNER JOIN "pg_type" "types" ON "types"."oid" = "a"."atttypid" LEFT JOIN "pg_constraint" "cnst" ON "cnst"."conname" = "i"."relname" WHERE "t"."relkind" IN ('m') AND "cnst"."contype" IS NULL AND (${constraintsCondition})`;
        const query = `SELECT "t".* FROM ${this.escapePath(this.getTypeormMetadataTableName())} "t" INNER JOIN "pg_catalog"."pg_class" "c" ON "c"."relname" = "t"."name" INNER JOIN "pg_namespace" "n" ON "n"."oid" = "c"."relnamespace" AND "n"."nspname" = "t"."schema" WHERE "t"."type" IN ('${MetadataTableType_1.MetadataTableType.VIEW}', '${MetadataTableType_1.MetadataTableType.MATERIALIZED_VIEW}') ${viewsCondition ? `AND (${viewsCondition})` : ""}`;
        const dbViews = await this.query(query);
        const dbIndices = await this.query(indicesSql);
        return dbViews.map((dbView) => {
          const tableIndexConstraints = OrmUtils_1.OrmUtils.uniq(dbIndices.filter((dbIndex) => {
            return dbIndex["table_name"] === dbView["name"] && dbIndex["table_schema"] === dbView["schema"];
          }), (dbIndex) => dbIndex["constraint_name"]);
          const view = new View_1.View();
          const schema = dbView["schema"] === currentSchema && !this.driver.options.schema ? void 0 : dbView["schema"];
          view.database = currentDatabase;
          view.schema = dbView["schema"];
          view.name = this.driver.buildTableName(dbView["name"], schema);
          view.expression = dbView["value"];
          view.materialized = dbView["type"] === MetadataTableType_1.MetadataTableType.MATERIALIZED_VIEW;
          view.indices = tableIndexConstraints.map((constraint) => {
            const indices = dbIndices.filter((index) => {
              return index["table_schema"] === constraint["table_schema"] && index["table_name"] === constraint["table_name"] && index["constraint_name"] === constraint["constraint_name"];
            });
            return new TableIndex_1.TableIndex({
              view,
              name: constraint["constraint_name"],
              columnNames: indices.map((i) => i["column_name"]),
              isUnique: constraint["is_unique"] === "TRUE",
              where: constraint["condition"],
              isFulltext: false
            });
          });
          return view;
        });
      }
      /**
       * Loads all tables (with given names) from the database and creates a Table from them.
       */
      async loadTables(tableNames) {
        if (tableNames && tableNames.length === 0) {
          return [];
        }
        const currentSchema = await this.getCurrentSchema();
        const currentDatabase = await this.getCurrentDatabase();
        const dbTables = [];
        if (!tableNames) {
          const tablesSql = `SELECT "table_schema", "table_name", obj_description(('"' || "table_schema" || '"."' || "table_name" || '"')::regclass, 'pg_class') AS table_comment FROM "information_schema"."tables"`;
          dbTables.push(...await this.query(tablesSql));
        } else {
          const tablesCondition = tableNames.map((tableName) => this.driver.parseTableName(tableName)).map(({ schema, tableName }) => {
            return `("table_schema" = '${schema || currentSchema}' AND "table_name" = '${tableName}')`;
          }).join(" OR ");
          const tablesSql = `SELECT "table_schema", "table_name", obj_description(('"' || "table_schema" || '"."' || "table_name" || '"')::regclass, 'pg_class') AS table_comment FROM "information_schema"."tables" WHERE ` + tablesCondition;
          dbTables.push(...await this.query(tablesSql));
        }
        if (dbTables.length === 0) {
          return [];
        }
        const columnsCondition = dbTables.map(({ table_schema, table_name }) => {
          return `("table_schema" = '${table_schema}' AND "table_name" = '${table_name}')`;
        }).join(" OR ");
        const columnsSql = `SELECT columns.*, pg_catalog.col_description(('"' || table_catalog || '"."' || table_schema || '"."' || table_name || '"')::regclass::oid, ordinal_position) AS description, ('"' || "udt_schema" || '"."' || "udt_name" || '"')::"regtype"::text AS "regtype", pg_catalog.format_type("col_attr"."atttypid", "col_attr"."atttypmod") AS "format_type" FROM "information_schema"."columns" LEFT JOIN "pg_catalog"."pg_attribute" AS "col_attr" ON "col_attr"."attname" = "columns"."column_name" AND "col_attr"."attrelid" = ( SELECT "cls"."oid" FROM "pg_catalog"."pg_class" AS "cls" LEFT JOIN "pg_catalog"."pg_namespace" AS "ns" ON "ns"."oid" = "cls"."relnamespace" WHERE "cls"."relname" = "columns"."table_name" AND "ns"."nspname" = "columns"."table_schema" ) WHERE ` + columnsCondition;
        const constraintsCondition = dbTables.map(({ table_schema, table_name }) => {
          return `("ns"."nspname" = '${table_schema}' AND "t"."relname" = '${table_name}')`;
        }).join(" OR ");
        const constraintsSql = `SELECT "ns"."nspname" AS "table_schema", "t"."relname" AS "table_name", "cnst"."conname" AS "constraint_name", pg_get_constraintdef("cnst"."oid") AS "expression", CASE "cnst"."contype" WHEN 'p' THEN 'PRIMARY' WHEN 'u' THEN 'UNIQUE' WHEN 'c' THEN 'CHECK' WHEN 'x' THEN 'EXCLUDE' END AS "constraint_type", "a"."attname" AS "column_name" FROM "pg_constraint" "cnst" INNER JOIN "pg_class" "t" ON "t"."oid" = "cnst"."conrelid" INNER JOIN "pg_namespace" "ns" ON "ns"."oid" = "cnst"."connamespace" LEFT JOIN "pg_attribute" "a" ON "a"."attrelid" = "cnst"."conrelid" AND "a"."attnum" = ANY ("cnst"."conkey") WHERE "t"."relkind" IN ('r', 'p') AND (${constraintsCondition})`;
        const indicesSql = `SELECT "ns"."nspname" AS "table_schema", "t"."relname" AS "table_name", "i"."relname" AS "constraint_name", "a"."attname" AS "column_name", CASE "ix"."indisunique" WHEN 't' THEN 'TRUE' ELSE'FALSE' END AS "is_unique", pg_get_expr("ix"."indpred", "ix"."indrelid") AS "condition", "types"."typname" AS "type_name", "am"."amname" AS "index_type" FROM "pg_class" "t" INNER JOIN "pg_index" "ix" ON "ix"."indrelid" = "t"."oid" INNER JOIN "pg_attribute" "a" ON "a"."attrelid" = "t"."oid"  AND "a"."attnum" = ANY ("ix"."indkey") INNER JOIN "pg_namespace" "ns" ON "ns"."oid" = "t"."relnamespace" INNER JOIN "pg_class" "i" ON "i"."oid" = "ix"."indexrelid" INNER JOIN "pg_type" "types" ON "types"."oid" = "a"."atttypid" INNER JOIN "pg_am" "am" ON "i"."relam" = "am"."oid" LEFT JOIN "pg_constraint" "cnst" ON "cnst"."conname" = "i"."relname" WHERE "t"."relkind" IN ('r', 'p') AND "cnst"."contype" IS NULL AND (${constraintsCondition})`;
        const foreignKeysCondition = dbTables.map(({ table_schema, table_name }) => {
          return `("ns"."nspname" = '${table_schema}' AND "cl"."relname" = '${table_name}')`;
        }).join(" OR ");
        const hasRelispartitionColumn = await this.hasSupportForPartitionedTables();
        const isPartitionCondition = hasRelispartitionColumn ? ` AND "cl"."relispartition" = 'f'` : "";
        const foreignKeysSql = `SELECT "con"."conname" AS "constraint_name", "con"."nspname" AS "table_schema", "con"."relname" AS "table_name", "att2"."attname" AS "column_name", "ns"."nspname" AS "referenced_table_schema", "cl"."relname" AS "referenced_table_name", "att"."attname" AS "referenced_column_name", "con"."confdeltype" AS "on_delete", "con"."confupdtype" AS "on_update", "con"."condeferrable" AS "deferrable", "con"."condeferred" AS "deferred" FROM ( SELECT UNNEST ("con1"."conkey") AS "parent", UNNEST ("con1"."confkey") AS "child", "con1"."confrelid", "con1"."conrelid", "con1"."conname", "con1"."contype", "ns"."nspname", "cl"."relname", "con1"."condeferrable", CASE WHEN "con1"."condeferred" THEN 'INITIALLY DEFERRED' ELSE 'INITIALLY IMMEDIATE' END as condeferred, CASE "con1"."confdeltype" WHEN 'a' THEN 'NO ACTION' WHEN 'r' THEN 'RESTRICT' WHEN 'c' THEN 'CASCADE' WHEN 'n' THEN 'SET NULL' WHEN 'd' THEN 'SET DEFAULT' END as "confdeltype", CASE "con1"."confupdtype" WHEN 'a' THEN 'NO ACTION' WHEN 'r' THEN 'RESTRICT' WHEN 'c' THEN 'CASCADE' WHEN 'n' THEN 'SET NULL' WHEN 'd' THEN 'SET DEFAULT' END as "confupdtype" FROM "pg_class" "cl" INNER JOIN "pg_namespace" "ns" ON "cl"."relnamespace" = "ns"."oid" INNER JOIN "pg_constraint" "con1" ON "con1"."conrelid" = "cl"."oid" WHERE "con1"."contype" = 'f' AND (${foreignKeysCondition}) ) "con" INNER JOIN "pg_attribute" "att" ON "att"."attrelid" = "con"."confrelid" AND "att"."attnum" = "con"."child" INNER JOIN "pg_class" "cl" ON "cl"."oid" = "con"."confrelid" ${isPartitionCondition}INNER JOIN "pg_namespace" "ns" ON "cl"."relnamespace" = "ns"."oid" INNER JOIN "pg_attribute" "att2" ON "att2"."attrelid" = "con"."conrelid" AND "att2"."attnum" = "con"."parent"`;
        const [dbColumns, dbConstraints, dbIndices, dbForeignKeys] = await Promise.all([
          this.query(columnsSql),
          this.query(constraintsSql),
          this.query(indicesSql),
          this.query(foreignKeysSql)
        ]);
        return Promise.all(dbTables.map(async (dbTable) => {
          const table = new Table_1.Table();
          const getSchemaFromKey = (dbObject, key) => {
            return dbObject[key] === currentSchema && (!this.driver.options.schema || this.driver.options.schema === currentSchema) ? void 0 : dbObject[key];
          };
          const schema = getSchemaFromKey(dbTable, "table_schema");
          table.database = currentDatabase;
          table.schema = dbTable["table_schema"];
          table.comment = dbTable["table_comment"];
          table.name = this.driver.buildTableName(dbTable["table_name"], schema);
          table.columns = await Promise.all(dbColumns.filter((dbColumn) => dbColumn["table_name"] === dbTable["table_name"] && dbColumn["table_schema"] === dbTable["table_schema"]).map(async (dbColumn) => {
            const columnConstraints = dbConstraints.filter((dbConstraint) => {
              return dbConstraint["table_name"] === dbColumn["table_name"] && dbConstraint["table_schema"] === dbColumn["table_schema"] && dbConstraint["column_name"] === dbColumn["column_name"];
            });
            const tableColumn = new TableColumn_1.TableColumn();
            tableColumn.name = dbColumn["column_name"];
            tableColumn.type = dbColumn["regtype"].toLowerCase();
            if (tableColumn.type === "numeric" || tableColumn.type === "numeric[]" || tableColumn.type === "decimal" || tableColumn.type === "float") {
              let numericPrecision = dbColumn["numeric_precision"];
              let numericScale = dbColumn["numeric_scale"];
              if (dbColumn["data_type"] === "ARRAY") {
                const numericSize = dbColumn["format_type"].match(/^numeric\(([0-9]+),([0-9]+)\)\[\]$/);
                if (numericSize) {
                  numericPrecision = +numericSize[1];
                  numericScale = +numericSize[2];
                }
              }
              if (numericPrecision !== null && !this.isDefaultColumnPrecision(table, tableColumn, numericPrecision)) {
                tableColumn.precision = numericPrecision;
              } else if (numericScale !== null && !this.isDefaultColumnScale(table, tableColumn, numericScale)) {
                tableColumn.precision = void 0;
              }
              if (numericScale !== null && !this.isDefaultColumnScale(table, tableColumn, numericScale)) {
                tableColumn.scale = numericScale;
              } else if (numericPrecision !== null && !this.isDefaultColumnPrecision(table, tableColumn, numericPrecision)) {
                tableColumn.scale = void 0;
              }
            }
            if (tableColumn.type === "interval" || tableColumn.type === "time without time zone" || tableColumn.type === "time with time zone" || tableColumn.type === "timestamp without time zone" || tableColumn.type === "timestamp with time zone") {
              tableColumn.precision = !this.isDefaultColumnPrecision(table, tableColumn, dbColumn["datetime_precision"]) ? dbColumn["datetime_precision"] : void 0;
            }
            if (dbColumn["data_type"] === "USER-DEFINED" || dbColumn["data_type"] === "ARRAY") {
              const { name } = await this.getUserDefinedTypeName(table, tableColumn);
              const builtEnumName = this.buildEnumName(table, tableColumn, false, true);
              const enumName = builtEnumName !== name ? name : void 0;
              const sql = `SELECT "e"."enumlabel" AS "value" FROM "pg_enum" "e" INNER JOIN "pg_type" "t" ON "t"."oid" = "e"."enumtypid" INNER JOIN "pg_namespace" "n" ON "n"."oid" = "t"."typnamespace" WHERE "n"."nspname" = '${dbTable["table_schema"]}' AND "t"."typname" = '${enumName || name}'`;
              const results = await this.query(sql);
              if (results.length) {
                tableColumn.type = "enum";
                tableColumn.enum = results.map((result) => result["value"]);
                tableColumn.enumName = enumName;
              }
              if (dbColumn["data_type"] === "ARRAY") {
                tableColumn.isArray = true;
                const type = tableColumn.type.replace("[]", "");
                tableColumn.type = this.connection.driver.normalizeType({
                  type
                });
              }
            }
            if (tableColumn.type === "geometry" || tableColumn.type === "geography") {
              const sql = `SELECT * FROM (SELECT "f_table_schema" "table_schema", "f_table_name" "table_name", "f_${tableColumn.type}_column" "column_name", "srid", "type" FROM "${tableColumn.type}_columns") AS _ WHERE "column_name" = '${dbColumn["column_name"]}' AND "table_schema" = '${dbColumn["table_schema"]}' AND "table_name" = '${dbColumn["table_name"]}'`;
              const results = await this.query(sql);
              if (results.length > 0) {
                tableColumn.spatialFeatureType = results[0].type;
                tableColumn.srid = results[0].srid;
              }
            }
            if (this.driver.withLengthColumnTypes.indexOf(tableColumn.type) !== -1) {
              let length;
              if (tableColumn.isArray) {
                const match = /\((\d+)\)/.exec(dbColumn["format_type"]);
                length = match ? match[1] : void 0;
              } else if (dbColumn["character_maximum_length"]) {
                length = dbColumn["character_maximum_length"].toString();
              }
              if (length) {
                tableColumn.length = !this.isDefaultColumnLength(table, tableColumn, length) ? length : "";
              }
            }
            tableColumn.isNullable = dbColumn["is_nullable"] === "YES";
            const primaryConstraint = columnConstraints.find((constraint) => constraint["constraint_type"] === "PRIMARY");
            if (primaryConstraint) {
              tableColumn.isPrimary = true;
              const anotherPrimaryConstraints = dbConstraints.filter((constraint) => constraint["table_name"] === dbColumn["table_name"] && constraint["table_schema"] === dbColumn["table_schema"] && constraint["column_name"] !== dbColumn["column_name"] && constraint["constraint_type"] === "PRIMARY");
              const columnNames = anotherPrimaryConstraints.map((constraint) => constraint["column_name"]);
              columnNames.push(dbColumn["column_name"]);
              const pkName = this.connection.namingStrategy.primaryKeyName(table, columnNames);
              if (primaryConstraint["constraint_name"] !== pkName) {
                tableColumn.primaryKeyConstraintName = primaryConstraint["constraint_name"];
              }
            }
            const uniqueConstraints = columnConstraints.filter((constraint) => constraint["constraint_type"] === "UNIQUE");
            const isConstraintComposite = uniqueConstraints.every((uniqueConstraint) => {
              return dbConstraints.some((dbConstraint) => dbConstraint["constraint_type"] === "UNIQUE" && dbConstraint["constraint_name"] === uniqueConstraint["constraint_name"] && dbConstraint["column_name"] !== dbColumn["column_name"]);
            });
            tableColumn.isUnique = uniqueConstraints.length > 0 && !isConstraintComposite;
            if (dbColumn.is_identity === "YES") {
              tableColumn.isGenerated = true;
              tableColumn.generationStrategy = "identity";
              tableColumn.generatedIdentity = dbColumn.identity_generation;
            } else if (dbColumn["column_default"] !== null && dbColumn["column_default"] !== void 0) {
              const serialDefaultName = `nextval('${this.buildSequenceName(table, dbColumn["column_name"])}'::regclass)`;
              const serialDefaultPath = `nextval('${this.buildSequencePath(table, dbColumn["column_name"])}'::regclass)`;
              const defaultWithoutQuotes = dbColumn["column_default"].replace(/"/g, "");
              if (defaultWithoutQuotes === serialDefaultName || defaultWithoutQuotes === serialDefaultPath) {
                tableColumn.isGenerated = true;
                tableColumn.generationStrategy = "increment";
              } else if (dbColumn["column_default"] === "gen_random_uuid()" || /^uuid_generate_v\d\(\)/.test(dbColumn["column_default"])) {
                if (tableColumn.type === "uuid") {
                  tableColumn.isGenerated = true;
                  tableColumn.generationStrategy = "uuid";
                } else {
                  tableColumn.default = dbColumn["column_default"];
                }
              } else if (dbColumn["column_default"] === "now()" || dbColumn["column_default"].indexOf("'now'::text") !== -1) {
                tableColumn.default = dbColumn["column_default"];
              } else {
                tableColumn.default = dbColumn["column_default"].replace(/::[\w\s.[\]\-"]+/g, "");
                tableColumn.default = tableColumn.default.replace(/^(-?\d+)$/, "'$1'");
              }
            }
            if (dbColumn["is_generated"] === "ALWAYS" && dbColumn["generation_expression"]) {
              tableColumn.generatedType = "STORED";
              const asExpressionQuery = this.selectTypeormMetadataSql({
                database: currentDatabase,
                schema: dbTable["table_schema"],
                table: dbTable["table_name"],
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: tableColumn.name
              });
              const results = await this.query(asExpressionQuery.query, asExpressionQuery.parameters);
              if (results[0] && results[0].value) {
                tableColumn.asExpression = results[0].value;
              } else {
                tableColumn.asExpression = "";
              }
            }
            tableColumn.comment = dbColumn["description"] ? dbColumn["description"] : void 0;
            if (dbColumn["character_set_name"])
              tableColumn.charset = dbColumn["character_set_name"];
            if (dbColumn["collation_name"])
              tableColumn.collation = dbColumn["collation_name"];
            return tableColumn;
          }));
          const tableUniqueConstraints = OrmUtils_1.OrmUtils.uniq(dbConstraints.filter((dbConstraint) => {
            return dbConstraint["table_name"] === dbTable["table_name"] && dbConstraint["table_schema"] === dbTable["table_schema"] && dbConstraint["constraint_type"] === "UNIQUE";
          }), (dbConstraint) => dbConstraint["constraint_name"]);
          table.uniques = tableUniqueConstraints.map((constraint) => {
            const uniques = dbConstraints.filter((dbC) => dbC["constraint_name"] === constraint["constraint_name"]);
            return new TableUnique_1.TableUnique({
              name: constraint["constraint_name"],
              columnNames: uniques.map((u) => u["column_name"]),
              deferrable: constraint["deferrable"] ? constraint["deferred"] : void 0
            });
          });
          const tableCheckConstraints = OrmUtils_1.OrmUtils.uniq(dbConstraints.filter((dbConstraint) => {
            return dbConstraint["table_name"] === dbTable["table_name"] && dbConstraint["table_schema"] === dbTable["table_schema"] && dbConstraint["constraint_type"] === "CHECK";
          }), (dbConstraint) => dbConstraint["constraint_name"]);
          table.checks = tableCheckConstraints.map((constraint) => {
            const checks = dbConstraints.filter((dbC) => dbC["constraint_name"] === constraint["constraint_name"]);
            return new TableCheck_1.TableCheck({
              name: constraint["constraint_name"],
              columnNames: checks.map((c) => c["column_name"]),
              expression: constraint["expression"].replace(/^\s*CHECK\s*\((.*)\)\s*$/i, "$1")
            });
          });
          const tableExclusionConstraints = OrmUtils_1.OrmUtils.uniq(dbConstraints.filter((dbConstraint) => {
            return dbConstraint["table_name"] === dbTable["table_name"] && dbConstraint["table_schema"] === dbTable["table_schema"] && dbConstraint["constraint_type"] === "EXCLUDE";
          }), (dbConstraint) => dbConstraint["constraint_name"]);
          table.exclusions = tableExclusionConstraints.map((constraint) => {
            return new TableExclusion_1.TableExclusion({
              name: constraint["constraint_name"],
              expression: constraint["expression"].substring(8)
              // trim EXCLUDE from start of expression
            });
          });
          const tableForeignKeyConstraints = OrmUtils_1.OrmUtils.uniq(dbForeignKeys.filter((dbForeignKey) => {
            return dbForeignKey["table_name"] === dbTable["table_name"] && dbForeignKey["table_schema"] === dbTable["table_schema"];
          }), (dbForeignKey) => dbForeignKey["constraint_name"]);
          table.foreignKeys = tableForeignKeyConstraints.map((dbForeignKey) => {
            const foreignKeys = dbForeignKeys.filter((dbFk) => dbFk["constraint_name"] === dbForeignKey["constraint_name"]);
            const schema2 = getSchemaFromKey(dbForeignKey, "referenced_table_schema");
            const referencedTableName = this.driver.buildTableName(dbForeignKey["referenced_table_name"], schema2);
            return new TableForeignKey_1.TableForeignKey({
              name: dbForeignKey["constraint_name"],
              columnNames: foreignKeys.map((dbFk) => dbFk["column_name"]),
              referencedSchema: dbForeignKey["referenced_table_schema"],
              referencedTableName,
              referencedColumnNames: foreignKeys.map((dbFk) => dbFk["referenced_column_name"]),
              onDelete: dbForeignKey["on_delete"],
              onUpdate: dbForeignKey["on_update"],
              deferrable: dbForeignKey["deferrable"] ? dbForeignKey["deferred"] : void 0
            });
          });
          const tableIndexConstraints = OrmUtils_1.OrmUtils.uniq(dbIndices.filter((dbIndex) => {
            return dbIndex["table_name"] === dbTable["table_name"] && dbIndex["table_schema"] === dbTable["table_schema"];
          }), (dbIndex) => dbIndex["constraint_name"]);
          table.indices = tableIndexConstraints.map((constraint) => {
            const indices = dbIndices.filter((index) => {
              return index["table_schema"] === constraint["table_schema"] && index["table_name"] === constraint["table_name"] && index["constraint_name"] === constraint["constraint_name"];
            });
            return new TableIndex_1.TableIndex({
              table,
              name: constraint["constraint_name"],
              columnNames: indices.map((i) => i["column_name"]),
              isUnique: constraint["is_unique"] === "TRUE",
              where: constraint["condition"],
              isSpatial: constraint["index_type"] === "gist",
              isFulltext: false
            });
          });
          return table;
        }));
      }
      /**
       * Builds create table sql.
       */
      createTableSql(table, createForeignKeys) {
        const columnDefinitions = table.columns.map((column) => this.buildCreateColumnSql(table, column)).join(", ");
        let sql = `CREATE TABLE ${this.escapePath(table)} (${columnDefinitions}`;
        table.columns.filter((column) => column.isUnique).forEach((column) => {
          const isUniqueExist = table.uniques.some((unique) => unique.columnNames.length === 1 && unique.columnNames[0] === column.name);
          if (!isUniqueExist)
            table.uniques.push(new TableUnique_1.TableUnique({
              name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),
              columnNames: [column.name]
            }));
        });
        if (table.uniques.length > 0) {
          const uniquesSql = table.uniques.map((unique) => {
            const uniqueName = unique.name ? unique.name : this.connection.namingStrategy.uniqueConstraintName(table, unique.columnNames);
            const columnNames = unique.columnNames.map((columnName) => `"${columnName}"`).join(", ");
            let constraint = `CONSTRAINT "${uniqueName}" UNIQUE (${columnNames})`;
            if (unique.deferrable)
              constraint += ` DEFERRABLE ${unique.deferrable}`;
            return constraint;
          }).join(", ");
          sql += `, ${uniquesSql}`;
        }
        if (table.checks.length > 0) {
          const checksSql = table.checks.map((check) => {
            const checkName = check.name ? check.name : this.connection.namingStrategy.checkConstraintName(table, check.expression);
            return `CONSTRAINT "${checkName}" CHECK (${check.expression})`;
          }).join(", ");
          sql += `, ${checksSql}`;
        }
        if (table.exclusions.length > 0) {
          const exclusionsSql = table.exclusions.map((exclusion) => {
            const exclusionName = exclusion.name ? exclusion.name : this.connection.namingStrategy.exclusionConstraintName(table, exclusion.expression);
            return `CONSTRAINT "${exclusionName}" EXCLUDE ${exclusion.expression}`;
          }).join(", ");
          sql += `, ${exclusionsSql}`;
        }
        if (table.foreignKeys.length > 0 && createForeignKeys) {
          const foreignKeysSql = table.foreignKeys.map((fk) => {
            const columnNames = fk.columnNames.map((columnName) => `"${columnName}"`).join(", ");
            if (!fk.name)
              fk.name = this.connection.namingStrategy.foreignKeyName(table, fk.columnNames, this.getTablePath(fk), fk.referencedColumnNames);
            const referencedColumnNames = fk.referencedColumnNames.map((columnName) => `"${columnName}"`).join(", ");
            let constraint = `CONSTRAINT "${fk.name}" FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(fk))} (${referencedColumnNames})`;
            if (fk.onDelete)
              constraint += ` ON DELETE ${fk.onDelete}`;
            if (fk.onUpdate)
              constraint += ` ON UPDATE ${fk.onUpdate}`;
            if (fk.deferrable)
              constraint += ` DEFERRABLE ${fk.deferrable}`;
            return constraint;
          }).join(", ");
          sql += `, ${foreignKeysSql}`;
        }
        const primaryColumns = table.columns.filter((column) => column.isPrimary);
        if (primaryColumns.length > 0) {
          const primaryKeyName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(table, primaryColumns.map((column) => column.name));
          const columnNames = primaryColumns.map((column) => `"${column.name}"`).join(", ");
          sql += `, CONSTRAINT "${primaryKeyName}" PRIMARY KEY (${columnNames})`;
        }
        sql += `)`;
        table.columns.filter((it) => it.comment).forEach((it) => sql += `; COMMENT ON COLUMN ${this.escapePath(table)}."${it.name}" IS ${this.escapeComment(it.comment)}`);
        return new Query_1.Query(sql);
      }
      /**
       * Loads Postgres version.
       */
      async getVersion() {
        const result = await this.query(`SELECT version()`);
        return result[0].version.replace(/^PostgreSQL ([\d.]+).*$/, "$1");
      }
      /**
       * Builds drop table sql.
       */
      dropTableSql(tableOrPath) {
        return new Query_1.Query(`DROP TABLE ${this.escapePath(tableOrPath)}`);
      }
      createViewSql(view) {
        const materializedClause = view.materialized ? "MATERIALIZED " : "";
        const viewName = this.escapePath(view);
        if (typeof view.expression === "string") {
          return new Query_1.Query(`CREATE ${materializedClause}VIEW ${viewName} AS ${view.expression}`);
        } else {
          return new Query_1.Query(`CREATE ${materializedClause}VIEW ${viewName} AS ${view.expression(this.connection).getQuery()}`);
        }
      }
      async insertViewDefinitionSql(view) {
        const currentSchema = await this.getCurrentSchema();
        let { schema, tableName: name } = this.driver.parseTableName(view);
        if (!schema) {
          schema = currentSchema;
        }
        const type = view.materialized ? MetadataTableType_1.MetadataTableType.MATERIALIZED_VIEW : MetadataTableType_1.MetadataTableType.VIEW;
        const expression = typeof view.expression === "string" ? view.expression.trim() : view.expression(this.connection).getQuery();
        return this.insertTypeormMetadataSql({
          type,
          schema,
          name,
          value: expression
        });
      }
      /**
       * Builds drop view sql.
       */
      dropViewSql(view) {
        const materializedClause = view.materialized ? "MATERIALIZED " : "";
        return new Query_1.Query(`DROP ${materializedClause}VIEW ${this.escapePath(view)}`);
      }
      /**
       * Builds remove view sql.
       */
      async deleteViewDefinitionSql(view) {
        const currentSchema = await this.getCurrentSchema();
        let { schema, tableName: name } = this.driver.parseTableName(view);
        if (!schema) {
          schema = currentSchema;
        }
        const type = view.materialized ? MetadataTableType_1.MetadataTableType.MATERIALIZED_VIEW : MetadataTableType_1.MetadataTableType.VIEW;
        return this.deleteTypeormMetadataSql({ type, schema, name });
      }
      /**
       * Drops ENUM type from given schemas.
       */
      async dropEnumTypes(schemaNames) {
        const selectDropsQuery = `SELECT 'DROP TYPE IF EXISTS "' || n.nspname || '"."' || t.typname || '" CASCADE;' as "query" FROM "pg_type" "t" INNER JOIN "pg_enum" "e" ON "e"."enumtypid" = "t"."oid" INNER JOIN "pg_namespace" "n" ON "n"."oid" = "t"."typnamespace" WHERE "n"."nspname" IN (${schemaNames}) GROUP BY "n"."nspname", "t"."typname"`;
        const dropQueries = await this.query(selectDropsQuery);
        await Promise.all(dropQueries.map((q) => this.query(q["query"])));
      }
      /**
       * Checks if enum with the given name exist in the database.
       */
      async hasEnumType(table, column) {
        let { schema } = this.driver.parseTableName(table);
        if (!schema) {
          schema = await this.getCurrentSchema();
        }
        const enumName = this.buildEnumName(table, column, false, true);
        const sql = `SELECT "n"."nspname", "t"."typname" FROM "pg_type" "t" INNER JOIN "pg_namespace" "n" ON "n"."oid" = "t"."typnamespace" WHERE "n"."nspname" = '${schema}' AND "t"."typname" = '${enumName}'`;
        const result = await this.query(sql);
        return result.length ? true : false;
      }
      /**
       * Builds create ENUM type sql.
       */
      createEnumTypeSql(table, column, enumName) {
        if (!enumName)
          enumName = this.buildEnumName(table, column);
        const enumValues = column.enum.map((value) => `'${value.replaceAll("'", "''")}'`).join(", ");
        return new Query_1.Query(`CREATE TYPE ${enumName} AS ENUM(${enumValues})`);
      }
      /**
       * Builds create ENUM type sql.
       */
      dropEnumTypeSql(table, column, enumName) {
        if (!enumName)
          enumName = this.buildEnumName(table, column);
        return new Query_1.Query(`DROP TYPE ${enumName}`);
      }
      /**
       * Builds create index sql.
       */
      createIndexSql(table, index) {
        const columns = index.columnNames.map((columnName) => `"${columnName}"`).join(", ");
        return new Query_1.Query(`CREATE ${index.isUnique ? "UNIQUE " : ""}INDEX${index.isConcurrent ? " CONCURRENTLY" : ""} "${index.name}" ON ${this.escapePath(table)} ${index.isSpatial ? "USING GiST " : ""}(${columns}) ${index.where ? "WHERE " + index.where : ""}`);
      }
      /**
       * Builds create view index sql.
       */
      createViewIndexSql(view, index) {
        const columns = index.columnNames.map((columnName) => `"${columnName}"`).join(", ");
        return new Query_1.Query(`CREATE ${index.isUnique ? "UNIQUE " : ""}INDEX "${index.name}" ON ${this.escapePath(view)} (${columns}) ${index.where ? "WHERE " + index.where : ""}`);
      }
      /**
       * Builds drop index sql.
       */
      dropIndexSql(table, indexOrName) {
        const indexName = InstanceChecker_1.InstanceChecker.isTableIndex(indexOrName) ? indexOrName.name : indexOrName;
        const concurrent = InstanceChecker_1.InstanceChecker.isTableIndex(indexOrName) ? indexOrName.isConcurrent : false;
        const { schema } = this.driver.parseTableName(table);
        return schema ? new Query_1.Query(`DROP INDEX ${concurrent ? "CONCURRENTLY " : ""}"${schema}"."${indexName}"`) : new Query_1.Query(`DROP INDEX ${concurrent ? "CONCURRENTLY " : ""}"${indexName}"`);
      }
      /**
       * Builds create primary key sql.
       */
      createPrimaryKeySql(table, columnNames, constraintName) {
        const primaryKeyName = constraintName ? constraintName : this.connection.namingStrategy.primaryKeyName(table, columnNames);
        const columnNamesString = columnNames.map((columnName) => `"${columnName}"`).join(", ");
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${primaryKeyName}" PRIMARY KEY (${columnNamesString})`);
      }
      /**
       * Builds drop primary key sql.
       */
      dropPrimaryKeySql(table) {
        if (!table.primaryColumns.length)
          throw new error_1.TypeORMError(`Table ${table} has no primary keys.`);
        const columnNames = table.primaryColumns.map((column) => column.name);
        const constraintName = table.primaryColumns[0].primaryKeyConstraintName;
        const primaryKeyName = constraintName ? constraintName : this.connection.namingStrategy.primaryKeyName(table, columnNames);
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${primaryKeyName}"`);
      }
      /**
       * Builds create unique constraint sql.
       */
      createUniqueConstraintSql(table, uniqueConstraint) {
        const columnNames = uniqueConstraint.columnNames.map((column) => `"` + column + `"`).join(", ");
        let sql = `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${uniqueConstraint.name}" UNIQUE (${columnNames})`;
        if (uniqueConstraint.deferrable)
          sql += ` DEFERRABLE ${uniqueConstraint.deferrable}`;
        return new Query_1.Query(sql);
      }
      /**
       * Builds drop unique constraint sql.
       */
      dropUniqueConstraintSql(table, uniqueOrName) {
        const uniqueName = InstanceChecker_1.InstanceChecker.isTableUnique(uniqueOrName) ? uniqueOrName.name : uniqueOrName;
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${uniqueName}"`);
      }
      /**
       * Builds create check constraint sql.
       */
      createCheckConstraintSql(table, checkConstraint) {
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${checkConstraint.name}" CHECK (${checkConstraint.expression})`);
      }
      /**
       * Builds drop check constraint sql.
       */
      dropCheckConstraintSql(table, checkOrName) {
        const checkName = InstanceChecker_1.InstanceChecker.isTableCheck(checkOrName) ? checkOrName.name : checkOrName;
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${checkName}"`);
      }
      /**
       * Builds create exclusion constraint sql.
       */
      createExclusionConstraintSql(table, exclusionConstraint) {
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${exclusionConstraint.name}" EXCLUDE ${exclusionConstraint.expression}`);
      }
      /**
       * Builds drop exclusion constraint sql.
       */
      dropExclusionConstraintSql(table, exclusionOrName) {
        const exclusionName = InstanceChecker_1.InstanceChecker.isTableExclusion(exclusionOrName) ? exclusionOrName.name : exclusionOrName;
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${exclusionName}"`);
      }
      /**
       * Builds create foreign key sql.
       */
      createForeignKeySql(table, foreignKey) {
        const columnNames = foreignKey.columnNames.map((column) => `"` + column + `"`).join(", ");
        const referencedColumnNames = foreignKey.referencedColumnNames.map((column) => `"` + column + `"`).join(",");
        let sql = `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${foreignKey.name}" FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;
        if (foreignKey.onDelete)
          sql += ` ON DELETE ${foreignKey.onDelete}`;
        if (foreignKey.onUpdate)
          sql += ` ON UPDATE ${foreignKey.onUpdate}`;
        if (foreignKey.deferrable)
          sql += ` DEFERRABLE ${foreignKey.deferrable}`;
        return new Query_1.Query(sql);
      }
      /**
       * Builds drop foreign key sql.
       */
      dropForeignKeySql(table, foreignKeyOrName) {
        const foreignKeyName = InstanceChecker_1.InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName.name : foreignKeyOrName;
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${foreignKeyName}"`);
      }
      /**
       * Builds sequence name from given table and column.
       */
      buildSequenceName(table, columnOrName) {
        const { tableName } = this.driver.parseTableName(table);
        const columnName = InstanceChecker_1.InstanceChecker.isTableColumn(columnOrName) ? columnOrName.name : columnOrName;
        let seqName = `${tableName}_${columnName}_seq`;
        if (seqName.length > this.connection.driver.maxAliasLength) {
          seqName = `${tableName.substring(0, 29)}_${columnName.substring(0, Math.max(29, 63 - table.name.length - 5))}_seq`;
        }
        return seqName;
      }
      buildSequencePath(table, columnOrName) {
        const { schema } = this.driver.parseTableName(table);
        return schema ? `${schema}.${this.buildSequenceName(table, columnOrName)}` : this.buildSequenceName(table, columnOrName);
      }
      /**
       * Builds ENUM type name from given table and column.
       */
      buildEnumName(table, column, withSchema = true, disableEscape, toOld) {
        const { schema, tableName } = this.driver.parseTableName(table);
        let enumName = column.enumName ? column.enumName : `${tableName}_${column.name.toLowerCase()}_enum`;
        if (schema && withSchema)
          enumName = `${schema}.${enumName}`;
        if (toOld)
          enumName = enumName + "_old";
        return enumName.split(".").map((i) => {
          return disableEscape ? i : `"${i}"`;
        }).join(".");
      }
      async getUserDefinedTypeName(table, column) {
        let { schema, tableName: name } = this.driver.parseTableName(table);
        if (!schema) {
          schema = await this.getCurrentSchema();
        }
        const result = await this.query(`SELECT "udt_schema", "udt_name" FROM "information_schema"."columns" WHERE "table_schema" = '${schema}' AND "table_name" = '${name}' AND "column_name"='${column.name}'`);
        let udtName = result[0]["udt_name"];
        if (udtName.indexOf("_") === 0) {
          udtName = udtName.substr(1, udtName.length);
        }
        return {
          schema: result[0]["udt_schema"],
          name: udtName
        };
      }
      /**
       * Escapes a given comment so it's safe to include in a query.
       */
      escapeComment(comment) {
        if (!comment || comment.length === 0) {
          return "NULL";
        }
        comment = comment.replace(/'/g, "''").replace(/\u0000/g, "");
        return `'${comment}'`;
      }
      /**
       * Escapes given table or view path.
       */
      escapePath(target) {
        const { schema, tableName } = this.driver.parseTableName(target);
        if (schema && schema !== this.driver.searchSchema) {
          return `"${schema}"."${tableName}"`;
        }
        return `"${tableName}"`;
      }
      /**
       * Get the table name with table schema
       * Note: Without ' or "
       */
      async getTableNameWithSchema(target) {
        const tableName = InstanceChecker_1.InstanceChecker.isTable(target) ? target.name : target;
        if (tableName.indexOf(".") === -1) {
          const schemaResult = await this.query(`SELECT current_schema()`);
          const schema = schemaResult[0]["current_schema"];
          return `${schema}.${tableName}`;
        } else {
          return `${tableName.split(".")[0]}.${tableName.split(".")[1]}`;
        }
      }
      /**
       * Builds a query for create column.
       */
      buildCreateColumnSql(table, column) {
        let c = '"' + column.name + '"';
        if (column.isGenerated === true && column.generationStrategy !== "uuid") {
          if (column.generationStrategy === "identity") {
            const generatedIdentityOrDefault = column.generatedIdentity || "BY DEFAULT";
            c += ` ${column.type} GENERATED ${generatedIdentityOrDefault} AS IDENTITY`;
          } else {
            if (column.type === "integer" || column.type === "int" || column.type === "int4")
              c += " SERIAL";
            if (column.type === "smallint" || column.type === "int2")
              c += " SMALLSERIAL";
            if (column.type === "bigint" || column.type === "int8")
              c += " BIGSERIAL";
          }
        }
        if (column.type === "enum" || column.type === "simple-enum") {
          c += " " + this.buildEnumName(table, column);
          if (column.isArray)
            c += " array";
        } else if (!column.isGenerated || column.type === "uuid") {
          c += " " + this.connection.driver.createFullType(column);
        }
        if (column.generatedType === "STORED" && column.asExpression) {
          c += ` GENERATED ALWAYS AS (${column.asExpression}) STORED`;
        }
        if (column.charset)
          c += ' CHARACTER SET "' + column.charset + '"';
        if (column.collation)
          c += ' COLLATE "' + column.collation + '"';
        if (column.isNullable !== true)
          c += " NOT NULL";
        if (column.default !== void 0 && column.default !== null)
          c += " DEFAULT " + column.default;
        if (column.isGenerated && column.generationStrategy === "uuid" && !column.default)
          c += ` DEFAULT ${this.driver.uuidGenerator}`;
        return c;
      }
      /**
       * Checks if the PostgreSQL server has support for partitioned tables
       */
      async hasSupportForPartitionedTables() {
        const result = await this.query(`SELECT TRUE FROM information_schema.columns WHERE table_name = 'pg_class' and column_name = 'relispartition'`);
        return result.length ? true : false;
      }
      /**
       * Change table comment.
       */
      async changeTableComment(tableOrName, newComment) {
        const upQueries = [];
        const downQueries = [];
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        newComment = this.escapeComment(newComment);
        const comment = this.escapeComment(table.comment);
        if (newComment === comment) {
          return;
        }
        const newTable = table.clone();
        upQueries.push(new Query_1.Query(`COMMENT ON TABLE ${this.escapePath(newTable)} IS ${newComment}`));
        downQueries.push(new Query_1.Query(`COMMENT ON TABLE ${this.escapePath(table)} IS ${comment}`));
        await this.executeQueries(upQueries, downQueries);
        table.comment = newTable.comment;
        this.replaceCachedTable(table, newTable);
      }
    };
    exports2.PostgresQueryRunner = PostgresQueryRunner;
  }
});

// node_modules/typeorm/driver/postgres/PostgresDriver.js
var require_PostgresDriver = __commonJS({
  "node_modules/typeorm/driver/postgres/PostgresDriver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PostgresDriver = void 0;
    var ConnectionIsNotSetError_1 = require_ConnectionIsNotSetError();
    var DriverPackageNotInstalledError_1 = require_DriverPackageNotInstalledError();
    var PlatformTools_1 = require_PlatformTools();
    var RdbmsSchemaBuilder_1 = require_RdbmsSchemaBuilder();
    var ApplyValueTransformers_1 = require_ApplyValueTransformers();
    var DateUtils_1 = require_DateUtils();
    var OrmUtils_1 = require_OrmUtils();
    var VersionUtils_1 = require_VersionUtils();
    var PostgresQueryRunner_1 = require_PostgresQueryRunner();
    var DriverUtils_1 = require_DriverUtils();
    var error_1 = require_error();
    var InstanceChecker_1 = require_InstanceChecker();
    var PostgresDriver = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection) {
        this.slaves = [];
        this.connectedQueryRunners = [];
        this.isReplicated = false;
        this.treeSupport = true;
        this.transactionSupport = "nested";
        this.supportedDataTypes = [
          "int",
          "int2",
          "int4",
          "int8",
          "smallint",
          "integer",
          "bigint",
          "decimal",
          "numeric",
          "real",
          "float",
          "float4",
          "float8",
          "double precision",
          "money",
          "character varying",
          "varchar",
          "character",
          "char",
          "text",
          "citext",
          "hstore",
          "bytea",
          "bit",
          "varbit",
          "bit varying",
          "timetz",
          "timestamptz",
          "timestamp",
          "timestamp without time zone",
          "timestamp with time zone",
          "date",
          "time",
          "time without time zone",
          "time with time zone",
          "interval",
          "bool",
          "boolean",
          "enum",
          "point",
          "line",
          "lseg",
          "box",
          "path",
          "polygon",
          "circle",
          "cidr",
          "inet",
          "macaddr",
          "macaddr8",
          "tsvector",
          "tsquery",
          "uuid",
          "xml",
          "json",
          "jsonb",
          "int4range",
          "int8range",
          "numrange",
          "tsrange",
          "tstzrange",
          "daterange",
          "int4multirange",
          "int8multirange",
          "nummultirange",
          "tsmultirange",
          "tstzmultirange",
          "datemultirange",
          "geometry",
          "geography",
          "cube",
          "ltree"
        ];
        this.supportedUpsertTypes = ["on-conflict-do-update"];
        this.spatialTypes = ["geometry", "geography"];
        this.withLengthColumnTypes = [
          "character varying",
          "varchar",
          "character",
          "char",
          "bit",
          "varbit",
          "bit varying"
        ];
        this.withPrecisionColumnTypes = [
          "numeric",
          "decimal",
          "interval",
          "time without time zone",
          "time with time zone",
          "timestamp without time zone",
          "timestamp with time zone"
        ];
        this.withScaleColumnTypes = ["numeric", "decimal"];
        this.mappedDataTypes = {
          createDate: "timestamp",
          createDateDefault: "now()",
          updateDate: "timestamp",
          updateDateDefault: "now()",
          deleteDate: "timestamp",
          deleteDateNullable: true,
          version: "int4",
          treeLevel: "int4",
          migrationId: "int4",
          migrationName: "varchar",
          migrationTimestamp: "int8",
          cacheId: "int4",
          cacheIdentifier: "varchar",
          cacheTime: "int8",
          cacheDuration: "int4",
          cacheQuery: "text",
          cacheResult: "text",
          metadataType: "varchar",
          metadataDatabase: "varchar",
          metadataSchema: "varchar",
          metadataTable: "varchar",
          metadataName: "varchar",
          metadataValue: "text"
        };
        this.parametersPrefix = "$";
        this.dataTypeDefaults = {
          character: { length: 1 },
          bit: { length: 1 },
          interval: { precision: 6 },
          "time without time zone": { precision: 6 },
          "time with time zone": { precision: 6 },
          "timestamp without time zone": { precision: 6 },
          "timestamp with time zone": { precision: 6 }
        };
        this.maxAliasLength = 63;
        this.isGeneratedColumnsSupported = false;
        this.cteCapabilities = {
          enabled: true,
          writable: true,
          requiresRecursiveHint: true,
          materializedHint: true
        };
        if (!connection) {
          return;
        }
        this.connection = connection;
        this.options = connection.options;
        this.isReplicated = this.options.replication ? true : false;
        if (this.options.useUTC) {
          process.env.PGTZ = "UTC";
        }
        this.loadDependencies();
        this.database = DriverUtils_1.DriverUtils.buildDriverOptions(this.options.replication ? this.options.replication.master : this.options).database;
        this.schema = DriverUtils_1.DriverUtils.buildDriverOptions(this.options).schema;
      }
      // -------------------------------------------------------------------------
      // Public Implemented Methods
      // -------------------------------------------------------------------------
      /**
       * Performs connection to the database.
       * Based on pooling options, it can either create connection immediately,
       * either create a pool and create connection when needed.
       */
      async connect() {
        if (this.options.replication) {
          this.slaves = await Promise.all(this.options.replication.slaves.map((slave) => {
            return this.createPool(this.options, slave);
          }));
          this.master = await this.createPool(this.options, this.options.replication.master);
        } else {
          this.master = await this.createPool(this.options, this.options);
        }
        const queryRunner = this.createQueryRunner("master");
        this.version = await queryRunner.getVersion();
        if (!this.database) {
          this.database = await queryRunner.getCurrentDatabase();
        }
        if (!this.searchSchema) {
          this.searchSchema = await queryRunner.getCurrentSchema();
        }
        await queryRunner.release();
        if (!this.schema) {
          this.schema = this.searchSchema;
        }
      }
      /**
       * Makes any action after connection (e.g. create extensions in Postgres driver).
       */
      async afterConnect() {
        const extensionsMetadata = await this.checkMetadataForExtensions();
        const [connection, release] = await this.obtainMasterConnection();
        const installExtensions = this.options.installExtensions === void 0 || this.options.installExtensions;
        if (installExtensions && extensionsMetadata.hasExtensions) {
          await this.enableExtensions(extensionsMetadata, connection);
        }
        this.isGeneratedColumnsSupported = VersionUtils_1.VersionUtils.isGreaterOrEqual(this.version, "12.0");
        await release();
      }
      async enableExtensions(extensionsMetadata, connection) {
        const { logger } = this.connection;
        const { hasUuidColumns, hasCitextColumns, hasHstoreColumns, hasCubeColumns, hasGeometryColumns, hasLtreeColumns, hasExclusionConstraints } = extensionsMetadata;
        if (hasUuidColumns)
          try {
            await this.executeQuery(connection, `CREATE EXTENSION IF NOT EXISTS "${this.options.uuidExtension || "uuid-ossp"}"`);
          } catch (_) {
            logger.log("warn", `At least one of the entities has uuid column, but the '${this.options.uuidExtension || "uuid-ossp"}' extension cannot be installed automatically. Please install it manually using superuser rights, or select another uuid extension.`);
          }
        if (hasCitextColumns)
          try {
            await this.executeQuery(connection, `CREATE EXTENSION IF NOT EXISTS "citext"`);
          } catch (_) {
            logger.log("warn", "At least one of the entities has citext column, but the 'citext' extension cannot be installed automatically. Please install it manually using superuser rights");
          }
        if (hasHstoreColumns)
          try {
            await this.executeQuery(connection, `CREATE EXTENSION IF NOT EXISTS "hstore"`);
          } catch (_) {
            logger.log("warn", "At least one of the entities has hstore column, but the 'hstore' extension cannot be installed automatically. Please install it manually using superuser rights");
          }
        if (hasGeometryColumns)
          try {
            await this.executeQuery(connection, `CREATE EXTENSION IF NOT EXISTS "postgis"`);
          } catch (_) {
            logger.log("warn", "At least one of the entities has a geometry column, but the 'postgis' extension cannot be installed automatically. Please install it manually using superuser rights");
          }
        if (hasCubeColumns)
          try {
            await this.executeQuery(connection, `CREATE EXTENSION IF NOT EXISTS "cube"`);
          } catch (_) {
            logger.log("warn", "At least one of the entities has a cube column, but the 'cube' extension cannot be installed automatically. Please install it manually using superuser rights");
          }
        if (hasLtreeColumns)
          try {
            await this.executeQuery(connection, `CREATE EXTENSION IF NOT EXISTS "ltree"`);
          } catch (_) {
            logger.log("warn", "At least one of the entities has a ltree column, but the 'ltree' extension cannot be installed automatically. Please install it manually using superuser rights");
          }
        if (hasExclusionConstraints)
          try {
            await this.executeQuery(connection, `CREATE EXTENSION IF NOT EXISTS "btree_gist"`);
          } catch (_) {
            logger.log("warn", "At least one of the entities has an exclusion constraint, but the 'btree_gist' extension cannot be installed automatically. Please install it manually using superuser rights");
          }
      }
      async checkMetadataForExtensions() {
        const hasUuidColumns = this.connection.entityMetadatas.some((metadata) => {
          return metadata.generatedColumns.filter((column) => column.generationStrategy === "uuid").length > 0;
        });
        const hasCitextColumns = this.connection.entityMetadatas.some((metadata) => {
          return metadata.columns.filter((column) => column.type === "citext").length > 0;
        });
        const hasHstoreColumns = this.connection.entityMetadatas.some((metadata) => {
          return metadata.columns.filter((column) => column.type === "hstore").length > 0;
        });
        const hasCubeColumns = this.connection.entityMetadatas.some((metadata) => {
          return metadata.columns.filter((column) => column.type === "cube").length > 0;
        });
        const hasGeometryColumns = this.connection.entityMetadatas.some((metadata) => {
          return metadata.columns.filter((column) => this.spatialTypes.indexOf(column.type) >= 0).length > 0;
        });
        const hasLtreeColumns = this.connection.entityMetadatas.some((metadata) => {
          return metadata.columns.filter((column) => column.type === "ltree").length > 0;
        });
        const hasExclusionConstraints = this.connection.entityMetadatas.some((metadata) => {
          return metadata.exclusions.length > 0;
        });
        return {
          hasUuidColumns,
          hasCitextColumns,
          hasHstoreColumns,
          hasCubeColumns,
          hasGeometryColumns,
          hasLtreeColumns,
          hasExclusionConstraints,
          hasExtensions: hasUuidColumns || hasCitextColumns || hasHstoreColumns || hasGeometryColumns || hasCubeColumns || hasLtreeColumns || hasExclusionConstraints
        };
      }
      /**
       * Closes connection with database.
       */
      async disconnect() {
        if (!this.master) {
          throw new ConnectionIsNotSetError_1.ConnectionIsNotSetError("postgres");
        }
        await this.closePool(this.master);
        await Promise.all(this.slaves.map((slave) => this.closePool(slave)));
        this.master = void 0;
        this.slaves = [];
      }
      /**
       * Creates a schema builder used to build and sync a schema.
       */
      createSchemaBuilder() {
        return new RdbmsSchemaBuilder_1.RdbmsSchemaBuilder(this.connection);
      }
      /**
       * Creates a query runner used to execute database queries.
       */
      createQueryRunner(mode) {
        return new PostgresQueryRunner_1.PostgresQueryRunner(this, mode);
      }
      /**
       * Prepares given value to a value to be persisted, based on its column type and metadata.
       */
      preparePersistentValue(value, columnMetadata) {
        if (columnMetadata.transformer)
          value = ApplyValueTransformers_1.ApplyValueTransformers.transformTo(columnMetadata.transformer, value);
        if (value === null || value === void 0)
          return value;
        if (columnMetadata.type === Boolean) {
          return value === true ? 1 : 0;
        } else if (columnMetadata.type === "date") {
          return DateUtils_1.DateUtils.mixedDateToDateString(value);
        } else if (columnMetadata.type === "time") {
          return DateUtils_1.DateUtils.mixedDateToTimeString(value);
        } else if (columnMetadata.type === "datetime" || columnMetadata.type === Date || columnMetadata.type === "timestamp" || columnMetadata.type === "timestamp with time zone" || columnMetadata.type === "timestamp without time zone") {
          return DateUtils_1.DateUtils.mixedDateToDate(value);
        } else if (["json", "jsonb", ...this.spatialTypes].indexOf(columnMetadata.type) >= 0) {
          return JSON.stringify(value);
        } else if (columnMetadata.type === "hstore") {
          if (typeof value === "string") {
            return value;
          } else {
            const quoteString = (value2) => {
              if (value2 === null || typeof value2 === "undefined") {
                return "NULL";
              }
              return `"${`${value2}`.replace(/(?=["\\])/g, "\\")}"`;
            };
            return Object.keys(value).map((key) => quoteString(key) + "=>" + quoteString(value[key])).join(",");
          }
        } else if (columnMetadata.type === "simple-array") {
          return DateUtils_1.DateUtils.simpleArrayToString(value);
        } else if (columnMetadata.type === "simple-json") {
          return DateUtils_1.DateUtils.simpleJsonToString(value);
        } else if (columnMetadata.type === "cube") {
          if (columnMetadata.isArray) {
            return `{${value.map((cube) => `"(${cube.join(",")})"`).join(",")}}`;
          }
          return `(${value.join(",")})`;
        } else if (columnMetadata.type === "ltree") {
          return value.split(".").filter(Boolean).join(".").replace(/[\s]+/g, "_");
        } else if ((columnMetadata.type === "enum" || columnMetadata.type === "simple-enum") && !columnMetadata.isArray) {
          return "" + value;
        }
        return value;
      }
      /**
       * Prepares given value to a value to be persisted, based on its column type or metadata.
       */
      prepareHydratedValue(value, columnMetadata) {
        if (value === null || value === void 0)
          return columnMetadata.transformer ? ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value) : value;
        if (columnMetadata.type === Boolean) {
          value = value ? true : false;
        } else if (columnMetadata.type === "datetime" || columnMetadata.type === Date || columnMetadata.type === "timestamp" || columnMetadata.type === "timestamp with time zone" || columnMetadata.type === "timestamp without time zone") {
          value = DateUtils_1.DateUtils.normalizeHydratedDate(value);
        } else if (columnMetadata.type === "date") {
          value = DateUtils_1.DateUtils.mixedDateToDateString(value);
        } else if (columnMetadata.type === "time") {
          value = DateUtils_1.DateUtils.mixedTimeToString(value);
        } else if (columnMetadata.type === "hstore") {
          if (columnMetadata.hstoreType === "object") {
            const unescapeString = (str) => str.replace(/\\./g, (m) => m[1]);
            const regexp = /"([^"\\]*(?:\\.[^"\\]*)*)"=>(?:(NULL)|"([^"\\]*(?:\\.[^"\\]*)*)")(?:,|$)/g;
            const object = {};
            `${value}`.replace(regexp, (_, key, nullValue, stringValue) => {
              object[unescapeString(key)] = nullValue ? null : unescapeString(stringValue);
              return "";
            });
            value = object;
          }
        } else if (columnMetadata.type === "simple-array") {
          value = DateUtils_1.DateUtils.stringToSimpleArray(value);
        } else if (columnMetadata.type === "simple-json") {
          value = DateUtils_1.DateUtils.stringToSimpleJson(value);
        } else if (columnMetadata.type === "cube") {
          value = value.replace(/[()\s]+/g, "");
          if (columnMetadata.isArray) {
            const regexp = /(?:"((?:[\d\s.,])*)")|(?:(NULL))/g;
            const unparsedArrayString = value;
            value = [];
            let cube = null;
            while ((cube = regexp.exec(unparsedArrayString)) !== null) {
              if (cube[1] !== void 0) {
                value.push(cube[1].split(",").filter(Boolean).map(Number));
              } else {
                value.push(void 0);
              }
            }
          } else {
            value = value.split(",").filter(Boolean).map(Number);
          }
        } else if (columnMetadata.type === "enum" || columnMetadata.type === "simple-enum") {
          if (columnMetadata.isArray) {
            if (value === "{}")
              return [];
            value = value.slice(1, -1).split(",").map((val) => {
              if (val.startsWith(`"`) && val.endsWith(`"`))
                val = val.slice(1, -1);
              return val.replace(/\\(\\|")/g, "$1");
            });
            value = value.map((val) => {
              return !isNaN(+val) && columnMetadata.enum.indexOf(parseInt(val)) >= 0 ? parseInt(val) : val;
            });
          } else {
            value = !isNaN(+value) && columnMetadata.enum.indexOf(parseInt(value)) >= 0 ? parseInt(value) : value;
          }
        } else if (columnMetadata.type === Number) {
          value = !isNaN(+value) ? parseInt(value) : value;
        }
        if (columnMetadata.transformer)
          value = ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);
        return value;
      }
      /**
       * Replaces parameters in the given sql with special escaping character
       * and an array of parameter names to be passed to a query.
       */
      escapeQueryWithParameters(sql, parameters, nativeParameters) {
        const escapedParameters = Object.keys(nativeParameters).map((key) => nativeParameters[key]);
        if (!parameters || !Object.keys(parameters).length)
          return [sql, escapedParameters];
        const parameterIndexMap = /* @__PURE__ */ new Map();
        sql = sql.replace(/:(\.\.\.)?([A-Za-z0-9_.]+)/g, (full, isArray, key) => {
          if (!parameters.hasOwnProperty(key)) {
            return full;
          }
          if (parameterIndexMap.has(key)) {
            return this.parametersPrefix + parameterIndexMap.get(key);
          }
          const value = parameters[key];
          if (isArray) {
            return value.map((v) => {
              escapedParameters.push(v);
              return this.createParameter(key, escapedParameters.length - 1);
            }).join(", ");
          }
          if (typeof value === "function") {
            return value();
          }
          escapedParameters.push(value);
          parameterIndexMap.set(key, escapedParameters.length);
          return this.createParameter(key, escapedParameters.length - 1);
        });
        return [sql, escapedParameters];
      }
      /**
       * Escapes a column name.
       */
      escape(columnName) {
        return '"' + columnName + '"';
      }
      /**
       * Build full table name with schema name and table name.
       * E.g. myDB.mySchema.myTable
       */
      buildTableName(tableName, schema) {
        const tablePath = [tableName];
        if (schema) {
          tablePath.unshift(schema);
        }
        return tablePath.join(".");
      }
      /**
       * Parse a target table name or other types and return a normalized table definition.
       */
      parseTableName(target) {
        const driverDatabase = this.database;
        const driverSchema = this.schema;
        if (InstanceChecker_1.InstanceChecker.isTable(target) || InstanceChecker_1.InstanceChecker.isView(target)) {
          const parsed = this.parseTableName(target.name);
          return {
            database: target.database || parsed.database || driverDatabase,
            schema: target.schema || parsed.schema || driverSchema,
            tableName: parsed.tableName
          };
        }
        if (InstanceChecker_1.InstanceChecker.isTableForeignKey(target)) {
          const parsed = this.parseTableName(target.referencedTableName);
          return {
            database: target.referencedDatabase || parsed.database || driverDatabase,
            schema: target.referencedSchema || parsed.schema || driverSchema,
            tableName: parsed.tableName
          };
        }
        if (InstanceChecker_1.InstanceChecker.isEntityMetadata(target)) {
          return {
            database: target.database || driverDatabase,
            schema: target.schema || driverSchema,
            tableName: target.tableName
          };
        }
        const parts = target.split(".");
        return {
          database: driverDatabase,
          schema: (parts.length > 1 ? parts[0] : void 0) || driverSchema,
          tableName: parts.length > 1 ? parts[1] : parts[0]
        };
      }
      /**
       * Creates a database type from a given column metadata.
       */
      normalizeType(column) {
        if (column.type === Number || column.type === "int" || column.type === "int4") {
          return "integer";
        } else if (column.type === String || column.type === "varchar") {
          return "character varying";
        } else if (column.type === Date || column.type === "timestamp") {
          return "timestamp without time zone";
        } else if (column.type === "timestamptz") {
          return "timestamp with time zone";
        } else if (column.type === "time") {
          return "time without time zone";
        } else if (column.type === "timetz") {
          return "time with time zone";
        } else if (column.type === Boolean || column.type === "bool") {
          return "boolean";
        } else if (column.type === "simple-array") {
          return "text";
        } else if (column.type === "simple-json") {
          return "text";
        } else if (column.type === "simple-enum") {
          return "enum";
        } else if (column.type === "int2") {
          return "smallint";
        } else if (column.type === "int8") {
          return "bigint";
        } else if (column.type === "decimal") {
          return "numeric";
        } else if (column.type === "float8" || column.type === "float") {
          return "double precision";
        } else if (column.type === "float4") {
          return "real";
        } else if (column.type === "char") {
          return "character";
        } else if (column.type === "varbit") {
          return "bit varying";
        } else {
          return column.type || "";
        }
      }
      /**
       * Normalizes "default" value of the column.
       */
      normalizeDefault(columnMetadata) {
        const defaultValue = columnMetadata.default;
        if (defaultValue === null || defaultValue === void 0) {
          return void 0;
        }
        if (columnMetadata.isArray && Array.isArray(defaultValue)) {
          return `'{${defaultValue.map((val) => String(val)).join(",")}}'`;
        }
        if ((columnMetadata.type === "enum" || columnMetadata.type === "simple-enum" || typeof defaultValue === "number" || typeof defaultValue === "string") && defaultValue !== void 0) {
          return `'${defaultValue}'`;
        }
        if (typeof defaultValue === "boolean") {
          return defaultValue ? "true" : "false";
        }
        if (typeof defaultValue === "function") {
          const value = defaultValue();
          return this.normalizeDatetimeFunction(value);
        }
        if (typeof defaultValue === "object") {
          return `'${JSON.stringify(defaultValue)}'`;
        }
        return `${defaultValue}`;
      }
      /**
       * Compares "default" value of the column.
       * Postgres sorts json values before it is saved, so in that case a deep comparison has to be performed to see if has changed.
       */
      defaultEqual(columnMetadata, tableColumn) {
        if (["json", "jsonb"].includes(columnMetadata.type) && !["function", "undefined"].includes(typeof columnMetadata.default)) {
          const tableColumnDefault = typeof tableColumn.default === "string" ? JSON.parse(tableColumn.default.substring(1, tableColumn.default.length - 1)) : tableColumn.default;
          return OrmUtils_1.OrmUtils.deepCompare(columnMetadata.default, tableColumnDefault);
        }
        const columnDefault = this.lowerDefaultValueIfNecessary(this.normalizeDefault(columnMetadata));
        return columnDefault === tableColumn.default;
      }
      /**
       * Normalizes "isUnique" value of the column.
       */
      normalizeIsUnique(column) {
        return column.entityMetadata.uniques.some((uq) => uq.columns.length === 1 && uq.columns[0] === column);
      }
      /**
       * Returns default column lengths, which is required on column creation.
       */
      getColumnLength(column) {
        return column.length ? column.length.toString() : "";
      }
      /**
       * Creates column type definition including length, precision and scale
       */
      createFullType(column) {
        let type = column.type;
        if (column.length) {
          type += "(" + column.length + ")";
        } else if (column.precision !== null && column.precision !== void 0 && column.scale !== null && column.scale !== void 0) {
          type += "(" + column.precision + "," + column.scale + ")";
        } else if (column.precision !== null && column.precision !== void 0) {
          type += "(" + column.precision + ")";
        }
        if (column.type === "time without time zone") {
          type = "TIME" + (column.precision !== null && column.precision !== void 0 ? "(" + column.precision + ")" : "");
        } else if (column.type === "time with time zone") {
          type = "TIME" + (column.precision !== null && column.precision !== void 0 ? "(" + column.precision + ")" : "") + " WITH TIME ZONE";
        } else if (column.type === "timestamp without time zone") {
          type = "TIMESTAMP" + (column.precision !== null && column.precision !== void 0 ? "(" + column.precision + ")" : "");
        } else if (column.type === "timestamp with time zone") {
          type = "TIMESTAMP" + (column.precision !== null && column.precision !== void 0 ? "(" + column.precision + ")" : "") + " WITH TIME ZONE";
        } else if (this.spatialTypes.indexOf(column.type) >= 0) {
          if (column.spatialFeatureType != null && column.srid != null) {
            type = `${column.type}(${column.spatialFeatureType},${column.srid})`;
          } else if (column.spatialFeatureType != null) {
            type = `${column.type}(${column.spatialFeatureType})`;
          } else {
            type = column.type;
          }
        }
        if (column.isArray)
          type += " array";
        return type;
      }
      /**
       * Obtains a new database connection to a master server.
       * Used for replication.
       * If replication is not setup then returns default connection's database connection.
       */
      async obtainMasterConnection() {
        if (!this.master) {
          throw new error_1.TypeORMError("Driver not Connected");
        }
        return new Promise((ok, fail) => {
          this.master.connect((err, connection, release) => {
            err ? fail(err) : ok([connection, release]);
          });
        });
      }
      /**
       * Obtains a new database connection to a slave server.
       * Used for replication.
       * If replication is not setup then returns master (default) connection's database connection.
       */
      async obtainSlaveConnection() {
        if (!this.slaves.length) {
          return this.obtainMasterConnection();
        }
        const random = Math.floor(Math.random() * this.slaves.length);
        return new Promise((ok, fail) => {
          this.slaves[random].connect((err, connection, release) => {
            err ? fail(err) : ok([connection, release]);
          });
        });
      }
      /**
       * Creates generated map of values generated or returned by database after INSERT query.
       *
       * todo: slow. optimize Object.keys(), OrmUtils.mergeDeep and column.createValueMap parts
       */
      createGeneratedMap(metadata, insertResult) {
        if (!insertResult)
          return void 0;
        return Object.keys(insertResult).reduce((map, key) => {
          const column = metadata.findColumnWithDatabaseName(key);
          if (column) {
            OrmUtils_1.OrmUtils.mergeDeep(map, column.createValueMap(insertResult[key]));
          }
          return map;
        }, {});
      }
      /**
       * Differentiate columns of this table and columns from the given column metadatas columns
       * and returns only changed.
       */
      findChangedColumns(tableColumns, columnMetadatas) {
        return columnMetadatas.filter((columnMetadata) => {
          const tableColumn = tableColumns.find((c) => c.name === columnMetadata.databaseName);
          if (!tableColumn)
            return false;
          const isColumnChanged = tableColumn.name !== columnMetadata.databaseName || tableColumn.type !== this.normalizeType(columnMetadata) || tableColumn.length !== columnMetadata.length || tableColumn.isArray !== columnMetadata.isArray || tableColumn.precision !== columnMetadata.precision || columnMetadata.scale !== void 0 && tableColumn.scale !== columnMetadata.scale || tableColumn.comment !== this.escapeComment(columnMetadata.comment) || !tableColumn.isGenerated && !this.defaultEqual(columnMetadata, tableColumn) || // we included check for generated here, because generated columns already can have default values
          tableColumn.isPrimary !== columnMetadata.isPrimary || tableColumn.isNullable !== columnMetadata.isNullable || tableColumn.isUnique !== this.normalizeIsUnique(columnMetadata) || tableColumn.enumName !== columnMetadata.enumName || tableColumn.enum && columnMetadata.enum && !OrmUtils_1.OrmUtils.isArraysEqual(tableColumn.enum, columnMetadata.enum.map((val) => val + "")) || // enums in postgres are always strings
          tableColumn.isGenerated !== columnMetadata.isGenerated || (tableColumn.spatialFeatureType || "").toLowerCase() !== (columnMetadata.spatialFeatureType || "").toLowerCase() || tableColumn.srid !== columnMetadata.srid || tableColumn.generatedType !== columnMetadata.generatedType || (tableColumn.asExpression || "").trim() !== (columnMetadata.asExpression || "").trim() || tableColumn.collation !== columnMetadata.collation;
          return isColumnChanged;
        });
      }
      lowerDefaultValueIfNecessary(value) {
        if (!value) {
          return value;
        }
        return value.split(`'`).map((v, i) => {
          return i % 2 === 1 ? v : v.toLowerCase();
        }).join(`'`);
      }
      /**
       * Returns true if driver supports RETURNING / OUTPUT statement.
       */
      isReturningSqlSupported() {
        return true;
      }
      /**
       * Returns true if driver supports uuid values generation on its own.
       */
      isUUIDGenerationSupported() {
        return true;
      }
      /**
       * Returns true if driver supports fulltext indices.
       */
      isFullTextColumnTypeSupported() {
        return false;
      }
      get uuidGenerator() {
        return this.options.uuidExtension === "pgcrypto" ? "gen_random_uuid()" : "uuid_generate_v4()";
      }
      /**
       * Creates an escaped parameter.
       */
      createParameter(parameterName, index) {
        return this.parametersPrefix + (index + 1);
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Loads postgres query stream package.
       */
      loadStreamDependency() {
        try {
          return PlatformTools_1.PlatformTools.load("pg-query-stream");
        } catch {
          throw new error_1.TypeORMError(`To use streams you should install pg-query-stream package. Please run "npm i pg-query-stream".`);
        }
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * If driver dependency is not given explicitly, then try to load it via "require".
       */
      loadDependencies() {
        try {
          const postgres = this.options.driver || PlatformTools_1.PlatformTools.load("pg");
          this.postgres = postgres;
          try {
            const pgNative = this.options.nativeDriver || PlatformTools_1.PlatformTools.load("pg-native");
            if (pgNative && this.postgres.native)
              this.postgres = this.postgres.native;
          } catch (e) {
          }
        } catch (e) {
          throw new DriverPackageNotInstalledError_1.DriverPackageNotInstalledError("Postgres", "pg");
        }
      }
      /**
       * Creates a new connection pool for a given database credentials.
       */
      async createPool(options, credentials) {
        const { logger } = this.connection;
        credentials = Object.assign({}, credentials);
        const connectionOptions = Object.assign({}, {
          connectionString: credentials.url,
          host: credentials.host,
          user: credentials.username,
          password: credentials.password,
          database: credentials.database,
          port: credentials.port,
          ssl: credentials.ssl,
          connectionTimeoutMillis: options.connectTimeoutMS,
          application_name: options.applicationName ?? credentials.applicationName,
          max: options.poolSize
        }, options.extra || {});
        if (options.parseInt8 !== void 0) {
          if (this.postgres.defaults && Object.getOwnPropertyDescriptor(this.postgres.defaults, "parseInt8")?.set) {
            this.postgres.defaults.parseInt8 = options.parseInt8;
          } else {
            logger.log("warn", "Attempted to set parseInt8 option, but the postgres driver does not support setting defaults.parseInt8. This option will be ignored.");
          }
        }
        const pool = new this.postgres.Pool(connectionOptions);
        const poolErrorHandler = options.poolErrorHandler || ((error) => logger.log("warn", `Postgres pool raised an error. ${error}`));
        pool.on("error", poolErrorHandler);
        return new Promise((ok, fail) => {
          pool.connect((err, connection, release) => {
            if (err)
              return fail(err);
            if (options.logNotifications) {
              connection.on("notice", (msg) => {
                msg && this.connection.logger.log("info", msg.message);
              });
              connection.on("notification", (msg) => {
                msg && this.connection.logger.log("info", `Received NOTIFY on channel ${msg.channel}: ${msg.payload}.`);
              });
            }
            release();
            ok(pool);
          });
        });
      }
      /**
       * Closes connection pool.
       */
      async closePool(pool) {
        while (this.connectedQueryRunners.length) {
          await this.connectedQueryRunners[0].release();
        }
        return new Promise((ok, fail) => {
          pool.end((err) => err ? fail(err) : ok());
        });
      }
      /**
       * Executes given query.
       */
      executeQuery(connection, query) {
        this.connection.logger.logQuery(query);
        return new Promise((ok, fail) => {
          connection.query(query, (err, result) => err ? fail(err) : ok(result));
        });
      }
      /**
       * If parameter is a datetime function, e.g. "CURRENT_TIMESTAMP", normalizes it.
       * Otherwise returns original input.
       */
      normalizeDatetimeFunction(value) {
        const upperCaseValue = value.toUpperCase();
        const isDatetimeFunction = upperCaseValue.indexOf("CURRENT_TIMESTAMP") !== -1 || upperCaseValue.indexOf("CURRENT_DATE") !== -1 || upperCaseValue.indexOf("CURRENT_TIME") !== -1 || upperCaseValue.indexOf("LOCALTIMESTAMP") !== -1 || upperCaseValue.indexOf("LOCALTIME") !== -1;
        if (isDatetimeFunction) {
          const precision = value.match(/\(\d+\)/);
          if (upperCaseValue.indexOf("CURRENT_TIMESTAMP") !== -1) {
            return precision ? `('now'::text)::timestamp${precision[0]} with time zone` : "now()";
          } else if (upperCaseValue === "CURRENT_DATE") {
            return "('now'::text)::date";
          } else if (upperCaseValue.indexOf("CURRENT_TIME") !== -1) {
            return precision ? `('now'::text)::time${precision[0]} with time zone` : "('now'::text)::time with time zone";
          } else if (upperCaseValue.indexOf("LOCALTIMESTAMP") !== -1) {
            return precision ? `('now'::text)::timestamp${precision[0]} without time zone` : "('now'::text)::timestamp without time zone";
          } else if (upperCaseValue.indexOf("LOCALTIME") !== -1) {
            return precision ? `('now'::text)::time${precision[0]} without time zone` : "('now'::text)::time without time zone";
          }
        }
        return value;
      }
      /**
       * Escapes a given comment.
       */
      escapeComment(comment) {
        if (!comment)
          return comment;
        comment = comment.replace(/\u0000/g, "");
        return comment;
      }
    };
    exports2.PostgresDriver = PostgresDriver;
  }
});

// node_modules/typeorm/driver/expo/ExpoQueryRunner.js
var require_ExpoQueryRunner = __commonJS({
  "node_modules/typeorm/driver/expo/ExpoQueryRunner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExpoQueryRunner = void 0;
    var QueryFailedError_1 = require_QueryFailedError();
    var QueryRunnerAlreadyReleasedError_1 = require_QueryRunnerAlreadyReleasedError();
    var QueryResult_1 = require_QueryResult();
    var Broadcaster_1 = require_Broadcaster();
    var BroadcasterResult_1 = require_BroadcasterResult();
    var AbstractSqliteQueryRunner_1 = require_AbstractSqliteQueryRunner();
    var ExpoQueryRunner = class extends AbstractSqliteQueryRunner_1.AbstractSqliteQueryRunner {
      constructor(driver) {
        super();
        this.driver = driver;
        this.connection = driver.connection;
        this.broadcaster = new Broadcaster_1.Broadcaster(this);
      }
      async beforeMigration() {
        await this.query("PRAGMA foreign_keys = OFF");
      }
      async afterMigration() {
        await this.query("PRAGMA foreign_keys = ON");
      }
      async query(query, parameters, useStructuredResult = false) {
        if (this.isReleased)
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        const databaseConnection = await this.connect();
        const broadcasterResult = new BroadcasterResult_1.BroadcasterResult();
        this.driver.connection.logger.logQuery(query, parameters, this);
        await this.broadcaster.broadcast("BeforeQuery", query, parameters);
        const queryStartTime = Date.now();
        const statement = await databaseConnection.prepareAsync(query);
        try {
          const rawResult = await statement.executeAsync(parameters);
          const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
          const queryEndTime = Date.now();
          const queryExecutionTime = queryEndTime - queryStartTime;
          this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, rawResult, void 0);
          await broadcasterResult.wait();
          if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) {
            this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
          }
          const result = new QueryResult_1.QueryResult();
          result.affected = rawResult.changes;
          result.records = await rawResult.getAllAsync();
          result.raw = query.startsWith("INSERT INTO") ? rawResult.lastInsertRowId : result.records;
          return useStructuredResult ? result : result.raw;
        } catch (err) {
          this.driver.connection.logger.logQueryError(err, query, parameters, this);
          this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, 0, void 0, err);
          await broadcasterResult.wait();
          throw new QueryFailedError_1.QueryFailedError(query, parameters, err);
        } finally {
          await broadcasterResult.wait();
          await statement.finalizeAsync();
        }
      }
    };
    exports2.ExpoQueryRunner = ExpoQueryRunner;
  }
});

// node_modules/typeorm/driver/expo/ExpoDriver.js
var require_ExpoDriver = __commonJS({
  "node_modules/typeorm/driver/expo/ExpoDriver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExpoDriver = void 0;
    var AbstractSqliteDriver_1 = require_AbstractSqliteDriver();
    var ExpoQueryRunner_1 = require_ExpoQueryRunner();
    var ExpoDriver = class extends AbstractSqliteDriver_1.AbstractSqliteDriver {
      constructor(connection) {
        super(connection);
        this.sqlite = this.options.driver;
      }
      async disconnect() {
        this.queryRunner = void 0;
        await this.databaseConnection.closeAsync();
        this.databaseConnection = void 0;
      }
      createQueryRunner() {
        if (!this.queryRunner)
          this.queryRunner = new ExpoQueryRunner_1.ExpoQueryRunner(this);
        return this.queryRunner;
      }
      async createDatabaseConnection() {
        this.databaseConnection = await this.sqlite.openDatabaseAsync(this.options.database);
        await this.databaseConnection.runAsync("PRAGMA foreign_keys = ON");
        return this.databaseConnection;
      }
    };
    exports2.ExpoDriver = ExpoDriver;
  }
});

// node_modules/typeorm/driver/expo/legacy/ExpoLegacyQueryRunner.js
var require_ExpoLegacyQueryRunner = __commonJS({
  "node_modules/typeorm/driver/expo/legacy/ExpoLegacyQueryRunner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExpoLegacyQueryRunner = void 0;
    var QueryRunnerAlreadyReleasedError_1 = require_QueryRunnerAlreadyReleasedError();
    var QueryFailedError_1 = require_QueryFailedError();
    var AbstractSqliteQueryRunner_1 = require_AbstractSqliteQueryRunner();
    var TransactionNotStartedError_1 = require_TransactionNotStartedError();
    var Broadcaster_1 = require_Broadcaster();
    var QueryResult_1 = require_QueryResult();
    var BroadcasterResult_1 = require_BroadcasterResult();
    var ExpoLegacyQueryRunner = class extends AbstractSqliteQueryRunner_1.AbstractSqliteQueryRunner {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(driver) {
        super();
        this.driver = driver;
        this.connection = driver.connection;
        this.broadcaster = new Broadcaster_1.Broadcaster(this);
      }
      /**
       * Starts transaction. Within Expo, all database operations happen in a
       * transaction context, so issuing a `BEGIN TRANSACTION` command is
       * redundant and will result in the following error:
       *
       * `Error: Error code 1: cannot start a transaction within a transaction`
       *
       * Instead, we keep track of a `Transaction` object in `this.transaction`
       * and continue using the same object until we wish to commit the
       * transaction.
       */
      async startTransaction() {
        this.isTransactionActive = true;
        try {
          await this.broadcaster.broadcast("BeforeTransactionStart");
        } catch (err) {
          this.isTransactionActive = false;
          throw err;
        }
        this.transactionDepth += 1;
        await this.broadcaster.broadcast("AfterTransactionStart");
      }
      /**
       * Commits transaction.
       * Error will be thrown if transaction was not started.
       * Since Expo will automatically commit the transaction once all the
       * callbacks of the transaction object have been completed, "committing" a
       * transaction in this driver's context means that we delete the transaction
       * object and set the stage for the next transaction.
       */
      async commitTransaction() {
        if (!this.isTransactionActive && typeof this.transaction === "undefined")
          throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionCommit");
        this.transaction = void 0;
        this.isTransactionActive = false;
        this.transactionDepth -= 1;
        await this.broadcaster.broadcast("AfterTransactionCommit");
      }
      /**
       * Rollbacks transaction.
       * Error will be thrown if transaction was not started.
       * This method's functionality is identical to `commitTransaction()` because
       * the transaction lifecycle is handled within the Expo transaction object.
       * Issuing separate statements for `COMMIT` or `ROLLBACK` aren't necessary.
       */
      async rollbackTransaction() {
        if (!this.isTransactionActive && typeof this.transaction === "undefined")
          throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionRollback");
        this.transaction = void 0;
        this.isTransactionActive = false;
        this.transactionDepth -= 1;
        await this.broadcaster.broadcast("AfterTransactionRollback");
      }
      /**
       * Called before migrations are run.
       */
      async beforeMigration() {
        const databaseConnection = await this.connect();
        return new Promise((ok, fail) => {
          databaseConnection.exec([{ sql: "PRAGMA foreign_keys = OFF", args: [] }], false, (err) => err ? fail(err) : ok());
        });
      }
      /**
       * Called after migrations are run.
       */
      async afterMigration() {
        const databaseConnection = await this.connect();
        return new Promise((ok, fail) => {
          databaseConnection.exec([{ sql: "PRAGMA foreign_keys = ON", args: [] }], false, (err) => err ? fail(err) : ok());
        });
      }
      /**
       * Executes a given SQL query.
       */
      async query(query, parameters, useStructuredResult = false) {
        if (this.isReleased)
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        return new Promise(async (ok, fail) => {
          const databaseConnection = await this.connect();
          const broadcasterResult = new BroadcasterResult_1.BroadcasterResult();
          this.driver.connection.logger.logQuery(query, parameters, this);
          this.broadcaster.broadcastBeforeQueryEvent(broadcasterResult, query, parameters);
          const queryStartTime = Date.now();
          databaseConnection.transaction(async (transaction) => {
            if (typeof this.transaction === "undefined") {
              await this.startTransaction();
              this.transaction = transaction;
            }
            this.transaction.executeSql(query, parameters, async (t, raw) => {
              const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
              const queryEndTime = Date.now();
              const queryExecutionTime = queryEndTime - queryStartTime;
              this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, raw, void 0);
              await broadcasterResult.wait();
              if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) {
                this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
              }
              const result = new QueryResult_1.QueryResult();
              if (raw?.hasOwnProperty("rowsAffected")) {
                result.affected = raw.rowsAffected;
              }
              if (raw?.hasOwnProperty("rows")) {
                const resultSet = [];
                for (let i = 0; i < raw.rows.length; i++) {
                  resultSet.push(raw.rows.item(i));
                }
                result.raw = resultSet;
                result.records = resultSet;
              }
              if (query.startsWith("INSERT INTO")) {
                result.raw = raw.insertId;
              }
              if (useStructuredResult) {
                ok(result);
              } else {
                ok(result.raw);
              }
            }, async (t, err) => {
              this.driver.connection.logger.logQueryError(err, query, parameters, this);
              this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, void 0, void 0, err);
              await broadcasterResult.wait();
              fail(new QueryFailedError_1.QueryFailedError(query, parameters, err));
            });
          }, async (err) => {
            await this.rollbackTransaction();
            fail(err);
          }, () => {
            this.isTransactionActive = false;
            this.transaction = void 0;
          });
        });
      }
    };
    exports2.ExpoLegacyQueryRunner = ExpoLegacyQueryRunner;
  }
});

// node_modules/typeorm/driver/expo/legacy/ExpoLegacyDriver.js
var require_ExpoLegacyDriver = __commonJS({
  "node_modules/typeorm/driver/expo/legacy/ExpoLegacyDriver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExpoLegacyDriver = void 0;
    var AbstractSqliteDriver_1 = require_AbstractSqliteDriver();
    var ExpoLegacyQueryRunner_1 = require_ExpoLegacyQueryRunner();
    var ExpoLegacyDriver = class extends AbstractSqliteDriver_1.AbstractSqliteDriver {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection) {
        super(connection);
        this.database = this.options.database;
        this.sqlite = this.options.driver;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Closes connection with database.
       */
      async disconnect() {
        return new Promise((ok, fail) => {
          try {
            this.queryRunner = void 0;
            this.databaseConnection._db.close();
            this.databaseConnection = void 0;
            ok();
          } catch (error) {
            fail(error);
          }
        });
      }
      /**
       * Creates a query runner used to execute database queries.
       */
      createQueryRunner(mode) {
        if (!this.queryRunner)
          this.queryRunner = new ExpoLegacyQueryRunner_1.ExpoLegacyQueryRunner(this);
        return this.queryRunner;
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Creates connection with the database.
       */
      createDatabaseConnection() {
        return new Promise((ok, fail) => {
          try {
            const databaseConnection = this.sqlite.openDatabase(this.options.database);
            databaseConnection.transaction((tsx) => {
              tsx.executeSql(`PRAGMA foreign_keys = ON`, [], (t, result) => {
                ok(databaseConnection);
              }, (t, err) => {
                fail({ transaction: t, error: err });
              });
            }, (err) => {
              fail(err);
            });
          } catch (error) {
            fail(error);
          }
        });
      }
    };
    exports2.ExpoLegacyDriver = ExpoLegacyDriver;
  }
});

// node_modules/typeorm/driver/expo/ExpoDriverFactory.js
var require_ExpoDriverFactory = __commonJS({
  "node_modules/typeorm/driver/expo/ExpoDriverFactory.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExpoDriverFactory = void 0;
    var ExpoDriver_1 = require_ExpoDriver();
    var ExpoLegacyDriver_1 = require_ExpoLegacyDriver();
    var ExpoDriverFactory = class {
      constructor(connection) {
        this.connection = connection;
      }
      create() {
        if (this.isLegacyDriver) {
          return new ExpoLegacyDriver_1.ExpoLegacyDriver(this.connection);
        }
        return new ExpoDriver_1.ExpoDriver(this.connection);
      }
      get isLegacyDriver() {
        return !("openDatabaseAsync" in this.connection.options.driver);
      }
    };
    exports2.ExpoDriverFactory = ExpoDriverFactory;
  }
});

// node_modules/typeorm/driver/aurora-mysql/AuroraMysqlQueryRunner.js
var require_AuroraMysqlQueryRunner = __commonJS({
  "node_modules/typeorm/driver/aurora-mysql/AuroraMysqlQueryRunner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AuroraMysqlQueryRunner = void 0;
    var QueryResult_1 = require_QueryResult();
    var TransactionNotStartedError_1 = require_TransactionNotStartedError();
    var TableColumn_1 = require_TableColumn();
    var Table_1 = require_Table();
    var TableForeignKey_1 = require_TableForeignKey();
    var TableIndex_1 = require_TableIndex();
    var QueryRunnerAlreadyReleasedError_1 = require_QueryRunnerAlreadyReleasedError();
    var View_1 = require_View();
    var Query_1 = require_Query();
    var OrmUtils_1 = require_OrmUtils();
    var TableUnique_1 = require_TableUnique();
    var BaseQueryRunner_1 = require_BaseQueryRunner();
    var Broadcaster_1 = require_Broadcaster();
    var error_1 = require_error();
    var MetadataTableType_1 = require_MetadataTableType();
    var InstanceChecker_1 = require_InstanceChecker();
    var AuroraMysqlQueryRunner = class extends BaseQueryRunner_1.BaseQueryRunner {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(driver, client) {
        super();
        this.driver = driver;
        this.connection = driver.connection;
        this.client = client;
        this.broadcaster = new Broadcaster_1.Broadcaster(this);
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Creates/uses database connection from the connection pool to perform further operations.
       * Returns obtained database connection.
       */
      async connect() {
        return {};
      }
      /**
       * Releases used database connection.
       * You cannot use query runner methods once its released.
       */
      release() {
        this.isReleased = true;
        if (this.databaseConnection)
          this.databaseConnection.release();
        return Promise.resolve();
      }
      /**
       * Starts transaction on the current connection.
       */
      async startTransaction(isolationLevel) {
        this.isTransactionActive = true;
        try {
          await this.broadcaster.broadcast("BeforeTransactionStart");
        } catch (err) {
          this.isTransactionActive = false;
          throw err;
        }
        if (this.transactionDepth === 0) {
          await this.client.startTransaction();
        } else {
          await this.query(`SAVEPOINT typeorm_${this.transactionDepth}`);
        }
        this.transactionDepth += 1;
        await this.broadcaster.broadcast("AfterTransactionStart");
      }
      /**
       * Commits transaction.
       * Error will be thrown if transaction was not started.
       */
      async commitTransaction() {
        if (!this.isTransactionActive)
          throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionCommit");
        if (this.transactionDepth > 1) {
          await this.query(`RELEASE SAVEPOINT typeorm_${this.transactionDepth - 1}`);
        } else {
          await this.client.commitTransaction();
          this.isTransactionActive = false;
        }
        this.transactionDepth -= 1;
        await this.broadcaster.broadcast("AfterTransactionCommit");
      }
      /**
       * Rollbacks transaction.
       * Error will be thrown if transaction was not started.
       */
      async rollbackTransaction() {
        if (!this.isTransactionActive)
          throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionRollback");
        if (this.transactionDepth > 1) {
          await this.query(`ROLLBACK TO SAVEPOINT typeorm_${this.transactionDepth - 1}`);
        } else {
          await this.client.rollbackTransaction();
          this.isTransactionActive = false;
        }
        this.transactionDepth -= 1;
        await this.broadcaster.broadcast("AfterTransactionRollback");
      }
      /**
       * Executes a raw SQL query.
       */
      async query(query, parameters, useStructuredResult = false) {
        if (this.isReleased)
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        const raw = await this.client.query(query, parameters);
        const result = new QueryResult_1.QueryResult();
        result.raw = raw;
        if (raw?.hasOwnProperty("records") && Array.isArray(raw.records)) {
          result.records = raw.records;
        }
        if (raw?.hasOwnProperty("numberOfRecordsUpdated")) {
          result.affected = raw.numberOfRecordsUpdated;
        }
        if (!useStructuredResult) {
          return result.raw;
        }
        return result;
      }
      /**
       * Returns raw data stream.
       */
      stream(query, parameters, onEnd, onError) {
        if (this.isReleased)
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        return new Promise(async (ok, fail) => {
          try {
            const databaseConnection = await this.connect();
            const stream = databaseConnection.query(query, parameters);
            if (onEnd)
              stream.on("end", onEnd);
            if (onError)
              stream.on("error", onError);
            ok(stream);
          } catch (err) {
            fail(err);
          }
        });
      }
      /**
       * Returns all available database names including system databases.
       */
      async getDatabases() {
        return Promise.resolve([]);
      }
      /**
       * Returns all available schema names including system schemas.
       * If database parameter specified, returns schemas of that database.
       */
      async getSchemas(database) {
        throw new error_1.TypeORMError(`MySql driver does not support table schemas`);
      }
      /**
       * Checks if database with the given name exist.
       */
      async hasDatabase(database) {
        const result = await this.query(`SELECT * FROM \`INFORMATION_SCHEMA\`.\`SCHEMATA\` WHERE \`SCHEMA_NAME\` = '${database}'`);
        return result.length ? true : false;
      }
      /**
       * Loads currently using database
       */
      async getCurrentDatabase() {
        const query = await this.query(`SELECT DATABASE() AS \`db_name\``);
        return query[0]["db_name"];
      }
      /**
       * Checks if schema with the given name exist.
       */
      async hasSchema(schema) {
        throw new error_1.TypeORMError(`MySql driver does not support table schemas`);
      }
      /**
       * Loads currently using database schema
       */
      async getCurrentSchema() {
        const query = await this.query(`SELECT SCHEMA() AS \`schema_name\``);
        return query[0]["schema_name"];
      }
      /**
       * Checks if table with the given name exist in the database.
       */
      async hasTable(tableOrName) {
        const parsedTableName = this.driver.parseTableName(tableOrName);
        const sql = `SELECT * FROM \`INFORMATION_SCHEMA\`.\`COLUMNS\` WHERE \`TABLE_SCHEMA\` = '${parsedTableName.database}' AND \`TABLE_NAME\` = '${parsedTableName.tableName}'`;
        const result = await this.query(sql);
        return result.length ? true : false;
      }
      /**
       * Checks if column with the given name exist in the given table.
       */
      async hasColumn(tableOrName, column) {
        const parsedTableName = this.driver.parseTableName(tableOrName);
        const columnName = InstanceChecker_1.InstanceChecker.isTableColumn(column) ? column.name : column;
        const sql = `SELECT * FROM \`INFORMATION_SCHEMA\`.\`COLUMNS\` WHERE \`TABLE_SCHEMA\` = '${parsedTableName.database}' AND \`TABLE_NAME\` = '${parsedTableName.tableName}' AND \`COLUMN_NAME\` = '${columnName}'`;
        const result = await this.query(sql);
        return result.length ? true : false;
      }
      /**
       * Creates a new database.
       */
      async createDatabase(database, ifNotExist) {
        const up = ifNotExist ? `CREATE DATABASE IF NOT EXISTS \`${database}\`` : `CREATE DATABASE \`${database}\``;
        const down = `DROP DATABASE \`${database}\``;
        await this.executeQueries(new Query_1.Query(up), new Query_1.Query(down));
      }
      /**
       * Drops database.
       */
      async dropDatabase(database, ifExist) {
        const up = ifExist ? `DROP DATABASE IF EXISTS \`${database}\`` : `DROP DATABASE \`${database}\``;
        const down = `CREATE DATABASE \`${database}\``;
        await this.executeQueries(new Query_1.Query(up), new Query_1.Query(down));
      }
      /**
       * Creates a new table schema.
       */
      async createSchema(schemaPath, ifNotExist) {
        throw new error_1.TypeORMError(`Schema create queries are not supported by MySql driver.`);
      }
      /**
       * Drops table schema.
       */
      async dropSchema(schemaPath, ifExist) {
        throw new error_1.TypeORMError(`Schema drop queries are not supported by MySql driver.`);
      }
      /**
       * Creates a new table.
       */
      async createTable(table, ifNotExist = false, createForeignKeys = true) {
        if (ifNotExist) {
          const isTableExist = await this.hasTable(table);
          if (isTableExist)
            return Promise.resolve();
        }
        const upQueries = [];
        const downQueries = [];
        upQueries.push(this.createTableSql(table, createForeignKeys));
        downQueries.push(this.dropTableSql(table));
        table.indices.forEach((index) => downQueries.push(this.dropIndexSql(table, index)));
        if (createForeignKeys)
          table.foreignKeys.forEach((foreignKey) => downQueries.push(this.dropForeignKeySql(table, foreignKey)));
        return this.executeQueries(upQueries, downQueries);
      }
      /**
       * Drop the table.
       */
      async dropTable(target, ifExist, dropForeignKeys = true) {
        if (ifExist) {
          const isTableExist = await this.hasTable(target);
          if (!isTableExist)
            return Promise.resolve();
        }
        const createForeignKeys = dropForeignKeys;
        const tablePath = this.getTablePath(target);
        const table = await this.getCachedTable(tablePath);
        const upQueries = [];
        const downQueries = [];
        if (dropForeignKeys)
          table.foreignKeys.forEach((foreignKey) => upQueries.push(this.dropForeignKeySql(table, foreignKey)));
        table.indices.forEach((index) => upQueries.push(this.dropIndexSql(table, index)));
        upQueries.push(this.dropTableSql(table));
        downQueries.push(this.createTableSql(table, createForeignKeys));
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Creates a new view.
       */
      async createView(view, syncWithMetadata = false) {
        const upQueries = [];
        const downQueries = [];
        upQueries.push(this.createViewSql(view));
        if (syncWithMetadata)
          upQueries.push(await this.insertViewDefinitionSql(view));
        downQueries.push(this.dropViewSql(view));
        if (syncWithMetadata)
          downQueries.push(await this.deleteViewDefinitionSql(view));
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Drops the view.
       */
      async dropView(target) {
        const viewName = InstanceChecker_1.InstanceChecker.isView(target) ? target.name : target;
        const view = await this.getCachedView(viewName);
        const upQueries = [];
        const downQueries = [];
        upQueries.push(await this.deleteViewDefinitionSql(view));
        upQueries.push(this.dropViewSql(view));
        downQueries.push(await this.insertViewDefinitionSql(view));
        downQueries.push(this.createViewSql(view));
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Renames a table.
       */
      async renameTable(oldTableOrName, newTableName) {
        const upQueries = [];
        const downQueries = [];
        const oldTable = InstanceChecker_1.InstanceChecker.isTable(oldTableOrName) ? oldTableOrName : await this.getCachedTable(oldTableOrName);
        const newTable = oldTable.clone();
        const { database } = this.driver.parseTableName(oldTable);
        newTable.name = database ? `${database}.${newTableName}` : newTableName;
        upQueries.push(new Query_1.Query(`RENAME TABLE ${this.escapePath(oldTable)} TO ${this.escapePath(newTable)}`));
        downQueries.push(new Query_1.Query(`RENAME TABLE ${this.escapePath(newTable)} TO ${this.escapePath(oldTable)}`));
        newTable.indices.forEach((index) => {
          const columnNames = index.columnNames.map((column) => `\`${column}\``).join(", ");
          const newIndexName = this.connection.namingStrategy.indexName(newTable, index.columnNames, index.where);
          let indexType = "";
          if (index.isUnique)
            indexType += "UNIQUE ";
          if (index.isSpatial)
            indexType += "SPATIAL ";
          if (index.isFulltext)
            indexType += "FULLTEXT ";
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} DROP INDEX \`${index.name}\`, ADD ${indexType}INDEX \`${newIndexName}\` (${columnNames})`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} DROP INDEX \`${newIndexName}\`, ADD ${indexType}INDEX \`${index.name}\` (${columnNames})`));
          index.name = newIndexName;
        });
        newTable.foreignKeys.forEach((foreignKey) => {
          const columnNames = foreignKey.columnNames.map((column) => `\`${column}\``).join(", ");
          const referencedColumnNames = foreignKey.referencedColumnNames.map((column) => `\`${column}\``).join(",");
          const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(newTable, foreignKey.columnNames);
          let up = `ALTER TABLE ${this.escapePath(newTable)} DROP FOREIGN KEY \`${foreignKey.name}\`, ADD CONSTRAINT \`${newForeignKeyName}\` FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;
          if (foreignKey.onDelete)
            up += ` ON DELETE ${foreignKey.onDelete}`;
          if (foreignKey.onUpdate)
            up += ` ON UPDATE ${foreignKey.onUpdate}`;
          let down = `ALTER TABLE ${this.escapePath(newTable)} DROP FOREIGN KEY \`${newForeignKeyName}\`, ADD CONSTRAINT \`${foreignKey.name}\` FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;
          if (foreignKey.onDelete)
            down += ` ON DELETE ${foreignKey.onDelete}`;
          if (foreignKey.onUpdate)
            down += ` ON UPDATE ${foreignKey.onUpdate}`;
          upQueries.push(new Query_1.Query(up));
          downQueries.push(new Query_1.Query(down));
          foreignKey.name = newForeignKeyName;
        });
        await this.executeQueries(upQueries, downQueries);
        oldTable.name = newTable.name;
        this.replaceCachedTable(oldTable, newTable);
      }
      /**
       * Creates a new column from the column in the table.
       */
      async addColumn(tableOrName, column) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        const skipColumnLevelPrimary = clonedTable.primaryColumns.length > 0;
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(column, skipColumnLevelPrimary, false)}`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN \`${column.name}\``));
        if (column.isPrimary && skipColumnLevelPrimary) {
          const generatedColumn = clonedTable.columns.find((column2) => column2.isGenerated && column2.generationStrategy === "increment");
          if (generatedColumn) {
            const nonGeneratedColumn = generatedColumn.clone();
            nonGeneratedColumn.isGenerated = false;
            nonGeneratedColumn.generationStrategy = void 0;
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${column.name}\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${nonGeneratedColumn.name}\` ${this.buildCreateColumnSql(column, true)}`));
          }
          const primaryColumns = clonedTable.primaryColumns;
          let columnNames = primaryColumns.map((column2) => `\`${column2.name}\``).join(", ");
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames})`));
          primaryColumns.push(column);
          columnNames = primaryColumns.map((column2) => `\`${column2.name}\``).join(", ");
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames})`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));
          if (generatedColumn) {
            const nonGeneratedColumn = generatedColumn.clone();
            nonGeneratedColumn.isGenerated = false;
            nonGeneratedColumn.generationStrategy = void 0;
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${nonGeneratedColumn.name}\` ${this.buildCreateColumnSql(column, true)}`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${column.name}\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));
          }
        }
        const columnIndex = clonedTable.indices.find((index) => index.columnNames.length === 1 && index.columnNames[0] === column.name);
        if (columnIndex) {
          upQueries.push(this.createIndexSql(table, columnIndex));
          downQueries.push(this.dropIndexSql(table, columnIndex));
        } else if (column.isUnique) {
          const uniqueIndex = new TableIndex_1.TableIndex({
            name: this.connection.namingStrategy.indexName(table, [
              column.name
            ]),
            columnNames: [column.name],
            isUnique: true
          });
          clonedTable.indices.push(uniqueIndex);
          clonedTable.uniques.push(new TableUnique_1.TableUnique({
            name: uniqueIndex.name,
            columnNames: uniqueIndex.columnNames
          }));
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD UNIQUE INDEX \`${uniqueIndex.name}\` (\`${column.name}\`)`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \`${uniqueIndex.name}\``));
        }
        await this.executeQueries(upQueries, downQueries);
        clonedTable.addColumn(column);
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Creates a new columns from the column in the table.
       */
      async addColumns(tableOrName, columns) {
        for (const column of columns) {
          await this.addColumn(tableOrName, column);
        }
      }
      /**
       * Renames column in the given table.
       */
      async renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const oldColumn = InstanceChecker_1.InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find((c) => c.name === oldTableColumnOrName);
        if (!oldColumn)
          throw new error_1.TypeORMError(`Column "${oldTableColumnOrName}" was not found in the "${table.name}" table.`);
        let newColumn = void 0;
        if (InstanceChecker_1.InstanceChecker.isTableColumn(newTableColumnOrName)) {
          newColumn = newTableColumnOrName;
        } else {
          newColumn = oldColumn.clone();
          newColumn.name = newTableColumnOrName;
        }
        await this.changeColumn(table, oldColumn, newColumn);
      }
      /**
       * Changes a column in the table.
       */
      async changeColumn(tableOrName, oldColumnOrName, newColumn) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        let clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        const oldColumn = InstanceChecker_1.InstanceChecker.isTableColumn(oldColumnOrName) ? oldColumnOrName : table.columns.find((column) => column.name === oldColumnOrName);
        if (!oldColumn)
          throw new error_1.TypeORMError(`Column "${oldColumnOrName}" was not found in the "${table.name}" table.`);
        if (newColumn.isGenerated !== oldColumn.isGenerated && newColumn.generationStrategy !== "uuid" || oldColumn.type !== newColumn.type || oldColumn.length !== newColumn.length || oldColumn.generatedType !== newColumn.generatedType) {
          await this.dropColumn(table, oldColumn);
          await this.addColumn(table, newColumn);
          clonedTable = table.clone();
        } else {
          if (newColumn.name !== oldColumn.name) {
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${oldColumn.name}\` \`${newColumn.name}\` ${this.buildCreateColumnSql(oldColumn, true, true)}`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${newColumn.name}\` \`${oldColumn.name}\` ${this.buildCreateColumnSql(oldColumn, true, true)}`));
            clonedTable.findColumnIndices(oldColumn).forEach((index) => {
              index.columnNames.splice(index.columnNames.indexOf(oldColumn.name), 1);
              index.columnNames.push(newColumn.name);
              const columnNames = index.columnNames.map((column) => `\`${column}\``).join(", ");
              const newIndexName = this.connection.namingStrategy.indexName(clonedTable, index.columnNames, index.where);
              let indexType = "";
              if (index.isUnique)
                indexType += "UNIQUE ";
              if (index.isSpatial)
                indexType += "SPATIAL ";
              if (index.isFulltext)
                indexType += "FULLTEXT ";
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \`${index.name}\`, ADD ${indexType}INDEX \`${newIndexName}\` (${columnNames})`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \`${newIndexName}\`, ADD ${indexType}INDEX \`${index.name}\` (${columnNames})`));
              index.name = newIndexName;
            });
            clonedTable.findColumnForeignKeys(oldColumn).forEach((foreignKey) => {
              foreignKey.columnNames.splice(foreignKey.columnNames.indexOf(oldColumn.name), 1);
              foreignKey.columnNames.push(newColumn.name);
              const columnNames = foreignKey.columnNames.map((column) => `\`${column}\``).join(", ");
              const referencedColumnNames = foreignKey.referencedColumnNames.map((column) => `\`${column}\``).join(",");
              const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(clonedTable, foreignKey.columnNames);
              let up = `ALTER TABLE ${this.escapePath(table)} DROP FOREIGN KEY \`${foreignKey.name}\`, ADD CONSTRAINT \`${newForeignKeyName}\` FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;
              if (foreignKey.onDelete)
                up += ` ON DELETE ${foreignKey.onDelete}`;
              if (foreignKey.onUpdate)
                up += ` ON UPDATE ${foreignKey.onUpdate}`;
              let down = `ALTER TABLE ${this.escapePath(table)} DROP FOREIGN KEY \`${newForeignKeyName}\`, ADD CONSTRAINT \`${foreignKey.name}\` FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;
              if (foreignKey.onDelete)
                down += ` ON DELETE ${foreignKey.onDelete}`;
              if (foreignKey.onUpdate)
                down += ` ON UPDATE ${foreignKey.onUpdate}`;
              upQueries.push(new Query_1.Query(up));
              downQueries.push(new Query_1.Query(down));
              foreignKey.name = newForeignKeyName;
            });
            const oldTableColumn = clonedTable.columns.find((column) => column.name === oldColumn.name);
            clonedTable.columns[clonedTable.columns.indexOf(oldTableColumn)].name = newColumn.name;
            oldColumn.name = newColumn.name;
          }
          if (this.isColumnChanged(oldColumn, newColumn, true)) {
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${oldColumn.name}\` ${this.buildCreateColumnSql(newColumn, true)}`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${newColumn.name}\` ${this.buildCreateColumnSql(oldColumn, true)}`));
          }
          if (newColumn.isPrimary !== oldColumn.isPrimary) {
            const generatedColumn = clonedTable.columns.find((column) => column.isGenerated && column.generationStrategy === "increment");
            if (generatedColumn) {
              const nonGeneratedColumn = generatedColumn.clone();
              nonGeneratedColumn.isGenerated = false;
              nonGeneratedColumn.generationStrategy = void 0;
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${generatedColumn.name}\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${nonGeneratedColumn.name}\` ${this.buildCreateColumnSql(generatedColumn, true)}`));
            }
            const primaryColumns = clonedTable.primaryColumns;
            if (primaryColumns.length > 0) {
              const columnNames = primaryColumns.map((column) => `\`${column.name}\``).join(", ");
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames})`));
            }
            if (newColumn.isPrimary === true) {
              primaryColumns.push(newColumn);
              const column = clonedTable.columns.find((column2) => column2.name === newColumn.name);
              column.isPrimary = true;
              const columnNames = primaryColumns.map((column2) => `\`${column2.name}\``).join(", ");
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames})`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));
            } else {
              const primaryColumn = primaryColumns.find((c) => c.name === newColumn.name);
              primaryColumns.splice(primaryColumns.indexOf(primaryColumn), 1);
              const column = clonedTable.columns.find((column2) => column2.name === newColumn.name);
              column.isPrimary = false;
              if (primaryColumns.length > 0) {
                const columnNames = primaryColumns.map((column2) => `\`${column2.name}\``).join(", ");
                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames})`));
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));
              }
            }
            if (generatedColumn) {
              const nonGeneratedColumn = generatedColumn.clone();
              nonGeneratedColumn.isGenerated = false;
              nonGeneratedColumn.generationStrategy = void 0;
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${nonGeneratedColumn.name}\` ${this.buildCreateColumnSql(generatedColumn, true)}`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${generatedColumn.name}\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));
            }
          }
          if (newColumn.isUnique !== oldColumn.isUnique) {
            if (newColumn.isUnique === true) {
              const uniqueIndex = new TableIndex_1.TableIndex({
                name: this.connection.namingStrategy.indexName(table, [
                  newColumn.name
                ]),
                columnNames: [newColumn.name],
                isUnique: true
              });
              clonedTable.indices.push(uniqueIndex);
              clonedTable.uniques.push(new TableUnique_1.TableUnique({
                name: uniqueIndex.name,
                columnNames: uniqueIndex.columnNames
              }));
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD UNIQUE INDEX \`${uniqueIndex.name}\` (\`${newColumn.name}\`)`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \`${uniqueIndex.name}\``));
            } else {
              const uniqueIndex = clonedTable.indices.find((index) => {
                return index.columnNames.length === 1 && index.isUnique === true && !!index.columnNames.find((columnName) => columnName === newColumn.name);
              });
              clonedTable.indices.splice(clonedTable.indices.indexOf(uniqueIndex), 1);
              const tableUnique = clonedTable.uniques.find((unique) => unique.name === uniqueIndex.name);
              clonedTable.uniques.splice(clonedTable.uniques.indexOf(tableUnique), 1);
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \`${uniqueIndex.name}\``));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD UNIQUE INDEX \`${uniqueIndex.name}\` (\`${newColumn.name}\`)`));
            }
          }
        }
        await this.executeQueries(upQueries, downQueries);
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Changes a column in the table.
       */
      async changeColumns(tableOrName, changedColumns) {
        for (const { oldColumn, newColumn } of changedColumns) {
          await this.changeColumn(tableOrName, oldColumn, newColumn);
        }
      }
      /**
       * Drops column in the table.
       */
      async dropColumn(tableOrName, columnOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const column = InstanceChecker_1.InstanceChecker.isTableColumn(columnOrName) ? columnOrName : table.findColumnByName(columnOrName);
        if (!column)
          throw new error_1.TypeORMError(`Column "${columnOrName}" was not found in table "${table.name}"`);
        const clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        if (column.isPrimary) {
          const generatedColumn = clonedTable.columns.find((column2) => column2.isGenerated && column2.generationStrategy === "increment");
          if (generatedColumn) {
            const nonGeneratedColumn = generatedColumn.clone();
            nonGeneratedColumn.isGenerated = false;
            nonGeneratedColumn.generationStrategy = void 0;
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${generatedColumn.name}\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${nonGeneratedColumn.name}\` ${this.buildCreateColumnSql(generatedColumn, true)}`));
          }
          const columnNames = clonedTable.primaryColumns.map((primaryColumn) => `\`${primaryColumn.name}\``).join(", ");
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP PRIMARY KEY`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD PRIMARY KEY (${columnNames})`));
          const tableColumn = clonedTable.findColumnByName(column.name);
          tableColumn.isPrimary = false;
          if (clonedTable.primaryColumns.length > 0) {
            const columnNames2 = clonedTable.primaryColumns.map((primaryColumn) => `\`${primaryColumn.name}\``).join(", ");
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD PRIMARY KEY (${columnNames2})`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP PRIMARY KEY`));
          }
          if (generatedColumn && generatedColumn.name !== column.name) {
            const nonGeneratedColumn = generatedColumn.clone();
            nonGeneratedColumn.isGenerated = false;
            nonGeneratedColumn.generationStrategy = void 0;
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${nonGeneratedColumn.name}\` ${this.buildCreateColumnSql(generatedColumn, true)}`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${generatedColumn.name}\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));
          }
        }
        const columnIndex = clonedTable.indices.find((index) => index.columnNames.length === 1 && index.columnNames[0] === column.name);
        if (columnIndex) {
          clonedTable.indices.splice(clonedTable.indices.indexOf(columnIndex), 1);
          upQueries.push(this.dropIndexSql(table, columnIndex));
          downQueries.push(this.createIndexSql(table, columnIndex));
        } else if (column.isUnique) {
          const uniqueName = this.connection.namingStrategy.uniqueConstraintName(table, [
            column.name
          ]);
          const foundUnique = clonedTable.uniques.find((unique) => unique.name === uniqueName);
          if (foundUnique)
            clonedTable.uniques.splice(clonedTable.uniques.indexOf(foundUnique), 1);
          const indexName = this.connection.namingStrategy.indexName(table, [
            column.name
          ]);
          const foundIndex = clonedTable.indices.find((index) => index.name === indexName);
          if (foundIndex)
            clonedTable.indices.splice(clonedTable.indices.indexOf(foundIndex), 1);
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \`${indexName}\``));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD UNIQUE INDEX \`${indexName}\` (\`${column.name}\`)`));
        }
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN \`${column.name}\``));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(column, true)}`));
        await this.executeQueries(upQueries, downQueries);
        clonedTable.removeColumn(column);
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Drops the columns in the table.
       */
      async dropColumns(tableOrName, columns) {
        for (const column of [...columns]) {
          await this.dropColumn(tableOrName, column);
        }
      }
      /**
       * Creates a new primary key.
       */
      async createPrimaryKey(tableOrName, columnNames) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const clonedTable = table.clone();
        const up = this.createPrimaryKeySql(table, columnNames);
        const down = this.dropPrimaryKeySql(table);
        await this.executeQueries(up, down);
        clonedTable.columns.forEach((column) => {
          if (columnNames.find((columnName) => columnName === column.name))
            column.isPrimary = true;
        });
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Updates composite primary keys.
       */
      async updatePrimaryKeys(tableOrName, columns) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const clonedTable = table.clone();
        const columnNames = columns.map((column) => column.name);
        const upQueries = [];
        const downQueries = [];
        const generatedColumn = clonedTable.columns.find((column) => column.isGenerated && column.generationStrategy === "increment");
        if (generatedColumn) {
          const nonGeneratedColumn = generatedColumn.clone();
          nonGeneratedColumn.isGenerated = false;
          nonGeneratedColumn.generationStrategy = void 0;
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${generatedColumn.name}\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${nonGeneratedColumn.name}\` ${this.buildCreateColumnSql(generatedColumn, true)}`));
        }
        const primaryColumns = clonedTable.primaryColumns;
        if (primaryColumns.length > 0) {
          const columnNames2 = primaryColumns.map((column) => `\`${column.name}\``).join(", ");
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames2})`));
        }
        clonedTable.columns.filter((column) => columnNames.indexOf(column.name) !== -1).forEach((column) => column.isPrimary = true);
        const columnNamesString = columnNames.map((columnName) => `\`${columnName}\``).join(", ");
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNamesString})`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));
        const newOrExistGeneratedColumn = generatedColumn ? generatedColumn : columns.find((column) => column.isGenerated && column.generationStrategy === "increment");
        if (newOrExistGeneratedColumn) {
          const nonGeneratedColumn = newOrExistGeneratedColumn.clone();
          nonGeneratedColumn.isGenerated = false;
          nonGeneratedColumn.generationStrategy = void 0;
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${nonGeneratedColumn.name}\` ${this.buildCreateColumnSql(newOrExistGeneratedColumn, true)}`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${newOrExistGeneratedColumn.name}\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));
          const changedGeneratedColumn = clonedTable.columns.find((column) => column.name === newOrExistGeneratedColumn.name);
          changedGeneratedColumn.isGenerated = true;
          changedGeneratedColumn.generationStrategy = "increment";
        }
        await this.executeQueries(upQueries, downQueries);
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Drops a primary key.
       */
      async dropPrimaryKey(tableOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const up = this.dropPrimaryKeySql(table);
        const down = this.createPrimaryKeySql(table, table.primaryColumns.map((column) => column.name));
        await this.executeQueries(up, down);
        table.primaryColumns.forEach((column) => {
          column.isPrimary = false;
        });
      }
      /**
       * Creates a new unique constraint.
       */
      async createUniqueConstraint(tableOrName, uniqueConstraint) {
        throw new error_1.TypeORMError(`MySql does not support unique constraints. Use unique index instead.`);
      }
      /**
       * Creates a new unique constraints.
       */
      async createUniqueConstraints(tableOrName, uniqueConstraints) {
        throw new error_1.TypeORMError(`MySql does not support unique constraints. Use unique index instead.`);
      }
      /**
       * Drops an unique constraint.
       */
      async dropUniqueConstraint(tableOrName, uniqueOrName) {
        throw new error_1.TypeORMError(`MySql does not support unique constraints. Use unique index instead.`);
      }
      /**
       * Drops an unique constraints.
       */
      async dropUniqueConstraints(tableOrName, uniqueConstraints) {
        throw new error_1.TypeORMError(`MySql does not support unique constraints. Use unique index instead.`);
      }
      /**
       * Creates a new check constraint.
       */
      async createCheckConstraint(tableOrName, checkConstraint) {
        throw new error_1.TypeORMError(`MySql does not support check constraints.`);
      }
      /**
       * Creates a new check constraints.
       */
      async createCheckConstraints(tableOrName, checkConstraints) {
        throw new error_1.TypeORMError(`MySql does not support check constraints.`);
      }
      /**
       * Drops check constraint.
       */
      async dropCheckConstraint(tableOrName, checkOrName) {
        throw new error_1.TypeORMError(`MySql does not support check constraints.`);
      }
      /**
       * Drops check constraints.
       */
      async dropCheckConstraints(tableOrName, checkConstraints) {
        throw new error_1.TypeORMError(`MySql does not support check constraints.`);
      }
      /**
       * Creates a new exclusion constraint.
       */
      async createExclusionConstraint(tableOrName, exclusionConstraint) {
        throw new error_1.TypeORMError(`MySql does not support exclusion constraints.`);
      }
      /**
       * Creates a new exclusion constraints.
       */
      async createExclusionConstraints(tableOrName, exclusionConstraints) {
        throw new error_1.TypeORMError(`MySql does not support exclusion constraints.`);
      }
      /**
       * Drops exclusion constraint.
       */
      async dropExclusionConstraint(tableOrName, exclusionOrName) {
        throw new error_1.TypeORMError(`MySql does not support exclusion constraints.`);
      }
      /**
       * Drops exclusion constraints.
       */
      async dropExclusionConstraints(tableOrName, exclusionConstraints) {
        throw new error_1.TypeORMError(`MySql does not support exclusion constraints.`);
      }
      /**
       * Creates a new foreign key.
       */
      async createForeignKey(tableOrName, foreignKey) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        if (!foreignKey.name)
          foreignKey.name = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames);
        const up = this.createForeignKeySql(table, foreignKey);
        const down = this.dropForeignKeySql(table, foreignKey);
        await this.executeQueries(up, down);
        table.addForeignKey(foreignKey);
      }
      /**
       * Creates a new foreign keys.
       */
      async createForeignKeys(tableOrName, foreignKeys) {
        const promises = foreignKeys.map((foreignKey) => this.createForeignKey(tableOrName, foreignKey));
        await Promise.all(promises);
      }
      /**
       * Drops a foreign key.
       */
      async dropForeignKey(tableOrName, foreignKeyOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const foreignKey = InstanceChecker_1.InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName : table.foreignKeys.find((fk) => fk.name === foreignKeyOrName);
        if (!foreignKey)
          throw new error_1.TypeORMError(`Supplied foreign key was not found in table ${table.name}`);
        const up = this.dropForeignKeySql(table, foreignKey);
        const down = this.createForeignKeySql(table, foreignKey);
        await this.executeQueries(up, down);
        table.removeForeignKey(foreignKey);
      }
      /**
       * Drops a foreign keys from the table.
       */
      async dropForeignKeys(tableOrName, foreignKeys) {
        const promises = foreignKeys.map((foreignKey) => this.dropForeignKey(tableOrName, foreignKey));
        await Promise.all(promises);
      }
      /**
       * Creates a new index.
       */
      async createIndex(tableOrName, index) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        if (!index.name)
          index.name = this.generateIndexName(table, index);
        const up = this.createIndexSql(table, index);
        const down = this.dropIndexSql(table, index);
        await this.executeQueries(up, down);
        table.addIndex(index, true);
      }
      /**
       * Creates a new indices
       */
      async createIndices(tableOrName, indices) {
        const promises = indices.map((index) => this.createIndex(tableOrName, index));
        await Promise.all(promises);
      }
      /**
       * Drops an index.
       */
      async dropIndex(tableOrName, indexOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const index = InstanceChecker_1.InstanceChecker.isTableIndex(indexOrName) ? indexOrName : table.indices.find((i) => i.name === indexOrName);
        if (!index)
          throw new error_1.TypeORMError(`Supplied index ${indexOrName} was not found in table ${table.name}`);
        if (!index.name)
          index.name = this.generateIndexName(table, index);
        const up = this.dropIndexSql(table, index);
        const down = this.createIndexSql(table, index);
        await this.executeQueries(up, down);
        table.removeIndex(index, true);
      }
      /**
       * Drops an indices from the table.
       */
      async dropIndices(tableOrName, indices) {
        const promises = indices.map((index) => this.dropIndex(tableOrName, index));
        await Promise.all(promises);
      }
      /**
       * Clears all table contents.
       * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.
       */
      async clearTable(tableOrName) {
        await this.query(`TRUNCATE TABLE ${this.escapePath(tableOrName)}`);
      }
      /**
       * Removes all tables from the currently connected database.
       * Be careful using this method and avoid using it in production or migrations
       * (because it can clear all your database).
       */
      async clearDatabase(database) {
        const dbName = database ? database : this.driver.database;
        if (dbName) {
          const isDatabaseExist = await this.hasDatabase(dbName);
          if (!isDatabaseExist)
            return Promise.resolve();
        } else {
          throw new error_1.TypeORMError(`Can not clear database. No database is specified`);
        }
        const isAnotherTransactionActive = this.isTransactionActive;
        if (!isAnotherTransactionActive)
          await this.startTransaction();
        try {
          const selectViewDropsQuery = `SELECT concat('DROP VIEW IF EXISTS \`', table_schema, '\`.\`', table_name, '\`') AS \`query\` FROM \`INFORMATION_SCHEMA\`.\`VIEWS\` WHERE \`TABLE_SCHEMA\` = '${dbName}'`;
          const dropViewQueries = await this.query(selectViewDropsQuery);
          await Promise.all(dropViewQueries.map((q) => this.query(q["query"])));
          const disableForeignKeysCheckQuery = `SET FOREIGN_KEY_CHECKS = 0;`;
          const dropTablesQuery = `SELECT concat('DROP TABLE IF EXISTS \`', table_schema, '\`.\`', table_name, '\`') AS \`query\` FROM \`INFORMATION_SCHEMA\`.\`TABLES\` WHERE \`TABLE_SCHEMA\` = '${dbName}'`;
          const enableForeignKeysCheckQuery = `SET FOREIGN_KEY_CHECKS = 1;`;
          await this.query(disableForeignKeysCheckQuery);
          const dropQueries = await this.query(dropTablesQuery);
          await Promise.all(dropQueries.map((query) => this.query(query["query"])));
          await this.query(enableForeignKeysCheckQuery);
          if (!isAnotherTransactionActive) {
            await this.commitTransaction();
          }
        } catch (error) {
          try {
            if (!isAnotherTransactionActive) {
              await this.rollbackTransaction();
            }
          } catch (rollbackError) {
          }
          throw error;
        }
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      async loadViews(viewNames) {
        const hasTable = await this.hasTable(this.getTypeormMetadataTableName());
        if (!hasTable) {
          return [];
        }
        if (!viewNames) {
          viewNames = [];
        }
        const currentDatabase = await this.getCurrentDatabase();
        const viewsCondition = viewNames.map((tableName) => {
          let { database, tableName: name } = this.driver.parseTableName(tableName);
          if (!database) {
            database = currentDatabase;
          }
          return `(\`t\`.\`schema\` = '${database}' AND \`t\`.\`name\` = '${name}')`;
        }).join(" OR ");
        const query = `SELECT \`t\`.*, \`v\`.\`check_option\` FROM ${this.escapePath(this.getTypeormMetadataTableName())} \`t\` INNER JOIN \`information_schema\`.\`views\` \`v\` ON \`v\`.\`table_schema\` = \`t\`.\`schema\` AND \`v\`.\`table_name\` = \`t\`.\`name\` WHERE \`t\`.\`type\` = '${MetadataTableType_1.MetadataTableType.VIEW}' ${viewsCondition ? `AND (${viewsCondition})` : ""}`;
        const dbViews = await this.query(query);
        return dbViews.map((dbView) => {
          const view = new View_1.View();
          const db = dbView["schema"] === currentDatabase ? void 0 : dbView["schema"];
          view.database = dbView["schema"];
          view.name = this.driver.buildTableName(dbView["name"], void 0, db);
          view.expression = dbView["value"];
          return view;
        });
      }
      /**
       * Loads all tables (with given names) from the database and creates a Table from them.
       */
      async loadTables(tableNames) {
        if (tableNames && tableNames.length === 0) {
          return [];
        }
        const dbTables = [];
        const currentDatabase = await this.getCurrentDatabase();
        if (!tableNames) {
          const tablesSql = `SELECT TABLE_NAME, TABLE_SCHEMA FROM \`INFORMATION_SCHEMA\`.\`TABLES\``;
          dbTables.push(...await this.query(tablesSql));
        } else {
          const tablesCondition = tableNames.map((tableName) => {
            let [database, name] = tableName.split(".");
            if (!name) {
              name = database;
              database = this.driver.database || currentDatabase;
            }
            return `(\`TABLE_SCHEMA\` = '${database}' AND \`TABLE_NAME\` = '${name}')`;
          }).join(" OR ");
          const tablesSql = `SELECT TABLE_NAME, TABLE_SCHEMA FROM \`INFORMATION_SCHEMA\`.\`TABLES\` WHERE ` + tablesCondition;
          dbTables.push(...await this.query(tablesSql));
        }
        if (dbTables.length === 0) {
          return [];
        }
        const columnsCondition = dbTables.map(({ TABLE_NAME, TABLE_SCHEMA }) => {
          return `(\`TABLE_SCHEMA\` = '${TABLE_SCHEMA}' AND \`TABLE_NAME\` = '${TABLE_NAME}')`;
        }).join(" OR ");
        const columnsSql = `SELECT * FROM \`INFORMATION_SCHEMA\`.\`COLUMNS\` WHERE ` + columnsCondition;
        const primaryKeySql = `SELECT * FROM \`INFORMATION_SCHEMA\`.\`KEY_COLUMN_USAGE\` WHERE \`CONSTRAINT_NAME\` = 'PRIMARY' AND (${columnsCondition})`;
        const collationsSql = `SELECT \`SCHEMA_NAME\`, \`DEFAULT_CHARACTER_SET_NAME\` as \`CHARSET\`, \`DEFAULT_COLLATION_NAME\` AS \`COLLATION\` FROM \`INFORMATION_SCHEMA\`.\`SCHEMATA\``;
        const indicesCondition = dbTables.map(({ TABLE_NAME, TABLE_SCHEMA }) => {
          return `(\`s\`.\`TABLE_SCHEMA\` = '${TABLE_SCHEMA}' AND \`s\`.\`TABLE_NAME\` = '${TABLE_NAME}')`;
        }).join(" OR ");
        const indicesSql = `SELECT \`s\`.* FROM \`INFORMATION_SCHEMA\`.\`STATISTICS\` \`s\` LEFT JOIN \`INFORMATION_SCHEMA\`.\`REFERENTIAL_CONSTRAINTS\` \`rc\` ON \`s\`.\`INDEX_NAME\` = \`rc\`.\`CONSTRAINT_NAME\` WHERE (${indicesCondition}) AND \`s\`.\`INDEX_NAME\` != 'PRIMARY' AND \`rc\`.\`CONSTRAINT_NAME\` IS NULL`;
        const foreignKeysCondition = dbTables.map(({ TABLE_NAME, TABLE_SCHEMA }) => {
          return `(\`kcu\`.\`TABLE_SCHEMA\` = '${TABLE_SCHEMA}' AND \`kcu\`.\`TABLE_NAME\` = '${TABLE_NAME}')`;
        }).join(" OR ");
        const foreignKeysSql = `SELECT \`kcu\`.\`TABLE_SCHEMA\`, \`kcu\`.\`TABLE_NAME\`, \`kcu\`.\`CONSTRAINT_NAME\`, \`kcu\`.\`COLUMN_NAME\`, \`kcu\`.\`REFERENCED_TABLE_SCHEMA\`, \`kcu\`.\`REFERENCED_TABLE_NAME\`, \`kcu\`.\`REFERENCED_COLUMN_NAME\`, \`rc\`.\`DELETE_RULE\` \`ON_DELETE\`, \`rc\`.\`UPDATE_RULE\` \`ON_UPDATE\` FROM \`INFORMATION_SCHEMA\`.\`KEY_COLUMN_USAGE\` \`kcu\` INNER JOIN \`INFORMATION_SCHEMA\`.\`REFERENTIAL_CONSTRAINTS\` \`rc\` ON \`rc\`.\`constraint_name\` = \`kcu\`.\`constraint_name\` WHERE ` + foreignKeysCondition;
        const [dbColumns, dbPrimaryKeys, dbCollations, dbIndices, dbForeignKeys] = await Promise.all([
          this.query(columnsSql),
          this.query(primaryKeySql),
          this.query(collationsSql),
          this.query(indicesSql),
          this.query(foreignKeysSql)
        ]);
        return dbTables.map((dbTable) => {
          const table = new Table_1.Table();
          const dbCollation = dbCollations.find((coll) => coll["SCHEMA_NAME"] === dbTable["TABLE_SCHEMA"]);
          const defaultCollation = dbCollation["COLLATION"];
          const defaultCharset = dbCollation["CHARSET"];
          const db = dbTable["TABLE_SCHEMA"] === currentDatabase ? void 0 : dbTable["TABLE_SCHEMA"];
          table.database = dbTable["TABLE_SCHEMA"];
          table.name = this.driver.buildTableName(dbTable["TABLE_NAME"], void 0, db);
          table.columns = dbColumns.filter((dbColumn) => dbColumn["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbColumn["TABLE_SCHEMA"] === dbTable["TABLE_SCHEMA"]).map((dbColumn) => {
            const columnUniqueIndices = dbIndices.filter((dbIndex) => {
              return dbIndex["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbIndex["TABLE_SCHEMA"] === dbTable["TABLE_SCHEMA"] && dbIndex["COLUMN_NAME"] === dbColumn["COLUMN_NAME"] && parseInt(dbIndex["NON_UNIQUE"], 10) === 0;
            });
            const tableMetadata = this.connection.entityMetadatas.find((metadata) => this.getTablePath(table) === this.getTablePath(metadata));
            const hasIgnoredIndex = columnUniqueIndices.length > 0 && tableMetadata && tableMetadata.indices.some((index) => {
              return columnUniqueIndices.some((uniqueIndex) => {
                return index.name === uniqueIndex["INDEX_NAME"] && index.synchronize === false;
              });
            });
            const isConstraintComposite = columnUniqueIndices.every((uniqueIndex) => {
              return dbIndices.some((dbIndex) => dbIndex["INDEX_NAME"] === uniqueIndex["INDEX_NAME"] && dbIndex["COLUMN_NAME"] !== dbColumn["COLUMN_NAME"]);
            });
            const tableColumn = new TableColumn_1.TableColumn();
            tableColumn.name = dbColumn["COLUMN_NAME"];
            tableColumn.type = dbColumn["DATA_TYPE"].toLowerCase();
            tableColumn.unsigned = tableColumn.zerofill ? true : dbColumn["COLUMN_TYPE"].indexOf("unsigned") !== -1;
            if (this.driver.withWidthColumnTypes.indexOf(tableColumn.type) !== -1) {
              const width = dbColumn["COLUMN_TYPE"].substring(dbColumn["COLUMN_TYPE"].indexOf("(") + 1, dbColumn["COLUMN_TYPE"].indexOf(")"));
              tableColumn.width = width && !this.isDefaultColumnWidth(table, tableColumn, parseInt(width)) ? parseInt(width) : void 0;
            }
            if (dbColumn["COLUMN_DEFAULT"] === null || dbColumn["COLUMN_DEFAULT"] === void 0) {
              tableColumn.default = void 0;
            } else {
              tableColumn.default = dbColumn["COLUMN_DEFAULT"] === "CURRENT_TIMESTAMP" ? dbColumn["COLUMN_DEFAULT"] : `'${dbColumn["COLUMN_DEFAULT"]}'`;
            }
            if (dbColumn["EXTRA"].indexOf("on update") !== -1) {
              tableColumn.onUpdate = dbColumn["EXTRA"].substring(dbColumn["EXTRA"].indexOf("on update") + 10);
            }
            if (dbColumn["GENERATION_EXPRESSION"]) {
              tableColumn.asExpression = dbColumn["GENERATION_EXPRESSION"];
              tableColumn.generatedType = dbColumn["EXTRA"].indexOf("VIRTUAL") !== -1 ? "VIRTUAL" : "STORED";
            }
            tableColumn.isUnique = columnUniqueIndices.length > 0 && !hasIgnoredIndex && !isConstraintComposite;
            tableColumn.isNullable = dbColumn["IS_NULLABLE"] === "YES";
            tableColumn.isPrimary = dbPrimaryKeys.some((dbPrimaryKey) => {
              return dbPrimaryKey["TABLE_NAME"] === dbColumn["TABLE_NAME"] && dbPrimaryKey["TABLE_SCHEMA"] === dbColumn["TABLE_SCHEMA"] && dbPrimaryKey["COLUMN_NAME"] === dbColumn["COLUMN_NAME"];
            });
            tableColumn.zerofill = dbColumn["COLUMN_TYPE"].indexOf("zerofill") !== -1;
            tableColumn.isGenerated = dbColumn["EXTRA"].indexOf("auto_increment") !== -1;
            if (tableColumn.isGenerated)
              tableColumn.generationStrategy = "increment";
            tableColumn.comment = typeof dbColumn["COLUMN_COMMENT"] === "string" && dbColumn["COLUMN_COMMENT"].length === 0 ? void 0 : dbColumn["COLUMN_COMMENT"];
            if (dbColumn["CHARACTER_SET_NAME"])
              tableColumn.charset = dbColumn["CHARACTER_SET_NAME"] === defaultCharset ? void 0 : dbColumn["CHARACTER_SET_NAME"];
            if (dbColumn["COLLATION_NAME"])
              tableColumn.collation = dbColumn["COLLATION_NAME"] === defaultCollation ? void 0 : dbColumn["COLLATION_NAME"];
            if (this.driver.withLengthColumnTypes.indexOf(tableColumn.type) !== -1 && dbColumn["CHARACTER_MAXIMUM_LENGTH"]) {
              const length = dbColumn["CHARACTER_MAXIMUM_LENGTH"].toString();
              tableColumn.length = !this.isDefaultColumnLength(table, tableColumn, length) ? length : "";
            }
            if (tableColumn.type === "decimal" || tableColumn.type === "double" || tableColumn.type === "float") {
              if (dbColumn["NUMERIC_PRECISION"] !== null && !this.isDefaultColumnPrecision(table, tableColumn, dbColumn["NUMERIC_PRECISION"]))
                tableColumn.precision = parseInt(dbColumn["NUMERIC_PRECISION"]);
              if (dbColumn["NUMERIC_SCALE"] !== null && !this.isDefaultColumnScale(table, tableColumn, dbColumn["NUMERIC_SCALE"]))
                tableColumn.scale = parseInt(dbColumn["NUMERIC_SCALE"]);
            }
            if (tableColumn.type === "enum" || tableColumn.type === "simple-enum" || tableColumn.type === "set") {
              const colType = dbColumn["COLUMN_TYPE"];
              const items = colType.substring(colType.indexOf("(") + 1, colType.lastIndexOf(")")).split(",");
              tableColumn.enum = items.map((item) => {
                return item.substring(1, item.length - 1);
              });
              tableColumn.length = "";
            }
            if ((tableColumn.type === "datetime" || tableColumn.type === "time" || tableColumn.type === "timestamp") && dbColumn["DATETIME_PRECISION"] !== null && dbColumn["DATETIME_PRECISION"] !== void 0 && !this.isDefaultColumnPrecision(table, tableColumn, parseInt(dbColumn["DATETIME_PRECISION"]))) {
              tableColumn.precision = parseInt(dbColumn["DATETIME_PRECISION"]);
            }
            return tableColumn;
          });
          const tableForeignKeyConstraints = OrmUtils_1.OrmUtils.uniq(dbForeignKeys.filter((dbForeignKey) => {
            return dbForeignKey["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbForeignKey["TABLE_SCHEMA"] === dbTable["TABLE_SCHEMA"];
          }), (dbForeignKey) => dbForeignKey["CONSTRAINT_NAME"]);
          table.foreignKeys = tableForeignKeyConstraints.map((dbForeignKey) => {
            const foreignKeys = dbForeignKeys.filter((dbFk) => dbFk["CONSTRAINT_NAME"] === dbForeignKey["CONSTRAINT_NAME"]);
            const database = dbForeignKey["REFERENCED_TABLE_SCHEMA"] === currentDatabase ? void 0 : dbForeignKey["REFERENCED_TABLE_SCHEMA"];
            const referencedTableName = this.driver.buildTableName(dbForeignKey["REFERENCED_TABLE_NAME"], void 0, database);
            return new TableForeignKey_1.TableForeignKey({
              name: dbForeignKey["CONSTRAINT_NAME"],
              columnNames: foreignKeys.map((dbFk) => dbFk["COLUMN_NAME"]),
              referencedDatabase: dbForeignKey["REFERENCED_TABLE_SCHEMA"],
              referencedTableName,
              referencedColumnNames: foreignKeys.map((dbFk) => dbFk["REFERENCED_COLUMN_NAME"]),
              onDelete: dbForeignKey["ON_DELETE"],
              onUpdate: dbForeignKey["ON_UPDATE"]
            });
          });
          const tableIndexConstraints = OrmUtils_1.OrmUtils.uniq(dbIndices.filter((dbIndex) => {
            return dbIndex["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbIndex["TABLE_SCHEMA"] === dbTable["TABLE_SCHEMA"];
          }), (dbIndex) => dbIndex["INDEX_NAME"]);
          table.indices = tableIndexConstraints.map((constraint) => {
            const indices = dbIndices.filter((index) => {
              return index["TABLE_SCHEMA"] === constraint["TABLE_SCHEMA"] && index["TABLE_NAME"] === constraint["TABLE_NAME"] && index["INDEX_NAME"] === constraint["INDEX_NAME"];
            });
            const nonUnique = parseInt(constraint["NON_UNIQUE"], 10);
            return new TableIndex_1.TableIndex({
              table,
              name: constraint["INDEX_NAME"],
              columnNames: indices.map((i) => i["COLUMN_NAME"]),
              isUnique: nonUnique === 0,
              isSpatial: constraint["INDEX_TYPE"] === "SPATIAL",
              isFulltext: constraint["INDEX_TYPE"] === "FULLTEXT"
            });
          });
          return table;
        });
      }
      /**
       * Builds create table sql
       */
      createTableSql(table, createForeignKeys) {
        const columnDefinitions = table.columns.map((column) => this.buildCreateColumnSql(column, true)).join(", ");
        let sql = `CREATE TABLE ${this.escapePath(table)} (${columnDefinitions}`;
        table.columns.filter((column) => column.isUnique).forEach((column) => {
          const isUniqueIndexExist = table.indices.some((index) => {
            return index.columnNames.length === 1 && !!index.isUnique && index.columnNames.indexOf(column.name) !== -1;
          });
          const isUniqueConstraintExist = table.uniques.some((unique) => {
            return unique.columnNames.length === 1 && unique.columnNames.indexOf(column.name) !== -1;
          });
          if (!isUniqueIndexExist && !isUniqueConstraintExist)
            table.indices.push(new TableIndex_1.TableIndex({
              name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),
              columnNames: [column.name],
              isUnique: true
            }));
        });
        if (table.uniques.length > 0) {
          table.uniques.forEach((unique) => {
            const uniqueExist = table.indices.some((index) => index.name === unique.name);
            if (!uniqueExist) {
              table.indices.push(new TableIndex_1.TableIndex({
                name: unique.name,
                columnNames: unique.columnNames,
                isUnique: true
              }));
            }
          });
        }
        if (table.indices.length > 0) {
          const indicesSql = table.indices.map((index) => {
            const columnNames = index.columnNames.map((columnName) => `\`${columnName}\``).join(", ");
            if (!index.name)
              index.name = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);
            let indexType = "";
            if (index.isUnique)
              indexType += "UNIQUE ";
            if (index.isSpatial)
              indexType += "SPATIAL ";
            if (index.isFulltext)
              indexType += "FULLTEXT ";
            return `${indexType}INDEX \`${index.name}\` (${columnNames})`;
          }).join(", ");
          sql += `, ${indicesSql}`;
        }
        if (table.foreignKeys.length > 0 && createForeignKeys) {
          const foreignKeysSql = table.foreignKeys.map((fk) => {
            const columnNames = fk.columnNames.map((columnName) => `\`${columnName}\``).join(", ");
            if (!fk.name)
              fk.name = this.connection.namingStrategy.foreignKeyName(table, fk.columnNames);
            const referencedColumnNames = fk.referencedColumnNames.map((columnName) => `\`${columnName}\``).join(", ");
            let constraint = `CONSTRAINT \`${fk.name}\` FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(fk))} (${referencedColumnNames})`;
            if (fk.onDelete)
              constraint += ` ON DELETE ${fk.onDelete}`;
            if (fk.onUpdate)
              constraint += ` ON UPDATE ${fk.onUpdate}`;
            return constraint;
          }).join(", ");
          sql += `, ${foreignKeysSql}`;
        }
        if (table.primaryColumns.length > 0) {
          const columnNames = table.primaryColumns.map((column) => `\`${column.name}\``).join(", ");
          sql += `, PRIMARY KEY (${columnNames})`;
        }
        sql += `) ENGINE=${table.engine || "InnoDB"}`;
        return new Query_1.Query(sql);
      }
      /**
       * Builds drop table sql
       */
      dropTableSql(tableOrName) {
        return new Query_1.Query(`DROP TABLE ${this.escapePath(tableOrName)}`);
      }
      createViewSql(view) {
        if (typeof view.expression === "string") {
          return new Query_1.Query(`CREATE VIEW ${this.escapePath(view)} AS ${view.expression}`);
        } else {
          return new Query_1.Query(`CREATE VIEW ${this.escapePath(view)} AS ${view.expression(this.connection).getQuery()}`);
        }
      }
      async insertViewDefinitionSql(view) {
        const currentDatabase = await this.getCurrentDatabase();
        const expression = typeof view.expression === "string" ? view.expression.trim() : view.expression(this.connection).getQuery();
        return this.insertTypeormMetadataSql({
          type: MetadataTableType_1.MetadataTableType.VIEW,
          schema: currentDatabase,
          name: view.name,
          value: expression
        });
      }
      /**
       * Builds drop view sql.
       */
      dropViewSql(viewOrPath) {
        return new Query_1.Query(`DROP VIEW ${this.escapePath(viewOrPath)}`);
      }
      /**
       * Builds remove view sql.
       */
      async deleteViewDefinitionSql(viewOrPath) {
        const currentDatabase = await this.getCurrentDatabase();
        const viewName = InstanceChecker_1.InstanceChecker.isView(viewOrPath) ? viewOrPath.name : viewOrPath;
        return this.deleteTypeormMetadataSql({
          type: MetadataTableType_1.MetadataTableType.VIEW,
          schema: currentDatabase,
          name: viewName
        });
      }
      /**
       * Builds create index sql.
       */
      createIndexSql(table, index) {
        const columns = index.columnNames.map((columnName) => `\`${columnName}\``).join(", ");
        let indexType = "";
        if (index.isUnique)
          indexType += "UNIQUE ";
        if (index.isSpatial)
          indexType += "SPATIAL ";
        if (index.isFulltext)
          indexType += "FULLTEXT ";
        return new Query_1.Query(`CREATE ${indexType}INDEX \`${index.name}\` ON ${this.escapePath(table)} (${columns})`);
      }
      /**
       * Builds drop index sql.
       */
      dropIndexSql(table, indexOrName) {
        const indexName = InstanceChecker_1.InstanceChecker.isTableIndex(indexOrName) ? indexOrName.name : indexOrName;
        return new Query_1.Query(`DROP INDEX \`${indexName}\` ON ${this.escapePath(table)}`);
      }
      /**
       * Builds create primary key sql.
       */
      createPrimaryKeySql(table, columnNames) {
        const columnNamesString = columnNames.map((columnName) => `\`${columnName}\``).join(", ");
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNamesString})`);
      }
      /**
       * Builds drop primary key sql.
       */
      dropPrimaryKeySql(table) {
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`);
      }
      /**
       * Builds create foreign key sql.
       */
      createForeignKeySql(table, foreignKey) {
        const columnNames = foreignKey.columnNames.map((column) => `\`${column}\``).join(", ");
        const referencedColumnNames = foreignKey.referencedColumnNames.map((column) => `\`${column}\``).join(",");
        let sql = `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \`${foreignKey.name}\` FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;
        if (foreignKey.onDelete)
          sql += ` ON DELETE ${foreignKey.onDelete}`;
        if (foreignKey.onUpdate)
          sql += ` ON UPDATE ${foreignKey.onUpdate}`;
        return new Query_1.Query(sql);
      }
      /**
       * Builds drop foreign key sql.
       */
      dropForeignKeySql(table, foreignKeyOrName) {
        const foreignKeyName = InstanceChecker_1.InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName.name : foreignKeyOrName;
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP FOREIGN KEY \`${foreignKeyName}\``);
      }
      /**
       * Escapes a given comment so it's safe to include in a query.
       */
      escapeComment(comment) {
        if (!comment || comment.length === 0) {
          return `''`;
        }
        comment = comment.replace(/\\/g, "\\\\").replace(/'/g, "''").replace(/\u0000/g, "");
        return `'${comment}'`;
      }
      /**
       * Escapes given table or view path.
       */
      escapePath(target) {
        const { database, tableName } = this.driver.parseTableName(target);
        if (database && database !== this.driver.database) {
          return `\`${database}\`.\`${tableName}\``;
        }
        return `\`${tableName}\``;
      }
      /**
       * Builds a part of query to create/change a column.
       */
      buildCreateColumnSql(column, skipPrimary, skipName = false) {
        let c = "";
        if (skipName) {
          c = this.connection.driver.createFullType(column);
        } else {
          c = `\`${column.name}\` ${this.connection.driver.createFullType(column)}`;
        }
        if (column.asExpression)
          c += ` AS (${column.asExpression}) ${column.generatedType ? column.generatedType : "VIRTUAL"}`;
        if (column.zerofill) {
          c += " ZEROFILL";
        } else if (column.unsigned) {
          c += " UNSIGNED";
        }
        if (column.enum)
          c += ` (${column.enum.map((value) => "'" + value + "'").join(", ")})`;
        if (column.charset)
          c += ` CHARACTER SET "${column.charset}"`;
        if (column.collation)
          c += ` COLLATE "${column.collation}"`;
        if (!column.isNullable)
          c += " NOT NULL";
        if (column.isNullable)
          c += " NULL";
        if (column.isPrimary && !skipPrimary)
          c += " PRIMARY KEY";
        if (column.isGenerated && column.generationStrategy === "increment")
          c += " AUTO_INCREMENT";
        if (column.comment)
          c += ` COMMENT ${this.escapeComment(column.comment)}`;
        if (column.default !== void 0 && column.default !== null)
          c += ` DEFAULT ${column.default}`;
        if (column.onUpdate)
          c += ` ON UPDATE ${column.onUpdate}`;
        return c;
      }
      /**
       * Checks if column display width is by default.
       */
      isDefaultColumnWidth(table, column, width) {
        if (this.connection.hasMetadata(table.name)) {
          const metadata = this.connection.getMetadata(table.name);
          const columnMetadata = metadata.findColumnWithDatabaseName(column.name);
          if (columnMetadata && columnMetadata.width)
            return false;
        }
        const defaultWidthForType = this.connection.driver.dataTypeDefaults && this.connection.driver.dataTypeDefaults[column.type] && this.connection.driver.dataTypeDefaults[column.type].width;
        if (defaultWidthForType) {
          const typesWithReducedUnsignedDefault = [
            "int",
            "tinyint",
            "smallint",
            "mediumint"
          ];
          const needsAdjustment = typesWithReducedUnsignedDefault.indexOf(column.type) !== -1;
          if (column.unsigned && needsAdjustment) {
            return defaultWidthForType - 1 === width;
          } else {
            return defaultWidthForType === width;
          }
        }
        return false;
      }
      /**
       * Change table comment.
       */
      changeTableComment(tableOrName, comment) {
        throw new error_1.TypeORMError(`aurora-mysql driver does not support change table comment.`);
      }
    };
    exports2.AuroraMysqlQueryRunner = AuroraMysqlQueryRunner;
  }
});

// node_modules/typeorm/driver/aurora-mysql/AuroraMysqlDriver.js
var require_AuroraMysqlDriver = __commonJS({
  "node_modules/typeorm/driver/aurora-mysql/AuroraMysqlDriver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AuroraMysqlDriver = void 0;
    var DriverUtils_1 = require_DriverUtils();
    var AuroraMysqlQueryRunner_1 = require_AuroraMysqlQueryRunner();
    var DateUtils_1 = require_DateUtils();
    var PlatformTools_1 = require_PlatformTools();
    var RdbmsSchemaBuilder_1 = require_RdbmsSchemaBuilder();
    var OrmUtils_1 = require_OrmUtils();
    var ApplyValueTransformers_1 = require_ApplyValueTransformers();
    var error_1 = require_error();
    var InstanceChecker_1 = require_InstanceChecker();
    var AuroraMysqlDriver = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection) {
        this.isReplicated = false;
        this.treeSupport = true;
        this.transactionSupport = "nested";
        this.supportedDataTypes = [
          // numeric types
          "bit",
          "int",
          "integer",
          // synonym for int
          "tinyint",
          "smallint",
          "mediumint",
          "bigint",
          "float",
          "double",
          "double precision",
          // synonym for double
          "real",
          // synonym for double
          "decimal",
          "dec",
          // synonym for decimal
          "numeric",
          // synonym for decimal
          "fixed",
          // synonym for decimal
          "bool",
          // synonym for tinyint
          "boolean",
          // synonym for tinyint
          // date and time types
          "date",
          "datetime",
          "timestamp",
          "time",
          "year",
          // string types
          "char",
          "nchar",
          // synonym for national char
          "national char",
          "varchar",
          "nvarchar",
          // synonym for national varchar
          "national varchar",
          "blob",
          "text",
          "tinyblob",
          "tinytext",
          "mediumblob",
          "mediumtext",
          "longblob",
          "longtext",
          "enum",
          "set",
          "binary",
          "varbinary",
          // json data type
          "json",
          // spatial data types
          "geometry",
          "point",
          "linestring",
          "polygon",
          "multipoint",
          "multilinestring",
          "multipolygon",
          "geometrycollection"
        ];
        this.supportedUpsertTypes = ["on-duplicate-key-update"];
        this.spatialTypes = [
          "geometry",
          "point",
          "linestring",
          "polygon",
          "multipoint",
          "multilinestring",
          "multipolygon",
          "geometrycollection"
        ];
        this.withLengthColumnTypes = [
          "char",
          "varchar",
          "nvarchar",
          "binary",
          "varbinary"
        ];
        this.withWidthColumnTypes = [
          "bit",
          "tinyint",
          "smallint",
          "mediumint",
          "int",
          "integer",
          "bigint"
        ];
        this.withPrecisionColumnTypes = [
          "decimal",
          "dec",
          "numeric",
          "fixed",
          "float",
          "double",
          "double precision",
          "real",
          "time",
          "datetime",
          "timestamp"
        ];
        this.withScaleColumnTypes = [
          "decimal",
          "dec",
          "numeric",
          "fixed",
          "float",
          "double",
          "double precision",
          "real"
        ];
        this.unsignedAndZerofillTypes = [
          "int",
          "integer",
          "smallint",
          "tinyint",
          "mediumint",
          "bigint",
          "decimal",
          "dec",
          "numeric",
          "fixed",
          "float",
          "double",
          "double precision",
          "real"
        ];
        this.mappedDataTypes = {
          createDate: "datetime",
          createDatePrecision: 6,
          createDateDefault: "CURRENT_TIMESTAMP(6)",
          updateDate: "datetime",
          updateDatePrecision: 6,
          updateDateDefault: "CURRENT_TIMESTAMP(6)",
          deleteDate: "datetime",
          deleteDatePrecision: 6,
          deleteDateNullable: true,
          version: "int",
          treeLevel: "int",
          migrationId: "int",
          migrationName: "varchar",
          migrationTimestamp: "bigint",
          cacheId: "int",
          cacheIdentifier: "varchar",
          cacheTime: "bigint",
          cacheDuration: "int",
          cacheQuery: "text",
          cacheResult: "text",
          metadataType: "varchar",
          metadataDatabase: "varchar",
          metadataSchema: "varchar",
          metadataTable: "varchar",
          metadataName: "varchar",
          metadataValue: "text"
        };
        this.dataTypeDefaults = {
          varchar: { length: 255 },
          nvarchar: { length: 255 },
          "national varchar": { length: 255 },
          char: { length: 1 },
          binary: { length: 1 },
          varbinary: { length: 255 },
          decimal: { precision: 10, scale: 0 },
          dec: { precision: 10, scale: 0 },
          numeric: { precision: 10, scale: 0 },
          fixed: { precision: 10, scale: 0 },
          float: { precision: 12 },
          double: { precision: 22 },
          time: { precision: 0 },
          datetime: { precision: 0 },
          timestamp: { precision: 0 },
          bit: { width: 1 },
          int: { width: 11 },
          integer: { width: 11 },
          tinyint: { width: 4 },
          smallint: { width: 6 },
          mediumint: { width: 9 },
          bigint: { width: 20 }
        };
        this.maxAliasLength = 63;
        this.cteCapabilities = {
          enabled: false
        };
        this.connection = connection;
        this.options = connection.options;
        this.loadDependencies();
        this.client = new this.DataApiDriver(this.options.region, this.options.secretArn, this.options.resourceArn, this.options.database, (query, parameters) => this.connection.logger.logQuery(query, parameters), this.options.serviceConfigOptions, this.options.formatOptions);
        this.database = DriverUtils_1.DriverUtils.buildDriverOptions(this.options).database;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Performs connection to the database.
       */
      async connect() {
        if (!this.database) {
          const queryRunner = this.createQueryRunner("master");
          this.database = await queryRunner.getCurrentDatabase();
          await queryRunner.release();
        }
      }
      /**
       * Makes any action after connection (e.g. create extensions in Postgres driver).
       */
      afterConnect() {
        return Promise.resolve();
      }
      /**
       * Closes connection with the database.
       */
      async disconnect() {
      }
      /**
       * Creates a schema builder used to build and sync a schema.
       */
      createSchemaBuilder() {
        return new RdbmsSchemaBuilder_1.RdbmsSchemaBuilder(this.connection);
      }
      /**
       * Creates a query runner used to execute database queries.
       */
      createQueryRunner(mode) {
        return new AuroraMysqlQueryRunner_1.AuroraMysqlQueryRunner(this, new this.DataApiDriver(this.options.region, this.options.secretArn, this.options.resourceArn, this.options.database, (query, parameters) => this.connection.logger.logQuery(query, parameters), this.options.serviceConfigOptions, this.options.formatOptions));
      }
      /**
       * Replaces parameters in the given sql with special escaping character
       * and an array of parameter names to be passed to a query.
       */
      escapeQueryWithParameters(sql, parameters, nativeParameters) {
        const escapedParameters = Object.keys(nativeParameters).map((key) => nativeParameters[key]);
        if (!parameters || !Object.keys(parameters).length)
          return [sql, escapedParameters];
        sql = sql.replace(/:(\.\.\.)?([A-Za-z0-9_.]+)/g, (full, isArray, key) => {
          if (!parameters.hasOwnProperty(key)) {
            return full;
          }
          const value = parameters[key];
          if (isArray) {
            return value.map((v) => {
              escapedParameters.push(v);
              return this.createParameter(key, escapedParameters.length - 1);
            }).join(", ");
          }
          if (typeof value === "function") {
            return value();
          }
          escapedParameters.push(value);
          return this.createParameter(key, escapedParameters.length - 1);
        });
        return [sql, escapedParameters];
      }
      /**
       * Escapes a column name.
       */
      escape(columnName) {
        return "`" + columnName + "`";
      }
      /**
       * Build full table name with database name, schema name and table name.
       * E.g. myDB.mySchema.myTable
       */
      buildTableName(tableName, schema, database) {
        const tablePath = [tableName];
        if (database) {
          tablePath.unshift(database);
        }
        return tablePath.join(".");
      }
      /**
       * Parse a target table name or other types and return a normalized table definition.
       */
      parseTableName(target) {
        const driverDatabase = this.database;
        const driverSchema = void 0;
        if (InstanceChecker_1.InstanceChecker.isTable(target) || InstanceChecker_1.InstanceChecker.isView(target)) {
          const parsed = this.parseTableName(target.name);
          return {
            database: target.database || parsed.database || driverDatabase,
            schema: target.schema || parsed.schema || driverSchema,
            tableName: parsed.tableName
          };
        }
        if (InstanceChecker_1.InstanceChecker.isTableForeignKey(target)) {
          const parsed = this.parseTableName(target.referencedTableName);
          return {
            database: target.referencedDatabase || parsed.database || driverDatabase,
            schema: target.referencedSchema || parsed.schema || driverSchema,
            tableName: parsed.tableName
          };
        }
        if (InstanceChecker_1.InstanceChecker.isEntityMetadata(target)) {
          return {
            database: target.database || driverDatabase,
            schema: target.schema || driverSchema,
            tableName: target.tableName
          };
        }
        const parts = target.split(".");
        return {
          database: (parts.length > 1 ? parts[0] : void 0) || driverDatabase,
          schema: driverSchema,
          tableName: parts.length > 1 ? parts[1] : parts[0]
        };
      }
      /**
       * Prepares given value to a value to be persisted, based on its column type and metadata.
       */
      preparePersistentValue(value, columnMetadata) {
        if (columnMetadata.transformer)
          value = ApplyValueTransformers_1.ApplyValueTransformers.transformTo(columnMetadata.transformer, value);
        if (!this.options.formatOptions || this.options.formatOptions.castParameters !== false) {
          return this.client.preparePersistentValue(value, columnMetadata);
        }
        if (value === null || value === void 0)
          return value;
        if (columnMetadata.type === Boolean) {
          return value === true ? 1 : 0;
        } else if (columnMetadata.type === "date") {
          return DateUtils_1.DateUtils.mixedDateToDateString(value);
        } else if (columnMetadata.type === "time") {
          return DateUtils_1.DateUtils.mixedDateToTimeString(value);
        } else if (columnMetadata.type === "json") {
          return JSON.stringify(value);
        } else if (columnMetadata.type === "timestamp" || columnMetadata.type === "datetime" || columnMetadata.type === Date) {
          return DateUtils_1.DateUtils.mixedDateToDate(value);
        } else if (columnMetadata.type === "simple-array" || columnMetadata.type === "set") {
          return DateUtils_1.DateUtils.simpleArrayToString(value);
        } else if (columnMetadata.type === "simple-json") {
          return DateUtils_1.DateUtils.simpleJsonToString(value);
        } else if (columnMetadata.type === "enum" || columnMetadata.type === "simple-enum") {
          return "" + value;
        }
        return value;
      }
      /**
       * Prepares given value to a value to be persisted, based on its column type or metadata.
       */
      prepareHydratedValue(value, columnMetadata) {
        if (value === null || value === void 0)
          return columnMetadata.transformer ? ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value) : value;
        if (!this.options.formatOptions || this.options.formatOptions.castParameters !== false) {
          return this.client.prepareHydratedValue(value, columnMetadata);
        }
        if (columnMetadata.type === Boolean || columnMetadata.type === "bool" || columnMetadata.type === "boolean") {
          value = value ? true : false;
        } else if (columnMetadata.type === "datetime" || columnMetadata.type === Date) {
          value = DateUtils_1.DateUtils.normalizeHydratedDate(value);
        } else if (columnMetadata.type === "date") {
          value = DateUtils_1.DateUtils.mixedDateToDateString(value);
        } else if (columnMetadata.type === "json") {
          value = typeof value === "string" ? JSON.parse(value) : value;
        } else if (columnMetadata.type === "time") {
          value = DateUtils_1.DateUtils.mixedTimeToString(value);
        } else if (columnMetadata.type === "simple-array" || columnMetadata.type === "set") {
          value = DateUtils_1.DateUtils.stringToSimpleArray(value);
        } else if (columnMetadata.type === "simple-json") {
          value = DateUtils_1.DateUtils.stringToSimpleJson(value);
        } else if ((columnMetadata.type === "enum" || columnMetadata.type === "simple-enum") && columnMetadata.enum && !isNaN(value) && columnMetadata.enum.indexOf(parseInt(value)) >= 0) {
          value = parseInt(value);
        } else if (columnMetadata.type === Number) {
          value = !isNaN(+value) ? parseInt(value) : value;
        }
        if (columnMetadata.transformer)
          value = ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);
        return value;
      }
      /**
       * Creates a database type from a given column metadata.
       */
      normalizeType(column) {
        if (column.type === Number || column.type === "integer") {
          return "int";
        } else if (column.type === String) {
          return "varchar";
        } else if (column.type === Date) {
          return "datetime";
        } else if (column.type === Buffer) {
          return "blob";
        } else if (column.type === Boolean) {
          return "tinyint";
        } else if (column.type === "uuid") {
          return "varchar";
        } else if (column.type === "simple-array" || column.type === "simple-json") {
          return "text";
        } else if (column.type === "simple-enum") {
          return "enum";
        } else if (column.type === "double precision" || column.type === "real") {
          return "double";
        } else if (column.type === "dec" || column.type === "numeric" || column.type === "fixed") {
          return "decimal";
        } else if (column.type === "bool" || column.type === "boolean") {
          return "tinyint";
        } else if (column.type === "nvarchar" || column.type === "national varchar") {
          return "varchar";
        } else if (column.type === "nchar" || column.type === "national char") {
          return "char";
        } else {
          return column.type || "";
        }
      }
      /**
       * Normalizes "default" value of the column.
       */
      normalizeDefault(columnMetadata) {
        const defaultValue = columnMetadata.default;
        if (defaultValue === null) {
          return void 0;
        }
        if ((columnMetadata.type === "enum" || columnMetadata.type === "simple-enum") && defaultValue !== void 0) {
          return `'${defaultValue}'`;
        }
        if (columnMetadata.type === "set" && defaultValue !== void 0) {
          return `'${DateUtils_1.DateUtils.simpleArrayToString(defaultValue)}'`;
        }
        if (typeof defaultValue === "number") {
          return `${defaultValue}`;
        }
        if (typeof defaultValue === "boolean") {
          return defaultValue ? "1" : "0";
        }
        if (typeof defaultValue === "function") {
          return defaultValue();
        }
        if (typeof defaultValue === "string") {
          return `'${defaultValue}'`;
        }
        if (defaultValue === void 0) {
          return void 0;
        }
        return `${defaultValue}`;
      }
      /**
       * Normalizes "isUnique" value of the column.
       */
      normalizeIsUnique(column) {
        return column.entityMetadata.indices.some((idx) => idx.isUnique && idx.columns.length === 1 && idx.columns[0] === column);
      }
      /**
       * Returns default column lengths, which is required on column creation.
       */
      getColumnLength(column) {
        if (column.length)
          return column.length.toString();
        if (column.generationStrategy === "uuid")
          return "36";
        switch (column.type) {
          case String:
          case "varchar":
          case "nvarchar":
          case "national varchar":
            return "255";
          case "varbinary":
            return "255";
          default:
            return "";
        }
      }
      /**
       * Creates column type definition including length, precision and scale
       */
      createFullType(column) {
        let type = column.type;
        if (this.getColumnLength(column)) {
          type += `(${this.getColumnLength(column)})`;
        } else if (column.width) {
          type += `(${column.width})`;
        } else if (column.precision !== null && column.precision !== void 0 && column.scale !== null && column.scale !== void 0) {
          type += `(${column.precision},${column.scale})`;
        } else if (column.precision !== null && column.precision !== void 0) {
          type += `(${column.precision})`;
        }
        if (column.isArray)
          type += " array";
        return type;
      }
      /**
       * Obtains a new database connection to a master server.
       * Used for replication.
       * If replication is not setup then returns default connection's database connection.
       */
      obtainMasterConnection() {
        return new Promise((ok, fail) => {
          if (this.poolCluster) {
            this.poolCluster.getConnection("MASTER", (err, dbConnection) => {
              err ? fail(err) : ok(this.prepareDbConnection(dbConnection));
            });
          } else if (this.pool) {
            this.pool.getConnection((err, dbConnection) => {
              err ? fail(err) : ok(this.prepareDbConnection(dbConnection));
            });
          } else {
            fail(new error_1.TypeORMError(`Connection is not established with mysql database`));
          }
        });
      }
      /**
       * Obtains a new database connection to a slave server.
       * Used for replication.
       * If replication is not setup then returns master (default) connection's database connection.
       */
      obtainSlaveConnection() {
        if (!this.poolCluster)
          return this.obtainMasterConnection();
        return new Promise((ok, fail) => {
          this.poolCluster.getConnection("SLAVE*", (err, dbConnection) => {
            err ? fail(err) : ok(this.prepareDbConnection(dbConnection));
          });
        });
      }
      /**
       * Creates generated map of values generated or returned by database after INSERT query.
       */
      createGeneratedMap(metadata, insertResult, entityIndex) {
        const generatedMap = metadata.generatedColumns.reduce((map, generatedColumn) => {
          let value;
          if (generatedColumn.generationStrategy === "increment" && insertResult.insertId) {
            value = insertResult.insertId + entityIndex;
          }
          return OrmUtils_1.OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));
        }, {});
        return Object.keys(generatedMap).length > 0 ? generatedMap : void 0;
      }
      /**
       * Differentiate columns of this table and columns from the given column metadatas columns
       * and returns only changed.
       */
      findChangedColumns(tableColumns, columnMetadatas) {
        return columnMetadatas.filter((columnMetadata) => {
          const tableColumn = tableColumns.find((c) => c.name === columnMetadata.databaseName);
          if (!tableColumn)
            return false;
          let columnMetadataLength = columnMetadata.length;
          if (!columnMetadataLength && columnMetadata.generationStrategy === "uuid") {
            columnMetadataLength = this.getColumnLength(columnMetadata);
          }
          return tableColumn.name !== columnMetadata.databaseName || tableColumn.type !== this.normalizeType(columnMetadata) || tableColumn.length !== columnMetadataLength || tableColumn.width !== columnMetadata.width || tableColumn.precision !== columnMetadata.precision || tableColumn.scale !== columnMetadata.scale || tableColumn.zerofill !== columnMetadata.zerofill || tableColumn.unsigned !== columnMetadata.unsigned || tableColumn.asExpression !== columnMetadata.asExpression || tableColumn.generatedType !== columnMetadata.generatedType || tableColumn.comment !== this.escapeComment(columnMetadata.comment) || !this.compareDefaultValues(this.normalizeDefault(columnMetadata), tableColumn.default) || tableColumn.enum && columnMetadata.enum && !OrmUtils_1.OrmUtils.isArraysEqual(tableColumn.enum, columnMetadata.enum.map((val) => val + "")) || tableColumn.onUpdate !== columnMetadata.onUpdate || tableColumn.isPrimary !== columnMetadata.isPrimary || tableColumn.isNullable !== columnMetadata.isNullable || tableColumn.isUnique !== this.normalizeIsUnique(columnMetadata) || columnMetadata.generationStrategy !== "uuid" && tableColumn.isGenerated !== columnMetadata.isGenerated;
        });
      }
      /**
       * Returns true if driver supports RETURNING / OUTPUT statement.
       */
      isReturningSqlSupported() {
        return false;
      }
      /**
       * Returns true if driver supports uuid values generation on its own.
       */
      isUUIDGenerationSupported() {
        return false;
      }
      /**
       * Returns true if driver supports fulltext indices.
       */
      isFullTextColumnTypeSupported() {
        return true;
      }
      /**
       * Creates an escaped parameter.
       */
      createParameter(parameterName, index) {
        return "?";
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Loads all driver dependencies.
       */
      loadDependencies() {
        const DataApiDriver = this.options.driver || PlatformTools_1.PlatformTools.load("typeorm-aurora-data-api-driver");
        this.DataApiDriver = DataApiDriver;
        this.DataApiDriver = this.DataApiDriver.default || this.DataApiDriver;
      }
      /**
       * Creates a new connection pool for a given database credentials.
       */
      createConnectionOptions(options, credentials) {
        credentials = Object.assign({}, credentials, DriverUtils_1.DriverUtils.buildDriverOptions(credentials));
        return Object.assign({}, {
          resourceArn: options.resourceArn,
          secretArn: options.secretArn,
          database: options.database,
          region: options.region,
          type: options.type
        }, {
          host: credentials.host,
          user: credentials.username,
          password: credentials.password,
          database: credentials.database,
          port: credentials.port,
          ssl: options.ssl
        }, options.extra || {});
      }
      /**
       * Creates a new connection pool for a given database credentials.
       */
      async createPool(connectionOptions) {
        return {};
      }
      /**
       * Attaches all required base handlers to a database connection, such as the unhandled error handler.
       */
      prepareDbConnection(connection) {
        const { logger } = this.connection;
        if (connection.listeners("error").length === 0) {
          connection.on("error", (error) => logger.log("warn", `MySQL connection raised an error. ${error}`));
        }
        return connection;
      }
      /**
       * Checks if "DEFAULT" values in the column metadata and in the database are equal.
       */
      compareDefaultValues(columnMetadataValue, databaseValue) {
        if (typeof columnMetadataValue === "string" && typeof databaseValue === "string") {
          columnMetadataValue = columnMetadataValue.replace(/^'+|'+$/g, "");
          databaseValue = databaseValue.replace(/^'+|'+$/g, "");
        }
        return columnMetadataValue === databaseValue;
      }
      /**
       * Escapes a given comment.
       */
      escapeComment(comment) {
        if (!comment)
          return comment;
        comment = comment.replace(/\u0000/g, "");
        return comment;
      }
    };
    exports2.AuroraMysqlDriver = AuroraMysqlDriver;
  }
});

// node_modules/typeorm/driver/aurora-postgres/AuroraPostgresQueryRunner.js
var require_AuroraPostgresQueryRunner = __commonJS({
  "node_modules/typeorm/driver/aurora-postgres/AuroraPostgresQueryRunner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AuroraPostgresQueryRunner = void 0;
    var QueryRunnerAlreadyReleasedError_1 = require_QueryRunnerAlreadyReleasedError();
    var TransactionNotStartedError_1 = require_TransactionNotStartedError();
    var PostgresQueryRunner_1 = require_PostgresQueryRunner();
    var QueryResult_1 = require_QueryResult();
    var error_1 = require_error();
    var PostgresQueryRunnerWrapper = class extends PostgresQueryRunner_1.PostgresQueryRunner {
      constructor(driver, mode) {
        super(driver, mode);
      }
    };
    var AuroraPostgresQueryRunner = class extends PostgresQueryRunnerWrapper {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(driver, client, mode) {
        super(driver, mode);
        this.client = client;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Creates/uses database connection from the connection pool to perform further operations.
       * Returns obtained database connection.
       */
      connect() {
        if (this.databaseConnection)
          return Promise.resolve(this.databaseConnection);
        if (this.databaseConnectionPromise)
          return this.databaseConnectionPromise;
        if (this.mode === "slave" && this.driver.isReplicated) {
          this.databaseConnectionPromise = this.driver.obtainSlaveConnection().then(([connection, release]) => {
            this.driver.connectedQueryRunners.push(this);
            this.databaseConnection = connection;
            this.releaseCallback = release;
            return this.databaseConnection;
          });
        } else {
          this.databaseConnectionPromise = this.driver.obtainMasterConnection().then(([connection, release]) => {
            this.driver.connectedQueryRunners.push(this);
            this.databaseConnection = connection;
            this.releaseCallback = release;
            return this.databaseConnection;
          });
        }
        return this.databaseConnectionPromise;
      }
      /**
       * Starts transaction on the current connection.
       */
      async startTransaction(isolationLevel) {
        this.isTransactionActive = true;
        try {
          await this.broadcaster.broadcast("BeforeTransactionStart");
        } catch (err) {
          this.isTransactionActive = false;
          throw err;
        }
        if (this.transactionDepth === 0) {
          await this.client.startTransaction();
        } else {
          await this.query(`SAVEPOINT typeorm_${this.transactionDepth}`);
        }
        this.transactionDepth += 1;
        await this.broadcaster.broadcast("AfterTransactionStart");
      }
      /**
       * Commits transaction.
       * Error will be thrown if transaction was not started.
       */
      async commitTransaction() {
        if (!this.isTransactionActive)
          throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionCommit");
        if (this.transactionDepth > 1) {
          await this.query(`RELEASE SAVEPOINT typeorm_${this.transactionDepth - 1}`);
        } else {
          await this.client.commitTransaction();
          this.isTransactionActive = false;
        }
        this.transactionDepth -= 1;
        await this.broadcaster.broadcast("AfterTransactionCommit");
      }
      /**
       * Rollbacks transaction.
       * Error will be thrown if transaction was not started.
       */
      async rollbackTransaction() {
        if (!this.isTransactionActive)
          throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionRollback");
        if (this.transactionDepth > 1) {
          await this.query(`ROLLBACK TO SAVEPOINT typeorm_${this.transactionDepth - 1}`);
        } else {
          await this.client.rollbackTransaction();
          this.isTransactionActive = false;
        }
        this.transactionDepth -= 1;
        await this.broadcaster.broadcast("AfterTransactionRollback");
      }
      /**
       * Executes a given SQL query.
       */
      async query(query, parameters, useStructuredResult = false) {
        if (this.isReleased)
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        const raw = await this.client.query(query, parameters);
        const result = new QueryResult_1.QueryResult();
        result.raw = raw;
        if (raw?.hasOwnProperty("records") && Array.isArray(raw.records)) {
          result.records = raw.records;
        }
        if (raw?.hasOwnProperty("numberOfRecordsUpdated")) {
          result.affected = raw.numberOfRecordsUpdated;
        }
        if (!useStructuredResult) {
          return result.raw;
        }
        return result;
      }
      /**
       * Change table comment.
       */
      changeTableComment(tableOrName, comment) {
        throw new error_1.TypeORMError(`aurora-postgres driver does not support change comment.`);
      }
    };
    exports2.AuroraPostgresQueryRunner = AuroraPostgresQueryRunner;
  }
});

// node_modules/typeorm/driver/aurora-postgres/AuroraPostgresDriver.js
var require_AuroraPostgresDriver = __commonJS({
  "node_modules/typeorm/driver/aurora-postgres/AuroraPostgresDriver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AuroraPostgresDriver = void 0;
    var PostgresDriver_1 = require_PostgresDriver();
    var PlatformTools_1 = require_PlatformTools();
    var AuroraPostgresQueryRunner_1 = require_AuroraPostgresQueryRunner();
    var ApplyValueTransformers_1 = require_ApplyValueTransformers();
    var DriverUtils_1 = require_DriverUtils();
    var PostgresWrapper = class extends PostgresDriver_1.PostgresDriver {
    };
    var AuroraPostgresDriver = class extends PostgresWrapper {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection) {
        super();
        this.transactionSupport = "nested";
        this.connection = connection;
        this.options = connection.options;
        this.isReplicated = false;
        this.loadDependencies();
        this.client = new this.DataApiDriver(this.options.region, this.options.secretArn, this.options.resourceArn, this.options.database, (query, parameters) => this.connection.logger.logQuery(query, parameters), this.options.serviceConfigOptions, this.options.formatOptions);
        this.database = DriverUtils_1.DriverUtils.buildDriverOptions(this.options).database;
      }
      // -------------------------------------------------------------------------
      // Public Implemented Methods
      // -------------------------------------------------------------------------
      /**
       * Performs connection to the database.
       * Based on pooling options, it can either create connection immediately,
       * either create a pool and create connection when needed.
       */
      async connect() {
      }
      /**
       * Closes connection with database.
       */
      async disconnect() {
      }
      /**
       * Creates a query runner used to execute database queries.
       */
      createQueryRunner(mode) {
        return new AuroraPostgresQueryRunner_1.AuroraPostgresQueryRunner(this, new this.DataApiDriver(this.options.region, this.options.secretArn, this.options.resourceArn, this.options.database, (query, parameters) => this.connection.logger.logQuery(query, parameters), this.options.serviceConfigOptions, this.options.formatOptions), mode);
      }
      /**
       * Prepares given value to a value to be persisted, based on its column type and metadata.
       */
      preparePersistentValue(value, columnMetadata) {
        if (this.options.formatOptions && this.options.formatOptions.castParameters === false) {
          return super.preparePersistentValue(value, columnMetadata);
        }
        if (columnMetadata.transformer)
          value = ApplyValueTransformers_1.ApplyValueTransformers.transformTo(columnMetadata.transformer, value);
        return this.client.preparePersistentValue(value, columnMetadata);
      }
      /**
       * Prepares given value to a value to be persisted, based on its column type and metadata.
       */
      prepareHydratedValue(value, columnMetadata) {
        if (this.options.formatOptions && this.options.formatOptions.castParameters === false) {
          return super.prepareHydratedValue(value, columnMetadata);
        }
        if (columnMetadata.transformer)
          value = ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);
        return this.client.prepareHydratedValue(value, columnMetadata);
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * If driver dependency is not given explicitly, then try to load it via "require".
       */
      loadDependencies() {
        const driver = this.options.driver || PlatformTools_1.PlatformTools.load("typeorm-aurora-data-api-driver");
        const { pg } = driver;
        this.DataApiDriver = pg;
      }
      /**
       * Executes given query.
       */
      executeQuery(connection, query) {
        return this.connection.query(query);
      }
      /**
       * Makes any action after connection (e.g. create extensions in Postgres driver).
       */
      async afterConnect() {
        const extensionsMetadata = await this.checkMetadataForExtensions();
        if (extensionsMetadata.hasExtensions) {
          await this.enableExtensions(extensionsMetadata, this.connection);
        }
        return Promise.resolve();
      }
    };
    exports2.AuroraPostgresDriver = AuroraPostgresDriver;
  }
});

// node_modules/typeorm/driver/sap/SapQueryRunner.js
var require_SapQueryRunner = __commonJS({
  "node_modules/typeorm/driver/sap/SapQueryRunner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SapQueryRunner = void 0;
    var node_util_1 = require("node:util");
    var error_1 = require_error();
    var QueryRunnerAlreadyReleasedError_1 = require_QueryRunnerAlreadyReleasedError();
    var TransactionAlreadyStartedError_1 = require_TransactionAlreadyStartedError();
    var TransactionNotStartedError_1 = require_TransactionNotStartedError();
    var BaseQueryRunner_1 = require_BaseQueryRunner();
    var QueryLock_1 = require_QueryLock();
    var QueryResult_1 = require_QueryResult();
    var Table_1 = require_Table();
    var TableCheck_1 = require_TableCheck();
    var TableColumn_1 = require_TableColumn();
    var TableForeignKey_1 = require_TableForeignKey();
    var TableIndex_1 = require_TableIndex();
    var TableUnique_1 = require_TableUnique();
    var View_1 = require_View();
    var Broadcaster_1 = require_Broadcaster();
    var BroadcasterResult_1 = require_BroadcasterResult();
    var InstanceChecker_1 = require_InstanceChecker();
    var OrmUtils_1 = require_OrmUtils();
    var Query_1 = require_Query();
    var MetadataTableType_1 = require_MetadataTableType();
    var SapQueryRunner = class extends BaseQueryRunner_1.BaseQueryRunner {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(driver, mode) {
        super();
        this.lock = new QueryLock_1.QueryLock();
        this.driver = driver;
        this.connection = driver.connection;
        this.broadcaster = new Broadcaster_1.Broadcaster(this);
        this.mode = mode;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Creates/uses database connection from the connection pool to perform further operations.
       * Returns obtained database connection.
       */
      async connect() {
        if (this.databaseConnection)
          return this.databaseConnection;
        this.databaseConnection = await this.driver.obtainMasterConnection();
        return this.databaseConnection;
      }
      /**
       * Releases used database connection.
       * You cannot use query runner methods once its released.
       */
      async release() {
        this.isReleased = true;
        if (this.databaseConnection) {
          try {
            await (0, node_util_1.promisify)(this.databaseConnection.disconnect).call(this.databaseConnection);
          } catch (error) {
            this.driver.poolErrorHandler(error);
            throw error;
          }
        }
      }
      /**
       * Starts transaction.
       */
      async startTransaction(isolationLevel) {
        if (this.isReleased)
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        if (this.isTransactionActive && this.driver.transactionSupport === "simple")
          throw new TransactionAlreadyStartedError_1.TransactionAlreadyStartedError();
        await this.broadcaster.broadcast("BeforeTransactionStart");
        this.isTransactionActive = true;
        await this.setAutoCommit({ status: "off" });
        if (isolationLevel) {
          await this.query(`SET TRANSACTION ISOLATION LEVEL ${isolationLevel || ""}`);
        }
        await this.broadcaster.broadcast("AfterTransactionStart");
      }
      /**
       * Commits transaction.
       * Error will be thrown if transaction was not started.
       */
      async commitTransaction() {
        if (this.isReleased)
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        if (!this.isTransactionActive)
          throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionCommit");
        await this.query("COMMIT");
        this.isTransactionActive = false;
        await this.setAutoCommit({ status: "on" });
        await this.broadcaster.broadcast("AfterTransactionCommit");
      }
      /**
       * Rollbacks transaction.
       * Error will be thrown if transaction was not started.
       */
      async rollbackTransaction() {
        if (this.isReleased)
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        if (!this.isTransactionActive)
          throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionRollback");
        await this.query("ROLLBACK");
        this.isTransactionActive = false;
        await this.setAutoCommit({ status: "on" });
        await this.broadcaster.broadcast("AfterTransactionRollback");
      }
      /**
       * @description Switches on/off AUTOCOMMIT mode
       * @link https://help.sap.com/docs/HANA_SERVICE_CF/7c78579ce9b14a669c1f3295b0d8ca16/d538d11053bd4f3f847ec5ce817a3d4c.html?locale=en-US
       */
      async setAutoCommit(options) {
        const connection = await this.connect();
        connection.setAutoCommit(options.status === "on");
        const query = `SET TRANSACTION AUTOCOMMIT DDL ${options.status.toUpperCase()}`;
        this.driver.connection.logger.logQuery(query, [], this);
        try {
          await (0, node_util_1.promisify)(connection.exec).call(connection, query);
        } catch (error) {
          throw new error_1.QueryFailedError(query, [], error);
        }
      }
      /**
       * Executes a given SQL query.
       */
      async query(query, parameters, useStructuredResult = false) {
        if (this.isReleased)
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        const release = await this.lock.acquire();
        const databaseConnection = await this.connect();
        let statement;
        const result = new QueryResult_1.QueryResult();
        this.driver.connection.logger.logQuery(query, parameters, this);
        await this.broadcaster.broadcast("BeforeQuery", query, parameters);
        const broadcasterResult = new BroadcasterResult_1.BroadcasterResult();
        try {
          const queryStartTime = Date.now();
          const isInsertQuery = query.substr(0, 11) === "INSERT INTO";
          if (parameters?.some(Array.isArray)) {
            statement = await (0, node_util_1.promisify)(databaseConnection.prepare).call(databaseConnection, query);
          }
          let raw;
          try {
            raw = statement ? await (0, node_util_1.promisify)(statement.exec).call(statement, parameters) : await (0, node_util_1.promisify)(databaseConnection.exec).call(databaseConnection, query, parameters, {});
          } catch (err) {
            throw new error_1.QueryFailedError(query, parameters, err);
          }
          const maxQueryExecutionTime = this.driver.connection.options.maxQueryExecutionTime;
          const queryEndTime = Date.now();
          const queryExecutionTime = queryEndTime - queryStartTime;
          this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, raw, void 0);
          if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) {
            this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
          }
          if (typeof raw === "number") {
            result.affected = raw;
          } else if (Array.isArray(raw)) {
            result.records = raw;
          }
          result.raw = raw;
          if (isInsertQuery) {
            const lastIdQuery = `SELECT CURRENT_IDENTITY_VALUE() FROM "SYS"."DUMMY"`;
            this.driver.connection.logger.logQuery(lastIdQuery, [], this);
            try {
              const identityValueResult = await (0, node_util_1.promisify)(databaseConnection.exec).call(databaseConnection, lastIdQuery);
              result.raw = identityValueResult[0]["CURRENT_IDENTITY_VALUE()"];
              result.records = identityValueResult;
            } catch (error) {
              throw new error_1.QueryFailedError(lastIdQuery, [], error);
            }
          }
        } catch (err) {
          this.driver.connection.logger.logQueryError(err, query, parameters, this);
          this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, void 0, void 0, err);
          throw err;
        } finally {
          if (statement?.drop) {
            await (0, node_util_1.promisify)(statement.drop).call(statement);
          }
          await broadcasterResult.wait();
          release();
        }
        if (useStructuredResult) {
          return result;
        } else {
          return result.raw;
        }
      }
      /**
       * Returns raw data stream.
       */
      async stream(query, parameters, onEnd, onError) {
        if (this.isReleased)
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        const release = await this.lock.acquire();
        let statement;
        let resultSet;
        const cleanup = async () => {
          const originalStatement = statement;
          const originalResultSet = resultSet;
          statement = null;
          resultSet = null;
          if (originalResultSet) {
            await (0, node_util_1.promisify)(originalResultSet.close).call(originalResultSet);
          }
          if (originalStatement) {
            await (0, node_util_1.promisify)(originalStatement.drop).call(originalStatement);
          }
          release();
        };
        try {
          const databaseConnection = await this.connect();
          this.driver.connection.logger.logQuery(query, parameters, this);
          statement = await (0, node_util_1.promisify)(databaseConnection.prepare).call(databaseConnection, query);
          resultSet = await (0, node_util_1.promisify)(statement.executeQuery).call(statement, parameters);
          const stream = this.driver.streamClient.createObjectStream(resultSet);
          if (onEnd) {
            stream.on("end", onEnd);
          }
          stream.on("error", (error) => {
            this.driver.connection.logger.logQueryError(error, query, parameters, this);
            onError?.(error);
          });
          stream.on("close", cleanup);
          return stream;
        } catch (error) {
          this.driver.connection.logger.logQueryError(error, query, parameters, this);
          await cleanup();
          throw new error_1.QueryFailedError(query, parameters, error);
        }
      }
      /**
       * Returns all available database names including system databases.
       */
      async getDatabases() {
        const results = await this.query(`SELECT DATABASE_NAME FROM "SYS"."M_DATABASES"`);
        return results.map((result) => result["DATABASE_NAME"]);
      }
      /**
       * Returns all available schema names including system schemas.
       * If database parameter specified, returns schemas of that database.
       */
      async getSchemas(database) {
        const query = database ? `SELECT * FROM "${database}"."SYS"."SCHEMAS"` : `SELECT * FROM "SYS"."SCHEMAS"`;
        const results = await this.query(query);
        return results.map((result) => result["SCHEMA_NAME"]);
      }
      /**
       * Checks if database with the given name exist.
       */
      async hasDatabase(database) {
        const databases = await this.getDatabases();
        return databases.indexOf(database) !== -1;
      }
      /**
       * Returns current database.
       */
      async getCurrentDatabase() {
        const currentDBQuery = await this.query(`SELECT "DATABASE_NAME" AS "dbName" FROM "SYS"."M_DATABASE"`);
        return currentDBQuery[0].dbName;
      }
      /**
       * Returns the database server version.
       */
      async getDatabaseAndVersion() {
        const currentDBQuery = await this.query(`SELECT  "DATABASE_NAME" AS "database", "VERSION" AS "version" FROM "SYS"."M_DATABASE"`);
        return currentDBQuery[0];
      }
      /**
       * Checks if schema with the given name exist.
       */
      async hasSchema(schema) {
        const schemas = await this.getSchemas();
        return schemas.indexOf(schema) !== -1;
      }
      /**
       * Returns current schema.
       */
      async getCurrentSchema() {
        const currentSchemaQuery = await this.query(`SELECT CURRENT_SCHEMA AS "schemaName" FROM "SYS"."DUMMY"`);
        return currentSchemaQuery[0].schemaName;
      }
      /**
       * Checks if table with the given name exist in the database.
       */
      async hasTable(tableOrName) {
        const parsedTableName = this.driver.parseTableName(tableOrName);
        if (!parsedTableName.schema) {
          parsedTableName.schema = await this.getCurrentSchema();
        }
        const sql = `SELECT COUNT(*) as "hasTable" FROM "SYS"."TABLES" WHERE "SCHEMA_NAME" = '${parsedTableName.schema}' AND "TABLE_NAME" = '${parsedTableName.tableName}'`;
        const result = await this.query(sql);
        return result[0].hasTable > 0;
      }
      /**
       * Checks if column with the given name exist in the given table.
       */
      async hasColumn(tableOrName, columnName) {
        const parsedTableName = this.driver.parseTableName(tableOrName);
        if (!parsedTableName.schema) {
          parsedTableName.schema = await this.getCurrentSchema();
        }
        const sql = `SELECT COUNT(*) as "hasColumn" FROM "SYS"."TABLE_COLUMNS" WHERE "SCHEMA_NAME" = '${parsedTableName.schema}' AND "TABLE_NAME" = '${parsedTableName.tableName}' AND "COLUMN_NAME" = '${columnName}'`;
        const result = await this.query(sql);
        return result[0].hasColumn > 0;
      }
      /**
       * Creates a new database.
       */
      async createDatabase(database, ifNotExist) {
        return Promise.resolve();
      }
      /**
       * Drops database.
       */
      async dropDatabase(database, ifExist) {
        return Promise.resolve();
      }
      /**
       * Creates a new table schema.
       */
      async createSchema(schemaPath, ifNotExist) {
        const schema = schemaPath.indexOf(".") === -1 ? schemaPath : schemaPath.split(".")[1];
        let exist = false;
        if (ifNotExist) {
          const result = await this.query(`SELECT * FROM "SYS"."SCHEMAS" WHERE "SCHEMA_NAME" = '${schema}'`);
          exist = !!result.length;
        }
        if (!ifNotExist || ifNotExist && !exist) {
          const up = `CREATE SCHEMA "${schema}"`;
          const down = `DROP SCHEMA "${schema}" CASCADE`;
          await this.executeQueries(new Query_1.Query(up), new Query_1.Query(down));
        }
      }
      /**
       * Drops table schema
       */
      async dropSchema(schemaPath, ifExist, isCascade) {
        const schema = schemaPath.indexOf(".") === -1 ? schemaPath : schemaPath.split(".")[0];
        let exist = false;
        if (ifExist) {
          const result = await this.query(`SELECT * FROM "SYS"."SCHEMAS" WHERE "SCHEMA_NAME" = '${schema}'`);
          exist = !!result.length;
        }
        if (!ifExist || ifExist && exist) {
          const up = `DROP SCHEMA "${schema}" ${isCascade ? "CASCADE" : ""}`;
          const down = `CREATE SCHEMA "${schema}"`;
          await this.executeQueries(new Query_1.Query(up), new Query_1.Query(down));
        }
      }
      /**
       * Creates a new table.
       */
      async createTable(table, ifNotExist = false, createForeignKeys = true, createIndices = true) {
        if (ifNotExist) {
          const isTableExist = await this.hasTable(table);
          if (isTableExist)
            return Promise.resolve();
        }
        const upQueries = [];
        const downQueries = [];
        upQueries.push(this.createTableSql(table, createForeignKeys));
        downQueries.push(this.dropTableSql(table));
        if (createForeignKeys)
          table.foreignKeys.forEach((foreignKey) => downQueries.push(this.dropForeignKeySql(table, foreignKey)));
        if (createIndices) {
          table.indices.forEach((index) => {
            if (!index.name)
              index.name = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);
            upQueries.push(this.createIndexSql(table, index));
            downQueries.push(this.dropIndexSql(table, index));
          });
        }
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Drops the table.
       */
      async dropTable(tableOrName, ifExist, dropForeignKeys = true, dropIndices = true) {
        if (ifExist) {
          const isTableExist = await this.hasTable(tableOrName);
          if (!isTableExist)
            return Promise.resolve();
        }
        const createForeignKeys = dropForeignKeys;
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const upQueries = [];
        const downQueries = [];
        if (dropIndices) {
          table.indices.forEach((index) => {
            upQueries.push(this.dropIndexSql(table, index));
            downQueries.push(this.createIndexSql(table, index));
          });
        }
        if (dropForeignKeys)
          table.foreignKeys.forEach((foreignKey) => upQueries.push(this.dropForeignKeySql(table, foreignKey)));
        upQueries.push(this.dropTableSql(table));
        downQueries.push(this.createTableSql(table, createForeignKeys));
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Creates a new view.
       */
      async createView(view, syncWithMetadata = false) {
        const upQueries = [];
        const downQueries = [];
        upQueries.push(this.createViewSql(view));
        if (syncWithMetadata)
          upQueries.push(await this.insertViewDefinitionSql(view));
        downQueries.push(this.dropViewSql(view));
        if (syncWithMetadata)
          downQueries.push(await this.deleteViewDefinitionSql(view));
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Drops the view.
       */
      async dropView(target) {
        const viewName = InstanceChecker_1.InstanceChecker.isView(target) ? target.name : target;
        const view = await this.getCachedView(viewName);
        const upQueries = [];
        const downQueries = [];
        upQueries.push(await this.deleteViewDefinitionSql(view));
        upQueries.push(this.dropViewSql(view));
        downQueries.push(await this.insertViewDefinitionSql(view));
        downQueries.push(this.createViewSql(view));
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Renames a table.
       */
      async renameTable(oldTableOrName, newTableName) {
        const upQueries = [];
        const downQueries = [];
        const oldTable = InstanceChecker_1.InstanceChecker.isTable(oldTableOrName) ? oldTableOrName : await this.getCachedTable(oldTableOrName);
        const newTable = oldTable.clone();
        const { schema: schemaName, tableName: oldTableName } = this.driver.parseTableName(oldTable);
        newTable.name = schemaName ? `${schemaName}.${newTableName}` : newTableName;
        upQueries.push(new Query_1.Query(`RENAME TABLE ${this.escapePath(oldTable)} TO ${this.escapePath(newTable)}`));
        downQueries.push(new Query_1.Query(`RENAME TABLE ${this.escapePath(newTable)} TO ${this.escapePath(oldTable)}`));
        newTable.foreignKeys.forEach((foreignKey) => {
          upQueries.push(this.dropForeignKeySql(newTable, foreignKey));
          downQueries.push(this.createForeignKeySql(newTable, foreignKey));
        });
        const referencedForeignKeySql = `SELECT * FROM "SYS"."REFERENTIAL_CONSTRAINTS" WHERE "REFERENCED_SCHEMA_NAME" = '${schemaName}' AND "REFERENCED_TABLE_NAME" = '${oldTableName}'`;
        const dbForeignKeys = await this.query(referencedForeignKeySql);
        let referencedForeignKeys = [];
        const referencedForeignKeyTableMapping = [];
        if (dbForeignKeys.length > 0) {
          referencedForeignKeys = dbForeignKeys.map((dbForeignKey) => {
            const foreignKeys = dbForeignKeys.filter((dbFk) => dbFk["CONSTRAINT_NAME"] === dbForeignKey["CONSTRAINT_NAME"]);
            referencedForeignKeyTableMapping.push({
              tableName: `${dbForeignKey["SCHEMA_NAME"]}.${dbForeignKey["TABLE_NAME"]}`,
              fkName: dbForeignKey["CONSTRAINT_NAME"]
            });
            return new TableForeignKey_1.TableForeignKey({
              name: dbForeignKey["CONSTRAINT_NAME"],
              columnNames: foreignKeys.map((dbFk) => dbFk["COLUMN_NAME"]),
              referencedDatabase: newTable.database,
              referencedSchema: newTable.schema,
              referencedTableName: newTable.name,
              // we use renamed table name
              referencedColumnNames: foreignKeys.map((dbFk) => dbFk["REFERENCED_COLUMN_NAME"]),
              onDelete: dbForeignKey["DELETE_RULE"] === "RESTRICT" ? "NO ACTION" : dbForeignKey["DELETE_RULE"],
              onUpdate: dbForeignKey["UPDATE_RULE"] === "RESTRICT" ? "NO ACTION" : dbForeignKey["UPDATE_RULE"],
              deferrable: dbForeignKey["CHECK_TIME"].replace("_", " ")
              // "CHECK_TIME" is "INITIALLY_IMMEDIATE" or "INITIALLY DEFERRED"
            });
          });
          referencedForeignKeys.forEach((foreignKey) => {
            const mapping = referencedForeignKeyTableMapping.find((it) => it.fkName === foreignKey.name);
            upQueries.push(this.dropForeignKeySql(mapping.tableName, foreignKey));
            downQueries.push(this.createForeignKeySql(mapping.tableName, foreignKey));
          });
        }
        if (newTable.primaryColumns.length > 0) {
          const columnNames = newTable.primaryColumns.map((column) => column.name);
          const columnNamesString = columnNames.map((columnName) => `"${columnName}"`).join(", ");
          const oldPkName = this.connection.namingStrategy.primaryKeyName(oldTable, columnNames);
          const newPkName = this.connection.namingStrategy.primaryKeyName(newTable, columnNames);
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} DROP CONSTRAINT "${oldPkName}"`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} ADD CONSTRAINT "${oldPkName}" PRIMARY KEY (${columnNamesString})`));
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} ADD CONSTRAINT "${newPkName}" PRIMARY KEY (${columnNamesString})`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} DROP CONSTRAINT "${newPkName}"`));
        }
        newTable.foreignKeys.forEach((foreignKey) => {
          foreignKey.name = this.connection.namingStrategy.foreignKeyName(newTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
          upQueries.push(this.createForeignKeySql(newTable, foreignKey));
          downQueries.push(this.dropForeignKeySql(newTable, foreignKey));
        });
        referencedForeignKeys.forEach((foreignKey) => {
          const mapping = referencedForeignKeyTableMapping.find((it) => it.fkName === foreignKey.name);
          upQueries.push(this.createForeignKeySql(mapping.tableName, foreignKey));
          downQueries.push(this.dropForeignKeySql(mapping.tableName, foreignKey));
        });
        newTable.indices.forEach((index) => {
          const newIndexName = this.connection.namingStrategy.indexName(newTable, index.columnNames, index.where);
          upQueries.push(this.dropIndexSql(newTable, index));
          downQueries.push(this.createIndexSql(newTable, index));
          index.name = newIndexName;
          upQueries.push(this.createIndexSql(newTable, index));
          downQueries.push(this.dropIndexSql(newTable, index));
        });
        await this.executeQueries(upQueries, downQueries);
        oldTable.name = newTable.name;
        this.replaceCachedTable(oldTable, newTable);
      }
      /**
       * Creates a new column from the column in the table.
       */
      async addColumn(tableOrName, column) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const parsedTableName = this.driver.parseTableName(table);
        if (!parsedTableName.schema) {
          parsedTableName.schema = await this.getCurrentSchema();
        }
        const clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        upQueries.push(new Query_1.Query(this.addColumnSql(table, column)));
        downQueries.push(new Query_1.Query(this.dropColumnSql(table, column)));
        if (column.isPrimary) {
          const primaryColumns = clonedTable.primaryColumns;
          if (primaryColumns.length > 0) {
            const referencedForeignKeySql = `SELECT * FROM "SYS"."REFERENTIAL_CONSTRAINTS" WHERE "REFERENCED_SCHEMA_NAME" = '${parsedTableName.schema}' AND "REFERENCED_TABLE_NAME" = '${parsedTableName.tableName}'`;
            const dbForeignKeys = await this.query(referencedForeignKeySql);
            let referencedForeignKeys = [];
            const referencedForeignKeyTableMapping = [];
            if (dbForeignKeys.length > 0) {
              referencedForeignKeys = dbForeignKeys.map((dbForeignKey) => {
                const foreignKeys = dbForeignKeys.filter((dbFk) => dbFk["CONSTRAINT_NAME"] === dbForeignKey["CONSTRAINT_NAME"]);
                referencedForeignKeyTableMapping.push({
                  tableName: `${dbForeignKey["SCHEMA_NAME"]}.${dbForeignKey["TABLE_NAME"]}`,
                  fkName: dbForeignKey["CONSTRAINT_NAME"]
                });
                return new TableForeignKey_1.TableForeignKey({
                  name: dbForeignKey["CONSTRAINT_NAME"],
                  columnNames: foreignKeys.map((dbFk) => dbFk["COLUMN_NAME"]),
                  referencedDatabase: table.database,
                  referencedSchema: table.schema,
                  referencedTableName: table.name,
                  referencedColumnNames: foreignKeys.map((dbFk) => dbFk["REFERENCED_COLUMN_NAME"]),
                  onDelete: dbForeignKey["DELETE_RULE"] === "RESTRICT" ? "NO ACTION" : dbForeignKey["DELETE_RULE"],
                  onUpdate: dbForeignKey["UPDATE_RULE"] === "RESTRICT" ? "NO ACTION" : dbForeignKey["UPDATE_RULE"],
                  deferrable: dbForeignKey["CHECK_TIME"].replace("_", " ")
                });
              });
              referencedForeignKeys.forEach((foreignKey) => {
                const mapping = referencedForeignKeyTableMapping.find((it) => it.fkName === foreignKey.name);
                upQueries.push(this.dropForeignKeySql(mapping.tableName, foreignKey));
                downQueries.push(this.createForeignKeySql(mapping.tableName, foreignKey));
              });
            }
            const pkName2 = this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column2) => column2.name));
            const columnNames2 = primaryColumns.map((column2) => `"${column2.name}"`).join(", ");
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName2}"`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName2}" PRIMARY KEY (${columnNames2})`));
            referencedForeignKeys.forEach((foreignKey) => {
              const mapping = referencedForeignKeyTableMapping.find((it) => it.fkName === foreignKey.name);
              upQueries.push(this.createForeignKeySql(mapping.tableName, foreignKey));
              downQueries.push(this.dropForeignKeySql(mapping.tableName, foreignKey));
            });
          }
          primaryColumns.push(column);
          const pkName = this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column2) => column2.name));
          const columnNames = primaryColumns.map((column2) => `"${column2.name}"`).join(", ");
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
        }
        const columnIndex = clonedTable.indices.find((index) => index.columnNames.length === 1 && index.columnNames[0] === column.name);
        if (columnIndex) {
          upQueries.push(this.createIndexSql(table, columnIndex));
          downQueries.push(this.dropIndexSql(table, columnIndex));
        } else if (column.isUnique) {
          const uniqueIndex = new TableIndex_1.TableIndex({
            name: this.connection.namingStrategy.indexName(table, [
              column.name
            ]),
            columnNames: [column.name],
            isUnique: true
          });
          clonedTable.indices.push(uniqueIndex);
          clonedTable.uniques.push(new TableUnique_1.TableUnique({
            name: uniqueIndex.name,
            columnNames: uniqueIndex.columnNames
          }));
          upQueries.push(this.createIndexSql(table, uniqueIndex));
          downQueries.push(this.dropIndexSql(table, uniqueIndex));
        }
        await this.executeQueries(upQueries, downQueries);
        clonedTable.addColumn(column);
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Creates a new columns from the column in the table.
       */
      async addColumns(tableOrName, columns) {
        for (const column of columns) {
          await this.addColumn(tableOrName, column);
        }
      }
      /**
       * Renames column in the given table.
       */
      async renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const oldColumn = InstanceChecker_1.InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find((c) => c.name === oldTableColumnOrName);
        if (!oldColumn)
          throw new error_1.TypeORMError(`Column "${oldTableColumnOrName}" was not found in the "${table.name}" table.`);
        let newColumn = void 0;
        if (InstanceChecker_1.InstanceChecker.isTableColumn(newTableColumnOrName)) {
          newColumn = newTableColumnOrName;
        } else {
          newColumn = oldColumn.clone();
          newColumn.name = newTableColumnOrName;
        }
        await this.changeColumn(table, oldColumn, newColumn);
      }
      /**
       * Changes a column in the table.
       */
      async changeColumn(tableOrName, oldTableColumnOrName, newColumn) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        let clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        const oldColumn = InstanceChecker_1.InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find((column) => column.name === oldTableColumnOrName);
        if (!oldColumn)
          throw new error_1.TypeORMError(`Column "${oldTableColumnOrName}" was not found in the "${table.name}" table.`);
        if (newColumn.isGenerated !== oldColumn.isGenerated && newColumn.generationStrategy !== "uuid" || newColumn.type !== oldColumn.type || newColumn.length !== oldColumn.length) {
          await this.dropColumn(table, oldColumn);
          await this.addColumn(table, newColumn);
          clonedTable = table.clone();
        } else {
          if (newColumn.name !== oldColumn.name) {
            upQueries.push(new Query_1.Query(`RENAME COLUMN ${this.escapePath(table)}."${oldColumn.name}" TO "${newColumn.name}"`));
            downQueries.push(new Query_1.Query(`RENAME COLUMN ${this.escapePath(table)}."${newColumn.name}" TO "${oldColumn.name}"`));
            if (oldColumn.isPrimary === true) {
              const primaryColumns = clonedTable.primaryColumns;
              const columnNames = primaryColumns.map((column) => column.name);
              const oldPkName = this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);
              columnNames.splice(columnNames.indexOf(oldColumn.name), 1);
              columnNames.push(newColumn.name);
              const columnNamesString = columnNames.map((columnName) => `"${columnName}"`).join(", ");
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP CONSTRAINT "${oldPkName}"`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD CONSTRAINT "${oldPkName}" PRIMARY KEY (${columnNamesString})`));
              const newPkName = this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD CONSTRAINT "${newPkName}" PRIMARY KEY (${columnNamesString})`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP CONSTRAINT "${newPkName}"`));
            }
            clonedTable.findColumnIndices(oldColumn).forEach((index) => {
              index.columnNames.splice(index.columnNames.indexOf(oldColumn.name), 1);
              index.columnNames.push(newColumn.name);
              const newIndexName = this.connection.namingStrategy.indexName(clonedTable, index.columnNames, index.where);
              upQueries.push(this.dropIndexSql(clonedTable, index));
              downQueries.push(this.createIndexSql(clonedTable, index));
              index.name = newIndexName;
              upQueries.push(this.createIndexSql(clonedTable, index));
              downQueries.push(this.dropIndexSql(clonedTable, index));
            });
            clonedTable.findColumnForeignKeys(oldColumn).forEach((foreignKey) => {
              foreignKey.columnNames.splice(foreignKey.columnNames.indexOf(oldColumn.name), 1);
              foreignKey.columnNames.push(newColumn.name);
              const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(clonedTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
              upQueries.push(this.dropForeignKeySql(clonedTable, foreignKey));
              downQueries.push(this.createForeignKeySql(clonedTable, foreignKey));
              foreignKey.name = newForeignKeyName;
              upQueries.push(this.createForeignKeySql(clonedTable, foreignKey));
              downQueries.push(this.dropForeignKeySql(clonedTable, foreignKey));
            });
            clonedTable.findColumnChecks(oldColumn).forEach((check) => {
              check.columnNames.splice(check.columnNames.indexOf(oldColumn.name), 1);
              check.columnNames.push(newColumn.name);
              const newCheckName = this.connection.namingStrategy.checkConstraintName(clonedTable, check.expression);
              upQueries.push(this.dropCheckConstraintSql(clonedTable, check));
              downQueries.push(this.createCheckConstraintSql(clonedTable, check));
              check.name = newCheckName;
              upQueries.push(this.createCheckConstraintSql(clonedTable, check));
              downQueries.push(this.dropCheckConstraintSql(clonedTable, check));
            });
            const oldTableColumn = clonedTable.columns.find((column) => column.name === oldColumn.name);
            clonedTable.columns[clonedTable.columns.indexOf(oldTableColumn)].name = newColumn.name;
            oldColumn.name = newColumn.name;
          }
          if (this.isColumnChanged(oldColumn, newColumn, true)) {
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER (${this.buildCreateColumnSql(newColumn, !(oldColumn.default === null || oldColumn.default === void 0), !oldColumn.isNullable)})`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER (${this.buildCreateColumnSql(oldColumn, !(newColumn.default === null || newColumn.default === void 0), !newColumn.isNullable)})`));
          } else if (oldColumn.comment !== newColumn.comment) {
            upQueries.push(new Query_1.Query(`COMMENT ON COLUMN ${this.escapePath(table)}."${oldColumn.name}" IS ${this.escapeComment(newColumn.comment)}`));
            downQueries.push(new Query_1.Query(`COMMENT ON COLUMN ${this.escapePath(table)}."${newColumn.name}" IS ${this.escapeComment(oldColumn.comment)}`));
          }
          if (newColumn.isPrimary !== oldColumn.isPrimary) {
            const primaryColumns = clonedTable.primaryColumns;
            if (primaryColumns.length > 0) {
              const pkName = this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column) => column.name));
              const columnNames = primaryColumns.map((column) => `"${column.name}"`).join(", ");
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
            }
            if (newColumn.isPrimary === true) {
              primaryColumns.push(newColumn);
              const column = clonedTable.columns.find((column2) => column2.name === newColumn.name);
              column.isPrimary = true;
              const pkName = this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column2) => column2.name));
              const columnNames = primaryColumns.map((column2) => `"${column2.name}"`).join(", ");
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
            } else {
              const primaryColumn = primaryColumns.find((c) => c.name === newColumn.name);
              primaryColumns.splice(primaryColumns.indexOf(primaryColumn), 1);
              const column = clonedTable.columns.find((column2) => column2.name === newColumn.name);
              column.isPrimary = false;
              if (primaryColumns.length > 0) {
                const pkName = this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column2) => column2.name));
                const columnNames = primaryColumns.map((column2) => `"${column2.name}"`).join(", ");
                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
              }
            }
          }
          if (newColumn.isUnique !== oldColumn.isUnique) {
            if (newColumn.isUnique === true) {
              const uniqueIndex = new TableIndex_1.TableIndex({
                name: this.connection.namingStrategy.indexName(table, [
                  newColumn.name
                ]),
                columnNames: [newColumn.name],
                isUnique: true
              });
              clonedTable.indices.push(uniqueIndex);
              clonedTable.uniques.push(new TableUnique_1.TableUnique({
                name: uniqueIndex.name,
                columnNames: uniqueIndex.columnNames
              }));
              upQueries.push(this.createIndexSql(table, uniqueIndex));
              downQueries.push(this.dropIndexSql(table, uniqueIndex));
            } else {
              const uniqueIndex = clonedTable.indices.find((index) => {
                return index.columnNames.length === 1 && index.isUnique === true && !!index.columnNames.find((columnName) => columnName === newColumn.name);
              });
              clonedTable.indices.splice(clonedTable.indices.indexOf(uniqueIndex), 1);
              const tableUnique = clonedTable.uniques.find((unique) => unique.name === uniqueIndex.name);
              clonedTable.uniques.splice(clonedTable.uniques.indexOf(tableUnique), 1);
              upQueries.push(this.dropIndexSql(table, uniqueIndex));
              downQueries.push(this.createIndexSql(table, uniqueIndex));
            }
          }
          await this.executeQueries(upQueries, downQueries);
          this.replaceCachedTable(table, clonedTable);
        }
      }
      /**
       * Changes a column in the table.
       */
      async changeColumns(tableOrName, changedColumns) {
        for (const { oldColumn, newColumn } of changedColumns) {
          await this.changeColumn(tableOrName, oldColumn, newColumn);
        }
      }
      /**
       * Drops column in the table.
       */
      async dropColumn(tableOrName, columnOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const parsedTableName = this.driver.parseTableName(table);
        if (!parsedTableName.schema) {
          parsedTableName.schema = await this.getCurrentSchema();
        }
        const column = InstanceChecker_1.InstanceChecker.isTableColumn(columnOrName) ? columnOrName : table.findColumnByName(columnOrName);
        if (!column)
          throw new error_1.TypeORMError(`Column "${columnOrName}" was not found in table "${table.name}"`);
        const clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        if (column.isPrimary) {
          const referencedForeignKeySql = `SELECT * FROM "SYS"."REFERENTIAL_CONSTRAINTS" WHERE "REFERENCED_SCHEMA_NAME" = '${parsedTableName.schema}' AND "REFERENCED_TABLE_NAME" = '${parsedTableName.tableName}'`;
          const dbForeignKeys = await this.query(referencedForeignKeySql);
          let referencedForeignKeys = [];
          const referencedForeignKeyTableMapping = [];
          if (dbForeignKeys.length > 0) {
            referencedForeignKeys = dbForeignKeys.map((dbForeignKey) => {
              const foreignKeys = dbForeignKeys.filter((dbFk) => dbFk["CONSTRAINT_NAME"] === dbForeignKey["CONSTRAINT_NAME"]);
              referencedForeignKeyTableMapping.push({
                tableName: `${dbForeignKey["SCHEMA_NAME"]}.${dbForeignKey["TABLE_NAME"]}`,
                fkName: dbForeignKey["CONSTRAINT_NAME"]
              });
              return new TableForeignKey_1.TableForeignKey({
                name: dbForeignKey["CONSTRAINT_NAME"],
                columnNames: foreignKeys.map((dbFk) => dbFk["COLUMN_NAME"]),
                referencedDatabase: table.database,
                referencedSchema: table.schema,
                referencedTableName: table.name,
                referencedColumnNames: foreignKeys.map((dbFk) => dbFk["REFERENCED_COLUMN_NAME"]),
                onDelete: dbForeignKey["DELETE_RULE"] === "RESTRICT" ? "NO ACTION" : dbForeignKey["DELETE_RULE"],
                onUpdate: dbForeignKey["UPDATE_RULE"] === "RESTRICT" ? "NO ACTION" : dbForeignKey["UPDATE_RULE"],
                deferrable: dbForeignKey["CHECK_TIME"].replace("_", " ")
              });
            });
            referencedForeignKeys.forEach((foreignKey) => {
              const mapping = referencedForeignKeyTableMapping.find((it) => it.fkName === foreignKey.name);
              upQueries.push(this.dropForeignKeySql(mapping.tableName, foreignKey));
              downQueries.push(this.createForeignKeySql(mapping.tableName, foreignKey));
            });
          }
          const pkName = this.connection.namingStrategy.primaryKeyName(clonedTable, clonedTable.primaryColumns.map((column2) => column2.name));
          const columnNames = clonedTable.primaryColumns.map((primaryColumn) => `"${primaryColumn.name}"`).join(", ");
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP CONSTRAINT "${pkName}"`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
          const tableColumn = clonedTable.findColumnByName(column.name);
          tableColumn.isPrimary = false;
          if (clonedTable.primaryColumns.length > 0) {
            const pkName2 = this.connection.namingStrategy.primaryKeyName(clonedTable, clonedTable.primaryColumns.map((column2) => column2.name));
            const columnNames2 = clonedTable.primaryColumns.map((primaryColumn) => `"${primaryColumn.name}"`).join(", ");
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD CONSTRAINT "${pkName2}" PRIMARY KEY (${columnNames2})`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP CONSTRAINT "${pkName2}"`));
          }
          referencedForeignKeys.forEach((foreignKey) => {
            const mapping = referencedForeignKeyTableMapping.find((it) => it.fkName === foreignKey.name);
            upQueries.push(this.createForeignKeySql(mapping.tableName, foreignKey));
            downQueries.push(this.dropForeignKeySql(mapping.tableName, foreignKey));
          });
        }
        const columnIndex = clonedTable.indices.find((index) => index.columnNames.length === 1 && index.columnNames[0] === column.name);
        if (columnIndex) {
          clonedTable.indices.splice(clonedTable.indices.indexOf(columnIndex), 1);
          upQueries.push(this.dropIndexSql(table, columnIndex));
          downQueries.push(this.createIndexSql(table, columnIndex));
        } else if (column.isUnique) {
          const uniqueName = this.connection.namingStrategy.uniqueConstraintName(table, [
            column.name
          ]);
          const foundUnique = clonedTable.uniques.find((unique) => unique.name === uniqueName);
          if (foundUnique) {
            clonedTable.uniques.splice(clonedTable.uniques.indexOf(foundUnique), 1);
            upQueries.push(this.dropIndexSql(table, uniqueName));
            downQueries.push(new Query_1.Query(`CREATE UNIQUE INDEX "${uniqueName}" ON ${this.escapePath(table)} ("${column.name}")`));
          }
          const indexName = this.connection.namingStrategy.indexName(table, [
            column.name
          ]);
          const foundIndex = clonedTable.indices.find((index) => index.name === indexName);
          if (foundIndex) {
            clonedTable.indices.splice(clonedTable.indices.indexOf(foundIndex), 1);
            upQueries.push(this.dropIndexSql(table, indexName));
            downQueries.push(new Query_1.Query(`CREATE UNIQUE INDEX "${indexName}" ON ${this.escapePath(table)} ("${column.name}")`));
          }
        }
        const columnCheck = clonedTable.checks.find((check) => !!check.columnNames && check.columnNames.length === 1 && check.columnNames[0] === column.name);
        if (columnCheck) {
          clonedTable.checks.splice(clonedTable.checks.indexOf(columnCheck), 1);
          upQueries.push(this.dropCheckConstraintSql(table, columnCheck));
          downQueries.push(this.createCheckConstraintSql(table, columnCheck));
        }
        upQueries.push(new Query_1.Query(this.dropColumnSql(table, column)));
        downQueries.push(new Query_1.Query(this.addColumnSql(table, column)));
        await this.executeQueries(upQueries, downQueries);
        clonedTable.removeColumn(column);
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Drops the columns in the table.
       */
      async dropColumns(tableOrName, columns) {
        for (const column of [...columns]) {
          await this.dropColumn(tableOrName, column);
        }
      }
      /**
       * Creates a new primary key.
       */
      async createPrimaryKey(tableOrName, columnNames) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const clonedTable = table.clone();
        const up = this.createPrimaryKeySql(table, columnNames);
        clonedTable.columns.forEach((column) => {
          if (columnNames.find((columnName) => columnName === column.name))
            column.isPrimary = true;
        });
        const down = this.dropPrimaryKeySql(clonedTable);
        await this.executeQueries(up, down);
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Updates composite primary keys.
       */
      async updatePrimaryKeys(tableOrName, columns) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const parsedTableName = this.driver.parseTableName(table);
        if (!parsedTableName.schema) {
          parsedTableName.schema = await this.getCurrentSchema();
        }
        const clonedTable = table.clone();
        const columnNames = columns.map((column) => column.name);
        const upQueries = [];
        const downQueries = [];
        const referencedForeignKeySql = `SELECT * FROM "SYS"."REFERENTIAL_CONSTRAINTS" WHERE "REFERENCED_SCHEMA_NAME" = '${parsedTableName.schema}' AND "REFERENCED_TABLE_NAME" = '${parsedTableName.tableName}'`;
        const dbForeignKeys = await this.query(referencedForeignKeySql);
        let referencedForeignKeys = [];
        const referencedForeignKeyTableMapping = [];
        if (dbForeignKeys.length > 0) {
          referencedForeignKeys = dbForeignKeys.map((dbForeignKey) => {
            const foreignKeys = dbForeignKeys.filter((dbFk) => dbFk["CONSTRAINT_NAME"] === dbForeignKey["CONSTRAINT_NAME"]);
            referencedForeignKeyTableMapping.push({
              tableName: `${dbForeignKey["SCHEMA_NAME"]}.${dbForeignKey["TABLE_NAME"]}`,
              fkName: dbForeignKey["CONSTRAINT_NAME"]
            });
            return new TableForeignKey_1.TableForeignKey({
              name: dbForeignKey["CONSTRAINT_NAME"],
              columnNames: foreignKeys.map((dbFk) => dbFk["COLUMN_NAME"]),
              referencedDatabase: table.database,
              referencedSchema: table.schema,
              referencedTableName: table.name,
              referencedColumnNames: foreignKeys.map((dbFk) => dbFk["REFERENCED_COLUMN_NAME"]),
              onDelete: dbForeignKey["DELETE_RULE"] === "RESTRICT" ? "NO ACTION" : dbForeignKey["DELETE_RULE"],
              onUpdate: dbForeignKey["UPDATE_RULE"] === "RESTRICT" ? "NO ACTION" : dbForeignKey["UPDATE_RULE"],
              deferrable: dbForeignKey["CHECK_TIME"].replace("_", " ")
            });
          });
          referencedForeignKeys.forEach((foreignKey) => {
            const mapping = referencedForeignKeyTableMapping.find((it) => it.fkName === foreignKey.name);
            upQueries.push(this.dropForeignKeySql(mapping.tableName, foreignKey));
            downQueries.push(this.createForeignKeySql(mapping.tableName, foreignKey));
          });
        }
        const primaryColumns = clonedTable.primaryColumns;
        if (primaryColumns.length > 0) {
          const pkName2 = this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column) => column.name));
          const columnNamesString2 = primaryColumns.map((column) => `"${column.name}"`).join(", ");
          upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName2}"`));
          downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName2}" PRIMARY KEY (${columnNamesString2})`));
        }
        clonedTable.columns.filter((column) => columnNames.indexOf(column.name) !== -1).forEach((column) => column.isPrimary = true);
        const pkName = this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);
        const columnNamesString = columnNames.map((columnName) => `"${columnName}"`).join(", ");
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNamesString})`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
        referencedForeignKeys.forEach((foreignKey) => {
          const mapping = referencedForeignKeyTableMapping.find((it) => it.fkName === foreignKey.name);
          upQueries.push(this.createForeignKeySql(mapping.tableName, foreignKey));
          downQueries.push(this.dropForeignKeySql(mapping.tableName, foreignKey));
        });
        await this.executeQueries(upQueries, downQueries);
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Drops a primary key.
       */
      async dropPrimaryKey(tableOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const parsedTableName = this.driver.parseTableName(table);
        if (!parsedTableName.schema) {
          parsedTableName.schema = await this.getCurrentSchema();
        }
        const upQueries = [];
        const downQueries = [];
        const referencedForeignKeySql = `SELECT * FROM "SYS"."REFERENTIAL_CONSTRAINTS" WHERE "REFERENCED_SCHEMA_NAME" = '${parsedTableName.schema}' AND "REFERENCED_TABLE_NAME" = '${parsedTableName.tableName}'`;
        const dbForeignKeys = await this.query(referencedForeignKeySql);
        let referencedForeignKeys = [];
        const referencedForeignKeyTableMapping = [];
        if (dbForeignKeys.length > 0) {
          referencedForeignKeys = dbForeignKeys.map((dbForeignKey) => {
            const foreignKeys = dbForeignKeys.filter((dbFk) => dbFk["CONSTRAINT_NAME"] === dbForeignKey["CONSTRAINT_NAME"]);
            referencedForeignKeyTableMapping.push({
              tableName: `${dbForeignKey["SCHEMA_NAME"]}.${dbForeignKey["TABLE_NAME"]}`,
              fkName: dbForeignKey["CONSTRAINT_NAME"]
            });
            return new TableForeignKey_1.TableForeignKey({
              name: dbForeignKey["CONSTRAINT_NAME"],
              columnNames: foreignKeys.map((dbFk) => dbFk["COLUMN_NAME"]),
              referencedDatabase: table.database,
              referencedSchema: table.schema,
              referencedTableName: table.name,
              referencedColumnNames: foreignKeys.map((dbFk) => dbFk["REFERENCED_COLUMN_NAME"]),
              onDelete: dbForeignKey["DELETE_RULE"] === "RESTRICT" ? "NO ACTION" : dbForeignKey["DELETE_RULE"],
              onUpdate: dbForeignKey["UPDATE_RULE"] === "RESTRICT" ? "NO ACTION" : dbForeignKey["UPDATE_RULE"],
              deferrable: dbForeignKey["CHECK_TIME"].replace("_", " ")
            });
          });
          referencedForeignKeys.forEach((foreignKey) => {
            const mapping = referencedForeignKeyTableMapping.find((it) => it.fkName === foreignKey.name);
            upQueries.push(this.dropForeignKeySql(mapping.tableName, foreignKey));
            downQueries.push(this.createForeignKeySql(mapping.tableName, foreignKey));
          });
        }
        upQueries.push(this.dropPrimaryKeySql(table));
        downQueries.push(this.createPrimaryKeySql(table, table.primaryColumns.map((column) => column.name)));
        referencedForeignKeys.forEach((foreignKey) => {
          const mapping = referencedForeignKeyTableMapping.find((it) => it.fkName === foreignKey.name);
          upQueries.push(this.createForeignKeySql(mapping.tableName, foreignKey));
          downQueries.push(this.dropForeignKeySql(mapping.tableName, foreignKey));
        });
        await this.executeQueries(upQueries, downQueries);
        table.primaryColumns.forEach((column) => {
          column.isPrimary = false;
        });
      }
      /**
       * Creates a new unique constraint.
       */
      async createUniqueConstraint(tableOrName, uniqueConstraint) {
        throw new error_1.TypeORMError(`SAP HANA does not support unique constraints. Use unique index instead.`);
      }
      /**
       * Creates a new unique constraints.
       */
      async createUniqueConstraints(tableOrName, uniqueConstraints) {
        throw new error_1.TypeORMError(`SAP HANA does not support unique constraints. Use unique index instead.`);
      }
      /**
       * Drops unique constraint.
       */
      async dropUniqueConstraint(tableOrName, uniqueOrName) {
        throw new error_1.TypeORMError(`SAP HANA does not support unique constraints. Use unique index instead.`);
      }
      /**
       * Drops an unique constraints.
       */
      async dropUniqueConstraints(tableOrName, uniqueConstraints) {
        throw new error_1.TypeORMError(`SAP HANA does not support unique constraints. Use unique index instead.`);
      }
      /**
       * Creates a new check constraint.
       */
      async createCheckConstraint(tableOrName, checkConstraint) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        if (!checkConstraint.name)
          checkConstraint.name = this.connection.namingStrategy.checkConstraintName(table, checkConstraint.expression);
        const up = this.createCheckConstraintSql(table, checkConstraint);
        const down = this.dropCheckConstraintSql(table, checkConstraint);
        await this.executeQueries(up, down);
        table.addCheckConstraint(checkConstraint);
      }
      /**
       * Creates a new check constraints.
       */
      async createCheckConstraints(tableOrName, checkConstraints) {
        const promises = checkConstraints.map((checkConstraint) => this.createCheckConstraint(tableOrName, checkConstraint));
        await Promise.all(promises);
      }
      /**
       * Drops check constraint.
       */
      async dropCheckConstraint(tableOrName, checkOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const checkConstraint = InstanceChecker_1.InstanceChecker.isTableCheck(checkOrName) ? checkOrName : table.checks.find((c) => c.name === checkOrName);
        if (!checkConstraint)
          throw new error_1.TypeORMError(`Supplied check constraint was not found in table ${table.name}`);
        const up = this.dropCheckConstraintSql(table, checkConstraint);
        const down = this.createCheckConstraintSql(table, checkConstraint);
        await this.executeQueries(up, down);
        table.removeCheckConstraint(checkConstraint);
      }
      /**
       * Drops check constraints.
       */
      async dropCheckConstraints(tableOrName, checkConstraints) {
        const promises = checkConstraints.map((checkConstraint) => this.dropCheckConstraint(tableOrName, checkConstraint));
        await Promise.all(promises);
      }
      /**
       * Creates a new exclusion constraint.
       */
      async createExclusionConstraint(tableOrName, exclusionConstraint) {
        throw new error_1.TypeORMError(`SAP HANA does not support exclusion constraints.`);
      }
      /**
       * Creates a new exclusion constraints.
       */
      async createExclusionConstraints(tableOrName, exclusionConstraints) {
        throw new error_1.TypeORMError(`SAP HANA does not support exclusion constraints.`);
      }
      /**
       * Drops exclusion constraint.
       */
      async dropExclusionConstraint(tableOrName, exclusionOrName) {
        throw new error_1.TypeORMError(`SAP HANA does not support exclusion constraints.`);
      }
      /**
       * Drops exclusion constraints.
       */
      async dropExclusionConstraints(tableOrName, exclusionConstraints) {
        throw new error_1.TypeORMError(`SAP HANA does not support exclusion constraints.`);
      }
      /**
       * Creates a new foreign key.
       */
      async createForeignKey(tableOrName, foreignKey) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        if (!foreignKey.name)
          foreignKey.name = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
        const up = this.createForeignKeySql(table, foreignKey);
        const down = this.dropForeignKeySql(table, foreignKey);
        await this.executeQueries(up, down);
        table.addForeignKey(foreignKey);
      }
      /**
       * Creates a new foreign keys.
       */
      async createForeignKeys(tableOrName, foreignKeys) {
        const promises = foreignKeys.map((foreignKey) => this.createForeignKey(tableOrName, foreignKey));
        await Promise.all(promises);
      }
      /**
       * Drops a foreign key from the table.
       */
      async dropForeignKey(tableOrName, foreignKeyOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const foreignKey = InstanceChecker_1.InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName : table.foreignKeys.find((fk) => fk.name === foreignKeyOrName);
        if (!foreignKey)
          throw new error_1.TypeORMError(`Supplied foreign key was not found in table ${table.name}`);
        const up = this.dropForeignKeySql(table, foreignKey);
        const down = this.createForeignKeySql(table, foreignKey);
        await this.executeQueries(up, down);
        table.removeForeignKey(foreignKey);
      }
      /**
       * Drops a foreign keys from the table.
       */
      async dropForeignKeys(tableOrName, foreignKeys) {
        const promises = foreignKeys.map((foreignKey) => this.dropForeignKey(tableOrName, foreignKey));
        await Promise.all(promises);
      }
      /**
       * Creates a new index.
       */
      async createIndex(tableOrName, index) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        if (!index.name)
          index.name = this.generateIndexName(table, index);
        const up = this.createIndexSql(table, index);
        const down = this.dropIndexSql(table, index);
        await this.executeQueries(up, down);
        table.addIndex(index);
      }
      /**
       * Creates a new indices
       */
      async createIndices(tableOrName, indices) {
        const promises = indices.map((index) => this.createIndex(tableOrName, index));
        await Promise.all(promises);
      }
      /**
       * Drops an index.
       */
      async dropIndex(tableOrName, indexOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const index = InstanceChecker_1.InstanceChecker.isTableIndex(indexOrName) ? indexOrName : table.indices.find((i) => i.name === indexOrName);
        if (!index)
          throw new error_1.TypeORMError(`Supplied index ${indexOrName} was not found in table ${table.name}`);
        if (!index.name)
          index.name = this.generateIndexName(table, index);
        const up = this.dropIndexSql(table, index);
        const down = this.createIndexSql(table, index);
        await this.executeQueries(up, down);
        table.removeIndex(index);
      }
      /**
       * Drops an indices from the table.
       */
      async dropIndices(tableOrName, indices) {
        const promises = indices.map((index) => this.dropIndex(tableOrName, index));
        await Promise.all(promises);
      }
      /**
       * Clears all table contents.
       * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.
       */
      async clearTable(tablePath) {
        await this.query(`TRUNCATE TABLE ${this.escapePath(tablePath)}`);
      }
      /**
       * Removes all tables from the currently connected database.
       */
      async clearDatabase() {
        const schemas = [];
        this.connection.entityMetadatas.filter((metadata) => metadata.schema).forEach((metadata) => {
          const isSchemaExist = !!schemas.find((schema) => schema === metadata.schema);
          if (!isSchemaExist)
            schemas.push(metadata.schema);
        });
        schemas.push(this.driver.options.schema || "current_schema");
        const schemaNamesString = schemas.map((name) => {
          return name === "current_schema" ? name : "'" + name + "'";
        }).join(", ");
        const isAnotherTransactionActive = this.isTransactionActive;
        if (!isAnotherTransactionActive)
          await this.startTransaction();
        try {
          const selectTableDropsQuery = `SELECT 'DROP TABLE "' || schema_name || '"."' || table_name || '" CASCADE;' as "query" FROM "SYS"."TABLES" WHERE "SCHEMA_NAME" IN (${schemaNamesString}) AND "TABLE_NAME" NOT IN ('SYS_AFL_GENERATOR_PARAMETERS') AND "IS_COLUMN_TABLE" = 'TRUE'`;
          const dropTableQueries = await this.query(selectTableDropsQuery);
          await Promise.all(dropTableQueries.map((q) => this.query(q["query"])));
          if (!isAnotherTransactionActive)
            await this.commitTransaction();
        } catch (error) {
          try {
            if (!isAnotherTransactionActive)
              await this.rollbackTransaction();
          } catch (rollbackError) {
          }
          throw error;
        }
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      async loadViews(viewNames) {
        const hasTable = await this.hasTable(this.getTypeormMetadataTableName());
        if (!hasTable) {
          return [];
        }
        if (!viewNames) {
          viewNames = [];
        }
        const currentDatabase = await this.getCurrentDatabase();
        const currentSchema = await this.getCurrentSchema();
        const viewsCondition = viewNames.map((viewName) => {
          let { schema, tableName: name } = this.driver.parseTableName(viewName);
          if (!schema) {
            schema = currentSchema;
          }
          return `("t"."schema" = '${schema}' AND "t"."name" = '${name}')`;
        }).join(" OR ");
        const query = `SELECT "t".* FROM ${this.escapePath(this.getTypeormMetadataTableName())} "t" WHERE "t"."type" = '${MetadataTableType_1.MetadataTableType.VIEW}' ${viewsCondition ? `AND (${viewsCondition})` : ""}`;
        const dbViews = await this.query(query);
        return dbViews.map((dbView) => {
          const view = new View_1.View();
          const schema = dbView["schema"] === currentSchema && !this.driver.options.schema ? void 0 : dbView["schema"];
          view.database = currentDatabase;
          view.schema = dbView["schema"];
          view.name = this.driver.buildTableName(dbView["name"], schema);
          view.expression = dbView["value"];
          return view;
        });
      }
      /**
       * Loads all tables (with given names) from the database and creates a Table from them.
       */
      async loadTables(tableNames) {
        if (tableNames && tableNames.length === 0) {
          return [];
        }
        const currentSchema = await this.getCurrentSchema();
        const currentDatabase = await this.getCurrentDatabase();
        const dbTables = [];
        if (!tableNames) {
          const tablesSql = `SELECT "SCHEMA_NAME", "TABLE_NAME" FROM "SYS"."TABLES"`;
          dbTables.push(...await this.query(tablesSql));
        } else {
          const tablesCondition = tableNames.map((tableName) => {
            let [schema, name] = tableName.split(".");
            if (!name) {
              name = schema;
              schema = this.driver.options.schema || currentSchema;
            }
            return `("SCHEMA_NAME" = '${schema}' AND "TABLE_NAME" = '${name}')`;
          }).join(" OR ");
          const tablesSql = `SELECT "SCHEMA_NAME", "TABLE_NAME" FROM "SYS"."TABLES" WHERE ` + tablesCondition;
          dbTables.push(...await this.query(tablesSql));
        }
        if (dbTables.length === 0)
          return [];
        const columnsCondition = dbTables.map(({ SCHEMA_NAME, TABLE_NAME }) => {
          return `("SCHEMA_NAME" = '${SCHEMA_NAME}' AND "TABLE_NAME" = '${TABLE_NAME}')`;
        }).join(" OR ");
        const columnsSql = `SELECT * FROM "SYS"."TABLE_COLUMNS" WHERE ` + columnsCondition + ` ORDER BY "POSITION"`;
        const constraintsCondition = dbTables.map(({ SCHEMA_NAME, TABLE_NAME }) => {
          return `("SCHEMA_NAME" = '${SCHEMA_NAME}' AND "TABLE_NAME" = '${TABLE_NAME}')`;
        }).join(" OR ");
        const constraintsSql = `SELECT * FROM "SYS"."CONSTRAINTS" WHERE (${constraintsCondition}) ORDER BY "POSITION"`;
        const indicesCondition = dbTables.map(({ SCHEMA_NAME, TABLE_NAME }) => {
          return `("I"."SCHEMA_NAME" = '${SCHEMA_NAME}' AND "I"."TABLE_NAME" = '${TABLE_NAME}')`;
        }).join(" OR ");
        const indicesSql = `SELECT "I"."INDEX_TYPE", "I"."SCHEMA_NAME", "I"."TABLE_NAME", "I"."INDEX_NAME", "IC"."COLUMN_NAME", "I"."CONSTRAINT" FROM "SYS"."INDEXES" "I" INNER JOIN "SYS"."INDEX_COLUMNS" "IC" ON "IC"."INDEX_OID" = "I"."INDEX_OID" WHERE (${indicesCondition}) AND ("I"."CONSTRAINT" IS NULL OR "I"."CONSTRAINT" != 'PRIMARY KEY') AND "I"."INDEX_NAME" NOT LIKE '%_SYS_FULLTEXT_%' ORDER BY "IC"."POSITION"`;
        const foreignKeysCondition = dbTables.map(({ SCHEMA_NAME, TABLE_NAME }) => {
          return `("SCHEMA_NAME" = '${SCHEMA_NAME}' AND "TABLE_NAME" = '${TABLE_NAME}')`;
        }).join(" OR ");
        const foreignKeysSql = `SELECT * FROM "SYS"."REFERENTIAL_CONSTRAINTS" WHERE (${foreignKeysCondition}) ORDER BY "POSITION"`;
        const [dbColumns, dbConstraints, dbIndices, dbForeignKeys] = await Promise.all([
          this.query(columnsSql),
          this.query(constraintsSql),
          this.query(indicesSql),
          this.query(foreignKeysSql)
        ]);
        return dbTables.map((dbTable) => {
          const table = new Table_1.Table();
          const getSchemaFromKey = (dbObject, key) => {
            return dbObject[key] === currentSchema && (!this.driver.options.schema || this.driver.options.schema === currentSchema) ? void 0 : dbObject[key];
          };
          const schema = getSchemaFromKey(dbTable, "SCHEMA_NAME");
          table.database = currentDatabase;
          table.schema = dbTable["SCHEMA_NAME"];
          table.name = this.driver.buildTableName(dbTable["TABLE_NAME"], schema);
          table.columns = dbColumns.filter((dbColumn) => dbColumn["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbColumn["SCHEMA_NAME"] === dbTable["SCHEMA_NAME"]).map((dbColumn) => {
            const columnConstraints = dbConstraints.filter((dbConstraint) => dbConstraint["TABLE_NAME"] === dbColumn["TABLE_NAME"] && dbConstraint["SCHEMA_NAME"] === dbColumn["SCHEMA_NAME"] && dbConstraint["COLUMN_NAME"] === dbColumn["COLUMN_NAME"]);
            const columnUniqueIndices = dbIndices.filter((dbIndex) => {
              return dbIndex["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbIndex["SCHEMA_NAME"] === dbTable["SCHEMA_NAME"] && dbIndex["COLUMN_NAME"] === dbColumn["COLUMN_NAME"] && dbIndex["CONSTRAINT"] && dbIndex["CONSTRAINT"].indexOf("UNIQUE") !== -1;
            });
            const tableMetadata = this.connection.entityMetadatas.find((metadata) => this.getTablePath(table) === this.getTablePath(metadata));
            const hasIgnoredIndex = columnUniqueIndices.length > 0 && tableMetadata && tableMetadata.indices.some((index) => {
              return columnUniqueIndices.some((uniqueIndex) => {
                return index.name === uniqueIndex["INDEX_NAME"] && index.synchronize === false;
              });
            });
            const isConstraintComposite = columnUniqueIndices.every((uniqueIndex) => {
              return dbIndices.some((dbIndex) => dbIndex["INDEX_NAME"] === uniqueIndex["INDEX_NAME"] && dbIndex["COLUMN_NAME"] !== dbColumn["COLUMN_NAME"]);
            });
            const tableColumn = new TableColumn_1.TableColumn();
            tableColumn.name = dbColumn["COLUMN_NAME"];
            tableColumn.type = dbColumn["DATA_TYPE_NAME"].toLowerCase();
            if (tableColumn.type === "dec" || tableColumn.type === "decimal") {
              if (dbColumn["LENGTH"] !== null && !this.isDefaultColumnPrecision(table, tableColumn, dbColumn["LENGTH"])) {
                tableColumn.precision = dbColumn["LENGTH"];
              } else if (dbColumn["SCALE"] !== null && !this.isDefaultColumnScale(table, tableColumn, dbColumn["SCALE"])) {
                tableColumn.precision = void 0;
              }
              if (dbColumn["SCALE"] !== null && !this.isDefaultColumnScale(table, tableColumn, dbColumn["SCALE"])) {
                tableColumn.scale = dbColumn["SCALE"];
              } else if (dbColumn["LENGTH"] !== null && !this.isDefaultColumnPrecision(table, tableColumn, dbColumn["LENGTH"])) {
                tableColumn.scale = void 0;
              }
            }
            if (dbColumn["DATA_TYPE_NAME"].toLowerCase() === "array") {
              tableColumn.isArray = true;
              tableColumn.type = dbColumn["CS_DATA_TYPE_NAME"].toLowerCase();
            }
            if (this.driver.withLengthColumnTypes.indexOf(tableColumn.type) !== -1 && dbColumn["LENGTH"]) {
              const length = dbColumn["LENGTH"].toString();
              tableColumn.length = !this.isDefaultColumnLength(table, tableColumn, length) ? length : "";
            }
            tableColumn.isUnique = columnUniqueIndices.length > 0 && !hasIgnoredIndex && !isConstraintComposite;
            tableColumn.isNullable = dbColumn["IS_NULLABLE"] === "TRUE";
            tableColumn.isPrimary = !!columnConstraints.find((constraint) => constraint["IS_PRIMARY_KEY"] === "TRUE");
            tableColumn.isGenerated = dbColumn["GENERATION_TYPE"] === "ALWAYS AS IDENTITY";
            if (tableColumn.isGenerated)
              tableColumn.generationStrategy = "increment";
            if (dbColumn["DEFAULT_VALUE"] === null || dbColumn["DEFAULT_VALUE"] === void 0) {
              tableColumn.default = void 0;
            } else {
              if (tableColumn.type === "char" || tableColumn.type === "nchar" || tableColumn.type === "varchar" || tableColumn.type === "nvarchar" || tableColumn.type === "alphanum" || tableColumn.type === "shorttext") {
                tableColumn.default = `'${dbColumn["DEFAULT_VALUE"]}'`;
              } else if (tableColumn.type === "boolean") {
                tableColumn.default = dbColumn["DEFAULT_VALUE"] === "1" ? "true" : "false";
              } else {
                tableColumn.default = dbColumn["DEFAULT_VALUE"];
              }
            }
            if (dbColumn["COMMENTS"]) {
              tableColumn.comment = dbColumn["COMMENTS"];
            }
            return tableColumn;
          });
          const tableCheckConstraints = OrmUtils_1.OrmUtils.uniq(dbConstraints.filter((dbConstraint) => dbConstraint["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbConstraint["SCHEMA_NAME"] === dbTable["SCHEMA_NAME"] && dbConstraint["CHECK_CONDITION"] !== null && dbConstraint["CHECK_CONDITION"] !== void 0), (dbConstraint) => dbConstraint["CONSTRAINT_NAME"]);
          table.checks = tableCheckConstraints.map((constraint) => {
            const checks = dbConstraints.filter((dbC) => dbC["CONSTRAINT_NAME"] === constraint["CONSTRAINT_NAME"]);
            return new TableCheck_1.TableCheck({
              name: constraint["CONSTRAINT_NAME"],
              columnNames: checks.map((c) => c["COLUMN_NAME"]),
              expression: constraint["CHECK_CONDITION"]
            });
          });
          const tableForeignKeyConstraints = OrmUtils_1.OrmUtils.uniq(dbForeignKeys.filter((dbForeignKey) => dbForeignKey["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbForeignKey["SCHEMA_NAME"] === dbTable["SCHEMA_NAME"]), (dbForeignKey) => dbForeignKey["CONSTRAINT_NAME"]);
          table.foreignKeys = tableForeignKeyConstraints.map((dbForeignKey) => {
            const foreignKeys = dbForeignKeys.filter((dbFk) => dbFk["CONSTRAINT_NAME"] === dbForeignKey["CONSTRAINT_NAME"]);
            const schema2 = getSchemaFromKey(dbForeignKey, "REFERENCED_SCHEMA_NAME");
            const referencedTableName = this.driver.buildTableName(dbForeignKey["REFERENCED_TABLE_NAME"], schema2);
            return new TableForeignKey_1.TableForeignKey({
              name: dbForeignKey["CONSTRAINT_NAME"],
              columnNames: foreignKeys.map((dbFk) => dbFk["COLUMN_NAME"]),
              referencedDatabase: table.database,
              referencedSchema: dbForeignKey["REFERENCED_SCHEMA_NAME"],
              referencedTableName,
              referencedColumnNames: foreignKeys.map((dbFk) => dbFk["REFERENCED_COLUMN_NAME"]),
              onDelete: dbForeignKey["DELETE_RULE"] === "RESTRICT" ? "NO ACTION" : dbForeignKey["DELETE_RULE"],
              onUpdate: dbForeignKey["UPDATE_RULE"] === "RESTRICT" ? "NO ACTION" : dbForeignKey["UPDATE_RULE"],
              deferrable: dbForeignKey["CHECK_TIME"].replace("_", " ")
            });
          });
          const tableIndexConstraints = OrmUtils_1.OrmUtils.uniq(dbIndices.filter((dbIndex) => dbIndex["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbIndex["SCHEMA_NAME"] === dbTable["SCHEMA_NAME"]), (dbIndex) => dbIndex["INDEX_NAME"]);
          table.indices = tableIndexConstraints.map((constraint) => {
            const indices = dbIndices.filter((index) => {
              return index["SCHEMA_NAME"] === constraint["SCHEMA_NAME"] && index["TABLE_NAME"] === constraint["TABLE_NAME"] && index["INDEX_NAME"] === constraint["INDEX_NAME"];
            });
            return new TableIndex_1.TableIndex({
              table,
              name: constraint["INDEX_NAME"],
              columnNames: indices.map((i) => i["COLUMN_NAME"]),
              isUnique: constraint["CONSTRAINT"] && constraint["CONSTRAINT"].indexOf("UNIQUE") !== -1,
              isFulltext: constraint["INDEX_TYPE"] === "FULLTEXT"
            });
          });
          return table;
        });
      }
      /**
       * Builds and returns SQL for create table.
       */
      createTableSql(table, createForeignKeys) {
        const columnDefinitions = table.columns.map((column) => this.buildCreateColumnSql(column)).join(", ");
        let sql = `CREATE TABLE ${this.escapePath(table)} (${columnDefinitions}`;
        table.columns.filter((column) => column.isUnique).forEach((column) => {
          const isUniqueIndexExist = table.indices.some((index) => {
            return index.columnNames.length === 1 && !!index.isUnique && index.columnNames.indexOf(column.name) !== -1;
          });
          const isUniqueConstraintExist = table.uniques.some((unique) => {
            return unique.columnNames.length === 1 && unique.columnNames.indexOf(column.name) !== -1;
          });
          if (!isUniqueIndexExist && !isUniqueConstraintExist)
            table.indices.push(new TableIndex_1.TableIndex({
              name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),
              columnNames: [column.name],
              isUnique: true
            }));
        });
        if (table.uniques.length > 0) {
          table.uniques.forEach((unique) => {
            const uniqueExist = table.indices.some((index) => index.name === unique.name);
            if (!uniqueExist) {
              table.indices.push(new TableIndex_1.TableIndex({
                name: unique.name,
                columnNames: unique.columnNames,
                isUnique: true
              }));
            }
          });
        }
        if (table.checks.length > 0) {
          const checksSql = table.checks.map((check) => {
            const checkName = check.name ? check.name : this.connection.namingStrategy.checkConstraintName(table, check.expression);
            return `CONSTRAINT "${checkName}" CHECK (${check.expression})`;
          }).join(", ");
          sql += `, ${checksSql}`;
        }
        if (table.foreignKeys.length > 0 && createForeignKeys) {
          const foreignKeysSql = table.foreignKeys.map((fk) => {
            const columnNames = fk.columnNames.map((columnName) => `"${columnName}"`).join(", ");
            if (!fk.name)
              fk.name = this.connection.namingStrategy.foreignKeyName(table, fk.columnNames, this.getTablePath(fk), fk.referencedColumnNames);
            const referencedColumnNames = fk.referencedColumnNames.map((columnName) => `"${columnName}"`).join(", ");
            let constraint = `CONSTRAINT "${fk.name}" FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(fk))} (${referencedColumnNames})`;
            if (fk.onDelete) {
              const onDelete = fk.onDelete === "NO ACTION" ? "RESTRICT" : fk.onDelete;
              constraint += ` ON DELETE ${onDelete}`;
            }
            if (fk.onUpdate) {
              const onUpdate = fk.onUpdate === "NO ACTION" ? "RESTRICT" : fk.onUpdate;
              constraint += ` ON UPDATE ${onUpdate}`;
            }
            if (fk.deferrable) {
              constraint += ` ${fk.deferrable}`;
            }
            return constraint;
          }).join(", ");
          sql += `, ${foreignKeysSql}`;
        }
        const primaryColumns = table.columns.filter((column) => column.isPrimary);
        if (primaryColumns.length > 0) {
          const primaryKeyName = this.connection.namingStrategy.primaryKeyName(table, primaryColumns.map((column) => column.name));
          const columnNames = primaryColumns.map((column) => `"${column.name}"`).join(", ");
          sql += `, CONSTRAINT "${primaryKeyName}" PRIMARY KEY (${columnNames})`;
        }
        sql += `)`;
        return new Query_1.Query(sql);
      }
      /**
       * Builds drop table sql.
       */
      dropTableSql(tableOrName, ifExist) {
        const query = ifExist ? `DROP TABLE IF EXISTS ${this.escapePath(tableOrName)}` : `DROP TABLE ${this.escapePath(tableOrName)}`;
        return new Query_1.Query(query);
      }
      createViewSql(view) {
        if (typeof view.expression === "string") {
          return new Query_1.Query(`CREATE VIEW ${this.escapePath(view)} AS ${view.expression}`);
        } else {
          return new Query_1.Query(`CREATE VIEW ${this.escapePath(view)} AS ${view.expression(this.connection).getQuery()}`);
        }
      }
      async insertViewDefinitionSql(view) {
        let { schema, tableName: name } = this.driver.parseTableName(view);
        if (!schema) {
          schema = await this.getCurrentSchema();
        }
        const expression = typeof view.expression === "string" ? view.expression.trim() : view.expression(this.connection).getQuery();
        return this.insertTypeormMetadataSql({
          type: MetadataTableType_1.MetadataTableType.VIEW,
          schema,
          name,
          value: expression
        });
      }
      /**
       * Builds drop view sql.
       */
      dropViewSql(viewOrPath) {
        return new Query_1.Query(`DROP VIEW ${this.escapePath(viewOrPath)}`);
      }
      /**
       * Builds remove view sql.
       */
      async deleteViewDefinitionSql(viewOrPath) {
        let { schema, tableName: name } = this.driver.parseTableName(viewOrPath);
        if (!schema) {
          schema = await this.getCurrentSchema();
        }
        return this.deleteTypeormMetadataSql({
          type: MetadataTableType_1.MetadataTableType.VIEW,
          schema,
          name
        });
      }
      addColumnSql(table, column) {
        return `ALTER TABLE ${this.escapePath(table)} ADD (${this.buildCreateColumnSql(column)})`;
      }
      dropColumnSql(table, column) {
        return `ALTER TABLE ${this.escapePath(table)} DROP ("${column.name}")`;
      }
      /**
       * Builds create index sql.
       */
      createIndexSql(table, index) {
        const columns = index.columnNames.map((columnName) => `"${columnName}"`).join(", ");
        let indexType = "";
        if (index.isUnique) {
          indexType += "UNIQUE ";
        }
        if (index.isFulltext && this.driver.isFullTextColumnTypeSupported()) {
          indexType += "FULLTEXT ";
        }
        return new Query_1.Query(`CREATE ${indexType}INDEX "${index.name}" ON ${this.escapePath(table)} (${columns}) ${index.where ? "WHERE " + index.where : ""}`);
      }
      /**
       * Builds drop index sql.
       */
      dropIndexSql(table, indexOrName) {
        const indexName = InstanceChecker_1.InstanceChecker.isTableIndex(indexOrName) ? indexOrName.name : indexOrName;
        const parsedTableName = this.driver.parseTableName(table);
        if (!parsedTableName.schema) {
          return new Query_1.Query(`DROP INDEX "${indexName}"`);
        } else {
          return new Query_1.Query(`DROP INDEX "${parsedTableName.schema}"."${indexName}"`);
        }
      }
      /**
       * Builds create primary key sql.
       */
      createPrimaryKeySql(table, columnNames) {
        const primaryKeyName = this.connection.namingStrategy.primaryKeyName(table, columnNames);
        const columnNamesString = columnNames.map((columnName) => `"${columnName}"`).join(", ");
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${primaryKeyName}" PRIMARY KEY (${columnNamesString})`);
      }
      /**
       * Builds drop primary key sql.
       */
      dropPrimaryKeySql(table) {
        const columnNames = table.primaryColumns.map((column) => column.name);
        const primaryKeyName = this.connection.namingStrategy.primaryKeyName(table, columnNames);
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${primaryKeyName}"`);
      }
      /**
       * Builds create check constraint sql.
       */
      createCheckConstraintSql(table, checkConstraint) {
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${checkConstraint.name}" CHECK (${checkConstraint.expression})`);
      }
      /**
       * Builds drop check constraint sql.
       */
      dropCheckConstraintSql(table, checkOrName) {
        const checkName = InstanceChecker_1.InstanceChecker.isTableCheck(checkOrName) ? checkOrName.name : checkOrName;
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${checkName}"`);
      }
      /**
       * Builds create foreign key sql.
       */
      createForeignKeySql(tableOrName, foreignKey) {
        const columnNames = foreignKey.columnNames.map((column) => `"` + column + `"`).join(", ");
        const referencedColumnNames = foreignKey.referencedColumnNames.map((column) => `"` + column + `"`).join(",");
        let sql = `ALTER TABLE ${this.escapePath(tableOrName)} ADD CONSTRAINT "${foreignKey.name}" FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;
        if (foreignKey.onDelete) {
          const onDelete = foreignKey.onDelete === "NO ACTION" ? "RESTRICT" : foreignKey.onDelete;
          sql += ` ON DELETE ${onDelete}`;
        }
        if (foreignKey.onUpdate) {
          const onUpdate = foreignKey.onUpdate === "NO ACTION" ? "RESTRICT" : foreignKey.onUpdate;
          sql += ` ON UPDATE ${onUpdate}`;
        }
        if (foreignKey.deferrable) {
          sql += ` ${foreignKey.deferrable}`;
        }
        return new Query_1.Query(sql);
      }
      /**
       * Builds drop foreign key sql.
       */
      dropForeignKeySql(tableOrName, foreignKeyOrName) {
        const foreignKeyName = InstanceChecker_1.InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName.name : foreignKeyOrName;
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(tableOrName)} DROP CONSTRAINT "${foreignKeyName}"`);
      }
      /**
       * Escapes a given comment so it's safe to include in a query.
       */
      escapeComment(comment) {
        if (!comment) {
          return "NULL";
        }
        comment = comment.replace(/'/g, "''").replace(/\u0000/g, "");
        return `'${comment}'`;
      }
      /**
       * Escapes given table or view path.
       */
      escapePath(target) {
        const { schema, tableName } = this.driver.parseTableName(target);
        if (schema) {
          return `"${schema}"."${tableName}"`;
        }
        return `"${tableName}"`;
      }
      /**
       * Builds a query for create column.
       */
      buildCreateColumnSql(column, explicitDefault, explicitNullable) {
        let c = `"${column.name}" ` + this.connection.driver.createFullType(column);
        if (column.default !== void 0 && column.default !== null) {
          c += " DEFAULT " + column.default;
        } else if (explicitDefault) {
          c += " DEFAULT NULL";
        }
        if (!column.isGenerated) {
          if (column.isNullable !== true)
            c += " NOT NULL";
          else if (explicitNullable)
            c += " NULL";
        }
        if (column.isGenerated === true && column.generationStrategy === "increment") {
          c += " GENERATED ALWAYS AS IDENTITY";
        }
        if (column.comment) {
          c += ` COMMENT ${this.escapeComment(column.comment)}`;
        }
        return c;
      }
      /**
       * Change table comment.
       */
      changeTableComment(tableOrName, comment) {
        throw new error_1.TypeORMError(`spa driver does not support change table comment.`);
      }
    };
    exports2.SapQueryRunner = SapQueryRunner;
  }
});

// node_modules/typeorm/driver/sap/SapDriver.js
var require_SapDriver = __commonJS({
  "node_modules/typeorm/driver/sap/SapDriver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SapDriver = void 0;
    var node_util_1 = require("node:util");
    var __1 = require_typeorm();
    var DriverPackageNotInstalledError_1 = require_DriverPackageNotInstalledError();
    var TypeORMError_1 = require_TypeORMError();
    var PlatformTools_1 = require_PlatformTools();
    var RdbmsSchemaBuilder_1 = require_RdbmsSchemaBuilder();
    var ApplyValueTransformers_1 = require_ApplyValueTransformers();
    var DateUtils_1 = require_DateUtils();
    var InstanceChecker_1 = require_InstanceChecker();
    var OrmUtils_1 = require_OrmUtils();
    var DriverUtils_1 = require_DriverUtils();
    var SapQueryRunner_1 = require_SapQueryRunner();
    var SapDriver = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection) {
        this.isReplicated = false;
        this.treeSupport = true;
        this.transactionSupport = "simple";
        this.supportedDataTypes = [
          "alphanum",
          // removed in SAP HANA Cloud
          "array",
          "bigint",
          "binary",
          "blob",
          "boolean",
          "char",
          // not officially supported, in SAP HANA Cloud: alias for "nchar"
          "clob",
          // in SAP HANA Cloud: alias for "nclob"
          "date",
          "dec",
          // typeorm alias for "decimal"
          "decimal",
          "double",
          "float",
          // database alias for "real" / "double"
          "half_vector",
          // only supported in SAP HANA Cloud, not in SAP HANA 2.0
          "int",
          // typeorm alias for "integer"
          "integer",
          "nchar",
          // not officially supported
          "nclob",
          "nvarchar",
          "real_vector",
          // only supported in SAP HANA Cloud, not in SAP HANA 2.0
          "real",
          "seconddate",
          "shorttext",
          // removed in SAP HANA Cloud
          "smalldecimal",
          "smallint",
          "st_geometry",
          "st_point",
          "text",
          // removed in SAP HANA Cloud
          "time",
          "timestamp",
          "tinyint",
          "varbinary",
          "varchar"
          // in SAP HANA Cloud: alias for "nvarchar"
        ];
        this.supportedUpsertTypes = ["merge-into"];
        this.spatialTypes = ["st_geometry", "st_point"];
        this.withLengthColumnTypes = [
          "alphanum",
          "binary",
          "half_vector",
          "nvarchar",
          "real_vector",
          "shorttext",
          "varbinary",
          "varchar"
        ];
        this.withPrecisionColumnTypes = ["decimal"];
        this.withScaleColumnTypes = ["decimal", "timestamp"];
        this.mappedDataTypes = {
          createDate: "timestamp",
          createDateDefault: "CURRENT_TIMESTAMP",
          updateDate: "timestamp",
          updateDateDefault: "CURRENT_TIMESTAMP",
          deleteDate: "timestamp",
          deleteDateNullable: true,
          version: "integer",
          treeLevel: "integer",
          migrationId: "integer",
          migrationName: "nvarchar",
          migrationTimestamp: "bigint",
          cacheId: "integer",
          cacheIdentifier: "nvarchar",
          cacheTime: "bigint",
          cacheDuration: "integer",
          cacheQuery: "nvarchar(5000)",
          cacheResult: "nclob",
          metadataType: "nvarchar",
          metadataDatabase: "nvarchar",
          metadataSchema: "nvarchar",
          metadataTable: "nvarchar",
          metadataName: "nvarchar",
          metadataValue: "nvarchar(5000)"
        };
        this.dataTypeDefaults = {
          binary: { length: 1 },
          char: { length: 1 },
          decimal: { precision: 18, scale: 0 },
          nchar: { length: 1 },
          nvarchar: { length: 255 },
          shorttext: { length: 255 },
          varbinary: { length: 255 },
          varchar: { length: 255 }
        };
        this.maxAliasLength = 128;
        this.cteCapabilities = {
          enabled: true
        };
        this.dummyTableName = `SYS.DUMMY`;
        this.connection = connection;
        this.options = connection.options;
        this.loadDependencies();
        this.database = DriverUtils_1.DriverUtils.buildDriverOptions(this.options).database;
        this.schema = DriverUtils_1.DriverUtils.buildDriverOptions(this.options).schema;
      }
      // -------------------------------------------------------------------------
      // Public Implemented Methods
      // -------------------------------------------------------------------------
      /**
       * Performs connection to the database.
       * Based on pooling options, it can either create connection immediately,
       * either create a pool and create connection when needed.
       */
      async connect() {
        const connectionOptions = {
          host: this.options.host,
          port: this.options.port,
          user: this.options.username,
          password: this.options.password,
          database: this.options.database,
          currentSchema: this.options.schema,
          encrypt: this.options.encrypt,
          sslValidateCertificate: this.options.sslValidateCertificate,
          key: this.options.key,
          cert: this.options.cert,
          ca: this.options.ca
        };
        Object.keys(connectionOptions).forEach((key) => {
          if (connectionOptions[key] === void 0) {
            delete connectionOptions[key];
          }
        });
        Object.assign(connectionOptions, this.options.extra ?? {});
        const poolOptions = {
          maxConnectedOrPooled: this.options.pool?.maxConnectedOrPooled ?? this.options.pool?.max ?? this.options.poolSize ?? 10,
          maxPooledIdleTime: this.options.pool?.maxPooledIdleTime ?? (this.options.pool?.idleTimeout ? this.options.pool.idleTimeout / 1e3 : 30)
        };
        if (this.options.pool?.pingCheck) {
          poolOptions.pingCheck = this.options.pool.pingCheck;
        }
        if (this.options.pool?.poolCapacity) {
          poolOptions.poolCapacity = this.options.pool.poolCapacity;
        }
        this.poolErrorHandler = this.options.pool?.poolErrorHandler ?? ((error) => {
          this.connection.logger.log("warn", `SAP HANA pool raised an error: ${error}`);
        });
        try {
          this.master = this.client.createPool(connectionOptions, poolOptions);
        } catch (error) {
          this.poolErrorHandler(error);
          throw error;
        }
        const queryRunner = this.createQueryRunner("master");
        const { version, database } = await queryRunner.getDatabaseAndVersion();
        this.version = version;
        this.database = database;
        if (!this.schema) {
          this.schema = await queryRunner.getCurrentSchema();
        }
        await queryRunner.release();
      }
      /**
       * Makes any action after connection (e.g. create extensions in Postgres driver).
       */
      afterConnect() {
        return Promise.resolve();
      }
      /**
       * Closes connection with the database.
       */
      async disconnect() {
        const pool = this.master;
        if (!pool) {
          throw new __1.ConnectionIsNotSetError("sap");
        }
        this.master = void 0;
        try {
          await (0, node_util_1.promisify)(pool.clear).call(pool);
        } catch (error) {
          this.poolErrorHandler(error);
          throw error;
        }
      }
      /**
       * Obtains a new database connection to a master server.
       * Used for replication.
       * If replication is not setup then returns default connection's database connection.
       */
      async obtainMasterConnection() {
        const pool = this.master;
        if (!pool) {
          throw new TypeORMError_1.TypeORMError("Driver not Connected");
        }
        try {
          return await (0, node_util_1.promisify)(pool.getConnection).call(pool);
        } catch (error) {
          this.poolErrorHandler(error);
          throw error;
        }
      }
      /**
       * Obtains a new database connection to a slave server.
       * Used for replication.
       * If replication is not setup then returns master (default) connection's database connection.
       */
      async obtainSlaveConnection() {
        return this.obtainMasterConnection();
      }
      /**
       * Creates a schema builder used to build and sync a schema.
       */
      createSchemaBuilder() {
        return new RdbmsSchemaBuilder_1.RdbmsSchemaBuilder(this.connection);
      }
      /**
       * Creates a query runner used to execute database queries.
       */
      createQueryRunner(mode) {
        return new SapQueryRunner_1.SapQueryRunner(this, mode);
      }
      /**
       * Replaces parameters in the given sql with special escaping character
       * and an array of parameter names to be passed to a query.
       */
      escapeQueryWithParameters(sql, parameters, nativeParameters) {
        const escapedParameters = Object.keys(nativeParameters).map((key) => {
          if (nativeParameters[key] instanceof Date)
            return DateUtils_1.DateUtils.mixedDateToDatetimeString(nativeParameters[key], true);
          return nativeParameters[key];
        });
        if (!parameters || !Object.keys(parameters).length)
          return [sql, escapedParameters];
        sql = sql.replace(/:(\.\.\.)?([A-Za-z0-9_.]+)/g, (full, isArray, key) => {
          if (!parameters.hasOwnProperty(key)) {
            return full;
          }
          const value = parameters[key];
          if (isArray) {
            return value.map((v) => {
              escapedParameters.push(v);
              return this.createParameter(key, escapedParameters.length - 1);
            }).join(", ");
          }
          if (typeof value === "function") {
            return value();
          }
          if (value instanceof Date) {
            return DateUtils_1.DateUtils.mixedDateToDatetimeString(value, true);
          }
          escapedParameters.push(value);
          return this.createParameter(key, escapedParameters.length - 1);
        });
        return [sql, escapedParameters];
      }
      /**
       * Escapes a column name.
       */
      escape(columnName) {
        return `"${columnName}"`;
      }
      /**
       * Build full table name with schema name and table name.
       * E.g. myDB.mySchema.myTable
       */
      buildTableName(tableName, schema) {
        const tablePath = [tableName];
        if (schema) {
          tablePath.unshift(schema);
        }
        return tablePath.join(".");
      }
      /**
       * Parse a target table name or other types and return a normalized table definition.
       */
      parseTableName(target) {
        const driverDatabase = this.database;
        const driverSchema = this.schema;
        if (InstanceChecker_1.InstanceChecker.isTable(target) || InstanceChecker_1.InstanceChecker.isView(target)) {
          const parsed = this.parseTableName(target.name);
          return {
            database: target.database || parsed.database || driverDatabase,
            schema: target.schema || parsed.schema || driverSchema,
            tableName: parsed.tableName
          };
        }
        if (InstanceChecker_1.InstanceChecker.isTableForeignKey(target)) {
          const parsed = this.parseTableName(target.referencedTableName);
          return {
            database: target.referencedDatabase || parsed.database || driverDatabase,
            schema: target.referencedSchema || parsed.schema || driverSchema,
            tableName: parsed.tableName
          };
        }
        if (InstanceChecker_1.InstanceChecker.isEntityMetadata(target)) {
          return {
            database: target.database || driverDatabase,
            schema: target.schema || driverSchema,
            tableName: target.tableName
          };
        }
        const parts = target.split(".");
        return {
          database: driverDatabase,
          schema: (parts.length > 1 ? parts[0] : void 0) || driverSchema,
          tableName: parts.length > 1 ? parts[1] : parts[0]
        };
      }
      /**
       * Prepares given value to a value to be persisted, based on its column type and metadata.
       */
      preparePersistentValue(value, columnMetadata) {
        if (columnMetadata.transformer)
          value = ApplyValueTransformers_1.ApplyValueTransformers.transformTo(columnMetadata.transformer, value);
        if (value === null || value === void 0)
          return value;
        if (columnMetadata.type === "date") {
          return DateUtils_1.DateUtils.mixedDateToDateString(value);
        } else if (columnMetadata.type === "time") {
          return DateUtils_1.DateUtils.mixedDateToTimeString(value);
        } else if (columnMetadata.type === "timestamp" || columnMetadata.type === Date) {
          return DateUtils_1.DateUtils.mixedDateToDatetimeString(value, true);
        } else if (columnMetadata.type === "seconddate") {
          return DateUtils_1.DateUtils.mixedDateToDatetimeString(value, false);
        } else if (columnMetadata.type === "simple-array") {
          return DateUtils_1.DateUtils.simpleArrayToString(value);
        } else if (columnMetadata.type === "simple-json") {
          return DateUtils_1.DateUtils.simpleJsonToString(value);
        } else if (columnMetadata.type === "simple-enum") {
          return DateUtils_1.DateUtils.simpleEnumToString(value);
        } else if (columnMetadata.isArray) {
          return () => `ARRAY(${value.map((it) => `'${it}'`)})`;
        }
        return value;
      }
      /**
       * Prepares given value to a value to be persisted, based on its column type or metadata.
       */
      prepareHydratedValue(value, columnMetadata) {
        if (value === null || value === void 0)
          return columnMetadata.transformer ? ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value) : value;
        if (columnMetadata.type === "timestamp" || columnMetadata.type === "seconddate" || columnMetadata.type === Date) {
          value = DateUtils_1.DateUtils.normalizeHydratedDate(value);
        } else if (columnMetadata.type === "date") {
          value = DateUtils_1.DateUtils.mixedDateToDateString(value);
        } else if (columnMetadata.type === "time") {
          value = DateUtils_1.DateUtils.mixedTimeToString(value);
        } else if (columnMetadata.type === "simple-array") {
          value = DateUtils_1.DateUtils.stringToSimpleArray(value);
        } else if (columnMetadata.type === "simple-json") {
          value = DateUtils_1.DateUtils.stringToSimpleJson(value);
        } else if (columnMetadata.type === "simple-enum") {
          value = DateUtils_1.DateUtils.stringToSimpleEnum(value, columnMetadata);
        }
        if (columnMetadata.transformer)
          value = ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);
        return value;
      }
      /**
       * Creates a database type from a given column metadata.
       */
      normalizeType(column) {
        if (column.type === Number || column.type === "int") {
          return "integer";
        } else if (column.type === "dec") {
          return "decimal";
        } else if (column.type === "float") {
          const length = typeof column.length === "string" ? parseInt(column.length) : column.length;
          if (length && length < 25) {
            return "real";
          }
          return "double";
        } else if (column.type === String) {
          return "nvarchar";
        } else if (column.type === Date) {
          return "timestamp";
        } else if (column.type === Boolean) {
          return "boolean";
        } else if (column.type === Buffer) {
          return "blob";
        } else if (column.type === "uuid") {
          return "nvarchar";
        } else if (column.type === "simple-array" || column.type === "simple-json") {
          return "nclob";
        } else if (column.type === "simple-enum") {
          return "nvarchar";
        }
        if (DriverUtils_1.DriverUtils.isReleaseVersionOrGreater(this, "4.0")) {
          if (column.type === "varchar" || column.type === "alphanum" || column.type === "shorttext") {
            return "nvarchar";
          } else if (column.type === "text" || column.type === "clob") {
            return "nclob";
          } else if (column.type === "char") {
            return "nchar";
          }
        } else {
          if (column.type === "real_vector" || column.type === "half_vector") {
            return "varbinary";
          }
        }
        return column.type || "";
      }
      /**
       * Normalizes "default" value of the column.
       */
      normalizeDefault(columnMetadata) {
        const defaultValue = columnMetadata.default;
        if (typeof defaultValue === "number") {
          return `${defaultValue}`;
        }
        if (typeof defaultValue === "boolean") {
          return defaultValue ? "true" : "false";
        }
        if (typeof defaultValue === "function") {
          return defaultValue();
        }
        if (typeof defaultValue === "string") {
          return `'${defaultValue}'`;
        }
        if (defaultValue === null || defaultValue === void 0) {
          return void 0;
        }
        return `${defaultValue}`;
      }
      /**
       * Normalizes "isUnique" value of the column.
       */
      normalizeIsUnique(column) {
        return column.entityMetadata.indices.some((idx) => idx.isUnique && idx.columns.length === 1 && idx.columns[0] === column);
      }
      /**
       * Returns default column lengths, which is required on column creation.
       */
      getColumnLength(column) {
        if (column.length)
          return column.length.toString();
        if (column.generationStrategy === "uuid")
          return "36";
        switch (column.type) {
          case "varchar":
          case "nvarchar":
          case "shorttext":
          case String:
            return "255";
          case "alphanum":
            return "127";
          case "varbinary":
            return "255";
        }
        return "";
      }
      /**
       * Creates column type definition including length, precision and scale
       */
      createFullType(column) {
        let type = column.type;
        if (this.getColumnLength(column)) {
          type += `(${this.getColumnLength(column)})`;
        } else if (column.precision !== null && column.precision !== void 0 && column.scale !== null && column.scale !== void 0) {
          type += `(${column.precision},${column.scale})`;
        } else if (column.precision !== null && column.precision !== void 0) {
          type += `(${column.precision})`;
        }
        if (column.isArray)
          type += " array";
        return type;
      }
      /**
       * Creates generated map of values generated or returned by database after INSERT query.
       */
      createGeneratedMap(metadata, insertResult) {
        const generatedMap = metadata.generatedColumns.reduce((map, generatedColumn) => {
          let value;
          if (generatedColumn.generationStrategy === "increment" && insertResult) {
            value = insertResult;
          }
          return OrmUtils_1.OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));
        }, {});
        return Object.keys(generatedMap).length > 0 ? generatedMap : void 0;
      }
      /**
       * Differentiate columns of this table and columns from the given column metadatas columns
       * and returns only changed.
       */
      findChangedColumns(tableColumns, columnMetadatas) {
        return columnMetadatas.filter((columnMetadata) => {
          const tableColumn = tableColumns.find((c) => c.name === columnMetadata.databaseName);
          if (!tableColumn) {
            return false;
          }
          const normalizedDefault = this.normalizeDefault(columnMetadata);
          return tableColumn.name !== columnMetadata.databaseName || tableColumn.type !== this.normalizeType(columnMetadata) || columnMetadata.length && tableColumn.length !== this.getColumnLength(columnMetadata) || tableColumn.precision !== columnMetadata.precision || tableColumn.scale !== columnMetadata.scale || tableColumn.comment !== this.escapeComment(columnMetadata.comment) || !tableColumn.isGenerated && normalizedDefault !== tableColumn.default || // we included check for generated here, because generated columns already can have default values
          tableColumn.isPrimary !== columnMetadata.isPrimary || tableColumn.isNullable !== columnMetadata.isNullable || tableColumn.isUnique !== this.normalizeIsUnique(columnMetadata) || columnMetadata.generationStrategy !== "uuid" && tableColumn.isGenerated !== columnMetadata.isGenerated;
        });
      }
      /**
       * Returns true if driver supports RETURNING / OUTPUT statement.
       */
      isReturningSqlSupported() {
        return false;
      }
      /**
       * Returns true if driver supports uuid values generation on its own.
       */
      isUUIDGenerationSupported() {
        return false;
      }
      /**
       * Returns true if driver supports fulltext indices.
       */
      isFullTextColumnTypeSupported() {
        return !DriverUtils_1.DriverUtils.isReleaseVersionOrGreater(this, "4.0");
      }
      /**
       * Creates an escaped parameter.
       */
      createParameter(parameterName, index) {
        return "?";
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * If driver dependency is not given explicitly, then try to load it via "require".
       */
      loadDependencies() {
        const client = this.options.driver ?? this.options.hanaClientDriver;
        if (client) {
          this.client = client;
          return;
        }
        try {
          this.client = PlatformTools_1.PlatformTools.load("@sap/hana-client");
          this.streamClient = PlatformTools_1.PlatformTools.load("@sap/hana-client/extension/Stream");
        } catch {
          throw new DriverPackageNotInstalledError_1.DriverPackageNotInstalledError("SAP Hana", "@sap/hana-client");
        }
      }
      /**
       * Escapes a given comment.
       */
      escapeComment(comment) {
        if (!comment)
          return comment;
        comment = comment.replace(/\u0000/g, "");
        return comment;
      }
    };
    exports2.SapDriver = SapDriver;
  }
});

// node_modules/typeorm/driver/better-sqlite3/BetterSqlite3QueryRunner.js
var require_BetterSqlite3QueryRunner = __commonJS({
  "node_modules/typeorm/driver/better-sqlite3/BetterSqlite3QueryRunner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BetterSqlite3QueryRunner = void 0;
    var QueryRunnerAlreadyReleasedError_1 = require_QueryRunnerAlreadyReleasedError();
    var QueryFailedError_1 = require_QueryFailedError();
    var AbstractSqliteQueryRunner_1 = require_AbstractSqliteQueryRunner();
    var Broadcaster_1 = require_Broadcaster();
    var QueryResult_1 = require_QueryResult();
    var BroadcasterResult_1 = require_BroadcasterResult();
    var BetterSqlite3QueryRunner = class extends AbstractSqliteQueryRunner_1.AbstractSqliteQueryRunner {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(driver) {
        super();
        this.stmtCache = /* @__PURE__ */ new Map();
        this.driver = driver;
        this.connection = driver.connection;
        this.broadcaster = new Broadcaster_1.Broadcaster(this);
        if (typeof this.driver.options.statementCacheSize === "number") {
          this.cacheSize = this.driver.options.statementCacheSize;
        } else {
          this.cacheSize = 100;
        }
      }
      async getStmt(query) {
        if (this.cacheSize > 0) {
          let stmt = this.stmtCache.get(query);
          if (!stmt) {
            const databaseConnection = await this.connect();
            stmt = databaseConnection.prepare(query);
            this.stmtCache.set(query, stmt);
            while (this.stmtCache.size > this.cacheSize) {
              const key = this.stmtCache.keys().next().value;
              this.stmtCache.delete(key);
            }
          }
          return stmt;
        } else {
          const databaseConnection = await this.connect();
          return databaseConnection.prepare(query);
        }
      }
      /**
       * Called before migrations are run.
       */
      async beforeMigration() {
        await this.query(`PRAGMA foreign_keys = OFF`);
      }
      /**
       * Called after migrations are run.
       */
      async afterMigration() {
        await this.query(`PRAGMA foreign_keys = ON`);
      }
      /**
       * Executes a given SQL query.
       */
      async query(query, parameters = [], useStructuredResult = false) {
        if (this.isReleased)
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        const connection = this.driver.connection;
        const broadcasterResult = new BroadcasterResult_1.BroadcasterResult();
        this.driver.connection.logger.logQuery(query, parameters, this);
        this.broadcaster.broadcastBeforeQueryEvent(broadcasterResult, query, parameters);
        const queryStartTime = Date.now();
        const stmt = await this.getStmt(query);
        try {
          const result = new QueryResult_1.QueryResult();
          if (stmt.reader) {
            const raw = stmt.all(...parameters);
            result.raw = raw;
            if (Array.isArray(raw)) {
              result.records = raw;
            }
          } else {
            const raw = stmt.run(...parameters);
            result.affected = raw.changes;
            result.raw = raw.lastInsertRowid;
          }
          const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
          const queryEndTime = Date.now();
          const queryExecutionTime = queryEndTime - queryStartTime;
          if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime)
            connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
          this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, result.raw, void 0);
          if (!useStructuredResult) {
            return result.raw;
          }
          return result;
        } catch (err) {
          connection.logger.logQueryError(err, query, parameters, this);
          throw new QueryFailedError_1.QueryFailedError(query, parameters, err);
        }
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      async loadTableRecords(tablePath, tableOrIndex) {
        const [database, tableName] = this.splitTablePath(tablePath);
        const res = await this.query(`SELECT ${database ? `'${database}'` : null} as database, * FROM ${this.escapePath(`${database ? `${database}.` : ""}sqlite_master`)} WHERE "type" = '${tableOrIndex}' AND "${tableOrIndex === "table" ? "name" : "tbl_name"}" IN ('${tableName}')`);
        return res;
      }
      async loadPragmaRecords(tablePath, pragma) {
        const [database, tableName] = this.splitTablePath(tablePath);
        const res = await this.query(`PRAGMA ${database ? `"${database}".` : ""}${pragma}("${tableName}")`);
        return res;
      }
    };
    exports2.BetterSqlite3QueryRunner = BetterSqlite3QueryRunner;
  }
});

// node_modules/typeorm/driver/better-sqlite3/BetterSqlite3Driver.js
var require_BetterSqlite3Driver = __commonJS({
  "node_modules/typeorm/driver/better-sqlite3/BetterSqlite3Driver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BetterSqlite3Driver = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var promises_1 = tslib_1.__importDefault(require("fs/promises"));
    var path_1 = tslib_1.__importDefault(require("path"));
    var error_1 = require_error();
    var PlatformTools_1 = require_PlatformTools();
    var AbstractSqliteDriver_1 = require_AbstractSqliteDriver();
    var BetterSqlite3QueryRunner_1 = require_BetterSqlite3QueryRunner();
    var PathUtils_1 = require_PathUtils();
    var BetterSqlite3Driver = class extends AbstractSqliteDriver_1.AbstractSqliteDriver {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection) {
        super(connection);
        this.connection = connection;
        this.options = connection.options;
        this.database = this.options.database;
        this.loadDependencies();
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Closes connection with database.
       */
      async disconnect() {
        this.queryRunner = void 0;
        this.databaseConnection.close();
      }
      /**
       * Creates a query runner used to execute database queries.
       */
      createQueryRunner(mode) {
        if (!this.queryRunner)
          this.queryRunner = new BetterSqlite3QueryRunner_1.BetterSqlite3QueryRunner(this);
        return this.queryRunner;
      }
      normalizeType(column) {
        if (column.type === Buffer) {
          return "blob";
        }
        return super.normalizeType(column);
      }
      async afterConnect() {
        return this.attachDatabases();
      }
      /**
       * For SQLite, the database may be added in the decorator metadata. It will be a filepath to a database file.
       */
      buildTableName(tableName, _schema, database) {
        if (!database)
          return tableName;
        if (this.getAttachedDatabaseHandleByRelativePath(database))
          return `${this.getAttachedDatabaseHandleByRelativePath(database)}.${tableName}`;
        if (database === this.options.database)
          return tableName;
        const identifierHash = (0, PathUtils_1.filepathToName)(database);
        const absFilepath = (0, PathUtils_1.isAbsolute)(database) ? database : path_1.default.join(this.getMainDatabasePath(), database);
        this.attachedDatabases[database] = {
          attachFilepathAbsolute: absFilepath,
          attachFilepathRelative: database,
          attachHandle: identifierHash
        };
        return `${identifierHash}.${tableName}`;
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Creates connection with the database.
       */
      async createDatabaseConnection() {
        if (this.options.database !== ":memory:")
          await this.createDatabaseDirectory(path_1.default.dirname(this.options.database));
        const { database, readonly = false, fileMustExist = false, timeout = 5e3, verbose = null, nativeBinding = null, prepareDatabase } = this.options;
        const databaseConnection = this.sqlite(database, {
          readonly,
          fileMustExist,
          timeout,
          verbose,
          nativeBinding
        });
        if (this.options.key) {
          databaseConnection.exec(`PRAGMA key = ${JSON.stringify(this.options.key)}`);
        }
        if (typeof prepareDatabase === "function") {
          await prepareDatabase(databaseConnection);
        }
        databaseConnection.exec(`PRAGMA foreign_keys = ON`);
        if (this.options.enableWAL) {
          databaseConnection.exec(`PRAGMA journal_mode = WAL`);
        }
        return databaseConnection;
      }
      /**
       * If driver dependency is not given explicitly, then try to load it via "require".
       */
      loadDependencies() {
        try {
          const sqlite = this.options.driver || PlatformTools_1.PlatformTools.load("better-sqlite3");
          this.sqlite = sqlite;
        } catch (e) {
          throw new error_1.DriverPackageNotInstalledError("SQLite", "better-sqlite3");
        }
      }
      /**
       * Auto creates database directory if it does not exist.
       */
      async createDatabaseDirectory(dbPath) {
        await promises_1.default.mkdir(dbPath, { recursive: true });
      }
      /**
       * Performs the attaching of the database files. The attachedDatabase should have been populated during calls to #buildTableName
       * during EntityMetadata production (see EntityMetadata#buildTablePath)
       *
       * https://sqlite.org/lang_attach.html
       */
      async attachDatabases() {
        for (const { attachHandle, attachFilepathAbsolute } of Object.values(this.attachedDatabases)) {
          await this.createDatabaseDirectory(path_1.default.dirname(attachFilepathAbsolute));
          await this.connection.query(`ATTACH "${attachFilepathAbsolute}" AS "${attachHandle}"`);
        }
      }
      getMainDatabasePath() {
        const optionsDb = this.options.database;
        return path_1.default.dirname((0, PathUtils_1.isAbsolute)(optionsDb) ? optionsDb : path_1.default.join(this.options.baseDirectory, optionsDb));
      }
    };
    exports2.BetterSqlite3Driver = BetterSqlite3Driver;
  }
});

// node_modules/typeorm/driver/capacitor/CapacitorQueryRunner.js
var require_CapacitorQueryRunner = __commonJS({
  "node_modules/typeorm/driver/capacitor/CapacitorQueryRunner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CapacitorQueryRunner = void 0;
    var QueryRunnerAlreadyReleasedError_1 = require_QueryRunnerAlreadyReleasedError();
    var QueryFailedError_1 = require_QueryFailedError();
    var AbstractSqliteQueryRunner_1 = require_AbstractSqliteQueryRunner();
    var Broadcaster_1 = require_Broadcaster();
    var QueryResult_1 = require_QueryResult();
    var CapacitorQueryRunner = class extends AbstractSqliteQueryRunner_1.AbstractSqliteQueryRunner {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(driver) {
        super();
        this.driver = driver;
        this.connection = driver.connection;
        this.broadcaster = new Broadcaster_1.Broadcaster(this);
      }
      /**
       * Called before migrations are run.
       */
      async beforeMigration() {
        await this.query(`PRAGMA foreign_keys = OFF`);
      }
      /**
       * Called after migrations are run.
       */
      async afterMigration() {
        await this.query(`PRAGMA foreign_keys = ON`);
      }
      async executeSet(set) {
        if (this.isReleased)
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        const databaseConnection = await this.connect();
        return databaseConnection.executeSet(set, false);
      }
      /**
       * Executes a given SQL query.
       */
      async query(query, parameters, useStructuredResult = false) {
        if (this.isReleased)
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        const databaseConnection = await this.connect();
        this.driver.connection.logger.logQuery(query, parameters, this);
        const command = query.substring(0, query.indexOf(" ") !== -1 ? query.indexOf(" ") : void 0);
        try {
          let raw;
          if ([
            "BEGIN",
            "ROLLBACK",
            "COMMIT",
            "CREATE",
            "ALTER",
            "DROP"
          ].indexOf(command) !== -1) {
            raw = await databaseConnection.execute(query, false);
          } else if (["INSERT", "UPDATE", "DELETE"].indexOf(command) !== -1) {
            raw = await databaseConnection.run(query, parameters, false);
          } else {
            raw = await databaseConnection.query(query, parameters || []);
          }
          const result = new QueryResult_1.QueryResult();
          if (raw?.hasOwnProperty("values")) {
            result.raw = raw.values;
            result.records = raw.values;
          }
          if (raw?.hasOwnProperty("changes")) {
            result.affected = raw.changes.changes;
            result.raw = raw.changes.lastId || raw.changes.changes;
          }
          if (!useStructuredResult) {
            return result.raw;
          }
          return result;
        } catch (err) {
          this.driver.connection.logger.logQueryError(err, query, parameters, this);
          throw new QueryFailedError_1.QueryFailedError(query, parameters, err);
        }
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Parametrizes given object of values. Used to create column=value queries.
       */
      parametrize(objectLiteral) {
        return Object.keys(objectLiteral).map((key) => `"${key}"=?`);
      }
    };
    exports2.CapacitorQueryRunner = CapacitorQueryRunner;
  }
});

// node_modules/typeorm/driver/capacitor/CapacitorDriver.js
var require_CapacitorDriver = __commonJS({
  "node_modules/typeorm/driver/capacitor/CapacitorDriver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CapacitorDriver = void 0;
    var AbstractSqliteDriver_1 = require_AbstractSqliteDriver();
    var CapacitorQueryRunner_1 = require_CapacitorQueryRunner();
    var error_1 = require_error();
    var CapacitorDriver = class extends AbstractSqliteDriver_1.AbstractSqliteDriver {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection) {
        super(connection);
        this.database = this.options.database;
        this.driver = this.options.driver;
        this.sqlite = this.options.driver;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Performs connection to the database.
       */
      async connect() {
        this.databaseConnection = this.createDatabaseConnection();
        await this.databaseConnection;
      }
      /**
       * Closes connection with database.
       */
      async disconnect() {
        this.queryRunner = void 0;
        const databaseConnection = await this.databaseConnection;
        return databaseConnection.close().then(() => {
          this.databaseConnection = void 0;
        });
      }
      /**
       * Creates a query runner used to execute database queries.
       */
      createQueryRunner(mode) {
        if (!this.queryRunner)
          this.queryRunner = new CapacitorQueryRunner_1.CapacitorQueryRunner(this);
        return this.queryRunner;
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Creates connection with the database.
       */
      async createDatabaseConnection() {
        const databaseMode = this.options.mode || "no-encryption";
        const isDatabaseEncryted = databaseMode !== "no-encryption";
        const databaseVersion = typeof this.options.version === "undefined" ? 1 : this.options.version;
        const connection = await this.sqlite.createConnection(this.options.database, isDatabaseEncryted, databaseMode, databaseVersion);
        await connection.open();
        await connection.execute(`PRAGMA foreign_keys = ON`);
        if (this.options.journalMode && ["DELETE", "TRUNCATE", "PERSIST", "MEMORY", "WAL", "OFF"].indexOf(this.options.journalMode) !== -1) {
          await connection.execute(`PRAGMA journal_mode = ${this.options.journalMode}`);
        }
        return connection;
      }
      loadDependencies() {
        this.sqlite = this.driver;
        if (!this.driver) {
          throw new error_1.DriverPackageNotInstalledError("Capacitor", "@capacitor-community/sqlite");
        }
      }
    };
    exports2.CapacitorDriver = CapacitorDriver;
  }
});

// node_modules/typeorm/driver/spanner/SpannerQueryRunner.js
var require_SpannerQueryRunner = __commonJS({
  "node_modules/typeorm/driver/spanner/SpannerQueryRunner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SpannerQueryRunner = void 0;
    var error_1 = require_error();
    var QueryFailedError_1 = require_QueryFailedError();
    var QueryRunnerAlreadyReleasedError_1 = require_QueryRunnerAlreadyReleasedError();
    var TransactionNotStartedError_1 = require_TransactionNotStartedError();
    var BaseQueryRunner_1 = require_BaseQueryRunner();
    var QueryResult_1 = require_QueryResult();
    var Table_1 = require_Table();
    var TableCheck_1 = require_TableCheck();
    var TableColumn_1 = require_TableColumn();
    var TableForeignKey_1 = require_TableForeignKey();
    var TableIndex_1 = require_TableIndex();
    var TableUnique_1 = require_TableUnique();
    var View_1 = require_View();
    var Broadcaster_1 = require_Broadcaster();
    var BroadcasterResult_1 = require_BroadcasterResult();
    var OrmUtils_1 = require_OrmUtils();
    var Query_1 = require_Query();
    var MetadataTableType_1 = require_MetadataTableType();
    var SpannerQueryRunner = class extends BaseQueryRunner_1.BaseQueryRunner {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(driver, mode) {
        super();
        this.driver = driver;
        this.connection = driver.connection;
        this.mode = mode;
        this.broadcaster = new Broadcaster_1.Broadcaster(this);
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Creates/uses database connection from the connection pool to perform further operations.
       * Returns obtained database connection.
       */
      async connect() {
        if (this.session) {
          return Promise.resolve(this.session);
        }
        const [session] = await this.driver.instanceDatabase.createSession({});
        this.session = session;
        this.sessionTransaction = await session.transaction();
        return this.session;
      }
      /**
       * Releases used database connection.
       * You cannot use query runner methods once its released.
       */
      async release() {
        this.isReleased = true;
        if (this.session) {
          await this.session.delete();
        }
        this.session = void 0;
        return Promise.resolve();
      }
      /**
       * Starts transaction.
       */
      async startTransaction(isolationLevel) {
        this.isTransactionActive = true;
        try {
          await this.broadcaster.broadcast("BeforeTransactionStart");
        } catch (err) {
          this.isTransactionActive = false;
          throw err;
        }
        await this.connect();
        await this.sessionTransaction.begin();
        this.connection.logger.logQuery("START TRANSACTION");
        await this.broadcaster.broadcast("AfterTransactionStart");
      }
      /**
       * Commits transaction.
       * Error will be thrown if transaction was not started.
       */
      async commitTransaction() {
        if (!this.isTransactionActive || !this.sessionTransaction)
          throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionCommit");
        await this.sessionTransaction.commit();
        this.connection.logger.logQuery("COMMIT");
        this.isTransactionActive = false;
        await this.broadcaster.broadcast("AfterTransactionCommit");
      }
      /**
       * Rollbacks transaction.
       * Error will be thrown if transaction was not started.
       */
      async rollbackTransaction() {
        if (!this.isTransactionActive || !this.sessionTransaction)
          throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionRollback");
        await this.sessionTransaction.rollback();
        this.connection.logger.logQuery("ROLLBACK");
        this.isTransactionActive = false;
        await this.broadcaster.broadcast("AfterTransactionRollback");
      }
      /**
       * Executes a given SQL query.
       */
      async query(query, parameters, useStructuredResult = false) {
        if (this.isReleased)
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        await this.connect();
        this.driver.connection.logger.logQuery(query, parameters, this);
        await this.broadcaster.broadcast("BeforeQuery", query, parameters);
        const broadcasterResult = new BroadcasterResult_1.BroadcasterResult();
        try {
          const queryStartTime = Date.now();
          let rawResult = void 0;
          const isSelect = query.startsWith("SELECT");
          const executor = isSelect && !this.isTransactionActive ? this.driver.instanceDatabase : this.sessionTransaction;
          if (!this.isTransactionActive && !isSelect) {
            await this.sessionTransaction.begin();
          }
          try {
            rawResult = await executor.run({
              sql: query,
              params: parameters ? parameters.reduce((params, value, index) => {
                params["param" + index] = value;
                return params;
              }, {}) : void 0,
              json: true
            });
            if (!this.isTransactionActive && !isSelect) {
              await this.sessionTransaction.commit();
            }
          } catch (error) {
            try {
              if (!this.isTransactionActive && !isSelect)
                await this.sessionTransaction.rollback();
            } catch (rollbackError) {
            }
            throw error;
          }
          const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
          const queryEndTime = Date.now();
          const queryExecutionTime = queryEndTime - queryStartTime;
          this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, rawResult, void 0);
          if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime)
            this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
          const result = new QueryResult_1.QueryResult();
          result.raw = rawResult;
          result.records = rawResult ? rawResult[0] : [];
          if (rawResult && rawResult[1] && rawResult[1].rowCountExact) {
            result.affected = parseInt(rawResult[1].rowCountExact);
          }
          if (!useStructuredResult) {
            return result.records;
          }
          return result;
        } catch (err) {
          this.driver.connection.logger.logQueryError(err, query, parameters, this);
          this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, void 0, void 0, err);
          throw new QueryFailedError_1.QueryFailedError(query, parameters, err);
        } finally {
          await broadcasterResult.wait();
        }
      }
      /**
       * Update database schema.
       * Used for creating/altering/dropping tables, columns, indexes, etc.
       *
       * DDL changing queries should be executed by `updateSchema()` method.
       */
      async updateDDL(query, parameters) {
        if (this.isReleased)
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        this.driver.connection.logger.logQuery(query, parameters, this);
        try {
          const queryStartTime = Date.now();
          const [operation] = await this.driver.instanceDatabase.updateSchema(query);
          await operation.promise();
          const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
          const queryEndTime = Date.now();
          const queryExecutionTime = queryEndTime - queryStartTime;
          if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime)
            this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
        } catch (err) {
          this.driver.connection.logger.logQueryError(err, query, parameters, this);
          throw new QueryFailedError_1.QueryFailedError(query, parameters, err);
        }
      }
      /**
       * Returns raw data stream.
       */
      async stream(query, parameters, onEnd, onError) {
        if (this.isReleased)
          throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        try {
          this.driver.connection.logger.logQuery(query, parameters, this);
          const request = {
            sql: query,
            params: parameters ? parameters.reduce((params, value, index) => {
              params["param" + index] = value;
              return params;
            }, {}) : void 0,
            json: true
          };
          const stream = this.driver.instanceDatabase.runStream(request);
          if (onEnd) {
            stream.on("end", onEnd);
          }
          if (onError) {
            stream.on("error", onError);
          }
          return stream;
        } catch (err) {
          this.driver.connection.logger.logQueryError(err, query, parameters, this);
          throw new QueryFailedError_1.QueryFailedError(query, parameters, err);
        }
      }
      /**
       * Returns all available database names including system databases.
       */
      async getDatabases() {
        return Promise.resolve([]);
      }
      /**
       * Returns all available schema names including system schemas.
       * If database parameter specified, returns schemas of that database.
       */
      async getSchemas(database) {
        return Promise.resolve([]);
      }
      /**
       * Checks if database with the given name exist.
       */
      async hasDatabase(database) {
        throw new error_1.TypeORMError(`Check database queries are not supported by Spanner driver.`);
      }
      /**
       * Loads currently using database
       */
      async getCurrentDatabase() {
        throw new error_1.TypeORMError(`Check database queries are not supported by Spanner driver.`);
      }
      /**
       * Checks if schema with the given name exist.
       */
      async hasSchema(schema) {
        const result = await this.query(`SELECT * FROM "information_schema"."schemata" WHERE "schema_name" = '${schema}'`);
        return result.length ? true : false;
      }
      /**
       * Loads currently using database schema
       */
      async getCurrentSchema() {
        throw new error_1.TypeORMError(`Check schema queries are not supported by Spanner driver.`);
      }
      /**
       * Checks if table with the given name exist in the database.
       */
      async hasTable(tableOrName) {
        const tableName = tableOrName instanceof Table_1.Table ? tableOrName.name : tableOrName;
        const sql = `SELECT * FROM \`INFORMATION_SCHEMA\`.\`TABLES\` WHERE \`TABLE_CATALOG\` = '' AND \`TABLE_SCHEMA\` = '' AND \`TABLE_TYPE\` = 'BASE TABLE' AND \`TABLE_NAME\` = '${tableName}'`;
        const result = await this.query(sql);
        return result.length ? true : false;
      }
      /**
       * Checks if column with the given name exist in the given table.
       */
      async hasColumn(tableOrName, columnName) {
        const tableName = tableOrName instanceof Table_1.Table ? tableOrName.name : tableOrName;
        const sql = `SELECT * FROM \`INFORMATION_SCHEMA\`.\`COLUMNS\` WHERE \`TABLE_CATALOG\` = '' AND \`TABLE_SCHEMA\` = '' AND \`TABLE_NAME\` = '${tableName}' AND \`COLUMN_NAME\` = '${columnName}'`;
        const result = await this.query(sql);
        return result.length ? true : false;
      }
      /**
       * Creates a new database.
       * Note: Spanner does not support database creation inside a transaction block.
       */
      async createDatabase(database, ifNotExist) {
        if (ifNotExist) {
          const databaseAlreadyExists = await this.hasDatabase(database);
          if (databaseAlreadyExists)
            return Promise.resolve();
        }
        const up = `CREATE DATABASE "${database}"`;
        const down = `DROP DATABASE "${database}"`;
        await this.executeQueries(new Query_1.Query(up), new Query_1.Query(down));
      }
      /**
       * Drops database.
       * Note: Spanner does not support database dropping inside a transaction block.
       */
      async dropDatabase(database, ifExist) {
        const up = ifExist ? `DROP DATABASE IF EXISTS "${database}"` : `DROP DATABASE "${database}"`;
        const down = `CREATE DATABASE "${database}"`;
        await this.executeQueries(new Query_1.Query(up), new Query_1.Query(down));
      }
      /**
       * Creates a new table schema.
       */
      async createSchema(schemaPath, ifNotExist) {
        return Promise.resolve();
      }
      /**
       * Drops table schema.
       */
      async dropSchema(schemaPath, ifExist, isCascade) {
        return Promise.resolve();
      }
      /**
       * Creates a new table.
       */
      async createTable(table, ifNotExist = false, createForeignKeys = true, createIndices = true) {
        if (ifNotExist) {
          const isTableExist = await this.hasTable(table);
          if (isTableExist)
            return Promise.resolve();
        }
        const upQueries = [];
        const downQueries = [];
        upQueries.push(this.createTableSql(table, createForeignKeys));
        downQueries.push(this.dropTableSql(table));
        if (createForeignKeys)
          table.foreignKeys.forEach((foreignKey) => downQueries.push(this.dropForeignKeySql(table, foreignKey)));
        if (createIndices) {
          table.indices.forEach((index) => {
            if (!index.name)
              index.name = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);
            upQueries.push(this.createIndexSql(table, index));
            downQueries.push(this.dropIndexSql(table, index));
          });
        }
        const generatedColumns = table.columns.filter((column) => column.generatedType && column.asExpression);
        for (const column of generatedColumns) {
          const insertQuery = this.insertTypeormMetadataSql({
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name,
            value: column.asExpression
          });
          const deleteQuery = this.deleteTypeormMetadataSql({
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name
          });
          upQueries.push(insertQuery);
          downQueries.push(deleteQuery);
        }
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Drops the table.
       */
      async dropTable(target, ifExist, dropForeignKeys = true, dropIndices = true) {
        if (ifExist) {
          const isTableExist = await this.hasTable(target);
          if (!isTableExist)
            return Promise.resolve();
        }
        const createForeignKeys = dropForeignKeys;
        const tablePath = this.getTablePath(target);
        const table = await this.getCachedTable(tablePath);
        const upQueries = [];
        const downQueries = [];
        if (dropIndices) {
          table.indices.forEach((index) => {
            upQueries.push(this.dropIndexSql(table, index));
            downQueries.push(this.createIndexSql(table, index));
          });
        }
        if (dropForeignKeys)
          table.foreignKeys.forEach((foreignKey) => upQueries.push(this.dropForeignKeySql(table, foreignKey)));
        upQueries.push(this.dropTableSql(table));
        downQueries.push(this.createTableSql(table, createForeignKeys));
        const generatedColumns = table.columns.filter((column) => column.generatedType && column.asExpression);
        for (const column of generatedColumns) {
          const deleteQuery = this.deleteTypeormMetadataSql({
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name
          });
          const insertQuery = this.insertTypeormMetadataSql({
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name,
            value: column.asExpression
          });
          upQueries.push(deleteQuery);
          downQueries.push(insertQuery);
        }
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Creates a new view.
       */
      async createView(view) {
        const upQueries = [];
        const downQueries = [];
        upQueries.push(this.createViewSql(view));
        upQueries.push(await this.insertViewDefinitionSql(view));
        downQueries.push(this.dropViewSql(view));
        downQueries.push(await this.deleteViewDefinitionSql(view));
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Drops the view.
       */
      async dropView(target) {
        const viewName = target instanceof View_1.View ? target.name : target;
        const view = await this.getCachedView(viewName);
        const upQueries = [];
        const downQueries = [];
        upQueries.push(await this.deleteViewDefinitionSql(view));
        upQueries.push(this.dropViewSql(view));
        downQueries.push(await this.insertViewDefinitionSql(view));
        downQueries.push(this.createViewSql(view));
        await this.executeQueries(upQueries, downQueries);
      }
      /**
       * Renames the given table.
       */
      async renameTable(oldTableOrName, newTableName) {
        throw new error_1.TypeORMError(`Rename table queries are not supported by Spanner driver.`);
      }
      /**
       * Creates a new column from the column in the table.
       */
      async addColumn(tableOrName, column) {
        const table = tableOrName instanceof Table_1.Table ? tableOrName : await this.getCachedTable(tableOrName);
        const clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(column)}`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN ${this.driver.escape(column.name)}`));
        const columnIndex = clonedTable.indices.find((index) => index.columnNames.length === 1 && index.columnNames[0] === column.name);
        if (columnIndex) {
          upQueries.push(this.createIndexSql(table, columnIndex));
          downQueries.push(this.dropIndexSql(table, columnIndex));
        } else if (column.isUnique) {
          const uniqueIndex = new TableIndex_1.TableIndex({
            name: this.connection.namingStrategy.indexName(table, [
              column.name
            ]),
            columnNames: [column.name],
            isUnique: true
          });
          clonedTable.indices.push(uniqueIndex);
          clonedTable.uniques.push(new TableUnique_1.TableUnique({
            name: uniqueIndex.name,
            columnNames: uniqueIndex.columnNames
          }));
          upQueries.push(this.createIndexSql(table, uniqueIndex));
          downQueries.push(this.dropIndexSql(table, uniqueIndex));
        }
        if (column.generatedType && column.asExpression) {
          const insertQuery = this.insertTypeormMetadataSql({
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name,
            value: column.asExpression
          });
          const deleteQuery = this.deleteTypeormMetadataSql({
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name
          });
          upQueries.push(insertQuery);
          downQueries.push(deleteQuery);
        }
        await this.executeQueries(upQueries, downQueries);
        clonedTable.addColumn(column);
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Creates a new columns from the column in the table.
       */
      async addColumns(tableOrName, columns) {
        for (const column of columns) {
          await this.addColumn(tableOrName, column);
        }
      }
      /**
       * Renames column in the given table.
       */
      async renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {
        const table = tableOrName instanceof Table_1.Table ? tableOrName : await this.getCachedTable(tableOrName);
        const oldColumn = oldTableColumnOrName instanceof TableColumn_1.TableColumn ? oldTableColumnOrName : table.columns.find((c) => c.name === oldTableColumnOrName);
        if (!oldColumn)
          throw new error_1.TypeORMError(`Column "${oldTableColumnOrName}" was not found in the "${table.name}" table.`);
        let newColumn;
        if (newTableColumnOrName instanceof TableColumn_1.TableColumn) {
          newColumn = newTableColumnOrName;
        } else {
          newColumn = oldColumn.clone();
          newColumn.name = newTableColumnOrName;
        }
        return this.changeColumn(table, oldColumn, newColumn);
      }
      /**
       * Changes a column in the table.
       */
      async changeColumn(tableOrName, oldTableColumnOrName, newColumn) {
        const table = tableOrName instanceof Table_1.Table ? tableOrName : await this.getCachedTable(tableOrName);
        let clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        const oldColumn = oldTableColumnOrName instanceof TableColumn_1.TableColumn ? oldTableColumnOrName : table.columns.find((column) => column.name === oldTableColumnOrName);
        if (!oldColumn)
          throw new error_1.TypeORMError(`Column "${oldTableColumnOrName}" was not found in the "${table.name}" table.`);
        if (oldColumn.name !== newColumn.name || oldColumn.type !== newColumn.type || oldColumn.length !== newColumn.length || oldColumn.isArray !== newColumn.isArray || oldColumn.generatedType !== newColumn.generatedType || oldColumn.asExpression !== newColumn.asExpression) {
          await this.dropColumn(table, oldColumn);
          await this.addColumn(table, newColumn);
          clonedTable = table.clone();
        } else {
          if (newColumn.precision !== oldColumn.precision || newColumn.scale !== oldColumn.scale) {
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" TYPE ${this.driver.createFullType(newColumn)}`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" TYPE ${this.driver.createFullType(oldColumn)}`));
          }
          if (oldColumn.isNullable !== newColumn.isNullable) {
            if (newColumn.isNullable) {
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" DROP NOT NULL`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" SET NOT NULL`));
            } else {
              upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" SET NOT NULL`));
              downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" DROP NOT NULL`));
            }
          }
          if (newColumn.isUnique !== oldColumn.isUnique) {
            if (newColumn.isUnique === true) {
              const uniqueIndex = new TableIndex_1.TableIndex({
                name: this.connection.namingStrategy.indexName(table, [
                  newColumn.name
                ]),
                columnNames: [newColumn.name],
                isUnique: true
              });
              clonedTable.indices.push(uniqueIndex);
              clonedTable.uniques.push(new TableUnique_1.TableUnique({
                name: uniqueIndex.name,
                columnNames: uniqueIndex.columnNames
              }));
              upQueries.push(this.createIndexSql(table, uniqueIndex));
              downQueries.push(this.dropIndexSql(table, uniqueIndex));
            } else {
              const uniqueIndex = clonedTable.indices.find((index) => {
                return index.columnNames.length === 1 && index.isUnique === true && !!index.columnNames.find((columnName) => columnName === newColumn.name);
              });
              clonedTable.indices.splice(clonedTable.indices.indexOf(uniqueIndex), 1);
              const tableUnique = clonedTable.uniques.find((unique) => unique.name === uniqueIndex.name);
              clonedTable.uniques.splice(clonedTable.uniques.indexOf(tableUnique), 1);
              upQueries.push(this.dropIndexSql(table, uniqueIndex));
              downQueries.push(this.createIndexSql(table, uniqueIndex));
            }
          }
        }
        await this.executeQueries(upQueries, downQueries);
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Changes a column in the table.
       */
      async changeColumns(tableOrName, changedColumns) {
        for (const { oldColumn, newColumn } of changedColumns) {
          await this.changeColumn(tableOrName, oldColumn, newColumn);
        }
      }
      /**
       * Drops column in the table.
       */
      async dropColumn(tableOrName, columnOrName) {
        const table = tableOrName instanceof Table_1.Table ? tableOrName : await this.getCachedTable(tableOrName);
        const column = columnOrName instanceof TableColumn_1.TableColumn ? columnOrName : table.findColumnByName(columnOrName);
        if (!column)
          throw new error_1.TypeORMError(`Column "${columnOrName}" was not found in table "${table.name}"`);
        const clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        const columnIndex = clonedTable.indices.find((index) => index.columnNames.length === 1 && index.columnNames[0] === column.name);
        if (columnIndex) {
          clonedTable.indices.splice(clonedTable.indices.indexOf(columnIndex), 1);
          upQueries.push(this.dropIndexSql(table, columnIndex));
          downQueries.push(this.createIndexSql(table, columnIndex));
        }
        const columnCheck = clonedTable.checks.find((check) => !!check.columnNames && check.columnNames.length === 1 && check.columnNames[0] === column.name);
        if (columnCheck) {
          clonedTable.checks.splice(clonedTable.checks.indexOf(columnCheck), 1);
          upQueries.push(this.dropCheckConstraintSql(table, columnCheck));
          downQueries.push(this.createCheckConstraintSql(table, columnCheck));
        }
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN ${this.driver.escape(column.name)}`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(column)}`));
        if (column.generatedType && column.asExpression) {
          const deleteQuery = this.deleteTypeormMetadataSql({
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name
          });
          const insertQuery = this.insertTypeormMetadataSql({
            table: table.name,
            type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
            name: column.name,
            value: column.asExpression
          });
          upQueries.push(deleteQuery);
          downQueries.push(insertQuery);
        }
        await this.executeQueries(upQueries, downQueries);
        clonedTable.removeColumn(column);
        this.replaceCachedTable(table, clonedTable);
      }
      /**
       * Drops the columns in the table.
       */
      async dropColumns(tableOrName, columns) {
        for (const column of [...columns]) {
          await this.dropColumn(tableOrName, column);
        }
      }
      /**
       * Creates a new primary key.
       *
       * Not supported in Spanner.
       * @see https://cloud.google.com/spanner/docs/schema-and-data-model#notes_about_key_columns
       */
      async createPrimaryKey(tableOrName, columnNames) {
        throw new Error("The keys of a table can't change; you can't add a key column to an existing table or remove a key column from an existing table.");
      }
      /**
       * Updates composite primary keys.
       */
      async updatePrimaryKeys(tableOrName, columns) {
        throw new Error("The keys of a table can't change; you can't add a key column to an existing table or remove a key column from an existing table.");
      }
      /**
       * Creates a new primary key.
       *
       * Not supported in Spanner.
       * @see https://cloud.google.com/spanner/docs/schema-and-data-model#notes_about_key_columns
       */
      async dropPrimaryKey(tableOrName) {
        throw new Error("The keys of a table can't change; you can't add a key column to an existing table or remove a key column from an existing table.");
      }
      /**
       * Creates new unique constraint.
       */
      async createUniqueConstraint(tableOrName, uniqueConstraint) {
        throw new error_1.TypeORMError(`Spanner does not support unique constraints. Use unique index instead.`);
      }
      /**
       * Creates new unique constraints.
       */
      async createUniqueConstraints(tableOrName, uniqueConstraints) {
        throw new error_1.TypeORMError(`Spanner does not support unique constraints. Use unique index instead.`);
      }
      /**
       * Drops unique constraint.
       */
      async dropUniqueConstraint(tableOrName, uniqueOrName) {
        throw new error_1.TypeORMError(`Spanner does not support unique constraints. Use unique index instead.`);
      }
      /**
       * Drops unique constraints.
       */
      async dropUniqueConstraints(tableOrName, uniqueConstraints) {
        throw new error_1.TypeORMError(`Spanner does not support unique constraints. Use unique index instead.`);
      }
      /**
       * Creates new check constraint.
       */
      async createCheckConstraint(tableOrName, checkConstraint) {
        const table = tableOrName instanceof Table_1.Table ? tableOrName : await this.getCachedTable(tableOrName);
        if (!checkConstraint.name)
          checkConstraint.name = this.connection.namingStrategy.checkConstraintName(table, checkConstraint.expression);
        const up = this.createCheckConstraintSql(table, checkConstraint);
        const down = this.dropCheckConstraintSql(table, checkConstraint);
        await this.executeQueries(up, down);
        table.addCheckConstraint(checkConstraint);
      }
      /**
       * Creates new check constraints.
       */
      async createCheckConstraints(tableOrName, checkConstraints) {
        const promises = checkConstraints.map((checkConstraint) => this.createCheckConstraint(tableOrName, checkConstraint));
        await Promise.all(promises);
      }
      /**
       * Drops check constraint.
       */
      async dropCheckConstraint(tableOrName, checkOrName) {
        const table = tableOrName instanceof Table_1.Table ? tableOrName : await this.getCachedTable(tableOrName);
        const checkConstraint = checkOrName instanceof TableCheck_1.TableCheck ? checkOrName : table.checks.find((c) => c.name === checkOrName);
        if (!checkConstraint)
          throw new error_1.TypeORMError(`Supplied check constraint was not found in table ${table.name}`);
        const up = this.dropCheckConstraintSql(table, checkConstraint);
        const down = this.createCheckConstraintSql(table, checkConstraint);
        await this.executeQueries(up, down);
        table.removeCheckConstraint(checkConstraint);
      }
      /**
       * Drops check constraints.
       */
      async dropCheckConstraints(tableOrName, checkConstraints) {
        const promises = checkConstraints.map((checkConstraint) => this.dropCheckConstraint(tableOrName, checkConstraint));
        await Promise.all(promises);
      }
      /**
       * Creates new exclusion constraint.
       */
      async createExclusionConstraint(tableOrName, exclusionConstraint) {
        throw new error_1.TypeORMError(`Spanner does not support exclusion constraints.`);
      }
      /**
       * Creates new exclusion constraints.
       */
      async createExclusionConstraints(tableOrName, exclusionConstraints) {
        throw new error_1.TypeORMError(`Spanner does not support exclusion constraints.`);
      }
      /**
       * Drops exclusion constraint.
       */
      async dropExclusionConstraint(tableOrName, exclusionOrName) {
        throw new error_1.TypeORMError(`Spanner does not support exclusion constraints.`);
      }
      /**
       * Drops exclusion constraints.
       */
      async dropExclusionConstraints(tableOrName, exclusionConstraints) {
        throw new error_1.TypeORMError(`Spanner does not support exclusion constraints.`);
      }
      /**
       * Creates a new foreign key.
       */
      async createForeignKey(tableOrName, foreignKey) {
        const table = tableOrName instanceof Table_1.Table ? tableOrName : await this.getCachedTable(tableOrName);
        if (!foreignKey.name)
          foreignKey.name = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
        const up = this.createForeignKeySql(table, foreignKey);
        const down = this.dropForeignKeySql(table, foreignKey);
        await this.executeQueries(up, down);
        table.addForeignKey(foreignKey);
      }
      /**
       * Creates a new foreign keys.
       */
      async createForeignKeys(tableOrName, foreignKeys) {
        for (const foreignKey of foreignKeys) {
          await this.createForeignKey(tableOrName, foreignKey);
        }
      }
      /**
       * Drops a foreign key from the table.
       */
      async dropForeignKey(tableOrName, foreignKeyOrName) {
        const table = tableOrName instanceof Table_1.Table ? tableOrName : await this.getCachedTable(tableOrName);
        const foreignKey = foreignKeyOrName instanceof TableForeignKey_1.TableForeignKey ? foreignKeyOrName : table.foreignKeys.find((fk) => fk.name === foreignKeyOrName);
        if (!foreignKey)
          throw new error_1.TypeORMError(`Supplied foreign key was not found in table ${table.name}`);
        const up = this.dropForeignKeySql(table, foreignKey);
        const down = this.createForeignKeySql(table, foreignKey);
        await this.executeQueries(up, down);
        table.removeForeignKey(foreignKey);
      }
      /**
       * Drops a foreign keys from the table.
       */
      async dropForeignKeys(tableOrName, foreignKeys) {
        for (const foreignKey of [...foreignKeys]) {
          await this.dropForeignKey(tableOrName, foreignKey);
        }
      }
      /**
       * Creates a new index.
       */
      async createIndex(tableOrName, index) {
        const table = tableOrName instanceof Table_1.Table ? tableOrName : await this.getCachedTable(tableOrName);
        if (!index.name)
          index.name = this.generateIndexName(table, index);
        const up = this.createIndexSql(table, index);
        const down = this.dropIndexSql(table, index);
        await this.executeQueries(up, down);
        table.addIndex(index);
      }
      /**
       * Creates a new indices
       */
      async createIndices(tableOrName, indices) {
        for (const index of indices) {
          await this.createIndex(tableOrName, index);
        }
      }
      /**
       * Drops an index from the table.
       */
      async dropIndex(tableOrName, indexOrName) {
        const table = tableOrName instanceof Table_1.Table ? tableOrName : await this.getCachedTable(tableOrName);
        const index = indexOrName instanceof TableIndex_1.TableIndex ? indexOrName : table.indices.find((i) => i.name === indexOrName);
        if (!index)
          throw new error_1.TypeORMError(`Supplied index ${indexOrName} was not found in table ${table.name}`);
        if (!index.name)
          index.name = this.generateIndexName(table, index);
        const up = this.dropIndexSql(table, index);
        const down = this.createIndexSql(table, index);
        await this.executeQueries(up, down);
        table.removeIndex(index);
      }
      /**
       * Drops an indices from the table.
       */
      async dropIndices(tableOrName, indices) {
        for (const index of [...indices]) {
          await this.dropIndex(tableOrName, index);
        }
      }
      /**
       * Clears all table contents.
       * Spanner does not support TRUNCATE TABLE statement, so we use DELETE FROM.
       */
      async clearTable(tableName) {
        await this.query(`DELETE FROM ${this.escapePath(tableName)} WHERE true`);
      }
      /**
       * Removes all tables from the currently connected database.
       */
      async clearDatabase() {
        const selectIndexDropsQuery = `SELECT concat('DROP INDEX \`', INDEX_NAME, '\`') AS \`query\` FROM \`INFORMATION_SCHEMA\`.\`INDEXES\` WHERE \`TABLE_CATALOG\` = '' AND \`TABLE_SCHEMA\` = '' AND \`INDEX_TYPE\` = 'INDEX' AND \`SPANNER_IS_MANAGED\` = false`;
        const dropIndexQueries = await this.query(selectIndexDropsQuery);
        const selectFKDropsQuery = `SELECT concat('ALTER TABLE \`', TABLE_NAME, '\`', ' DROP CONSTRAINT \`', CONSTRAINT_NAME, '\`') AS \`query\` FROM \`INFORMATION_SCHEMA\`.\`TABLE_CONSTRAINTS\` WHERE \`TABLE_CATALOG\` = '' AND \`TABLE_SCHEMA\` = '' AND \`CONSTRAINT_TYPE\` = 'FOREIGN KEY'`;
        const dropFKQueries = await this.query(selectFKDropsQuery);
        const dropTablesQuery = `SELECT concat('DROP TABLE \`', TABLE_NAME, '\`') AS \`query\` FROM \`INFORMATION_SCHEMA\`.\`TABLES\` WHERE \`TABLE_CATALOG\` = '' AND \`TABLE_SCHEMA\` = '' AND \`TABLE_TYPE\` = 'BASE TABLE'`;
        const dropTableQueries = await this.query(dropTablesQuery);
        if (!dropIndexQueries.length && !dropFKQueries.length && // !dropViewQueries.length &&
        !dropTableQueries.length)
          return;
        const isAnotherTransactionActive = this.isTransactionActive;
        if (!isAnotherTransactionActive)
          await this.startTransaction();
        try {
          for (const query of dropIndexQueries) {
            await this.updateDDL(query["query"]);
          }
          for (const query of dropFKQueries) {
            await this.updateDDL(query["query"]);
          }
          for (const query of dropTableQueries) {
            await this.updateDDL(query["query"]);
          }
          await this.commitTransaction();
        } catch (error) {
          try {
            if (!isAnotherTransactionActive)
              await this.rollbackTransaction();
          } catch (rollbackError) {
          }
          throw error;
        }
      }
      // -------------------------------------------------------------------------
      // Override Methods
      // -------------------------------------------------------------------------
      /**
       * Executes up sql queries.
       */
      async executeMemoryUpSql() {
        for (const { query, parameters } of this.sqlInMemory.upQueries) {
          if (this.isDMLQuery(query)) {
            await this.query(query, parameters);
          } else {
            await this.updateDDL(query, parameters);
          }
        }
      }
      /**
       * Executes down sql queries.
       */
      async executeMemoryDownSql() {
        for (const { query, parameters } of this.sqlInMemory.downQueries.reverse()) {
          if (this.isDMLQuery(query)) {
            await this.query(query, parameters);
          } else {
            await this.updateDDL(query, parameters);
          }
        }
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      async loadViews(viewNames) {
        return Promise.resolve([]);
      }
      /**
       * Loads all tables (with given names) from the database and creates a Table from them.
       */
      async loadTables(tableNames) {
        if (tableNames && tableNames.length === 0) {
          return [];
        }
        const dbTables = [];
        if (!tableNames || !tableNames.length) {
          const tablesSql = `SELECT \`TABLE_NAME\` FROM \`INFORMATION_SCHEMA\`.\`TABLES\` WHERE \`TABLE_CATALOG\` = '' AND \`TABLE_SCHEMA\` = '' AND \`TABLE_TYPE\` = 'BASE TABLE'`;
          dbTables.push(...await this.query(tablesSql));
        } else {
          const tablesSql = `SELECT \`TABLE_NAME\` FROM \`INFORMATION_SCHEMA\`.\`TABLES\` WHERE \`TABLE_CATALOG\` = '' AND \`TABLE_SCHEMA\` = '' AND \`TABLE_TYPE\` = 'BASE TABLE' AND \`TABLE_NAME\` IN (${tableNames.map((tableName) => `'${tableName}'`).join(", ")})`;
          dbTables.push(...await this.query(tablesSql));
        }
        if (!dbTables.length)
          return [];
        const loadedTableNames = dbTables.map((dbTable) => `'${dbTable.TABLE_NAME}'`).join(", ");
        const columnsSql = `SELECT * FROM \`INFORMATION_SCHEMA\`.\`COLUMNS\` WHERE \`TABLE_CATALOG\` = '' AND \`TABLE_SCHEMA\` = '' AND \`TABLE_NAME\` IN (${loadedTableNames})`;
        const primaryKeySql = `SELECT \`KCU\`.\`TABLE_NAME\`, \`KCU\`.\`COLUMN_NAME\` FROM \`INFORMATION_SCHEMA\`.\`TABLE_CONSTRAINTS\` \`TC\` INNER JOIN \`INFORMATION_SCHEMA\`.\`KEY_COLUMN_USAGE\` \`KCU\` ON \`KCU\`.\`CONSTRAINT_NAME\` = \`TC\`.\`CONSTRAINT_NAME\` WHERE \`TC\`.\`TABLE_CATALOG\` = '' AND \`TC\`.\`TABLE_SCHEMA\` = '' AND \`TC\`.\`CONSTRAINT_TYPE\` = 'PRIMARY KEY' AND \`TC\`.\`TABLE_NAME\` IN (${loadedTableNames})`;
        const indicesSql = `SELECT \`I\`.\`TABLE_NAME\`, \`I\`.\`INDEX_NAME\`, \`I\`.\`IS_UNIQUE\`, \`I\`.\`IS_NULL_FILTERED\`, \`IC\`.\`COLUMN_NAME\` FROM \`INFORMATION_SCHEMA\`.\`INDEXES\` \`I\` INNER JOIN \`INFORMATION_SCHEMA\`.\`INDEX_COLUMNS\` \`IC\` ON \`IC\`.\`INDEX_NAME\` = \`I\`.\`INDEX_NAME\` AND \`IC\`.\`TABLE_NAME\` = \`I\`.\`TABLE_NAME\` WHERE \`I\`.\`TABLE_CATALOG\` = '' AND \`I\`.\`TABLE_SCHEMA\` = '' AND \`I\`.\`TABLE_NAME\` IN (${loadedTableNames}) AND \`I\`.\`INDEX_TYPE\` = 'INDEX' AND \`I\`.\`SPANNER_IS_MANAGED\` = false`;
        const checksSql = `SELECT \`TC\`.\`TABLE_NAME\`, \`TC\`.\`CONSTRAINT_NAME\`, \`CC\`.\`CHECK_CLAUSE\`, \`CCU\`.\`COLUMN_NAME\`FROM \`INFORMATION_SCHEMA\`.\`TABLE_CONSTRAINTS\` \`TC\` INNER JOIN \`INFORMATION_SCHEMA\`.\`CONSTRAINT_COLUMN_USAGE\` \`CCU\` ON \`CCU\`.\`CONSTRAINT_NAME\` = \`TC\`.\`CONSTRAINT_NAME\` INNER JOIN \`INFORMATION_SCHEMA\`.\`CHECK_CONSTRAINTS\` \`CC\` ON \`CC\`.\`CONSTRAINT_NAME\` = \`TC\`.\`CONSTRAINT_NAME\` WHERE \`TC\`.\`TABLE_CATALOG\` = '' AND \`TC\`.\`TABLE_SCHEMA\` = '' AND \`TC\`.\`CONSTRAINT_TYPE\` = 'CHECK' AND \`TC\`.\`TABLE_NAME\` IN (${loadedTableNames}) AND \`TC\`.\`CONSTRAINT_NAME\` NOT LIKE 'CK_IS_NOT_NULL%'`;
        const foreignKeysSql = `SELECT \`TC\`.\`TABLE_NAME\`, \`TC\`.\`CONSTRAINT_NAME\`, \`KCU\`.\`COLUMN_NAME\`, \`CTU\`.\`TABLE_NAME\` AS \`REFERENCED_TABLE_NAME\`, \`CCU\`.\`COLUMN_NAME\` AS \`REFERENCED_COLUMN_NAME\`, \`RC\`.\`UPDATE_RULE\`, \`RC\`.\`DELETE_RULE\` FROM \`INFORMATION_SCHEMA\`.\`TABLE_CONSTRAINTS\` \`TC\` INNER JOIN \`INFORMATION_SCHEMA\`.\`KEY_COLUMN_USAGE\` \`KCU\` ON \`KCU\`.\`CONSTRAINT_NAME\` = \`TC\`.\`CONSTRAINT_NAME\` INNER JOIN \`INFORMATION_SCHEMA\`.\`CONSTRAINT_TABLE_USAGE\` \`CTU\` ON \`CTU\`.\`CONSTRAINT_NAME\` = \`TC\`.\`CONSTRAINT_NAME\` INNER JOIN \`INFORMATION_SCHEMA\`.\`REFERENTIAL_CONSTRAINTS\` \`RC\` ON \`RC\`.\`CONSTRAINT_NAME\` = \`TC\`.\`CONSTRAINT_NAME\` INNER JOIN \`INFORMATION_SCHEMA\`.\`CONSTRAINT_COLUMN_USAGE\` \`CCU\` ON \`CCU\`.\`CONSTRAINT_NAME\` = \`TC\`.\`CONSTRAINT_NAME\` WHERE \`TC\`.\`TABLE_CATALOG\` = '' AND \`TC\`.\`TABLE_SCHEMA\` = '' AND \`TC\`.\`CONSTRAINT_TYPE\` = 'FOREIGN KEY' AND \`TC\`.\`TABLE_NAME\` IN (${loadedTableNames})`;
        const [dbColumns, dbPrimaryKeys, dbIndices, dbChecks, dbForeignKeys] = await Promise.all([
          this.query(columnsSql),
          this.query(primaryKeySql),
          this.query(indicesSql),
          this.query(checksSql),
          this.query(foreignKeysSql)
        ]);
        return Promise.all(dbTables.map(async (dbTable) => {
          const table = new Table_1.Table();
          table.name = this.driver.buildTableName(dbTable["TABLE_NAME"]);
          table.columns = await Promise.all(dbColumns.filter((dbColumn) => dbColumn["TABLE_NAME"] === dbTable["TABLE_NAME"]).map(async (dbColumn) => {
            const columnUniqueIndices = dbIndices.filter((dbIndex) => {
              return dbIndex["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbIndex["COLUMN_NAME"] === dbColumn["COLUMN_NAME"] && dbIndex["IS_UNIQUE"] === true;
            });
            const tableMetadata = this.connection.entityMetadatas.find((metadata) => this.getTablePath(table) === this.getTablePath(metadata));
            const hasIgnoredIndex = columnUniqueIndices.length > 0 && tableMetadata && tableMetadata.indices.some((index) => {
              return columnUniqueIndices.some((uniqueIndex) => {
                return index.name === uniqueIndex["INDEX_NAME"] && index.synchronize === false;
              });
            });
            const isConstraintComposite = columnUniqueIndices.every((uniqueIndex) => {
              return dbIndices.some((dbIndex) => dbIndex["INDEX_NAME"] === uniqueIndex["INDEX_NAME"] && dbIndex["COLUMN_NAME"] !== dbColumn["COLUMN_NAME"]);
            });
            const tableColumn = new TableColumn_1.TableColumn();
            tableColumn.name = dbColumn["COLUMN_NAME"];
            let fullType = dbColumn["SPANNER_TYPE"].toLowerCase();
            if (fullType.indexOf("array") !== -1) {
              tableColumn.isArray = true;
              fullType = fullType.substring(fullType.indexOf("<") + 1, fullType.indexOf(">"));
            }
            if (fullType.indexOf("(") !== -1) {
              tableColumn.type = fullType.substring(0, fullType.indexOf("("));
            } else {
              tableColumn.type = fullType;
            }
            if (this.driver.withLengthColumnTypes.indexOf(tableColumn.type) !== -1) {
              tableColumn.length = fullType.substring(fullType.indexOf("(") + 1, fullType.indexOf(")"));
            }
            if (dbColumn["IS_GENERATED"] === "ALWAYS") {
              tableColumn.asExpression = dbColumn["GENERATION_EXPRESSION"];
              tableColumn.generatedType = "STORED";
              const asExpressionQuery = this.selectTypeormMetadataSql({
                table: dbTable["TABLE_NAME"],
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: tableColumn.name
              });
              const results = await this.query(asExpressionQuery.query, asExpressionQuery.parameters);
              if (results[0] && results[0].value) {
                tableColumn.asExpression = results[0].value;
              } else {
                tableColumn.asExpression = "";
              }
            }
            tableColumn.isUnique = columnUniqueIndices.length > 0 && !hasIgnoredIndex && !isConstraintComposite;
            tableColumn.isNullable = dbColumn["IS_NULLABLE"] === "YES";
            tableColumn.isPrimary = dbPrimaryKeys.some((dbPrimaryKey) => {
              return dbPrimaryKey["TABLE_NAME"] === dbColumn["TABLE_NAME"] && dbPrimaryKey["COLUMN_NAME"] === dbColumn["COLUMN_NAME"];
            });
            return tableColumn;
          }));
          const tableForeignKeys = dbForeignKeys.filter((dbForeignKey) => {
            return dbForeignKey["TABLE_NAME"] === dbTable["TABLE_NAME"];
          });
          table.foreignKeys = OrmUtils_1.OrmUtils.uniq(tableForeignKeys, (dbForeignKey) => dbForeignKey["CONSTRAINT_NAME"]).map((dbForeignKey) => {
            const foreignKeys = tableForeignKeys.filter((dbFk) => dbFk["CONSTRAINT_NAME"] === dbForeignKey["CONSTRAINT_NAME"]);
            return new TableForeignKey_1.TableForeignKey({
              name: dbForeignKey["CONSTRAINT_NAME"],
              columnNames: OrmUtils_1.OrmUtils.uniq(foreignKeys.map((dbFk) => dbFk["COLUMN_NAME"])),
              referencedDatabase: dbForeignKey["REFERENCED_TABLE_SCHEMA"],
              referencedTableName: dbForeignKey["REFERENCED_TABLE_NAME"],
              referencedColumnNames: OrmUtils_1.OrmUtils.uniq(foreignKeys.map((dbFk) => dbFk["REFERENCED_COLUMN_NAME"])),
              onDelete: dbForeignKey["DELETE_RULE"],
              onUpdate: dbForeignKey["UPDATE_RULE"]
            });
          });
          const tableIndices = dbIndices.filter((dbIndex) => dbIndex["TABLE_NAME"] === dbTable["TABLE_NAME"]);
          table.indices = OrmUtils_1.OrmUtils.uniq(tableIndices, (dbIndex) => dbIndex["INDEX_NAME"]).map((constraint) => {
            const indices = tableIndices.filter((index) => {
              return index["INDEX_NAME"] === constraint["INDEX_NAME"];
            });
            return new TableIndex_1.TableIndex({
              table,
              name: constraint["INDEX_NAME"],
              columnNames: indices.map((i) => i["COLUMN_NAME"]),
              isUnique: constraint["IS_UNIQUE"],
              isNullFiltered: constraint["IS_NULL_FILTERED"]
            });
          });
          const tableChecks = dbChecks.filter((dbCheck) => dbCheck["TABLE_NAME"] === dbTable["TABLE_NAME"]);
          table.checks = OrmUtils_1.OrmUtils.uniq(tableChecks, (dbIndex) => dbIndex["CONSTRAINT_NAME"]).map((constraint) => {
            const checks = tableChecks.filter((dbC) => dbC["CONSTRAINT_NAME"] === constraint["CONSTRAINT_NAME"]);
            return new TableCheck_1.TableCheck({
              name: constraint["CONSTRAINT_NAME"],
              columnNames: checks.map((c) => c["COLUMN_NAME"]),
              expression: constraint["CHECK_CLAUSE"]
            });
          });
          return table;
        }));
      }
      /**
       * Builds create table sql.
       */
      createTableSql(table, createForeignKeys) {
        const columnDefinitions = table.columns.map((column) => this.buildCreateColumnSql(column)).join(", ");
        let sql = `CREATE TABLE ${this.escapePath(table)} (${columnDefinitions}`;
        table.columns.filter((column) => column.isUnique).forEach((column) => {
          const isUniqueIndexExist = table.indices.some((index) => {
            return index.columnNames.length === 1 && !!index.isUnique && index.columnNames.indexOf(column.name) !== -1;
          });
          const isUniqueConstraintExist = table.uniques.some((unique) => {
            return unique.columnNames.length === 1 && unique.columnNames.indexOf(column.name) !== -1;
          });
          if (!isUniqueIndexExist && !isUniqueConstraintExist)
            table.indices.push(new TableIndex_1.TableIndex({
              name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),
              columnNames: [column.name],
              isUnique: true
            }));
        });
        if (table.uniques.length > 0) {
          table.uniques.forEach((unique) => {
            const uniqueExist = table.indices.some((index) => index.name === unique.name);
            if (!uniqueExist) {
              table.indices.push(new TableIndex_1.TableIndex({
                name: unique.name,
                columnNames: unique.columnNames,
                isUnique: true
              }));
            }
          });
        }
        if (table.checks.length > 0) {
          const checksSql = table.checks.map((check) => {
            const checkName = check.name ? check.name : this.connection.namingStrategy.checkConstraintName(table, check.expression);
            return `CONSTRAINT \`${checkName}\` CHECK (${check.expression})`;
          }).join(", ");
          sql += `, ${checksSql}`;
        }
        if (table.foreignKeys.length > 0 && createForeignKeys) {
          const foreignKeysSql = table.foreignKeys.map((fk) => {
            const columnNames = fk.columnNames.map((columnName) => `\`${columnName}\``).join(", ");
            if (!fk.name)
              fk.name = this.connection.namingStrategy.foreignKeyName(table, fk.columnNames, this.getTablePath(fk), fk.referencedColumnNames);
            const referencedColumnNames = fk.referencedColumnNames.map((columnName) => `\`${columnName}\``).join(", ");
            return `CONSTRAINT \`${fk.name}\` FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(fk))} (${referencedColumnNames})`;
          }).join(", ");
          sql += `, ${foreignKeysSql}`;
        }
        sql += `)`;
        const primaryColumns = table.columns.filter((column) => column.isPrimary);
        if (primaryColumns.length > 0) {
          const columnNames = primaryColumns.map((column) => this.driver.escape(column.name)).join(", ");
          sql += ` PRIMARY KEY (${columnNames})`;
        }
        return new Query_1.Query(sql);
      }
      /**
       * Builds drop table sql.
       */
      dropTableSql(tableOrPath) {
        return new Query_1.Query(`DROP TABLE ${this.escapePath(tableOrPath)}`);
      }
      createViewSql(view) {
        const materializedClause = view.materialized ? "MATERIALIZED " : "";
        const viewName = this.escapePath(view);
        const expression = typeof view.expression === "string" ? view.expression : view.expression(this.connection).getQuery();
        return new Query_1.Query(`CREATE ${materializedClause}VIEW ${viewName} SQL SECURITY INVOKER AS ${expression}`);
      }
      async insertViewDefinitionSql(view) {
        const { schema, tableName: name } = this.driver.parseTableName(view);
        const type = view.materialized ? MetadataTableType_1.MetadataTableType.MATERIALIZED_VIEW : MetadataTableType_1.MetadataTableType.VIEW;
        const expression = typeof view.expression === "string" ? view.expression.trim() : view.expression(this.connection).getQuery();
        return this.insertTypeormMetadataSql({
          type,
          schema,
          name,
          value: expression
        });
      }
      /**
       * Builds drop view sql.
       */
      dropViewSql(view) {
        const materializedClause = view.materialized ? "MATERIALIZED " : "";
        return new Query_1.Query(`DROP ${materializedClause}VIEW ${this.escapePath(view)}`);
      }
      /**
       * Builds remove view sql.
       */
      async deleteViewDefinitionSql(view) {
        const { schema, tableName: name } = this.driver.parseTableName(view);
        const type = view.materialized ? MetadataTableType_1.MetadataTableType.MATERIALIZED_VIEW : MetadataTableType_1.MetadataTableType.VIEW;
        return this.deleteTypeormMetadataSql({ type, schema, name });
      }
      /**
       * Builds create index sql.
       */
      createIndexSql(table, index) {
        const columns = index.columnNames.map((columnName) => this.driver.escape(columnName)).join(", ");
        let indexType = "";
        if (index.isUnique)
          indexType += "UNIQUE ";
        if (index.isNullFiltered)
          indexType += "NULL_FILTERED ";
        return new Query_1.Query(`CREATE ${indexType}INDEX \`${index.name}\` ON ${this.escapePath(table)} (${columns})`);
      }
      /**
       * Builds drop index sql.
       */
      dropIndexSql(table, indexOrName) {
        const indexName = indexOrName instanceof TableIndex_1.TableIndex ? indexOrName.name : indexOrName;
        return new Query_1.Query(`DROP INDEX \`${indexName}\``);
      }
      /**
       * Builds create check constraint sql.
       */
      createCheckConstraintSql(table, checkConstraint) {
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \`${checkConstraint.name}\` CHECK (${checkConstraint.expression})`);
      }
      /**
       * Builds drop check constraint sql.
       */
      dropCheckConstraintSql(table, checkOrName) {
        const checkName = checkOrName instanceof TableCheck_1.TableCheck ? checkOrName.name : checkOrName;
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \`${checkName}\``);
      }
      /**
       * Builds create foreign key sql.
       */
      createForeignKeySql(table, foreignKey) {
        const columnNames = foreignKey.columnNames.map((column) => this.driver.escape(column)).join(", ");
        const referencedColumnNames = foreignKey.referencedColumnNames.map((column) => this.driver.escape(column)).join(",");
        const sql = `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \`${foreignKey.name}\` FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(foreignKey))} (${referencedColumnNames})`;
        return new Query_1.Query(sql);
      }
      /**
       * Builds drop foreign key sql.
       */
      dropForeignKeySql(table, foreignKeyOrName) {
        const foreignKeyName = foreignKeyOrName instanceof TableForeignKey_1.TableForeignKey ? foreignKeyOrName.name : foreignKeyOrName;
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \`${foreignKeyName}\``);
      }
      /**
       * Escapes given table or view path.
       */
      escapePath(target) {
        const { tableName } = this.driver.parseTableName(target);
        return `\`${tableName}\``;
      }
      /**
       * Builds a part of query to create/change a column.
       */
      buildCreateColumnSql(column) {
        let c = `${this.driver.escape(column.name)} ${this.connection.driver.createFullType(column)}`;
        if (column.generatedType === "STORED" && column.asExpression) {
          c += ` AS (${column.asExpression}) STORED`;
        } else {
          if (!column.isNullable)
            c += " NOT NULL";
        }
        return c;
      }
      /**
       * Executes sql used special for schema build.
       */
      async executeQueries(upQueries, downQueries) {
        if (upQueries instanceof Query_1.Query)
          upQueries = [upQueries];
        if (downQueries instanceof Query_1.Query)
          downQueries = [downQueries];
        this.sqlInMemory.upQueries.push(...upQueries);
        this.sqlInMemory.downQueries.push(...downQueries);
        if (this.sqlMemoryMode === true)
          return Promise.resolve();
        for (const { query, parameters } of upQueries) {
          if (this.isDMLQuery(query)) {
            await this.query(query, parameters);
          } else {
            await this.updateDDL(query, parameters);
          }
        }
      }
      isDMLQuery(query) {
        return query.startsWith("INSERT") || query.startsWith("UPDATE") || query.startsWith("DELETE");
      }
      /**
       * Change table comment.
       */
      changeTableComment(tableOrName, comment) {
        throw new error_1.TypeORMError(`spanner driver does not support change table comment.`);
      }
    };
    exports2.SpannerQueryRunner = SpannerQueryRunner;
  }
});

// node_modules/typeorm/driver/spanner/SpannerDriver.js
var require_SpannerDriver = __commonJS({
  "node_modules/typeorm/driver/spanner/SpannerDriver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SpannerDriver = void 0;
    var DriverPackageNotInstalledError_1 = require_DriverPackageNotInstalledError();
    var SpannerQueryRunner_1 = require_SpannerQueryRunner();
    var DateUtils_1 = require_DateUtils();
    var PlatformTools_1 = require_PlatformTools();
    var RdbmsSchemaBuilder_1 = require_RdbmsSchemaBuilder();
    var EntityMetadata_1 = require_EntityMetadata();
    var OrmUtils_1 = require_OrmUtils();
    var ApplyValueTransformers_1 = require_ApplyValueTransformers();
    var Table_1 = require_Table();
    var View_1 = require_View();
    var TableForeignKey_1 = require_TableForeignKey();
    var SpannerDriver = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection) {
        this.isReplicated = false;
        this.treeSupport = true;
        this.transactionSupport = "none";
        this.supportedDataTypes = [
          "bool",
          "int64",
          "float64",
          "numeric",
          "string",
          "json",
          "bytes",
          "date",
          "timestamp",
          "array"
        ];
        this.supportedUpsertTypes = [];
        this.spatialTypes = [];
        this.withLengthColumnTypes = ["string", "bytes"];
        this.withWidthColumnTypes = [];
        this.withPrecisionColumnTypes = [];
        this.withScaleColumnTypes = [];
        this.mappedDataTypes = {
          createDate: "timestamp",
          createDateDefault: "",
          updateDate: "timestamp",
          updateDateDefault: "",
          deleteDate: "timestamp",
          deleteDateNullable: true,
          version: "int64",
          treeLevel: "int64",
          migrationId: "int64",
          migrationName: "string",
          migrationTimestamp: "int64",
          cacheId: "string",
          cacheIdentifier: "string",
          cacheTime: "int64",
          cacheDuration: "int64",
          cacheQuery: "string",
          cacheResult: "string",
          metadataType: "string",
          metadataDatabase: "string",
          metadataSchema: "string",
          metadataTable: "string",
          metadataName: "string",
          metadataValue: "string"
        };
        this.parametersPrefix = "@param";
        this.dataTypeDefaults = {};
        this.maxAliasLength = 63;
        this.cteCapabilities = {
          enabled: true
        };
        this.connection = connection;
        this.options = connection.options;
        this.isReplicated = this.options.replication ? true : false;
        this.loadDependencies();
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Performs connection to the database.
       */
      async connect() {
        this.instance = this.spanner.instance(this.options.instanceId);
        this.instanceDatabase = this.instance.database(this.options.databaseId);
      }
      /**
       * Makes any action after connection (e.g. create extensions in Postgres driver).
       */
      afterConnect() {
        return Promise.resolve();
      }
      /**
       * Closes connection with the database.
       */
      async disconnect() {
        this.instanceDatabase.close();
      }
      /**
       * Creates a schema builder used to build and sync a schema.
       */
      createSchemaBuilder() {
        return new RdbmsSchemaBuilder_1.RdbmsSchemaBuilder(this.connection);
      }
      /**
       * Creates a query runner used to execute database queries.
       */
      createQueryRunner(mode) {
        return new SpannerQueryRunner_1.SpannerQueryRunner(this, mode);
      }
      /**
       * Replaces parameters in the given sql with special escaping character
       * and an array of parameter names to be passed to a query.
       */
      escapeQueryWithParameters(sql, parameters, nativeParameters) {
        const escapedParameters = Object.keys(nativeParameters).map((key) => nativeParameters[key]);
        if (!parameters || !Object.keys(parameters).length)
          return [sql, escapedParameters];
        const parameterIndexMap = /* @__PURE__ */ new Map();
        sql = sql.replace(/:(\.\.\.)?([A-Za-z0-9_.]+)/g, (full, isArray, key) => {
          if (!parameters.hasOwnProperty(key)) {
            return full;
          }
          if (parameterIndexMap.has(key)) {
            return this.parametersPrefix + parameterIndexMap.get(key);
          }
          const value = parameters[key];
          if (value === null) {
            return full;
          }
          if (isArray) {
            return value.map((v) => {
              escapedParameters.push(v);
              return this.createParameter(key, escapedParameters.length - 1);
            }).join(", ");
          }
          if (value instanceof Function) {
            return value();
          }
          escapedParameters.push(value);
          parameterIndexMap.set(key, escapedParameters.length - 1);
          return this.createParameter(key, escapedParameters.length - 1);
        });
        sql = sql.replace(/([ ]+)?=([ ]+)?:(\.\.\.)?([A-Za-z0-9_.]+)/g, (full, emptySpaceBefore, emptySpaceAfter, isArray, key) => {
          if (!parameters.hasOwnProperty(key)) {
            return full;
          }
          const value = parameters[key];
          if (value === null) {
            return " IS NULL";
          }
          return full;
        });
        return [sql, escapedParameters];
      }
      /**
       * Escapes a column name.
       */
      escape(columnName) {
        return `\`${columnName}\``;
      }
      /**
       * Build full table name with database name, schema name and table name.
       * E.g. myDB.mySchema.myTable
       */
      buildTableName(tableName, schema, database) {
        const tablePath = [tableName];
        if (database) {
          tablePath.unshift(database);
        }
        return tablePath.join(".");
      }
      /**
       * Parse a target table name or other types and return a normalized table definition.
       */
      parseTableName(target) {
        const driverDatabase = this.database;
        const driverSchema = void 0;
        if (target instanceof Table_1.Table || target instanceof View_1.View) {
          const parsed = this.parseTableName(target.name);
          return {
            database: target.database || parsed.database || driverDatabase,
            schema: target.schema || parsed.schema || driverSchema,
            tableName: parsed.tableName
          };
        }
        if (target instanceof TableForeignKey_1.TableForeignKey) {
          const parsed = this.parseTableName(target.referencedTableName);
          return {
            database: target.referencedDatabase || parsed.database || driverDatabase,
            schema: target.referencedSchema || parsed.schema || driverSchema,
            tableName: parsed.tableName
          };
        }
        if (target instanceof EntityMetadata_1.EntityMetadata) {
          return {
            database: target.database || driverDatabase,
            schema: target.schema || driverSchema,
            tableName: target.tableName
          };
        }
        const parts = target.split(".");
        return {
          database: (parts.length > 1 ? parts[0] : void 0) || driverDatabase,
          schema: driverSchema,
          tableName: parts.length > 1 ? parts[1] : parts[0]
        };
      }
      /**
       * Prepares given value to a value to be persisted, based on its column type and metadata.
       */
      preparePersistentValue(value, columnMetadata) {
        if (columnMetadata.transformer)
          value = ApplyValueTransformers_1.ApplyValueTransformers.transformTo(columnMetadata.transformer, value);
        if (value === null || value === void 0)
          return value;
        if (columnMetadata.type === "numeric") {
          const lib = this.options.driver || PlatformTools_1.PlatformTools.load("spanner");
          return lib.Spanner.numeric(value.toString());
        } else if (columnMetadata.type === "date") {
          return DateUtils_1.DateUtils.mixedDateToDateString(value);
        } else if (columnMetadata.type === "json") {
          return value;
        } else if (columnMetadata.type === "timestamp" || columnMetadata.type === Date) {
          return DateUtils_1.DateUtils.mixedDateToDate(value);
        }
        return value;
      }
      /**
       * Prepares given value to a value to be persisted, based on its column type or metadata.
       */
      prepareHydratedValue(value, columnMetadata) {
        if (value === null || value === void 0)
          return columnMetadata.transformer ? ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value) : value;
        if (columnMetadata.type === Boolean || columnMetadata.type === "bool") {
          value = value ? true : false;
        } else if (columnMetadata.type === "timestamp" || columnMetadata.type === Date) {
          value = new Date(value);
        } else if (columnMetadata.type === "numeric") {
          value = value.value;
        } else if (columnMetadata.type === "date") {
          value = DateUtils_1.DateUtils.mixedDateToDateString(value);
        } else if (columnMetadata.type === "json") {
          value = typeof value === "string" ? JSON.parse(value) : value;
        } else if (columnMetadata.type === Number) {
          value = !isNaN(+value) ? parseInt(value) : value;
        }
        if (columnMetadata.transformer)
          value = ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);
        return value;
      }
      /**
       * Creates a database type from a given column metadata.
       */
      normalizeType(column) {
        if (column.type === Number) {
          return "int64";
        } else if (column.type === String || column.type === "uuid") {
          return "string";
        } else if (column.type === Date) {
          return "timestamp";
        } else if (column.type === Buffer) {
          return "bytes";
        } else if (column.type === Boolean) {
          return "bool";
        } else {
          return column.type || "";
        }
      }
      /**
       * Normalizes "default" value of the column.
       *
       * Spanner does not support default values.
       */
      normalizeDefault(columnMetadata) {
        return columnMetadata.default === "" ? `"${columnMetadata.default}"` : `${columnMetadata.default}`;
      }
      /**
       * Normalizes "isUnique" value of the column.
       */
      normalizeIsUnique(column) {
        return column.entityMetadata.indices.some((idx) => idx.isUnique && idx.columns.length === 1 && idx.columns[0] === column);
      }
      /**
       * Returns default column lengths, which is required on column creation.
       */
      getColumnLength(column) {
        if (column.length)
          return column.length.toString();
        if (column.generationStrategy === "uuid")
          return "36";
        switch (column.type) {
          case String:
          case "string":
          case "bytes":
            return "max";
          default:
            return "";
        }
      }
      /**
       * Creates column type definition including length, precision and scale
       */
      createFullType(column) {
        let type = column.type;
        if (this.getColumnLength(column)) {
          type += `(${this.getColumnLength(column)})`;
        } else if (column.width) {
          type += `(${column.width})`;
        } else if (column.precision !== null && column.precision !== void 0 && column.scale !== null && column.scale !== void 0) {
          type += `(${column.precision},${column.scale})`;
        } else if (column.precision !== null && column.precision !== void 0) {
          type += `(${column.precision})`;
        }
        if (column.isArray)
          type = `array<${type}>`;
        return type;
      }
      /**
       * Obtains a new database connection to a master server.
       * Used for replication.
       * If replication is not setup then returns default connection's database connection.
       */
      obtainMasterConnection() {
        return this.instanceDatabase;
      }
      /**
       * Obtains a new database connection to a slave server.
       * Used for replication.
       * If replication is not setup then returns master (default) connection's database connection.
       */
      obtainSlaveConnection() {
        return this.instanceDatabase;
      }
      /**
       * Creates generated map of values generated or returned by database after INSERT query.
       */
      createGeneratedMap(metadata, insertResult, entityIndex) {
        if (!insertResult) {
          return void 0;
        }
        if (insertResult.insertId === void 0) {
          return Object.keys(insertResult).reduce((map, key) => {
            const column = metadata.findColumnWithDatabaseName(key);
            if (column) {
              OrmUtils_1.OrmUtils.mergeDeep(map, column.createValueMap(insertResult[key]));
            }
            return map;
          }, {});
        }
        const generatedMap = metadata.generatedColumns.reduce((map, generatedColumn) => {
          let value;
          if (generatedColumn.generationStrategy === "increment" && insertResult.insertId) {
            value = insertResult.insertId + entityIndex;
          }
          return OrmUtils_1.OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));
        }, {});
        return Object.keys(generatedMap).length > 0 ? generatedMap : void 0;
      }
      /**
       * Differentiate columns of this table and columns from the given column metadatas columns
       * and returns only changed.
       */
      findChangedColumns(tableColumns, columnMetadatas) {
        return columnMetadatas.filter((columnMetadata) => {
          const tableColumn = tableColumns.find((c) => c.name === columnMetadata.databaseName);
          if (!tableColumn)
            return false;
          const isColumnChanged = tableColumn.name !== columnMetadata.databaseName || tableColumn.type !== this.normalizeType(columnMetadata) || tableColumn.length !== this.getColumnLength(columnMetadata) || tableColumn.asExpression !== columnMetadata.asExpression || tableColumn.generatedType !== columnMetadata.generatedType || tableColumn.isPrimary !== columnMetadata.isPrimary || !this.compareNullableValues(columnMetadata, tableColumn) || tableColumn.isUnique !== this.normalizeIsUnique(columnMetadata);
          return isColumnChanged;
        });
      }
      /**
       * Returns true if driver supports RETURNING / OUTPUT statement.
       */
      isReturningSqlSupported() {
        return true;
      }
      /**
       * Returns true if driver supports uuid values generation on its own.
       */
      isUUIDGenerationSupported() {
        return true;
      }
      /**
       * Returns true if driver supports fulltext indices.
       */
      isFullTextColumnTypeSupported() {
        return false;
      }
      /**
       * Creates an escaped parameter.
       */
      createParameter(parameterName, index) {
        return this.parametersPrefix + index;
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Loads all driver dependencies.
       */
      loadDependencies() {
        try {
          const lib = this.options.driver || PlatformTools_1.PlatformTools.load("spanner");
          if (this.options.credentials) {
            this.spanner = new lib.Spanner({
              projectId: this.options.projectId,
              credentials: this.options.credentials
            });
            return;
          }
          this.spanner = new lib.Spanner({
            projectId: this.options.projectId
          });
        } catch (e) {
          console.error(e);
          throw new DriverPackageNotInstalledError_1.DriverPackageNotInstalledError("Spanner", "@google-cloud/spanner");
        }
      }
      compareNullableValues(columnMetadata, tableColumn) {
        if (columnMetadata.generatedType) {
          return true;
        }
        return columnMetadata.isNullable === tableColumn.isNullable;
      }
      /**
       * Checks if "DEFAULT" values in the column metadata and in the database are equal.
       */
      compareDefaultValues(columnMetadataValue, databaseValue) {
        if (typeof columnMetadataValue === "string" && typeof databaseValue === "string") {
          columnMetadataValue = columnMetadataValue.replace(/^'+|'+$/g, "");
          databaseValue = databaseValue.replace(/^'+|'+$/g, "");
        }
        return columnMetadataValue === databaseValue;
      }
      /**
       * If parameter is a datetime function, e.g. "CURRENT_TIMESTAMP", normalizes it.
       * Otherwise returns original input.
       */
      normalizeDatetimeFunction(value) {
        if (!value)
          return value;
        const isDatetimeFunction = value.toUpperCase().indexOf("CURRENT_TIMESTAMP") !== -1 || value.toUpperCase().indexOf("NOW") !== -1;
        if (isDatetimeFunction) {
          const precision = value.match(/\(\d+\)/);
          return precision ? `CURRENT_TIMESTAMP${precision[0]}` : "CURRENT_TIMESTAMP";
        } else {
          return value;
        }
      }
      /**
       * Escapes a given comment.
       */
      escapeComment(comment) {
        if (!comment)
          return comment;
        comment = comment.replace(/\u0000/g, "");
        return comment;
      }
    };
    exports2.SpannerDriver = SpannerDriver;
  }
});

// node_modules/typeorm/driver/DriverFactory.js
var require_DriverFactory = __commonJS({
  "node_modules/typeorm/driver/DriverFactory.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DriverFactory = void 0;
    var MissingDriverError_1 = require_MissingDriverError();
    var CockroachDriver_1 = require_CockroachDriver();
    var MongoDriver_1 = require_MongoDriver();
    var SqlServerDriver_1 = require_SqlServerDriver();
    var OracleDriver_1 = require_OracleDriver();
    var SqliteDriver_1 = require_SqliteDriver();
    var CordovaDriver_1 = require_CordovaDriver();
    var ReactNativeDriver_1 = require_ReactNativeDriver();
    var NativescriptDriver_1 = require_NativescriptDriver();
    var SqljsDriver_1 = require_SqljsDriver();
    var MysqlDriver_1 = require_MysqlDriver();
    var PostgresDriver_1 = require_PostgresDriver();
    var ExpoDriverFactory_1 = require_ExpoDriverFactory();
    var AuroraMysqlDriver_1 = require_AuroraMysqlDriver();
    var AuroraPostgresDriver_1 = require_AuroraPostgresDriver();
    var SapDriver_1 = require_SapDriver();
    var BetterSqlite3Driver_1 = require_BetterSqlite3Driver();
    var CapacitorDriver_1 = require_CapacitorDriver();
    var SpannerDriver_1 = require_SpannerDriver();
    var DriverFactory = class {
      /**
       * Creates a new driver depend on a given connection's driver type.
       */
      create(connection) {
        const { type } = connection.options;
        switch (type) {
          case "mysql":
            return new MysqlDriver_1.MysqlDriver(connection);
          case "postgres":
            return new PostgresDriver_1.PostgresDriver(connection);
          case "cockroachdb":
            return new CockroachDriver_1.CockroachDriver(connection);
          case "sap":
            return new SapDriver_1.SapDriver(connection);
          case "mariadb":
            return new MysqlDriver_1.MysqlDriver(connection);
          case "sqlite":
            return new SqliteDriver_1.SqliteDriver(connection);
          case "better-sqlite3":
            return new BetterSqlite3Driver_1.BetterSqlite3Driver(connection);
          case "cordova":
            return new CordovaDriver_1.CordovaDriver(connection);
          case "nativescript":
            return new NativescriptDriver_1.NativescriptDriver(connection);
          case "react-native":
            return new ReactNativeDriver_1.ReactNativeDriver(connection);
          case "sqljs":
            return new SqljsDriver_1.SqljsDriver(connection);
          case "oracle":
            return new OracleDriver_1.OracleDriver(connection);
          case "mssql":
            return new SqlServerDriver_1.SqlServerDriver(connection);
          case "mongodb":
            return new MongoDriver_1.MongoDriver(connection);
          case "expo":
            return new ExpoDriverFactory_1.ExpoDriverFactory(connection).create();
          case "aurora-mysql":
            return new AuroraMysqlDriver_1.AuroraMysqlDriver(connection);
          case "aurora-postgres":
            return new AuroraPostgresDriver_1.AuroraPostgresDriver(connection);
          case "capacitor":
            return new CapacitorDriver_1.CapacitorDriver(connection);
          case "spanner":
            return new SpannerDriver_1.SpannerDriver(connection);
          default:
            throw new MissingDriverError_1.MissingDriverError(type, [
              "aurora-mysql",
              "aurora-postgres",
              "better-sqlite3",
              "capacitor",
              "cockroachdb",
              "cordova",
              "expo",
              "mariadb",
              "mongodb",
              "mssql",
              "mysql",
              "nativescript",
              "oracle",
              "postgres",
              "react-native",
              "sap",
              "sqlite",
              "sqljs",
              "spanner"
            ]);
        }
      }
    };
    exports2.DriverFactory = DriverFactory;
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports2, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp) a = maybeMatch(a, str);
      if (b instanceof RegExp) b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(exports2, module2) {
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m) return [str];
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      if (/\$$/.test(m.pre)) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + "{" + m.body + "}" + post[k];
          expansions.push(expansion);
        }
      } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m.post.match(/,(?!,).*\}/)) {
            str = m.pre + "{" + m.body + escClose + m.post;
            return expand(str);
          }
          return [str];
        }
        var n;
        if (isSequence) {
          n = m.body.split(/\.\./);
        } else {
          n = parseCommaParts(m.body);
          if (n.length === 1) {
            n = expand(n[0], false).map(embrace);
            if (n.length === 1) {
              return post.map(function(p) {
                return m.pre + n[0] + p;
              });
            }
          }
        }
        var N;
        if (isSequence) {
          var x = numeric(n[0]);
          var y = numeric(n[1]);
          var width = Math.max(n[0].length, n[1].length);
          var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
          var test = lte;
          var reverse = y < x;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n.some(isPadded);
          N = [];
          for (var i = x; test(i, y); i += incr) {
            var c;
            if (isAlphaSequence) {
              c = String.fromCharCode(i);
              if (c === "\\")
                c = "";
            } else {
              c = String(i);
              if (pad) {
                var need = width - c.length;
                if (need > 0) {
                  var z = new Array(need + 1).join("0");
                  if (i < 0)
                    c = "-" + z + c.slice(1);
                  else
                    c = z + c;
                }
              }
            }
            N.push(c);
          }
        } else {
          N = [];
          for (var j = 0; j < n.length; j++) {
            N.push.apply(N, expand(n[j], false));
          }
        }
        for (var j = 0; j < N.length; j++) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N[j] + post[k];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
      }
      return expansions;
    }
  }
});

// node_modules/minimatch/dist/commonjs/assert-valid-pattern.js
var require_assert_valid_pattern = __commonJS({
  "node_modules/minimatch/dist/commonjs/assert-valid-pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assertValidPattern = void 0;
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = (pattern) => {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    exports2.assertValidPattern = assertValidPattern;
  }
});

// node_modules/minimatch/dist/commonjs/brace-expressions.js
var require_brace_expressions = __commonJS({
  "node_modules/minimatch/dist/commonjs/brace-expressions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseClass = void 0;
    var posixClasses = {
      "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
      "[:alpha:]": ["\\p{L}\\p{Nl}", true],
      "[:ascii:]": ["\\x00-\\x7f", false],
      "[:blank:]": ["\\p{Zs}\\t", true],
      "[:cntrl:]": ["\\p{Cc}", true],
      "[:digit:]": ["\\p{Nd}", true],
      "[:graph:]": ["\\p{Z}\\p{C}", true, true],
      "[:lower:]": ["\\p{Ll}", true],
      "[:print:]": ["\\p{C}", true],
      "[:punct:]": ["\\p{P}", true],
      "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
      "[:upper:]": ["\\p{Lu}", true],
      "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
      "[:xdigit:]": ["A-Fa-f0-9", false]
    };
    var braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&");
    var regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var rangesToString = (ranges) => ranges.join("");
    var parseClass = (glob, position) => {
      const pos = position;
      if (glob.charAt(pos) !== "[") {
        throw new Error("not in a brace expression");
      }
      const ranges = [];
      const negs = [];
      let i = pos + 1;
      let sawStart = false;
      let uflag = false;
      let escaping = false;
      let negate = false;
      let endPos = pos;
      let rangeStart = "";
      WHILE: while (i < glob.length) {
        const c = glob.charAt(i);
        if ((c === "!" || c === "^") && i === pos + 1) {
          negate = true;
          i++;
          continue;
        }
        if (c === "]" && sawStart && !escaping) {
          endPos = i + 1;
          break;
        }
        sawStart = true;
        if (c === "\\") {
          if (!escaping) {
            escaping = true;
            i++;
            continue;
          }
        }
        if (c === "[" && !escaping) {
          for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
            if (glob.startsWith(cls, i)) {
              if (rangeStart) {
                return ["$.", false, glob.length - pos, true];
              }
              i += cls.length;
              if (neg)
                negs.push(unip);
              else
                ranges.push(unip);
              uflag = uflag || u;
              continue WHILE;
            }
          }
        }
        escaping = false;
        if (rangeStart) {
          if (c > rangeStart) {
            ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c));
          } else if (c === rangeStart) {
            ranges.push(braceEscape(c));
          }
          rangeStart = "";
          i++;
          continue;
        }
        if (glob.startsWith("-]", i + 1)) {
          ranges.push(braceEscape(c + "-"));
          i += 2;
          continue;
        }
        if (glob.startsWith("-", i + 1)) {
          rangeStart = c;
          i += 2;
          continue;
        }
        ranges.push(braceEscape(c));
        i++;
      }
      if (endPos < i) {
        return ["", false, 0, false];
      }
      if (!ranges.length && !negs.length) {
        return ["$.", false, glob.length - pos, true];
      }
      if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
        return [regexpEscape(r), false, endPos - pos, false];
      }
      const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
      const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
      const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
      return [comb, uflag, endPos - pos, true];
    };
    exports2.parseClass = parseClass;
  }
});

// node_modules/minimatch/dist/commonjs/unescape.js
var require_unescape = __commonJS({
  "node_modules/minimatch/dist/commonjs/unescape.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unescape = void 0;
    var unescape2 = (s, { windowsPathsNoEscape = false } = {}) => {
      return windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
    };
    exports2.unescape = unescape2;
  }
});

// node_modules/minimatch/dist/commonjs/ast.js
var require_ast = __commonJS({
  "node_modules/minimatch/dist/commonjs/ast.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AST = void 0;
    var brace_expressions_js_1 = require_brace_expressions();
    var unescape_js_1 = require_unescape();
    var types = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
    var isExtglobType = (c) => types.has(c);
    var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
    var startNoDot = "(?!\\.)";
    var addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
    var justDots = /* @__PURE__ */ new Set(["..", "."]);
    var reSpecials = new Set("().*{}+?[]^$\\!");
    var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var qmark = "[^/]";
    var star = qmark + "*?";
    var starNoEmpty = qmark + "+?";
    var _root, _hasMagic, _uflag, _parts, _parent, _parentIndex, _negs, _filledNegs, _options, _toString, _emptyExt, _AST_instances, fillNegs_fn, _AST_static, parseAST_fn, partsToRegExp_fn, parseGlob_fn;
    var _AST = class _AST {
      constructor(type, parent, options = {}) {
        __privateAdd(this, _AST_instances);
        __publicField(this, "type");
        __privateAdd(this, _root);
        __privateAdd(this, _hasMagic);
        __privateAdd(this, _uflag, false);
        __privateAdd(this, _parts, []);
        __privateAdd(this, _parent);
        __privateAdd(this, _parentIndex);
        __privateAdd(this, _negs);
        __privateAdd(this, _filledNegs, false);
        __privateAdd(this, _options);
        __privateAdd(this, _toString);
        // set to true if it's an extglob with no children
        // (which really means one child of '')
        __privateAdd(this, _emptyExt, false);
        this.type = type;
        if (type)
          __privateSet(this, _hasMagic, true);
        __privateSet(this, _parent, parent);
        __privateSet(this, _root, __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _root) : this);
        __privateSet(this, _options, __privateGet(this, _root) === this ? options : __privateGet(__privateGet(this, _root), _options));
        __privateSet(this, _negs, __privateGet(this, _root) === this ? [] : __privateGet(__privateGet(this, _root), _negs));
        if (type === "!" && !__privateGet(__privateGet(this, _root), _filledNegs))
          __privateGet(this, _negs).push(this);
        __privateSet(this, _parentIndex, __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _parts).length : 0);
      }
      get hasMagic() {
        if (__privateGet(this, _hasMagic) !== void 0)
          return __privateGet(this, _hasMagic);
        for (const p of __privateGet(this, _parts)) {
          if (typeof p === "string")
            continue;
          if (p.type || p.hasMagic)
            return __privateSet(this, _hasMagic, true);
        }
        return __privateGet(this, _hasMagic);
      }
      // reconstructs the pattern
      toString() {
        if (__privateGet(this, _toString) !== void 0)
          return __privateGet(this, _toString);
        if (!this.type) {
          return __privateSet(this, _toString, __privateGet(this, _parts).map((p) => String(p)).join(""));
        } else {
          return __privateSet(this, _toString, this.type + "(" + __privateGet(this, _parts).map((p) => String(p)).join("|") + ")");
        }
      }
      push(...parts) {
        for (const p of parts) {
          if (p === "")
            continue;
          if (typeof p !== "string" && !(p instanceof _AST && __privateGet(p, _parent) === this)) {
            throw new Error("invalid part: " + p);
          }
          __privateGet(this, _parts).push(p);
        }
      }
      toJSON() {
        const ret = this.type === null ? __privateGet(this, _parts).slice().map((p) => typeof p === "string" ? p : p.toJSON()) : [this.type, ...__privateGet(this, _parts).map((p) => p.toJSON())];
        if (this.isStart() && !this.type)
          ret.unshift([]);
        if (this.isEnd() && (this === __privateGet(this, _root) || __privateGet(__privateGet(this, _root), _filledNegs) && __privateGet(this, _parent)?.type === "!")) {
          ret.push({});
        }
        return ret;
      }
      isStart() {
        if (__privateGet(this, _root) === this)
          return true;
        if (!__privateGet(this, _parent)?.isStart())
          return false;
        if (__privateGet(this, _parentIndex) === 0)
          return true;
        const p = __privateGet(this, _parent);
        for (let i = 0; i < __privateGet(this, _parentIndex); i++) {
          const pp = __privateGet(p, _parts)[i];
          if (!(pp instanceof _AST && pp.type === "!")) {
            return false;
          }
        }
        return true;
      }
      isEnd() {
        if (__privateGet(this, _root) === this)
          return true;
        if (__privateGet(this, _parent)?.type === "!")
          return true;
        if (!__privateGet(this, _parent)?.isEnd())
          return false;
        if (!this.type)
          return __privateGet(this, _parent)?.isEnd();
        const pl = __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _parts).length : 0;
        return __privateGet(this, _parentIndex) === pl - 1;
      }
      copyIn(part) {
        if (typeof part === "string")
          this.push(part);
        else
          this.push(part.clone(this));
      }
      clone(parent) {
        const c = new _AST(this.type, parent);
        for (const p of __privateGet(this, _parts)) {
          c.copyIn(p);
        }
        return c;
      }
      static fromGlob(pattern, options = {}) {
        var _a;
        const ast = new _AST(null, void 0, options);
        __privateMethod(_a = _AST, _AST_static, parseAST_fn).call(_a, pattern, ast, 0, options);
        return ast;
      }
      // returns the regular expression if there's magic, or the unescaped
      // string if not.
      toMMPattern() {
        if (this !== __privateGet(this, _root))
          return __privateGet(this, _root).toMMPattern();
        const glob = this.toString();
        const [re, body, hasMagic, uflag] = this.toRegExpSource();
        const anyMagic = hasMagic || __privateGet(this, _hasMagic) || __privateGet(this, _options).nocase && !__privateGet(this, _options).nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase();
        if (!anyMagic) {
          return body;
        }
        const flags = (__privateGet(this, _options).nocase ? "i" : "") + (uflag ? "u" : "");
        return Object.assign(new RegExp(`^${re}$`, flags), {
          _src: re,
          _glob: glob
        });
      }
      get options() {
        return __privateGet(this, _options);
      }
      // returns the string match, the regexp source, whether there's magic
      // in the regexp (so a regular expression is required) and whether or
      // not the uflag is needed for the regular expression (for posix classes)
      // TODO: instead of injecting the start/end at this point, just return
      // the BODY of the regexp, along with the start/end portions suitable
      // for binding the start/end in either a joined full-path makeRe context
      // (where we bind to (^|/), or a standalone matchPart context (where
      // we bind to ^, and not /).  Otherwise slashes get duped!
      //
      // In part-matching mode, the start is:
      // - if not isStart: nothing
      // - if traversal possible, but not allowed: ^(?!\.\.?$)
      // - if dots allowed or not possible: ^
      // - if dots possible and not allowed: ^(?!\.)
      // end is:
      // - if not isEnd(): nothing
      // - else: $
      //
      // In full-path matching mode, we put the slash at the START of the
      // pattern, so start is:
      // - if first pattern: same as part-matching mode
      // - if not isStart(): nothing
      // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
      // - if dots allowed or not possible: /
      // - if dots possible and not allowed: /(?!\.)
      // end is:
      // - if last pattern, same as part-matching mode
      // - else nothing
      //
      // Always put the (?:$|/) on negated tails, though, because that has to be
      // there to bind the end of the negated pattern portion, and it's easier to
      // just stick it in now rather than try to inject it later in the middle of
      // the pattern.
      //
      // We can just always return the same end, and leave it up to the caller
      // to know whether it's going to be used joined or in parts.
      // And, if the start is adjusted slightly, can do the same there:
      // - if not isStart: nothing
      // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
      // - if dots allowed or not possible: (?:/|^)
      // - if dots possible and not allowed: (?:/|^)(?!\.)
      //
      // But it's better to have a simpler binding without a conditional, for
      // performance, so probably better to return both start options.
      //
      // Then the caller just ignores the end if it's not the first pattern,
      // and the start always gets applied.
      //
      // But that's always going to be $ if it's the ending pattern, or nothing,
      // so the caller can just attach $ at the end of the pattern when building.
      //
      // So the todo is:
      // - better detect what kind of start is needed
      // - return both flavors of starting pattern
      // - attach $ at the end of the pattern when creating the actual RegExp
      //
      // Ah, but wait, no, that all only applies to the root when the first pattern
      // is not an extglob. If the first pattern IS an extglob, then we need all
      // that dot prevention biz to live in the extglob portions, because eg
      // +(*|.x*) can match .xy but not .yx.
      //
      // So, return the two flavors if it's #root and the first child is not an
      // AST, otherwise leave it to the child AST to handle it, and there,
      // use the (?:^|/) style of start binding.
      //
      // Even simplified further:
      // - Since the start for a join is eg /(?!\.) and the start for a part
      // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
      // or start or whatever) and prepend ^ or / at the Regexp construction.
      toRegExpSource(allowDot) {
        const dot = allowDot ?? !!__privateGet(this, _options).dot;
        if (__privateGet(this, _root) === this)
          __privateMethod(this, _AST_instances, fillNegs_fn).call(this);
        if (!this.type) {
          const noEmpty = this.isStart() && this.isEnd();
          const src = __privateGet(this, _parts).map((p) => {
            var _a;
            const [re, _, hasMagic, uflag] = typeof p === "string" ? __privateMethod(_a = _AST, _AST_static, parseGlob_fn).call(_a, p, __privateGet(this, _hasMagic), noEmpty) : p.toRegExpSource(allowDot);
            __privateSet(this, _hasMagic, __privateGet(this, _hasMagic) || hasMagic);
            __privateSet(this, _uflag, __privateGet(this, _uflag) || uflag);
            return re;
          }).join("");
          let start2 = "";
          if (this.isStart()) {
            if (typeof __privateGet(this, _parts)[0] === "string") {
              const dotTravAllowed = __privateGet(this, _parts).length === 1 && justDots.has(__privateGet(this, _parts)[0]);
              if (!dotTravAllowed) {
                const aps = addPatternStart;
                const needNoTrav = (
                  // dots are allowed, and the pattern starts with [ or .
                  dot && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
                  src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
                  src.startsWith("\\.\\.") && aps.has(src.charAt(4))
                );
                const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
                start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
              }
            }
          }
          let end = "";
          if (this.isEnd() && __privateGet(__privateGet(this, _root), _filledNegs) && __privateGet(this, _parent)?.type === "!") {
            end = "(?:$|\\/)";
          }
          const final2 = start2 + src + end;
          return [
            final2,
            (0, unescape_js_1.unescape)(src),
            __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)),
            __privateGet(this, _uflag)
          ];
        }
        const repeated = this.type === "*" || this.type === "+";
        const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
        let body = __privateMethod(this, _AST_instances, partsToRegExp_fn).call(this, dot);
        if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
          const s = this.toString();
          __privateSet(this, _parts, [s]);
          this.type = null;
          __privateSet(this, _hasMagic, void 0);
          return [s, (0, unescape_js_1.unescape)(this.toString()), false, false];
        }
        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : __privateMethod(this, _AST_instances, partsToRegExp_fn).call(this, true);
        if (bodyDotAllowed === body) {
          bodyDotAllowed = "";
        }
        if (bodyDotAllowed) {
          body = `(?:${body})(?:${bodyDotAllowed})*?`;
        }
        let final = "";
        if (this.type === "!" && __privateGet(this, _emptyExt)) {
          final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
        } else {
          const close = this.type === "!" ? (
            // !() must match something,but !(x) can match ''
            "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")"
          ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
          final = start + body + close;
        }
        return [
          final,
          (0, unescape_js_1.unescape)(body),
          __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)),
          __privateGet(this, _uflag)
        ];
      }
    };
    _root = new WeakMap();
    _hasMagic = new WeakMap();
    _uflag = new WeakMap();
    _parts = new WeakMap();
    _parent = new WeakMap();
    _parentIndex = new WeakMap();
    _negs = new WeakMap();
    _filledNegs = new WeakMap();
    _options = new WeakMap();
    _toString = new WeakMap();
    _emptyExt = new WeakMap();
    _AST_instances = new WeakSet();
    fillNegs_fn = function() {
      if (this !== __privateGet(this, _root))
        throw new Error("should only call on root");
      if (__privateGet(this, _filledNegs))
        return this;
      this.toString();
      __privateSet(this, _filledNegs, true);
      let n;
      while (n = __privateGet(this, _negs).pop()) {
        if (n.type !== "!")
          continue;
        let p = n;
        let pp = __privateGet(p, _parent);
        while (pp) {
          for (let i = __privateGet(p, _parentIndex) + 1; !pp.type && i < __privateGet(pp, _parts).length; i++) {
            for (const part of __privateGet(n, _parts)) {
              if (typeof part === "string") {
                throw new Error("string part in extglob AST??");
              }
              part.copyIn(__privateGet(pp, _parts)[i]);
            }
          }
          p = pp;
          pp = __privateGet(p, _parent);
        }
      }
      return this;
    };
    _AST_static = new WeakSet();
    parseAST_fn = function(str, ast, pos, opt) {
      var _a, _b;
      let escaping = false;
      let inBrace = false;
      let braceStart = -1;
      let braceNeg = false;
      if (ast.type === null) {
        let i2 = pos;
        let acc2 = "";
        while (i2 < str.length) {
          const c = str.charAt(i2++);
          if (escaping || c === "\\") {
            escaping = !escaping;
            acc2 += c;
            continue;
          }
          if (inBrace) {
            if (i2 === braceStart + 1) {
              if (c === "^" || c === "!") {
                braceNeg = true;
              }
            } else if (c === "]" && !(i2 === braceStart + 2 && braceNeg)) {
              inBrace = false;
            }
            acc2 += c;
            continue;
          } else if (c === "[") {
            inBrace = true;
            braceStart = i2;
            braceNeg = false;
            acc2 += c;
            continue;
          }
          if (!opt.noext && isExtglobType(c) && str.charAt(i2) === "(") {
            ast.push(acc2);
            acc2 = "";
            const ext = new _AST(c, ast);
            i2 = __privateMethod(_a = _AST, _AST_static, parseAST_fn).call(_a, str, ext, i2, opt);
            ast.push(ext);
            continue;
          }
          acc2 += c;
        }
        ast.push(acc2);
        return i2;
      }
      let i = pos + 1;
      let part = new _AST(null, ast);
      const parts = [];
      let acc = "";
      while (i < str.length) {
        const c = str.charAt(i++);
        if (escaping || c === "\\") {
          escaping = !escaping;
          acc += c;
          continue;
        }
        if (inBrace) {
          if (i === braceStart + 1) {
            if (c === "^" || c === "!") {
              braceNeg = true;
            }
          } else if (c === "]" && !(i === braceStart + 2 && braceNeg)) {
            inBrace = false;
          }
          acc += c;
          continue;
        } else if (c === "[") {
          inBrace = true;
          braceStart = i;
          braceNeg = false;
          acc += c;
          continue;
        }
        if (isExtglobType(c) && str.charAt(i) === "(") {
          part.push(acc);
          acc = "";
          const ext = new _AST(c, part);
          part.push(ext);
          i = __privateMethod(_b = _AST, _AST_static, parseAST_fn).call(_b, str, ext, i, opt);
          continue;
        }
        if (c === "|") {
          part.push(acc);
          acc = "";
          parts.push(part);
          part = new _AST(null, ast);
          continue;
        }
        if (c === ")") {
          if (acc === "" && __privateGet(ast, _parts).length === 0) {
            __privateSet(ast, _emptyExt, true);
          }
          part.push(acc);
          acc = "";
          ast.push(...parts, part);
          return i;
        }
        acc += c;
      }
      ast.type = null;
      __privateSet(ast, _hasMagic, void 0);
      __privateSet(ast, _parts, [str.substring(pos - 1)]);
      return i;
    };
    partsToRegExp_fn = function(dot) {
      return __privateGet(this, _parts).map((p) => {
        if (typeof p === "string") {
          throw new Error("string type in extglob ast??");
        }
        const [re, _, _hasMagic2, uflag] = p.toRegExpSource(dot);
        __privateSet(this, _uflag, __privateGet(this, _uflag) || uflag);
        return re;
      }).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
    };
    parseGlob_fn = function(glob, hasMagic, noEmpty = false) {
      let escaping = false;
      let re = "";
      let uflag = false;
      for (let i = 0; i < glob.length; i++) {
        const c = glob.charAt(i);
        if (escaping) {
          escaping = false;
          re += (reSpecials.has(c) ? "\\" : "") + c;
          continue;
        }
        if (c === "\\") {
          if (i === glob.length - 1) {
            re += "\\\\";
          } else {
            escaping = true;
          }
          continue;
        }
        if (c === "[") {
          const [src, needUflag, consumed, magic] = (0, brace_expressions_js_1.parseClass)(glob, i);
          if (consumed) {
            re += src;
            uflag = uflag || needUflag;
            i += consumed - 1;
            hasMagic = hasMagic || magic;
            continue;
          }
        }
        if (c === "*") {
          if (noEmpty && glob === "*")
            re += starNoEmpty;
          else
            re += star;
          hasMagic = true;
          continue;
        }
        if (c === "?") {
          re += qmark;
          hasMagic = true;
          continue;
        }
        re += regExpEscape(c);
      }
      return [re, (0, unescape_js_1.unescape)(glob), !!hasMagic, uflag];
    };
    __privateAdd(_AST, _AST_static);
    var AST = _AST;
    exports2.AST = AST;
  }
});

// node_modules/minimatch/dist/commonjs/escape.js
var require_escape = __commonJS({
  "node_modules/minimatch/dist/commonjs/escape.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.escape = void 0;
    var escape = (s, { windowsPathsNoEscape = false } = {}) => {
      return windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&");
    };
    exports2.escape = escape;
  }
});

// node_modules/minimatch/dist/commonjs/index.js
var require_commonjs = __commonJS({
  "node_modules/minimatch/dist/commonjs/index.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unescape = exports2.escape = exports2.AST = exports2.Minimatch = exports2.match = exports2.makeRe = exports2.braceExpand = exports2.defaults = exports2.filter = exports2.GLOBSTAR = exports2.sep = exports2.minimatch = void 0;
    var brace_expansion_1 = __importDefault2(require_brace_expansion());
    var assert_valid_pattern_js_1 = require_assert_valid_pattern();
    var ast_js_1 = require_ast();
    var escape_js_1 = require_escape();
    var unescape_js_1 = require_unescape();
    var minimatch = (p, pattern, options = {}) => {
      (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    };
    exports2.minimatch = minimatch;
    var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
    var starDotExtTest = (ext2) => (f) => !f.startsWith(".") && f.endsWith(ext2);
    var starDotExtTestDot = (ext2) => (f) => f.endsWith(ext2);
    var starDotExtTestNocase = (ext2) => {
      ext2 = ext2.toLowerCase();
      return (f) => !f.startsWith(".") && f.toLowerCase().endsWith(ext2);
    };
    var starDotExtTestNocaseDot = (ext2) => {
      ext2 = ext2.toLowerCase();
      return (f) => f.toLowerCase().endsWith(ext2);
    };
    var starDotStarRE = /^\*+\.\*+$/;
    var starDotStarTest = (f) => !f.startsWith(".") && f.includes(".");
    var starDotStarTestDot = (f) => f !== "." && f !== ".." && f.includes(".");
    var dotStarRE = /^\.\*+$/;
    var dotStarTest = (f) => f !== "." && f !== ".." && f.startsWith(".");
    var starRE = /^\*+$/;
    var starTest = (f) => f.length !== 0 && !f.startsWith(".");
    var starTestDot = (f) => f.length !== 0 && f !== "." && f !== "..";
    var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
    var qmarksTestNocase = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExt([$0]);
      if (!ext2)
        return noext;
      ext2 = ext2.toLowerCase();
      return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
    };
    var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExtDot([$0]);
      if (!ext2)
        return noext;
      ext2 = ext2.toLowerCase();
      return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
    };
    var qmarksTestDot = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExtDot([$0]);
      return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
    };
    var qmarksTest = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExt([$0]);
      return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
    };
    var qmarksTestNoExt = ([$0]) => {
      const len = $0.length;
      return (f) => f.length === len && !f.startsWith(".");
    };
    var qmarksTestNoExtDot = ([$0]) => {
      const len = $0.length;
      return (f) => f.length === len && f !== "." && f !== "..";
    };
    var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
    var path = {
      win32: { sep: "\\" },
      posix: { sep: "/" }
    };
    exports2.sep = defaultPlatform === "win32" ? path.win32.sep : path.posix.sep;
    exports2.minimatch.sep = exports2.sep;
    exports2.GLOBSTAR = Symbol("globstar **");
    exports2.minimatch.GLOBSTAR = exports2.GLOBSTAR;
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var filter = (pattern, options = {}) => (p) => (0, exports2.minimatch)(p, pattern, options);
    exports2.filter = filter;
    exports2.minimatch.filter = exports2.filter;
    var ext = (a, b = {}) => Object.assign({}, a, b);
    var defaults = (def) => {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return exports2.minimatch;
      }
      const orig = exports2.minimatch;
      const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
      return Object.assign(m, {
        Minimatch: class Minimatch extends orig.Minimatch {
          constructor(pattern, options = {}) {
            super(pattern, ext(def, options));
          }
          static defaults(options) {
            return orig.defaults(ext(def, options)).Minimatch;
          }
        },
        AST: class AST extends orig.AST {
          /* c8 ignore start */
          constructor(type, parent, options = {}) {
            super(type, parent, ext(def, options));
          }
          /* c8 ignore stop */
          static fromGlob(pattern, options = {}) {
            return orig.AST.fromGlob(pattern, ext(def, options));
          }
        },
        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
        escape: (s, options = {}) => orig.escape(s, ext(def, options)),
        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
        defaults: (options) => orig.defaults(ext(def, options)),
        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
        sep: orig.sep,
        GLOBSTAR: exports2.GLOBSTAR
      });
    };
    exports2.defaults = defaults;
    exports2.minimatch.defaults = exports2.defaults;
    var braceExpand = (pattern, options = {}) => {
      (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return (0, brace_expansion_1.default)(pattern);
    };
    exports2.braceExpand = braceExpand;
    exports2.minimatch.braceExpand = exports2.braceExpand;
    var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
    exports2.makeRe = makeRe;
    exports2.minimatch.makeRe = exports2.makeRe;
    var match = (list, pattern, options = {}) => {
      const mm = new Minimatch(pattern, options);
      list = list.filter((f) => mm.match(f));
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    exports2.match = match;
    exports2.minimatch.match = exports2.match;
    var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
    var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var Minimatch = class {
      constructor(pattern, options = {}) {
        __publicField(this, "options");
        __publicField(this, "set");
        __publicField(this, "pattern");
        __publicField(this, "windowsPathsNoEscape");
        __publicField(this, "nonegate");
        __publicField(this, "negate");
        __publicField(this, "comment");
        __publicField(this, "empty");
        __publicField(this, "preserveMultipleSlashes");
        __publicField(this, "partial");
        __publicField(this, "globSet");
        __publicField(this, "globParts");
        __publicField(this, "nocase");
        __publicField(this, "isWindows");
        __publicField(this, "platform");
        __publicField(this, "windowsNoMagicRoot");
        __publicField(this, "regexp");
        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
        options = options || {};
        this.options = options;
        this.pattern = pattern;
        this.platform = options.platform || defaultPlatform;
        this.isWindows = this.platform === "win32";
        this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
          this.pattern = this.pattern.replace(/\\/g, "/");
        }
        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
        this.regexp = null;
        this.negate = false;
        this.nonegate = !!options.nonegate;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.nocase = !!this.options.nocase;
        this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
        this.globSet = [];
        this.globParts = [];
        this.set = [];
        this.make();
      }
      hasMagic() {
        if (this.options.magicalBraces && this.set.length > 1) {
          return true;
        }
        for (const pattern of this.set) {
          for (const part of pattern) {
            if (typeof part !== "string")
              return true;
          }
        }
        return false;
      }
      debug(..._) {
      }
      make() {
        const pattern = this.pattern;
        const options = this.options;
        if (!options.nocomment && pattern.charAt(0) === "#") {
          this.comment = true;
          return;
        }
        if (!pattern) {
          this.empty = true;
          return;
        }
        this.parseNegate();
        this.globSet = [...new Set(this.braceExpand())];
        if (options.debug) {
          this.debug = (...args) => console.error(...args);
        }
        this.debug(this.pattern, this.globSet);
        const rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
        this.globParts = this.preprocess(rawGlobParts);
        this.debug(this.pattern, this.globParts);
        let set = this.globParts.map((s, _, __) => {
          if (this.isWindows && this.windowsNoMagicRoot) {
            const isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]);
            const isDrive = /^[a-z]:/i.test(s[0]);
            if (isUNC) {
              return [...s.slice(0, 4), ...s.slice(4).map((ss) => this.parse(ss))];
            } else if (isDrive) {
              return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
            }
          }
          return s.map((ss) => this.parse(ss));
        });
        this.debug(this.pattern, set);
        this.set = set.filter((s) => s.indexOf(false) === -1);
        if (this.isWindows) {
          for (let i = 0; i < this.set.length; i++) {
            const p = this.set[i];
            if (p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] === "string" && /^[a-z]:$/i.test(p[3])) {
              p[2] = "?";
            }
          }
        }
        this.debug(this.pattern, this.set);
      }
      // various transforms to equivalent pattern sets that are
      // faster to process in a filesystem walk.  The goal is to
      // eliminate what we can, and push all ** patterns as far
      // to the right as possible, even if it increases the number
      // of patterns that we have to process.
      preprocess(globParts) {
        if (this.options.noglobstar) {
          for (let i = 0; i < globParts.length; i++) {
            for (let j = 0; j < globParts[i].length; j++) {
              if (globParts[i][j] === "**") {
                globParts[i][j] = "*";
              }
            }
          }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
          globParts = this.firstPhasePreProcess(globParts);
          globParts = this.secondPhasePreProcess(globParts);
        } else if (optimizationLevel >= 1) {
          globParts = this.levelOneOptimize(globParts);
        } else {
          globParts = this.adjascentGlobstarOptimize(globParts);
        }
        return globParts;
      }
      // just get rid of adjascent ** portions
      adjascentGlobstarOptimize(globParts) {
        return globParts.map((parts) => {
          let gs = -1;
          while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
            let i = gs;
            while (parts[i + 1] === "**") {
              i++;
            }
            if (i !== gs) {
              parts.splice(gs, i - gs);
            }
          }
          return parts;
        });
      }
      // get rid of adjascent ** and resolve .. portions
      levelOneOptimize(globParts) {
        return globParts.map((parts) => {
          parts = parts.reduce((set, part) => {
            const prev = set[set.length - 1];
            if (part === "**" && prev === "**") {
              return set;
            }
            if (part === "..") {
              if (prev && prev !== ".." && prev !== "." && prev !== "**") {
                set.pop();
                return set;
              }
            }
            set.push(part);
            return set;
          }, []);
          return parts.length === 0 ? [""] : parts;
        });
      }
      levelTwoFileOptimize(parts) {
        if (!Array.isArray(parts)) {
          parts = this.slashSplit(parts);
        }
        let didSomething = false;
        do {
          didSomething = false;
          if (!this.preserveMultipleSlashes) {
            for (let i = 1; i < parts.length - 1; i++) {
              const p = parts[i];
              if (i === 1 && p === "" && parts[0] === "")
                continue;
              if (p === "." || p === "") {
                didSomething = true;
                parts.splice(i, 1);
                i--;
              }
            }
            if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
              didSomething = true;
              parts.pop();
            }
          }
          let dd = 0;
          while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
            const p = parts[dd - 1];
            if (p && p !== "." && p !== ".." && p !== "**") {
              didSomething = true;
              parts.splice(dd - 1, 2);
              dd -= 2;
            }
          }
        } while (didSomething);
        return parts.length === 0 ? [""] : parts;
      }
      // First phase: single-pattern processing
      // <pre> is 1 or more portions
      // <rest> is 1 or more portions
      // <p> is any portion other than ., .., '', or **
      // <e> is . or ''
      //
      // **/.. is *brutal* for filesystem walking performance, because
      // it effectively resets the recursive walk each time it occurs,
      // and ** cannot be reduced out by a .. pattern part like a regexp
      // or most strings (other than .., ., and '') can be.
      //
      // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
      // <pre>/<e>/<rest> -> <pre>/<rest>
      // <pre>/<p>/../<rest> -> <pre>/<rest>
      // **/**/<rest> -> **/<rest>
      //
      // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
      // this WOULD be allowed if ** did follow symlinks, or * didn't
      firstPhasePreProcess(globParts) {
        let didSomething = false;
        do {
          didSomething = false;
          for (let parts of globParts) {
            let gs = -1;
            while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
              let gss = gs;
              while (parts[gss + 1] === "**") {
                gss++;
              }
              if (gss > gs) {
                parts.splice(gs + 1, gss - gs);
              }
              let next = parts[gs + 1];
              const p = parts[gs + 2];
              const p2 = parts[gs + 3];
              if (next !== "..")
                continue;
              if (!p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") {
                continue;
              }
              didSomething = true;
              parts.splice(gs, 1);
              const other = parts.slice(0);
              other[gs] = "**";
              globParts.push(other);
              gs--;
            }
            if (!this.preserveMultipleSlashes) {
              for (let i = 1; i < parts.length - 1; i++) {
                const p = parts[i];
                if (i === 1 && p === "" && parts[0] === "")
                  continue;
                if (p === "." || p === "") {
                  didSomething = true;
                  parts.splice(i, 1);
                  i--;
                }
              }
              if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
                didSomething = true;
                parts.pop();
              }
            }
            let dd = 0;
            while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
              const p = parts[dd - 1];
              if (p && p !== "." && p !== ".." && p !== "**") {
                didSomething = true;
                const needDot = dd === 1 && parts[dd + 1] === "**";
                const splin = needDot ? ["."] : [];
                parts.splice(dd - 1, 2, ...splin);
                if (parts.length === 0)
                  parts.push("");
                dd -= 2;
              }
            }
          }
        } while (didSomething);
        return globParts;
      }
      // second phase: multi-pattern dedupes
      // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
      // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
      // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
      //
      // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
      // ^-- not valid because ** doens't follow symlinks
      secondPhasePreProcess(globParts) {
        for (let i = 0; i < globParts.length - 1; i++) {
          for (let j = i + 1; j < globParts.length; j++) {
            const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
            if (matched) {
              globParts[i] = [];
              globParts[j] = matched;
              break;
            }
          }
        }
        return globParts.filter((gs) => gs.length);
      }
      partsMatch(a, b, emptyGSMatch = false) {
        let ai = 0;
        let bi = 0;
        let result = [];
        let which = "";
        while (ai < a.length && bi < b.length) {
          if (a[ai] === b[bi]) {
            result.push(which === "b" ? b[bi] : a[ai]);
            ai++;
            bi++;
          } else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1]) {
            result.push(a[ai]);
            ai++;
          } else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1]) {
            result.push(b[bi]);
            bi++;
          } else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
            if (which === "b")
              return false;
            which = "a";
            result.push(a[ai]);
            ai++;
            bi++;
          } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
            if (which === "a")
              return false;
            which = "b";
            result.push(b[bi]);
            ai++;
            bi++;
          } else {
            return false;
          }
        }
        return a.length === b.length && result;
      }
      parseNegate() {
        if (this.nonegate)
          return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
          negate = !negate;
          negateOffset++;
        }
        if (negateOffset)
          this.pattern = pattern.slice(negateOffset);
        this.negate = negate;
      }
      // set partial to true to test if, for example,
      // "/a/b" matches the start of "/*/b/*/d"
      // Partial means, if you run out of file before you run
      // out of pattern, then that's fine, as long as all
      // the parts match.
      matchOne(file, pattern, partial = false) {
        const options = this.options;
        if (this.isWindows) {
          const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
          const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
          const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
          const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
          const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
          const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
          if (typeof fdi === "number" && typeof pdi === "number") {
            const [fd, pd] = [file[fdi], pattern[pdi]];
            if (fd.toLowerCase() === pd.toLowerCase()) {
              pattern[pdi] = fd;
              if (pdi > fdi) {
                pattern = pattern.slice(pdi);
              } else if (fdi > pdi) {
                file = file.slice(fdi);
              }
            }
          }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
          file = this.levelTwoFileOptimize(file);
        }
        this.debug("matchOne", this, { file, pattern });
        this.debug("matchOne", file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
          this.debug("matchOne loop");
          var p = pattern[pi];
          var f = file[fi];
          this.debug(pattern, p, f);
          if (p === false) {
            return false;
          }
          if (p === exports2.GLOBSTAR) {
            this.debug("GLOBSTAR", [pattern, p, f]);
            var fr = fi;
            var pr = pi + 1;
            if (pr === pl) {
              this.debug("** at the end");
              for (; fi < fl; fi++) {
                if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                  return false;
              }
              return true;
            }
            while (fr < fl) {
              var swallowee = file[fr];
              this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
              if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                this.debug("globstar found match!", fr, fl, swallowee);
                return true;
              } else {
                if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                  this.debug("dot detected!", file, fr, pattern, pr);
                  break;
                }
                this.debug("globstar swallow a segment, and continue");
                fr++;
              }
            }
            if (partial) {
              this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
              if (fr === fl) {
                return true;
              }
            }
            return false;
          }
          let hit;
          if (typeof p === "string") {
            hit = f === p;
            this.debug("string match", p, f, hit);
          } else {
            hit = p.test(f);
            this.debug("pattern match", p, f, hit);
          }
          if (!hit)
            return false;
        }
        if (fi === fl && pi === pl) {
          return true;
        } else if (fi === fl) {
          return partial;
        } else if (pi === pl) {
          return fi === fl - 1 && file[fi] === "";
        } else {
          throw new Error("wtf?");
        }
      }
      braceExpand() {
        return (0, exports2.braceExpand)(this.pattern, this.options);
      }
      parse(pattern) {
        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
        const options = this.options;
        if (pattern === "**")
          return exports2.GLOBSTAR;
        if (pattern === "")
          return "";
        let m;
        let fastTest = null;
        if (m = pattern.match(starRE)) {
          fastTest = options.dot ? starTestDot : starTest;
        } else if (m = pattern.match(starDotExtRE)) {
          fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
        } else if (m = pattern.match(qmarksRE)) {
          fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);
        } else if (m = pattern.match(starDotStarRE)) {
          fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
        } else if (m = pattern.match(dotStarRE)) {
          fastTest = dotStarTest;
        }
        const re = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();
        if (fastTest && typeof re === "object") {
          Reflect.defineProperty(re, "test", { value: fastTest });
        }
        return re;
      }
      makeRe() {
        if (this.regexp || this.regexp === false)
          return this.regexp;
        const set = this.set;
        if (!set.length) {
          this.regexp = false;
          return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
        const flags = new Set(options.nocase ? ["i"] : []);
        let re = set.map((pattern) => {
          const pp = pattern.map((p) => {
            if (p instanceof RegExp) {
              for (const f of p.flags.split(""))
                flags.add(f);
            }
            return typeof p === "string" ? regExpEscape(p) : p === exports2.GLOBSTAR ? exports2.GLOBSTAR : p._src;
          });
          pp.forEach((p, i) => {
            const next = pp[i + 1];
            const prev = pp[i - 1];
            if (p !== exports2.GLOBSTAR || prev === exports2.GLOBSTAR) {
              return;
            }
            if (prev === void 0) {
              if (next !== void 0 && next !== exports2.GLOBSTAR) {
                pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
              } else {
                pp[i] = twoStar;
              }
            } else if (next === void 0) {
              pp[i - 1] = prev + "(?:\\/|" + twoStar + ")?";
            } else if (next !== exports2.GLOBSTAR) {
              pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
              pp[i + 1] = exports2.GLOBSTAR;
            }
          });
          return pp.filter((p) => p !== exports2.GLOBSTAR).join("/");
        }).join("|");
        const [open, close] = set.length > 1 ? ["(?:", ")"] : ["", ""];
        re = "^" + open + re + close + "$";
        if (this.negate)
          re = "^(?!" + re + ").+$";
        try {
          this.regexp = new RegExp(re, [...flags].join(""));
        } catch (ex) {
          this.regexp = false;
        }
        return this.regexp;
      }
      slashSplit(p) {
        if (this.preserveMultipleSlashes) {
          return p.split("/");
        } else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
          return ["", ...p.split(/\/+/)];
        } else {
          return p.split(/\/+/);
        }
      }
      match(f, partial = this.partial) {
        this.debug("match", f, this.pattern);
        if (this.comment) {
          return false;
        }
        if (this.empty) {
          return f === "";
        }
        if (f === "/" && partial) {
          return true;
        }
        const options = this.options;
        if (this.isWindows) {
          f = f.split("\\").join("/");
        }
        const ff = this.slashSplit(f);
        this.debug(this.pattern, "split", ff);
        const set = this.set;
        this.debug(this.pattern, "set", set);
        let filename = ff[ff.length - 1];
        if (!filename) {
          for (let i = ff.length - 2; !filename && i >= 0; i--) {
            filename = ff[i];
          }
        }
        for (let i = 0; i < set.length; i++) {
          const pattern = set[i];
          let file = ff;
          if (options.matchBase && pattern.length === 1) {
            file = [filename];
          }
          const hit = this.matchOne(file, pattern, partial);
          if (hit) {
            if (options.flipNegate) {
              return true;
            }
            return !this.negate;
          }
        }
        if (options.flipNegate) {
          return false;
        }
        return this.negate;
      }
      static defaults(def) {
        return exports2.minimatch.defaults(def).Minimatch;
      }
    };
    exports2.Minimatch = Minimatch;
    var ast_js_2 = require_ast();
    Object.defineProperty(exports2, "AST", { enumerable: true, get: function() {
      return ast_js_2.AST;
    } });
    var escape_js_2 = require_escape();
    Object.defineProperty(exports2, "escape", { enumerable: true, get: function() {
      return escape_js_2.escape;
    } });
    var unescape_js_2 = require_unescape();
    Object.defineProperty(exports2, "unescape", { enumerable: true, get: function() {
      return unescape_js_2.unescape;
    } });
    exports2.minimatch.AST = ast_js_1.AST;
    exports2.minimatch.Minimatch = Minimatch;
    exports2.minimatch.escape = escape_js_1.escape;
    exports2.minimatch.unescape = unescape_js_1.unescape;
  }
});

// node_modules/typeorm/node_modules/lru-cache/dist/commonjs/index.js
var require_commonjs2 = __commonJS({
  "node_modules/typeorm/node_modules/lru-cache/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LRUCache = void 0;
    var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var warned = /* @__PURE__ */ new Set();
    var PROCESS = typeof process === "object" && !!process ? process : {};
    var emitWarning = (msg, type, code, fn) => {
      typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
    };
    var AC = globalThis.AbortController;
    var AS = globalThis.AbortSignal;
    if (typeof AC === "undefined") {
      AS = class AbortSignal {
        constructor() {
          __publicField(this, "onabort");
          __publicField(this, "_onabort", []);
          __publicField(this, "reason");
          __publicField(this, "aborted", false);
        }
        addEventListener(_, fn) {
          this._onabort.push(fn);
        }
      };
      AC = class AbortController {
        constructor() {
          __publicField(this, "signal", new AS());
          warnACPolyfill();
        }
        abort(reason) {
          if (this.signal.aborted)
            return;
          this.signal.reason = reason;
          this.signal.aborted = true;
          for (const fn of this.signal._onabort) {
            fn(reason);
          }
          this.signal.onabort?.(reason);
        }
      };
      let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
      const warnACPolyfill = () => {
        if (!printACPolyfillWarning)
          return;
        printACPolyfillWarning = false;
        emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
      };
    }
    var shouldWarn = (code) => !warned.has(code);
    var TYPE = Symbol("type");
    var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
    var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
    var ZeroArray = class extends Array {
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    var _constructing;
    var _Stack = class _Stack {
      constructor(max, HeapCls) {
        __publicField(this, "heap");
        __publicField(this, "length");
        if (!__privateGet(_Stack, _constructing)) {
          throw new TypeError("instantiate Stack using Stack.create(n)");
        }
        this.heap = new HeapCls(max);
        this.length = 0;
      }
      static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls)
          return [];
        __privateSet(_Stack, _constructing, true);
        const s = new _Stack(max, HeapCls);
        __privateSet(_Stack, _constructing, false);
        return s;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    _constructing = new WeakMap();
    // private constructor
    __privateAdd(_Stack, _constructing, false);
    var Stack = _Stack;
    var _a, _b, _max, _maxSize, _dispose, _disposeAfter, _fetchMethod, _memoMethod, _size, _calculatedSize, _keyMap, _keyList, _valList, _next, _prev, _head, _tail, _free, _disposed, _sizes, _starts, _ttls, _hasDispose, _hasFetchMethod, _hasDisposeAfter, _LRUCache_instances, initializeTTLTracking_fn, _updateItemAge, _statusTTL, _setItemTTL, _isStale, initializeSizeTracking_fn, _removeItemSize, _addItemSize, _requireSize, indexes_fn, rindexes_fn, isValidIndex_fn, evict_fn, backgroundFetch_fn, isBackgroundFetch_fn, connect_fn, moveToTail_fn, delete_fn, clear_fn;
    var _LRUCache = class _LRUCache {
      constructor(options) {
        __privateAdd(this, _LRUCache_instances);
        // options that cannot be changed without disaster
        __privateAdd(this, _max);
        __privateAdd(this, _maxSize);
        __privateAdd(this, _dispose);
        __privateAdd(this, _disposeAfter);
        __privateAdd(this, _fetchMethod);
        __privateAdd(this, _memoMethod);
        /**
         * {@link LRUCache.OptionsBase.ttl}
         */
        __publicField(this, "ttl");
        /**
         * {@link LRUCache.OptionsBase.ttlResolution}
         */
        __publicField(this, "ttlResolution");
        /**
         * {@link LRUCache.OptionsBase.ttlAutopurge}
         */
        __publicField(this, "ttlAutopurge");
        /**
         * {@link LRUCache.OptionsBase.updateAgeOnGet}
         */
        __publicField(this, "updateAgeOnGet");
        /**
         * {@link LRUCache.OptionsBase.updateAgeOnHas}
         */
        __publicField(this, "updateAgeOnHas");
        /**
         * {@link LRUCache.OptionsBase.allowStale}
         */
        __publicField(this, "allowStale");
        /**
         * {@link LRUCache.OptionsBase.noDisposeOnSet}
         */
        __publicField(this, "noDisposeOnSet");
        /**
         * {@link LRUCache.OptionsBase.noUpdateTTL}
         */
        __publicField(this, "noUpdateTTL");
        /**
         * {@link LRUCache.OptionsBase.maxEntrySize}
         */
        __publicField(this, "maxEntrySize");
        /**
         * {@link LRUCache.OptionsBase.sizeCalculation}
         */
        __publicField(this, "sizeCalculation");
        /**
         * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
         */
        __publicField(this, "noDeleteOnFetchRejection");
        /**
         * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
         */
        __publicField(this, "noDeleteOnStaleGet");
        /**
         * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
         */
        __publicField(this, "allowStaleOnFetchAbort");
        /**
         * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
         */
        __publicField(this, "allowStaleOnFetchRejection");
        /**
         * {@link LRUCache.OptionsBase.ignoreFetchAbort}
         */
        __publicField(this, "ignoreFetchAbort");
        // computed properties
        __privateAdd(this, _size);
        __privateAdd(this, _calculatedSize);
        __privateAdd(this, _keyMap);
        __privateAdd(this, _keyList);
        __privateAdd(this, _valList);
        __privateAdd(this, _next);
        __privateAdd(this, _prev);
        __privateAdd(this, _head);
        __privateAdd(this, _tail);
        __privateAdd(this, _free);
        __privateAdd(this, _disposed);
        __privateAdd(this, _sizes);
        __privateAdd(this, _starts);
        __privateAdd(this, _ttls);
        __privateAdd(this, _hasDispose);
        __privateAdd(this, _hasFetchMethod);
        __privateAdd(this, _hasDisposeAfter);
        // conditionally set private methods related to TTL
        __privateAdd(this, _updateItemAge, () => {
        });
        __privateAdd(this, _statusTTL, () => {
        });
        __privateAdd(this, _setItemTTL, () => {
        });
        /* c8 ignore stop */
        __privateAdd(this, _isStale, () => false);
        __privateAdd(this, _removeItemSize, (_i) => {
        });
        __privateAdd(this, _addItemSize, (_i, _s, _st) => {
        });
        __privateAdd(this, _requireSize, (_k, _v, size, sizeCalculation) => {
          if (size || sizeCalculation) {
            throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
          }
          return 0;
        });
        /**
         * A String value that is used in the creation of the default string
         * description of an object. Called by the built-in method
         * `Object.prototype.toString`.
         */
        __publicField(this, _a, "LRUCache");
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
        if (max !== 0 && !isPosInt(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        __privateSet(this, _max, max);
        __privateSet(this, _maxSize, maxSize);
        this.maxEntrySize = maxEntrySize || __privateGet(this, _maxSize);
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
          if (!__privateGet(this, _maxSize) && !this.maxEntrySize) {
            throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        if (memoMethod !== void 0 && typeof memoMethod !== "function") {
          throw new TypeError("memoMethod must be a function if defined");
        }
        __privateSet(this, _memoMethod, memoMethod);
        if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
          throw new TypeError("fetchMethod must be a function if specified");
        }
        __privateSet(this, _fetchMethod, fetchMethod);
        __privateSet(this, _hasFetchMethod, !!fetchMethod);
        __privateSet(this, _keyMap, /* @__PURE__ */ new Map());
        __privateSet(this, _keyList, new Array(max).fill(void 0));
        __privateSet(this, _valList, new Array(max).fill(void 0));
        __privateSet(this, _next, new UintArray(max));
        __privateSet(this, _prev, new UintArray(max));
        __privateSet(this, _head, 0);
        __privateSet(this, _tail, 0);
        __privateSet(this, _free, Stack.create(max));
        __privateSet(this, _size, 0);
        __privateSet(this, _calculatedSize, 0);
        if (typeof dispose === "function") {
          __privateSet(this, _dispose, dispose);
        }
        if (typeof disposeAfter === "function") {
          __privateSet(this, _disposeAfter, disposeAfter);
          __privateSet(this, _disposed, []);
        } else {
          __privateSet(this, _disposeAfter, void 0);
          __privateSet(this, _disposed, void 0);
        }
        __privateSet(this, _hasDispose, !!__privateGet(this, _dispose));
        __privateSet(this, _hasDisposeAfter, !!__privateGet(this, _disposeAfter));
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        if (this.maxEntrySize !== 0) {
          if (__privateGet(this, _maxSize) !== 0) {
            if (!isPosInt(__privateGet(this, _maxSize))) {
              throw new TypeError("maxSize must be a positive integer if specified");
            }
          }
          if (!isPosInt(this.maxEntrySize)) {
            throw new TypeError("maxEntrySize must be a positive integer if specified");
          }
          __privateMethod(this, _LRUCache_instances, initializeSizeTracking_fn).call(this);
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError("ttl must be a positive integer if specified");
          }
          __privateMethod(this, _LRUCache_instances, initializeTTLTracking_fn).call(this);
        }
        if (__privateGet(this, _max) === 0 && this.ttl === 0 && __privateGet(this, _maxSize) === 0) {
          throw new TypeError("At least one of max, maxSize, or ttl is required");
        }
        if (!this.ttlAutopurge && !__privateGet(this, _max) && !__privateGet(this, _maxSize)) {
          const code = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code)) {
            warned.add(code);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
          }
        }
      }
      /**
       * Do not call this method unless you need to inspect the
       * inner workings of the cache.  If anything returned by this
       * object is modified in any way, strange breakage may occur.
       *
       * These fields are private for a reason!
       *
       * @internal
       */
      static unsafeExposeInternals(c) {
        return {
          // properties
          starts: __privateGet(c, _starts),
          ttls: __privateGet(c, _ttls),
          sizes: __privateGet(c, _sizes),
          keyMap: __privateGet(c, _keyMap),
          keyList: __privateGet(c, _keyList),
          valList: __privateGet(c, _valList),
          next: __privateGet(c, _next),
          prev: __privateGet(c, _prev),
          get head() {
            return __privateGet(c, _head);
          },
          get tail() {
            return __privateGet(c, _tail);
          },
          free: __privateGet(c, _free),
          // methods
          isBackgroundFetch: (p) => {
            var _a2;
            return __privateMethod(_a2 = c, _LRUCache_instances, isBackgroundFetch_fn).call(_a2, p);
          },
          backgroundFetch: (k, index, options, context) => {
            var _a2;
            return __privateMethod(_a2 = c, _LRUCache_instances, backgroundFetch_fn).call(_a2, k, index, options, context);
          },
          moveToTail: (index) => {
            var _a2;
            return __privateMethod(_a2 = c, _LRUCache_instances, moveToTail_fn).call(_a2, index);
          },
          indexes: (options) => {
            var _a2;
            return __privateMethod(_a2 = c, _LRUCache_instances, indexes_fn).call(_a2, options);
          },
          rindexes: (options) => {
            var _a2;
            return __privateMethod(_a2 = c, _LRUCache_instances, rindexes_fn).call(_a2, options);
          },
          isStale: (index) => {
            var _a2;
            return __privateGet(_a2 = c, _isStale).call(_a2, index);
          }
        };
      }
      // Protected read-only members
      /**
       * {@link LRUCache.OptionsBase.max} (read-only)
       */
      get max() {
        return __privateGet(this, _max);
      }
      /**
       * {@link LRUCache.OptionsBase.maxSize} (read-only)
       */
      get maxSize() {
        return __privateGet(this, _maxSize);
      }
      /**
       * The total computed size of items in the cache (read-only)
       */
      get calculatedSize() {
        return __privateGet(this, _calculatedSize);
      }
      /**
       * The number of items stored in the cache (read-only)
       */
      get size() {
        return __privateGet(this, _size);
      }
      /**
       * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
       */
      get fetchMethod() {
        return __privateGet(this, _fetchMethod);
      }
      get memoMethod() {
        return __privateGet(this, _memoMethod);
      }
      /**
       * {@link LRUCache.OptionsBase.dispose} (read-only)
       */
      get dispose() {
        return __privateGet(this, _dispose);
      }
      /**
       * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
       */
      get disposeAfter() {
        return __privateGet(this, _disposeAfter);
      }
      /**
       * Return the number of ms left in the item's TTL. If item is not in cache,
       * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
       */
      getRemainingTTL(key) {
        return __privateGet(this, _keyMap).has(key) ? Infinity : 0;
      }
      /**
       * Return a generator yielding `[key, value]` pairs,
       * in order from most recently used to least recently used.
       */
      *entries() {
        for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
          if (__privateGet(this, _valList)[i] !== void 0 && __privateGet(this, _keyList)[i] !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
            yield [__privateGet(this, _keyList)[i], __privateGet(this, _valList)[i]];
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.entries}
       *
       * Return a generator yielding `[key, value]` pairs,
       * in order from least recently used to most recently used.
       */
      *rentries() {
        for (const i of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
          if (__privateGet(this, _valList)[i] !== void 0 && __privateGet(this, _keyList)[i] !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
            yield [__privateGet(this, _keyList)[i], __privateGet(this, _valList)[i]];
          }
        }
      }
      /**
       * Return a generator yielding the keys in the cache,
       * in order from most recently used to least recently used.
       */
      *keys() {
        for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
          const k = __privateGet(this, _keyList)[i];
          if (k !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
            yield k;
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.keys}
       *
       * Return a generator yielding the keys in the cache,
       * in order from least recently used to most recently used.
       */
      *rkeys() {
        for (const i of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
          const k = __privateGet(this, _keyList)[i];
          if (k !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
            yield k;
          }
        }
      }
      /**
       * Return a generator yielding the values in the cache,
       * in order from most recently used to least recently used.
       */
      *values() {
        for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
          const v = __privateGet(this, _valList)[i];
          if (v !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
            yield __privateGet(this, _valList)[i];
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.values}
       *
       * Return a generator yielding the values in the cache,
       * in order from least recently used to most recently used.
       */
      *rvalues() {
        for (const i of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
          const v = __privateGet(this, _valList)[i];
          if (v !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
            yield __privateGet(this, _valList)[i];
          }
        }
      }
      /**
       * Iterating over the cache itself yields the same results as
       * {@link LRUCache.entries}
       */
      [(_b = Symbol.iterator, _a = Symbol.toStringTag, _b)]() {
        return this.entries();
      }
      /**
       * Find a value for which the supplied fn method returns a truthy value,
       * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
       */
      find(fn, getOptions = {}) {
        for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
          const v = __privateGet(this, _valList)[i];
          const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          if (fn(value, __privateGet(this, _keyList)[i], this)) {
            return this.get(__privateGet(this, _keyList)[i], getOptions);
          }
        }
      }
      /**
       * Call the supplied function on each item in the cache, in order from most
       * recently used to least recently used.
       *
       * `fn` is called as `fn(value, key, cache)`.
       *
       * If `thisp` is provided, function will be called in the `this`-context of
       * the provided object, or the cache if no `thisp` object is provided.
       *
       * Does not update age or recenty of use, or iterate over stale values.
       */
      forEach(fn, thisp = this) {
        for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
          const v = __privateGet(this, _valList)[i];
          const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          fn.call(thisp, value, __privateGet(this, _keyList)[i], this);
        }
      }
      /**
       * The same as {@link LRUCache.forEach} but items are iterated over in
       * reverse order.  (ie, less recently used items are iterated over first.)
       */
      rforEach(fn, thisp = this) {
        for (const i of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
          const v = __privateGet(this, _valList)[i];
          const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          fn.call(thisp, value, __privateGet(this, _keyList)[i], this);
        }
      }
      /**
       * Delete any stale entries. Returns true if anything was removed,
       * false otherwise.
       */
      purgeStale() {
        let deleted = false;
        for (const i of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this, { allowStale: true })) {
          if (__privateGet(this, _isStale).call(this, i)) {
            __privateMethod(this, _LRUCache_instances, delete_fn).call(this, __privateGet(this, _keyList)[i], "expire");
            deleted = true;
          }
        }
        return deleted;
      }
      /**
       * Get the extended info about a given entry, to get its value, size, and
       * TTL info simultaneously. Returns `undefined` if the key is not present.
       *
       * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
       * serialization, the `start` value is always the current timestamp, and the
       * `ttl` is a calculated remaining time to live (negative if expired).
       *
       * Always returns stale values, if their info is found in the cache, so be
       * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
       * if relevant.
       */
      info(key) {
        const i = __privateGet(this, _keyMap).get(key);
        if (i === void 0)
          return void 0;
        const v = __privateGet(this, _valList)[i];
        const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
        if (value === void 0)
          return void 0;
        const entry = { value };
        if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
          const ttl = __privateGet(this, _ttls)[i];
          const start = __privateGet(this, _starts)[i];
          if (ttl && start) {
            const remain = ttl - (perf.now() - start);
            entry.ttl = remain;
            entry.start = Date.now();
          }
        }
        if (__privateGet(this, _sizes)) {
          entry.size = __privateGet(this, _sizes)[i];
        }
        return entry;
      }
      /**
       * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
       * passed to {@link LRLUCache#load}.
       *
       * The `start` fields are calculated relative to a portable `Date.now()`
       * timestamp, even if `performance.now()` is available.
       *
       * Stale entries are always included in the `dump`, even if
       * {@link LRUCache.OptionsBase.allowStale} is false.
       *
       * Note: this returns an actual array, not a generator, so it can be more
       * easily passed around.
       */
      dump() {
        const arr = [];
        for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this, { allowStale: true })) {
          const key = __privateGet(this, _keyList)[i];
          const v = __privateGet(this, _valList)[i];
          const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
          if (value === void 0 || key === void 0)
            continue;
          const entry = { value };
          if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
            entry.ttl = __privateGet(this, _ttls)[i];
            const age = perf.now() - __privateGet(this, _starts)[i];
            entry.start = Math.floor(Date.now() - age);
          }
          if (__privateGet(this, _sizes)) {
            entry.size = __privateGet(this, _sizes)[i];
          }
          arr.unshift([key, entry]);
        }
        return arr;
      }
      /**
       * Reset the cache and load in the items in entries in the order listed.
       *
       * The shape of the resulting cache may be different if the same options are
       * not used in both caches.
       *
       * The `start` fields are assumed to be calculated relative to a portable
       * `Date.now()` timestamp, even if `performance.now()` is available.
       */
      load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
          if (entry.start) {
            const age = Date.now() - entry.start;
            entry.start = perf.now() - age;
          }
          this.set(key, entry.value, entry);
        }
      }
      /**
       * Add a value to the cache.
       *
       * Note: if `undefined` is specified as a value, this is an alias for
       * {@link LRUCache#delete}
       *
       * Fields on the {@link LRUCache.SetOptions} options param will override
       * their corresponding values in the constructor options for the scope
       * of this single `set()` operation.
       *
       * If `start` is provided, then that will set the effective start
       * time for the TTL calculation. Note that this must be a previous
       * value of `performance.now()` if supported, or a previous value of
       * `Date.now()` if not.
       *
       * Options object may also include `size`, which will prevent
       * calling the `sizeCalculation` function and just use the specified
       * number if it is a positive integer, and `noDisposeOnSet` which
       * will prevent calling a `dispose` function in the case of
       * overwrites.
       *
       * If the `size` (or return value of `sizeCalculation`) for a given
       * entry is greater than `maxEntrySize`, then the item will not be
       * added to the cache.
       *
       * Will update the recency of the entry.
       *
       * If the value is `undefined`, then this is an alias for
       * `cache.delete(key)`. `undefined` is never stored in the cache.
       */
      set(k, v, setOptions = {}) {
        var _a2, _b2, _c;
        if (v === void 0) {
          this.delete(k);
          return this;
        }
        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
        const size = __privateGet(this, _requireSize).call(this, k, v, setOptions.size || 0, sizeCalculation);
        if (this.maxEntrySize && size > this.maxEntrySize) {
          if (status) {
            status.set = "miss";
            status.maxEntrySizeExceeded = true;
          }
          __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k, "set");
          return this;
        }
        let index = __privateGet(this, _size) === 0 ? void 0 : __privateGet(this, _keyMap).get(k);
        if (index === void 0) {
          index = __privateGet(this, _size) === 0 ? __privateGet(this, _tail) : __privateGet(this, _free).length !== 0 ? __privateGet(this, _free).pop() : __privateGet(this, _size) === __privateGet(this, _max) ? __privateMethod(this, _LRUCache_instances, evict_fn).call(this, false) : __privateGet(this, _size);
          __privateGet(this, _keyList)[index] = k;
          __privateGet(this, _valList)[index] = v;
          __privateGet(this, _keyMap).set(k, index);
          __privateGet(this, _next)[__privateGet(this, _tail)] = index;
          __privateGet(this, _prev)[index] = __privateGet(this, _tail);
          __privateSet(this, _tail, index);
          __privateWrapper(this, _size)._++;
          __privateGet(this, _addItemSize).call(this, index, size, status);
          if (status)
            status.set = "add";
          noUpdateTTL = false;
        } else {
          __privateMethod(this, _LRUCache_instances, moveToTail_fn).call(this, index);
          const oldVal = __privateGet(this, _valList)[index];
          if (v !== oldVal) {
            if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, oldVal)) {
              oldVal.__abortController.abort(new Error("replaced"));
              const { __staleWhileFetching: s } = oldVal;
              if (s !== void 0 && !noDisposeOnSet) {
                if (__privateGet(this, _hasDispose)) {
                  (_a2 = __privateGet(this, _dispose)) == null ? void 0 : _a2.call(this, s, k, "set");
                }
                if (__privateGet(this, _hasDisposeAfter)) {
                  __privateGet(this, _disposed)?.push([s, k, "set"]);
                }
              }
            } else if (!noDisposeOnSet) {
              if (__privateGet(this, _hasDispose)) {
                (_b2 = __privateGet(this, _dispose)) == null ? void 0 : _b2.call(this, oldVal, k, "set");
              }
              if (__privateGet(this, _hasDisposeAfter)) {
                __privateGet(this, _disposed)?.push([oldVal, k, "set"]);
              }
            }
            __privateGet(this, _removeItemSize).call(this, index);
            __privateGet(this, _addItemSize).call(this, index, size, status);
            __privateGet(this, _valList)[index] = v;
            if (status) {
              status.set = "replace";
              const oldValue = oldVal && __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, oldVal) ? oldVal.__staleWhileFetching : oldVal;
              if (oldValue !== void 0)
                status.oldValue = oldValue;
            }
          } else if (status) {
            status.set = "update";
          }
        }
        if (ttl !== 0 && !__privateGet(this, _ttls)) {
          __privateMethod(this, _LRUCache_instances, initializeTTLTracking_fn).call(this);
        }
        if (__privateGet(this, _ttls)) {
          if (!noUpdateTTL) {
            __privateGet(this, _setItemTTL).call(this, index, ttl, start);
          }
          if (status)
            __privateGet(this, _statusTTL).call(this, status, index);
        }
        if (!noDisposeOnSet && __privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
          const dt = __privateGet(this, _disposed);
          let task;
          while (task = dt?.shift()) {
            (_c = __privateGet(this, _disposeAfter)) == null ? void 0 : _c.call(this, ...task);
          }
        }
        return this;
      }
      /**
       * Evict the least recently used item, returning its value or
       * `undefined` if cache is empty.
       */
      pop() {
        var _a2;
        try {
          while (__privateGet(this, _size)) {
            const val = __privateGet(this, _valList)[__privateGet(this, _head)];
            __privateMethod(this, _LRUCache_instances, evict_fn).call(this, true);
            if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, val)) {
              if (val.__staleWhileFetching) {
                return val.__staleWhileFetching;
              }
            } else if (val !== void 0) {
              return val;
            }
          }
        } finally {
          if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
            const dt = __privateGet(this, _disposed);
            let task;
            while (task = dt?.shift()) {
              (_a2 = __privateGet(this, _disposeAfter)) == null ? void 0 : _a2.call(this, ...task);
            }
          }
        }
      }
      /**
       * Check if a key is in the cache, without updating the recency of use.
       * Will return false if the item is stale, even though it is technically
       * in the cache.
       *
       * Check if a key is in the cache, without updating the recency of
       * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
       * to `true` in either the options or the constructor.
       *
       * Will return `false` if the item is stale, even though it is technically in
       * the cache. The difference can be determined (if it matters) by using a
       * `status` argument, and inspecting the `has` field.
       *
       * Will not update item age unless
       * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
       */
      has(k, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
        const index = __privateGet(this, _keyMap).get(k);
        if (index !== void 0) {
          const v = __privateGet(this, _valList)[index];
          if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) && v.__staleWhileFetching === void 0) {
            return false;
          }
          if (!__privateGet(this, _isStale).call(this, index)) {
            if (updateAgeOnHas) {
              __privateGet(this, _updateItemAge).call(this, index);
            }
            if (status) {
              status.has = "hit";
              __privateGet(this, _statusTTL).call(this, status, index);
            }
            return true;
          } else if (status) {
            status.has = "stale";
            __privateGet(this, _statusTTL).call(this, status, index);
          }
        } else if (status) {
          status.has = "miss";
        }
        return false;
      }
      /**
       * Like {@link LRUCache#get} but doesn't update recency or delete stale
       * items.
       *
       * Returns `undefined` if the item is stale, unless
       * {@link LRUCache.OptionsBase.allowStale} is set.
       */
      peek(k, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index = __privateGet(this, _keyMap).get(k);
        if (index === void 0 || !allowStale && __privateGet(this, _isStale).call(this, index)) {
          return;
        }
        const v = __privateGet(this, _valList)[index];
        return __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
      }
      async fetch(k, fetchOptions = {}) {
        const {
          // get options
          allowStale = this.allowStale,
          updateAgeOnGet = this.updateAgeOnGet,
          noDeleteOnStaleGet = this.noDeleteOnStaleGet,
          // set options
          ttl = this.ttl,
          noDisposeOnSet = this.noDisposeOnSet,
          size = 0,
          sizeCalculation = this.sizeCalculation,
          noUpdateTTL = this.noUpdateTTL,
          // fetch exclusive options
          noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
          allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
          ignoreFetchAbort = this.ignoreFetchAbort,
          allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
          context,
          forceRefresh = false,
          status,
          signal
        } = fetchOptions;
        if (!__privateGet(this, _hasFetchMethod)) {
          if (status)
            status.fetch = "get";
          return this.get(k, {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            status
          });
        }
        const options = {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          ttl,
          noDisposeOnSet,
          size,
          sizeCalculation,
          noUpdateTTL,
          noDeleteOnFetchRejection,
          allowStaleOnFetchRejection,
          allowStaleOnFetchAbort,
          ignoreFetchAbort,
          status,
          signal
        };
        let index = __privateGet(this, _keyMap).get(k);
        if (index === void 0) {
          if (status)
            status.fetch = "miss";
          const p = __privateMethod(this, _LRUCache_instances, backgroundFetch_fn).call(this, k, index, options, context);
          return p.__returned = p;
        } else {
          const v = __privateGet(this, _valList)[index];
          if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
            const stale = allowStale && v.__staleWhileFetching !== void 0;
            if (status) {
              status.fetch = "inflight";
              if (stale)
                status.returnedStale = true;
            }
            return stale ? v.__staleWhileFetching : v.__returned = v;
          }
          const isStale = __privateGet(this, _isStale).call(this, index);
          if (!forceRefresh && !isStale) {
            if (status)
              status.fetch = "hit";
            __privateMethod(this, _LRUCache_instances, moveToTail_fn).call(this, index);
            if (updateAgeOnGet) {
              __privateGet(this, _updateItemAge).call(this, index);
            }
            if (status)
              __privateGet(this, _statusTTL).call(this, status, index);
            return v;
          }
          const p = __privateMethod(this, _LRUCache_instances, backgroundFetch_fn).call(this, k, index, options, context);
          const hasStale = p.__staleWhileFetching !== void 0;
          const staleVal = hasStale && allowStale;
          if (status) {
            status.fetch = isStale ? "stale" : "refresh";
            if (staleVal && isStale)
              status.returnedStale = true;
          }
          return staleVal ? p.__staleWhileFetching : p.__returned = p;
        }
      }
      async forceFetch(k, fetchOptions = {}) {
        const v = await this.fetch(k, fetchOptions);
        if (v === void 0)
          throw new Error("fetch() returned undefined");
        return v;
      }
      memo(k, memoOptions = {}) {
        const memoMethod = __privateGet(this, _memoMethod);
        if (!memoMethod) {
          throw new Error("no memoMethod provided to constructor");
        }
        const { context, forceRefresh, ...options } = memoOptions;
        const v = this.get(k, options);
        if (!forceRefresh && v !== void 0)
          return v;
        const vv = memoMethod(k, v, {
          options,
          context
        });
        this.set(k, vv, options);
        return vv;
      }
      /**
       * Return a value from the cache. Will update the recency of the cache
       * entry found.
       *
       * If the key is not found, get() will return `undefined`.
       */
      get(k, getOptions = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
        const index = __privateGet(this, _keyMap).get(k);
        if (index !== void 0) {
          const value = __privateGet(this, _valList)[index];
          const fetching = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, value);
          if (status)
            __privateGet(this, _statusTTL).call(this, status, index);
          if (__privateGet(this, _isStale).call(this, index)) {
            if (status)
              status.get = "stale";
            if (!fetching) {
              if (!noDeleteOnStaleGet) {
                __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k, "expire");
              }
              if (status && allowStale)
                status.returnedStale = true;
              return allowStale ? value : void 0;
            } else {
              if (status && allowStale && value.__staleWhileFetching !== void 0) {
                status.returnedStale = true;
              }
              return allowStale ? value.__staleWhileFetching : void 0;
            }
          } else {
            if (status)
              status.get = "hit";
            if (fetching) {
              return value.__staleWhileFetching;
            }
            __privateMethod(this, _LRUCache_instances, moveToTail_fn).call(this, index);
            if (updateAgeOnGet) {
              __privateGet(this, _updateItemAge).call(this, index);
            }
            return value;
          }
        } else if (status) {
          status.get = "miss";
        }
      }
      /**
       * Deletes a key out of the cache.
       *
       * Returns true if the key was deleted, false otherwise.
       */
      delete(k) {
        return __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k, "delete");
      }
      /**
       * Clear the cache entirely, throwing away all values.
       */
      clear() {
        return __privateMethod(this, _LRUCache_instances, clear_fn).call(this, "delete");
      }
    };
    _max = new WeakMap();
    _maxSize = new WeakMap();
    _dispose = new WeakMap();
    _disposeAfter = new WeakMap();
    _fetchMethod = new WeakMap();
    _memoMethod = new WeakMap();
    _size = new WeakMap();
    _calculatedSize = new WeakMap();
    _keyMap = new WeakMap();
    _keyList = new WeakMap();
    _valList = new WeakMap();
    _next = new WeakMap();
    _prev = new WeakMap();
    _head = new WeakMap();
    _tail = new WeakMap();
    _free = new WeakMap();
    _disposed = new WeakMap();
    _sizes = new WeakMap();
    _starts = new WeakMap();
    _ttls = new WeakMap();
    _hasDispose = new WeakMap();
    _hasFetchMethod = new WeakMap();
    _hasDisposeAfter = new WeakMap();
    _LRUCache_instances = new WeakSet();
    initializeTTLTracking_fn = function() {
      const ttls = new ZeroArray(__privateGet(this, _max));
      const starts = new ZeroArray(__privateGet(this, _max));
      __privateSet(this, _ttls, ttls);
      __privateSet(this, _starts, starts);
      __privateSet(this, _setItemTTL, (index, ttl, start = perf.now()) => {
        starts[index] = ttl !== 0 ? start : 0;
        ttls[index] = ttl;
        if (ttl !== 0 && this.ttlAutopurge) {
          const t = setTimeout(() => {
            if (__privateGet(this, _isStale).call(this, index)) {
              __privateMethod(this, _LRUCache_instances, delete_fn).call(this, __privateGet(this, _keyList)[index], "expire");
            }
          }, ttl + 1);
          if (t.unref) {
            t.unref();
          }
        }
      });
      __privateSet(this, _updateItemAge, (index) => {
        starts[index] = ttls[index] !== 0 ? perf.now() : 0;
      });
      __privateSet(this, _statusTTL, (status, index) => {
        if (ttls[index]) {
          const ttl = ttls[index];
          const start = starts[index];
          if (!ttl || !start)
            return;
          status.ttl = ttl;
          status.start = start;
          status.now = cachedNow || getNow();
          const age = status.now - start;
          status.remainingTTL = ttl - age;
        }
      });
      let cachedNow = 0;
      const getNow = () => {
        const n = perf.now();
        if (this.ttlResolution > 0) {
          cachedNow = n;
          const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
          if (t.unref) {
            t.unref();
          }
        }
        return n;
      };
      this.getRemainingTTL = (key) => {
        const index = __privateGet(this, _keyMap).get(key);
        if (index === void 0) {
          return 0;
        }
        const ttl = ttls[index];
        const start = starts[index];
        if (!ttl || !start) {
          return Infinity;
        }
        const age = (cachedNow || getNow()) - start;
        return ttl - age;
      };
      __privateSet(this, _isStale, (index) => {
        const s = starts[index];
        const t = ttls[index];
        return !!t && !!s && (cachedNow || getNow()) - s > t;
      });
    };
    _updateItemAge = new WeakMap();
    _statusTTL = new WeakMap();
    _setItemTTL = new WeakMap();
    _isStale = new WeakMap();
    initializeSizeTracking_fn = function() {
      const sizes = new ZeroArray(__privateGet(this, _max));
      __privateSet(this, _calculatedSize, 0);
      __privateSet(this, _sizes, sizes);
      __privateSet(this, _removeItemSize, (index) => {
        __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) - sizes[index]);
        sizes[index] = 0;
      });
      __privateSet(this, _requireSize, (k, v, size, sizeCalculation) => {
        if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
          return 0;
        }
        if (!isPosInt(size)) {
          if (sizeCalculation) {
            if (typeof sizeCalculation !== "function") {
              throw new TypeError("sizeCalculation must be a function");
            }
            size = sizeCalculation(v, k);
            if (!isPosInt(size)) {
              throw new TypeError("sizeCalculation return invalid (expect positive integer)");
            }
          } else {
            throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
          }
        }
        return size;
      });
      __privateSet(this, _addItemSize, (index, size, status) => {
        sizes[index] = size;
        if (__privateGet(this, _maxSize)) {
          const maxSize = __privateGet(this, _maxSize) - sizes[index];
          while (__privateGet(this, _calculatedSize) > maxSize) {
            __privateMethod(this, _LRUCache_instances, evict_fn).call(this, true);
          }
        }
        __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) + sizes[index]);
        if (status) {
          status.entrySize = size;
          status.totalCalculatedSize = __privateGet(this, _calculatedSize);
        }
      });
    };
    _removeItemSize = new WeakMap();
    _addItemSize = new WeakMap();
    _requireSize = new WeakMap();
    indexes_fn = function* ({ allowStale = this.allowStale } = {}) {
      if (__privateGet(this, _size)) {
        for (let i = __privateGet(this, _tail); true; ) {
          if (!__privateMethod(this, _LRUCache_instances, isValidIndex_fn).call(this, i)) {
            break;
          }
          if (allowStale || !__privateGet(this, _isStale).call(this, i)) {
            yield i;
          }
          if (i === __privateGet(this, _head)) {
            break;
          } else {
            i = __privateGet(this, _prev)[i];
          }
        }
      }
    };
    rindexes_fn = function* ({ allowStale = this.allowStale } = {}) {
      if (__privateGet(this, _size)) {
        for (let i = __privateGet(this, _head); true; ) {
          if (!__privateMethod(this, _LRUCache_instances, isValidIndex_fn).call(this, i)) {
            break;
          }
          if (allowStale || !__privateGet(this, _isStale).call(this, i)) {
            yield i;
          }
          if (i === __privateGet(this, _tail)) {
            break;
          } else {
            i = __privateGet(this, _next)[i];
          }
        }
      }
    };
    isValidIndex_fn = function(index) {
      return index !== void 0 && __privateGet(this, _keyMap).get(__privateGet(this, _keyList)[index]) === index;
    };
    evict_fn = function(free) {
      var _a2;
      const head = __privateGet(this, _head);
      const k = __privateGet(this, _keyList)[head];
      const v = __privateGet(this, _valList)[head];
      if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
        v.__abortController.abort(new Error("evicted"));
      } else if (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) {
        if (__privateGet(this, _hasDispose)) {
          (_a2 = __privateGet(this, _dispose)) == null ? void 0 : _a2.call(this, v, k, "evict");
        }
        if (__privateGet(this, _hasDisposeAfter)) {
          __privateGet(this, _disposed)?.push([v, k, "evict"]);
        }
      }
      __privateGet(this, _removeItemSize).call(this, head);
      if (free) {
        __privateGet(this, _keyList)[head] = void 0;
        __privateGet(this, _valList)[head] = void 0;
        __privateGet(this, _free).push(head);
      }
      if (__privateGet(this, _size) === 1) {
        __privateSet(this, _head, __privateSet(this, _tail, 0));
        __privateGet(this, _free).length = 0;
      } else {
        __privateSet(this, _head, __privateGet(this, _next)[head]);
      }
      __privateGet(this, _keyMap).delete(k);
      __privateWrapper(this, _size)._--;
      return head;
    };
    backgroundFetch_fn = function(k, index, options, context) {
      const v = index === void 0 ? void 0 : __privateGet(this, _valList)[index];
      if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
        return v;
      }
      const ac = new AC();
      const { signal } = options;
      signal?.addEventListener("abort", () => ac.abort(signal.reason), {
        signal: ac.signal
      });
      const fetchOpts = {
        signal: ac.signal,
        options,
        context
      };
      const cb = (v2, updateCache = false) => {
        const { aborted } = ac.signal;
        const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
        if (options.status) {
          if (aborted && !updateCache) {
            options.status.fetchAborted = true;
            options.status.fetchError = ac.signal.reason;
            if (ignoreAbort)
              options.status.fetchAbortIgnored = true;
          } else {
            options.status.fetchResolved = true;
          }
        }
        if (aborted && !ignoreAbort && !updateCache) {
          return fetchFail(ac.signal.reason);
        }
        const bf2 = p;
        if (__privateGet(this, _valList)[index] === p) {
          if (v2 === void 0) {
            if (bf2.__staleWhileFetching) {
              __privateGet(this, _valList)[index] = bf2.__staleWhileFetching;
            } else {
              __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k, "fetch");
            }
          } else {
            if (options.status)
              options.status.fetchUpdated = true;
            this.set(k, v2, fetchOpts.options);
          }
        }
        return v2;
      };
      const eb = (er) => {
        if (options.status) {
          options.status.fetchRejected = true;
          options.status.fetchError = er;
        }
        return fetchFail(er);
      };
      const fetchFail = (er) => {
        const { aborted } = ac.signal;
        const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
        const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
        const noDelete = allowStale || options.noDeleteOnFetchRejection;
        const bf2 = p;
        if (__privateGet(this, _valList)[index] === p) {
          const del = !noDelete || bf2.__staleWhileFetching === void 0;
          if (del) {
            __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k, "fetch");
          } else if (!allowStaleAborted) {
            __privateGet(this, _valList)[index] = bf2.__staleWhileFetching;
          }
        }
        if (allowStale) {
          if (options.status && bf2.__staleWhileFetching !== void 0) {
            options.status.returnedStale = true;
          }
          return bf2.__staleWhileFetching;
        } else if (bf2.__returned === bf2) {
          throw er;
        }
      };
      const pcall = (res, rej) => {
        var _a2;
        const fmp = (_a2 = __privateGet(this, _fetchMethod)) == null ? void 0 : _a2.call(this, k, v, fetchOpts);
        if (fmp && fmp instanceof Promise) {
          fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
        }
        ac.signal.addEventListener("abort", () => {
          if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
            res(void 0);
            if (options.allowStaleOnFetchAbort) {
              res = (v2) => cb(v2, true);
            }
          }
        });
      };
      if (options.status)
        options.status.fetchDispatched = true;
      const p = new Promise(pcall).then(cb, eb);
      const bf = Object.assign(p, {
        __abortController: ac,
        __staleWhileFetching: v,
        __returned: void 0
      });
      if (index === void 0) {
        this.set(k, bf, { ...fetchOpts.options, status: void 0 });
        index = __privateGet(this, _keyMap).get(k);
      } else {
        __privateGet(this, _valList)[index] = bf;
      }
      return bf;
    };
    isBackgroundFetch_fn = function(p) {
      if (!__privateGet(this, _hasFetchMethod))
        return false;
      const b = p;
      return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
    };
    connect_fn = function(p, n) {
      __privateGet(this, _prev)[n] = p;
      __privateGet(this, _next)[p] = n;
    };
    moveToTail_fn = function(index) {
      if (index !== __privateGet(this, _tail)) {
        if (index === __privateGet(this, _head)) {
          __privateSet(this, _head, __privateGet(this, _next)[index]);
        } else {
          __privateMethod(this, _LRUCache_instances, connect_fn).call(this, __privateGet(this, _prev)[index], __privateGet(this, _next)[index]);
        }
        __privateMethod(this, _LRUCache_instances, connect_fn).call(this, __privateGet(this, _tail), index);
        __privateSet(this, _tail, index);
      }
    };
    delete_fn = function(k, reason) {
      var _a2, _b2;
      let deleted = false;
      if (__privateGet(this, _size) !== 0) {
        const index = __privateGet(this, _keyMap).get(k);
        if (index !== void 0) {
          deleted = true;
          if (__privateGet(this, _size) === 1) {
            __privateMethod(this, _LRUCache_instances, clear_fn).call(this, reason);
          } else {
            __privateGet(this, _removeItemSize).call(this, index);
            const v = __privateGet(this, _valList)[index];
            if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
              v.__abortController.abort(new Error("deleted"));
            } else if (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) {
              if (__privateGet(this, _hasDispose)) {
                (_a2 = __privateGet(this, _dispose)) == null ? void 0 : _a2.call(this, v, k, reason);
              }
              if (__privateGet(this, _hasDisposeAfter)) {
                __privateGet(this, _disposed)?.push([v, k, reason]);
              }
            }
            __privateGet(this, _keyMap).delete(k);
            __privateGet(this, _keyList)[index] = void 0;
            __privateGet(this, _valList)[index] = void 0;
            if (index === __privateGet(this, _tail)) {
              __privateSet(this, _tail, __privateGet(this, _prev)[index]);
            } else if (index === __privateGet(this, _head)) {
              __privateSet(this, _head, __privateGet(this, _next)[index]);
            } else {
              const pi = __privateGet(this, _prev)[index];
              __privateGet(this, _next)[pi] = __privateGet(this, _next)[index];
              const ni = __privateGet(this, _next)[index];
              __privateGet(this, _prev)[ni] = __privateGet(this, _prev)[index];
            }
            __privateWrapper(this, _size)._--;
            __privateGet(this, _free).push(index);
          }
        }
      }
      if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)?.length) {
        const dt = __privateGet(this, _disposed);
        let task;
        while (task = dt?.shift()) {
          (_b2 = __privateGet(this, _disposeAfter)) == null ? void 0 : _b2.call(this, ...task);
        }
      }
      return deleted;
    };
    clear_fn = function(reason) {
      var _a2, _b2;
      for (const index of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this, { allowStale: true })) {
        const v = __privateGet(this, _valList)[index];
        if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
          v.__abortController.abort(new Error("deleted"));
        } else {
          const k = __privateGet(this, _keyList)[index];
          if (__privateGet(this, _hasDispose)) {
            (_a2 = __privateGet(this, _dispose)) == null ? void 0 : _a2.call(this, v, k, reason);
          }
          if (__privateGet(this, _hasDisposeAfter)) {
            __privateGet(this, _disposed)?.push([v, k, reason]);
          }
        }
      }
      __privateGet(this, _keyMap).clear();
      __privateGet(this, _valList).fill(void 0);
      __privateGet(this, _keyList).fill(void 0);
      if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
        __privateGet(this, _ttls).fill(0);
        __privateGet(this, _starts).fill(0);
      }
      if (__privateGet(this, _sizes)) {
        __privateGet(this, _sizes).fill(0);
      }
      __privateSet(this, _head, 0);
      __privateSet(this, _tail, 0);
      __privateGet(this, _free).length = 0;
      __privateSet(this, _calculatedSize, 0);
      __privateSet(this, _size, 0);
      if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
        const dt = __privateGet(this, _disposed);
        let task;
        while (task = dt?.shift()) {
          (_b2 = __privateGet(this, _disposeAfter)) == null ? void 0 : _b2.call(this, ...task);
        }
      }
    };
    var LRUCache = _LRUCache;
    exports2.LRUCache = LRUCache;
  }
});

// node_modules/minipass/dist/commonjs/index.js
var require_commonjs3 = __commonJS({
  "node_modules/minipass/dist/commonjs/index.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Minipass = exports2.isWritable = exports2.isReadable = exports2.isStream = void 0;
    var proc = typeof process === "object" && process ? process : {
      stdout: null,
      stderr: null
    };
    var node_events_1 = require("node:events");
    var node_stream_1 = __importDefault2(require("node:stream"));
    var node_string_decoder_1 = require("node:string_decoder");
    var isStream = (s) => !!s && typeof s === "object" && (s instanceof Minipass || s instanceof node_stream_1.default || (0, exports2.isReadable)(s) || (0, exports2.isWritable)(s));
    exports2.isStream = isStream;
    var isReadable = (s) => !!s && typeof s === "object" && s instanceof node_events_1.EventEmitter && typeof s.pipe === "function" && // node core Writable streams have a pipe() method, but it throws
    s.pipe !== node_stream_1.default.Writable.prototype.pipe;
    exports2.isReadable = isReadable;
    var isWritable = (s) => !!s && typeof s === "object" && s instanceof node_events_1.EventEmitter && typeof s.write === "function" && typeof s.end === "function";
    exports2.isWritable = isWritable;
    var EOF = Symbol("EOF");
    var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
    var EMITTED_END = Symbol("emittedEnd");
    var EMITTING_END = Symbol("emittingEnd");
    var EMITTED_ERROR = Symbol("emittedError");
    var CLOSED = Symbol("closed");
    var READ = Symbol("read");
    var FLUSH = Symbol("flush");
    var FLUSHCHUNK = Symbol("flushChunk");
    var ENCODING = Symbol("encoding");
    var DECODER = Symbol("decoder");
    var FLOWING = Symbol("flowing");
    var PAUSED = Symbol("paused");
    var RESUME = Symbol("resume");
    var BUFFER = Symbol("buffer");
    var PIPES = Symbol("pipes");
    var BUFFERLENGTH = Symbol("bufferLength");
    var BUFFERPUSH = Symbol("bufferPush");
    var BUFFERSHIFT = Symbol("bufferShift");
    var OBJECTMODE = Symbol("objectMode");
    var DESTROYED = Symbol("destroyed");
    var ERROR = Symbol("error");
    var EMITDATA = Symbol("emitData");
    var EMITEND = Symbol("emitEnd");
    var EMITEND2 = Symbol("emitEnd2");
    var ASYNC = Symbol("async");
    var ABORT = Symbol("abort");
    var ABORTED = Symbol("aborted");
    var SIGNAL = Symbol("signal");
    var DATALISTENERS = Symbol("dataListeners");
    var DISCARDED = Symbol("discarded");
    var defer = (fn) => Promise.resolve().then(fn);
    var nodefer = (fn) => fn();
    var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
    var isArrayBufferLike = (b) => b instanceof ArrayBuffer || !!b && typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
    var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
    var Pipe = class {
      constructor(src, dest, opts) {
        __publicField(this, "src");
        __publicField(this, "dest");
        __publicField(this, "opts");
        __publicField(this, "ondrain");
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src[RESUME]();
        this.dest.on("drain", this.ondrain);
      }
      unpipe() {
        this.dest.removeListener("drain", this.ondrain);
      }
      // only here for the prototype
      /* c8 ignore start */
      proxyErrors(_er) {
      }
      /* c8 ignore stop */
      end() {
        this.unpipe();
        if (this.opts.end)
          this.dest.end();
      }
    };
    var PipeProxyErrors = class extends Pipe {
      unpipe() {
        this.src.removeListener("error", this.proxyErrors);
        super.unpipe();
      }
      constructor(src, dest, opts) {
        super(src, dest, opts);
        this.proxyErrors = (er) => dest.emit("error", er);
        src.on("error", this.proxyErrors);
      }
    };
    var isObjectModeOptions = (o) => !!o.objectMode;
    var isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== "buffer";
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;
    var Minipass = class extends node_events_1.EventEmitter {
      /**
       * If `RType` is Buffer, then options do not need to be provided.
       * Otherwise, an options object must be provided to specify either
       * {@link Minipass.SharedOptions.objectMode} or
       * {@link Minipass.SharedOptions.encoding}, as appropriate.
       */
      constructor(...args) {
        const options = args[0] || {};
        super();
        __publicField(this, _s, false);
        __publicField(this, _r, false);
        __publicField(this, _q, []);
        __publicField(this, _p, []);
        __publicField(this, _o);
        __publicField(this, _n);
        __publicField(this, _m);
        __publicField(this, _l);
        __publicField(this, _k, false);
        __publicField(this, _j, false);
        __publicField(this, _i, false);
        __publicField(this, _h, false);
        __publicField(this, _g, null);
        __publicField(this, _f, 0);
        __publicField(this, _e, false);
        __publicField(this, _d);
        __publicField(this, _c, false);
        __publicField(this, _b, 0);
        __publicField(this, _a, false);
        /**
         * true if the stream can be written
         */
        __publicField(this, "writable", true);
        /**
         * true if the stream can be read
         */
        __publicField(this, "readable", true);
        if (options.objectMode && typeof options.encoding === "string") {
          throw new TypeError("Encoding and objectMode may not be used together");
        }
        if (isObjectModeOptions(options)) {
          this[OBJECTMODE] = true;
          this[ENCODING] = null;
        } else if (isEncodingOptions(options)) {
          this[ENCODING] = options.encoding;
          this[OBJECTMODE] = false;
        } else {
          this[OBJECTMODE] = false;
          this[ENCODING] = null;
        }
        this[ASYNC] = !!options.async;
        this[DECODER] = this[ENCODING] ? new node_string_decoder_1.StringDecoder(this[ENCODING]) : null;
        if (options && options.debugExposeBuffer === true) {
          Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
        }
        if (options && options.debugExposePipes === true) {
          Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
        }
        const { signal } = options;
        if (signal) {
          this[SIGNAL] = signal;
          if (signal.aborted) {
            this[ABORT]();
          } else {
            signal.addEventListener("abort", () => this[ABORT]());
          }
        }
      }
      /**
       * The amount of data stored in the buffer waiting to be read.
       *
       * For Buffer strings, this will be the total byte length.
       * For string encoding streams, this will be the string character length,
       * according to JavaScript's `string.length` logic.
       * For objectMode streams, this is a count of the items waiting to be
       * emitted.
       */
      get bufferLength() {
        return this[BUFFERLENGTH];
      }
      /**
       * The `BufferEncoding` currently in use, or `null`
       */
      get encoding() {
        return this[ENCODING];
      }
      /**
       * @deprecated - This is a read only property
       */
      set encoding(_enc) {
        throw new Error("Encoding must be set at instantiation time");
      }
      /**
       * @deprecated - Encoding may only be set at instantiation time
       */
      setEncoding(_enc) {
        throw new Error("Encoding must be set at instantiation time");
      }
      /**
       * True if this is an objectMode stream
       */
      get objectMode() {
        return this[OBJECTMODE];
      }
      /**
       * @deprecated - This is a read-only property
       */
      set objectMode(_om) {
        throw new Error("objectMode must be set at instantiation time");
      }
      /**
       * true if this is an async stream
       */
      get ["async"]() {
        return this[ASYNC];
      }
      /**
       * Set to true to make this stream async.
       *
       * Once set, it cannot be unset, as this would potentially cause incorrect
       * behavior.  Ie, a sync stream can be made async, but an async stream
       * cannot be safely made sync.
       */
      set ["async"](a) {
        this[ASYNC] = this[ASYNC] || !!a;
      }
      // drop everything and get out of the flow completely
      [(_s = FLOWING, _r = PAUSED, _q = PIPES, _p = BUFFER, _o = OBJECTMODE, _n = ENCODING, _m = ASYNC, _l = DECODER, _k = EOF, _j = EMITTED_END, _i = EMITTING_END, _h = CLOSED, _g = EMITTED_ERROR, _f = BUFFERLENGTH, _e = DESTROYED, _d = SIGNAL, _c = ABORTED, _b = DATALISTENERS, _a = DISCARDED, ABORT)]() {
        this[ABORTED] = true;
        this.emit("abort", this[SIGNAL]?.reason);
        this.destroy(this[SIGNAL]?.reason);
      }
      /**
       * True if the stream has been aborted.
       */
      get aborted() {
        return this[ABORTED];
      }
      /**
       * No-op setter. Stream aborted status is set via the AbortSignal provided
       * in the constructor options.
       */
      set aborted(_) {
      }
      write(chunk, encoding, cb) {
        if (this[ABORTED])
          return false;
        if (this[EOF])
          throw new Error("write after end");
        if (this[DESTROYED]) {
          this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
          return true;
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = "utf8";
        }
        if (!encoding)
          encoding = "utf8";
        const fn = this[ASYNC] ? defer : nodefer;
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
          if (isArrayBufferView(chunk)) {
            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
          } else if (isArrayBufferLike(chunk)) {
            chunk = Buffer.from(chunk);
          } else if (typeof chunk !== "string") {
            throw new Error("Non-contiguous data written to non-objectMode stream");
          }
        }
        if (this[OBJECTMODE]) {
          if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
          if (this[FLOWING])
            this.emit("data", chunk);
          else
            this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this[FLOWING];
        }
        if (!chunk.length) {
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this[FLOWING];
        }
        if (typeof chunk === "string" && // unless it is a string already ready for us to use
        !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {
          chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING]) {
          chunk = this[DECODER].write(chunk);
        }
        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this[FLOWING])
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this[FLOWING];
      }
      /**
       * Low-level explicit read method.
       *
       * In objectMode, the argument is ignored, and one item is returned if
       * available.
       *
       * `n` is the number of bytes (or in the case of encoding streams,
       * characters) to consume. If `n` is not provided, then the entire buffer
       * is returned, or `null` is returned if no data is available.
       *
       * If `n` is greater that the amount of data in the internal buffer,
       * then `null` is returned.
       */
      read(n) {
        if (this[DESTROYED])
          return null;
        this[DISCARDED] = false;
        if (this[BUFFERLENGTH] === 0 || n === 0 || n && n > this[BUFFERLENGTH]) {
          this[MAYBE_EMIT_END]();
          return null;
        }
        if (this[OBJECTMODE])
          n = null;
        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
          this[BUFFER] = [
            this[ENCODING] ? this[BUFFER].join("") : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])
          ];
        }
        const ret = this[READ](n || null, this[BUFFER][0]);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [READ](n, chunk) {
        if (this[OBJECTMODE])
          this[BUFFERSHIFT]();
        else {
          const c = chunk;
          if (n === c.length || n === null)
            this[BUFFERSHIFT]();
          else if (typeof c === "string") {
            this[BUFFER][0] = c.slice(n);
            chunk = c.slice(0, n);
            this[BUFFERLENGTH] -= n;
          } else {
            this[BUFFER][0] = c.subarray(n);
            chunk = c.subarray(0, n);
            this[BUFFERLENGTH] -= n;
          }
        }
        this.emit("data", chunk);
        if (!this[BUFFER].length && !this[EOF])
          this.emit("drain");
        return chunk;
      }
      end(chunk, encoding, cb) {
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = void 0;
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = "utf8";
        }
        if (chunk !== void 0)
          this.write(chunk, encoding);
        if (cb)
          this.once("end", cb);
        this[EOF] = true;
        this.writable = false;
        if (this[FLOWING] || !this[PAUSED])
          this[MAYBE_EMIT_END]();
        return this;
      }
      // don't let the internal resume be overwritten
      [RESUME]() {
        if (this[DESTROYED])
          return;
        if (!this[DATALISTENERS] && !this[PIPES].length) {
          this[DISCARDED] = true;
        }
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit("resume");
        if (this[BUFFER].length)
          this[FLUSH]();
        else if (this[EOF])
          this[MAYBE_EMIT_END]();
        else
          this.emit("drain");
      }
      /**
       * Resume the stream if it is currently in a paused state
       *
       * If called when there are no pipe destinations or `data` event listeners,
       * this will place the stream in a "discarded" state, where all data will
       * be thrown away. The discarded state is removed if a pipe destination or
       * data handler is added, if pause() is called, or if any synchronous or
       * asynchronous iteration is started.
       */
      resume() {
        return this[RESUME]();
      }
      /**
       * Pause the stream
       */
      pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
        this[DISCARDED] = false;
      }
      /**
       * true if the stream has been forcibly destroyed
       */
      get destroyed() {
        return this[DESTROYED];
      }
      /**
       * true if the stream is currently in a flowing state, meaning that
       * any writes will be immediately emitted.
       */
      get flowing() {
        return this[FLOWING];
      }
      /**
       * true if the stream is currently in a paused state
       */
      get paused() {
        return this[PAUSED];
      }
      [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] += 1;
        else
          this[BUFFERLENGTH] += chunk.length;
        this[BUFFER].push(chunk);
      }
      [BUFFERSHIFT]() {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] -= 1;
        else
          this[BUFFERLENGTH] -= this[BUFFER][0].length;
        return this[BUFFER].shift();
      }
      [FLUSH](noDrain = false) {
        do {
        } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
        if (!noDrain && !this[BUFFER].length && !this[EOF])
          this.emit("drain");
      }
      [FLUSHCHUNK](chunk) {
        this.emit("data", chunk);
        return this[FLOWING];
      }
      /**
       * Pipe all data emitted by this stream into the destination provided.
       *
       * Triggers the flow of data.
       */
      pipe(dest, opts) {
        if (this[DESTROYED])
          return dest;
        this[DISCARDED] = false;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr)
          opts.end = false;
        else
          opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        if (ended) {
          if (opts.end)
            dest.end();
        } else {
          this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
          if (this[ASYNC])
            defer(() => this[RESUME]());
          else
            this[RESUME]();
        }
        return dest;
      }
      /**
       * Fully unhook a piped destination stream.
       *
       * If the destination stream was the only consumer of this stream (ie,
       * there are no other piped destinations or `'data'` event listeners)
       * then the flow of data will stop until there is another consumer or
       * {@link Minipass#resume} is explicitly called.
       */
      unpipe(dest) {
        const p = this[PIPES].find((p2) => p2.dest === dest);
        if (p) {
          if (this[PIPES].length === 1) {
            if (this[FLOWING] && this[DATALISTENERS] === 0) {
              this[FLOWING] = false;
            }
            this[PIPES] = [];
          } else
            this[PIPES].splice(this[PIPES].indexOf(p), 1);
          p.unpipe();
        }
      }
      /**
       * Alias for {@link Minipass#on}
       */
      addListener(ev, handler2) {
        return this.on(ev, handler2);
      }
      /**
       * Mostly identical to `EventEmitter.on`, with the following
       * behavior differences to prevent data loss and unnecessary hangs:
       *
       * - Adding a 'data' event handler will trigger the flow of data
       *
       * - Adding a 'readable' event handler when there is data waiting to be read
       *   will cause 'readable' to be emitted immediately.
       *
       * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
       *   already passed will cause the event to be emitted immediately and all
       *   handlers removed.
       *
       * - Adding an 'error' event handler after an error has been emitted will
       *   cause the event to be re-emitted immediately with the error previously
       *   raised.
       */
      on(ev, handler2) {
        const ret = super.on(ev, handler2);
        if (ev === "data") {
          this[DISCARDED] = false;
          this[DATALISTENERS]++;
          if (!this[PIPES].length && !this[FLOWING]) {
            this[RESUME]();
          }
        } else if (ev === "readable" && this[BUFFERLENGTH] !== 0) {
          super.emit("readable");
        } else if (isEndish(ev) && this[EMITTED_END]) {
          super.emit(ev);
          this.removeAllListeners(ev);
        } else if (ev === "error" && this[EMITTED_ERROR]) {
          const h = handler2;
          if (this[ASYNC])
            defer(() => h.call(this, this[EMITTED_ERROR]));
          else
            h.call(this, this[EMITTED_ERROR]);
        }
        return ret;
      }
      /**
       * Alias for {@link Minipass#off}
       */
      removeListener(ev, handler2) {
        return this.off(ev, handler2);
      }
      /**
       * Mostly identical to `EventEmitter.off`
       *
       * If a 'data' event handler is removed, and it was the last consumer
       * (ie, there are no pipe destinations or other 'data' event listeners),
       * then the flow of data will stop until there is another consumer or
       * {@link Minipass#resume} is explicitly called.
       */
      off(ev, handler2) {
        const ret = super.off(ev, handler2);
        if (ev === "data") {
          this[DATALISTENERS] = this.listeners("data").length;
          if (this[DATALISTENERS] === 0 && !this[DISCARDED] && !this[PIPES].length) {
            this[FLOWING] = false;
          }
        }
        return ret;
      }
      /**
       * Mostly identical to `EventEmitter.removeAllListeners`
       *
       * If all 'data' event handlers are removed, and they were the last consumer
       * (ie, there are no pipe destinations), then the flow of data will stop
       * until there is another consumer or {@link Minipass#resume} is explicitly
       * called.
       */
      removeAllListeners(ev) {
        const ret = super.removeAllListeners(ev);
        if (ev === "data" || ev === void 0) {
          this[DATALISTENERS] = 0;
          if (!this[DISCARDED] && !this[PIPES].length) {
            this[FLOWING] = false;
          }
        }
        return ret;
      }
      /**
       * true if the 'end' event has been emitted
       */
      get emittedEnd() {
        return this[EMITTED_END];
      }
      [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
          this[EMITTING_END] = true;
          this.emit("end");
          this.emit("prefinish");
          this.emit("finish");
          if (this[CLOSED])
            this.emit("close");
          this[EMITTING_END] = false;
        }
      }
      /**
       * Mostly identical to `EventEmitter.emit`, with the following
       * behavior differences to prevent data loss and unnecessary hangs:
       *
       * If the stream has been destroyed, and the event is something other
       * than 'close' or 'error', then `false` is returned and no handlers
       * are called.
       *
       * If the event is 'end', and has already been emitted, then the event
       * is ignored. If the stream is in a paused or non-flowing state, then
       * the event will be deferred until data flow resumes. If the stream is
       * async, then handlers will be called on the next tick rather than
       * immediately.
       *
       * If the event is 'close', and 'end' has not yet been emitted, then
       * the event will be deferred until after 'end' is emitted.
       *
       * If the event is 'error', and an AbortSignal was provided for the stream,
       * and there are no listeners, then the event is ignored, matching the
       * behavior of node core streams in the presense of an AbortSignal.
       *
       * If the event is 'finish' or 'prefinish', then all listeners will be
       * removed after emitting the event, to prevent double-firing.
       */
      emit(ev, ...args) {
        const data = args[0];
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED]) {
          return false;
        } else if (ev === "data") {
          return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? (defer(() => this[EMITDATA](data)), true) : this[EMITDATA](data);
        } else if (ev === "end") {
          return this[EMITEND]();
        } else if (ev === "close") {
          this[CLOSED] = true;
          if (!this[EMITTED_END] && !this[DESTROYED])
            return false;
          const ret2 = super.emit("close");
          this.removeAllListeners("close");
          return ret2;
        } else if (ev === "error") {
          this[EMITTED_ERROR] = data;
          super.emit(ERROR, data);
          const ret2 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : false;
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "resume") {
          const ret2 = super.emit("resume");
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "finish" || ev === "prefinish") {
          const ret2 = super.emit(ev);
          this.removeAllListeners(ev);
          return ret2;
        }
        const ret = super.emit(ev, ...args);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITDATA](data) {
        for (const p of this[PIPES]) {
          if (p.dest.write(data) === false)
            this.pause();
        }
        const ret = this[DISCARDED] ? false : super.emit("data", data);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITEND]() {
        if (this[EMITTED_END])
          return false;
        this[EMITTED_END] = true;
        this.readable = false;
        return this[ASYNC] ? (defer(() => this[EMITEND2]()), true) : this[EMITEND2]();
      }
      [EMITEND2]() {
        if (this[DECODER]) {
          const data = this[DECODER].end();
          if (data) {
            for (const p of this[PIPES]) {
              p.dest.write(data);
            }
            if (!this[DISCARDED])
              super.emit("data", data);
          }
        }
        for (const p of this[PIPES]) {
          p.end();
        }
        const ret = super.emit("end");
        this.removeAllListeners("end");
        return ret;
      }
      /**
       * Return a Promise that resolves to an array of all emitted data once
       * the stream ends.
       */
      async collect() {
        const buf = Object.assign([], {
          dataLength: 0
        });
        if (!this[OBJECTMODE])
          buf.dataLength = 0;
        const p = this.promise();
        this.on("data", (c) => {
          buf.push(c);
          if (!this[OBJECTMODE])
            buf.dataLength += c.length;
        });
        await p;
        return buf;
      }
      /**
       * Return a Promise that resolves to the concatenation of all emitted data
       * once the stream ends.
       *
       * Not allowed on objectMode streams.
       */
      async concat() {
        if (this[OBJECTMODE]) {
          throw new Error("cannot concat in objectMode");
        }
        const buf = await this.collect();
        return this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
      }
      /**
       * Return a void Promise that resolves once the stream ends.
       */
      async promise() {
        return new Promise((resolve, reject) => {
          this.on(DESTROYED, () => reject(new Error("stream destroyed")));
          this.on("error", (er) => reject(er));
          this.on("end", () => resolve());
        });
      }
      /**
       * Asynchronous `for await of` iteration.
       *
       * This will continue emitting all chunks until the stream terminates.
       */
      [Symbol.asyncIterator]() {
        this[DISCARDED] = false;
        let stopped = false;
        const stop = async () => {
          this.pause();
          stopped = true;
          return { value: void 0, done: true };
        };
        const next = () => {
          if (stopped)
            return stop();
          const res = this.read();
          if (res !== null)
            return Promise.resolve({ done: false, value: res });
          if (this[EOF])
            return stop();
          let resolve;
          let reject;
          const onerr = (er) => {
            this.off("data", ondata);
            this.off("end", onend);
            this.off(DESTROYED, ondestroy);
            stop();
            reject(er);
          };
          const ondata = (value) => {
            this.off("error", onerr);
            this.off("end", onend);
            this.off(DESTROYED, ondestroy);
            this.pause();
            resolve({ value, done: !!this[EOF] });
          };
          const onend = () => {
            this.off("error", onerr);
            this.off("data", ondata);
            this.off(DESTROYED, ondestroy);
            stop();
            resolve({ done: true, value: void 0 });
          };
          const ondestroy = () => onerr(new Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej;
            resolve = res2;
            this.once(DESTROYED, ondestroy);
            this.once("error", onerr);
            this.once("end", onend);
            this.once("data", ondata);
          });
        };
        return {
          next,
          throw: stop,
          return: stop,
          [Symbol.asyncIterator]() {
            return this;
          }
        };
      }
      /**
       * Synchronous `for of` iteration.
       *
       * The iteration will terminate when the internal buffer runs out, even
       * if the stream has not yet terminated.
       */
      [Symbol.iterator]() {
        this[DISCARDED] = false;
        let stopped = false;
        const stop = () => {
          this.pause();
          this.off(ERROR, stop);
          this.off(DESTROYED, stop);
          this.off("end", stop);
          stopped = true;
          return { done: true, value: void 0 };
        };
        const next = () => {
          if (stopped)
            return stop();
          const value = this.read();
          return value === null ? stop() : { done: false, value };
        };
        this.once("end", stop);
        this.once(ERROR, stop);
        this.once(DESTROYED, stop);
        return {
          next,
          throw: stop,
          return: stop,
          [Symbol.iterator]() {
            return this;
          }
        };
      }
      /**
       * Destroy a stream, preventing it from being used for any further purpose.
       *
       * If the stream has a `close()` method, then it will be called on
       * destruction.
       *
       * After destruction, any attempt to write data, read data, or emit most
       * events will be ignored.
       *
       * If an error argument is provided, then it will be emitted in an
       * 'error' event.
       */
      destroy(er) {
        if (this[DESTROYED]) {
          if (er)
            this.emit("error", er);
          else
            this.emit(DESTROYED);
          return this;
        }
        this[DESTROYED] = true;
        this[DISCARDED] = true;
        this[BUFFER].length = 0;
        this[BUFFERLENGTH] = 0;
        const wc = this;
        if (typeof wc.close === "function" && !this[CLOSED])
          wc.close();
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      /**
       * Alias for {@link isStream}
       *
       * Former export location, maintained for backwards compatibility.
       *
       * @deprecated
       */
      static get isStream() {
        return exports2.isStream;
      }
    };
    exports2.Minipass = Minipass;
  }
});

// node_modules/typeorm/node_modules/path-scurry/dist/commonjs/index.js
var require_commonjs4 = __commonJS({
  "node_modules/typeorm/node_modules/path-scurry/dist/commonjs/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PathScurry = exports2.Path = exports2.PathScurryDarwin = exports2.PathScurryPosix = exports2.PathScurryWin32 = exports2.PathScurryBase = exports2.PathPosix = exports2.PathWin32 = exports2.PathBase = exports2.ChildrenCache = exports2.ResolveCache = void 0;
    var lru_cache_1 = require_commonjs2();
    var node_path_1 = require("node:path");
    var node_url_1 = require("node:url");
    var fs_1 = require("fs");
    var actualFS = __importStar2(require("node:fs"));
    var realpathSync = fs_1.realpathSync.native;
    var promises_1 = require("node:fs/promises");
    var minipass_1 = require_commonjs3();
    var defaultFS = {
      lstatSync: fs_1.lstatSync,
      readdir: fs_1.readdir,
      readdirSync: fs_1.readdirSync,
      readlinkSync: fs_1.readlinkSync,
      realpathSync,
      promises: {
        lstat: promises_1.lstat,
        readdir: promises_1.readdir,
        readlink: promises_1.readlink,
        realpath: promises_1.realpath
      }
    };
    var fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS ? defaultFS : {
      ...defaultFS,
      ...fsOption,
      promises: {
        ...defaultFS.promises,
        ...fsOption.promises || {}
      }
    };
    var uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i;
    var uncToDrive = (rootPath) => rootPath.replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
    var eitherSep = /[\\\/]/;
    var UNKNOWN = 0;
    var IFIFO = 1;
    var IFCHR = 2;
    var IFDIR = 4;
    var IFBLK = 6;
    var IFREG = 8;
    var IFLNK = 10;
    var IFSOCK = 12;
    var IFMT = 15;
    var IFMT_UNKNOWN = ~IFMT;
    var READDIR_CALLED = 16;
    var LSTAT_CALLED = 32;
    var ENOTDIR = 64;
    var ENOENT = 128;
    var ENOREADLINK = 256;
    var ENOREALPATH = 512;
    var ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;
    var TYPEMASK = 1023;
    var entToType = (s) => s.isFile() ? IFREG : s.isDirectory() ? IFDIR : s.isSymbolicLink() ? IFLNK : s.isCharacterDevice() ? IFCHR : s.isBlockDevice() ? IFBLK : s.isSocket() ? IFSOCK : s.isFIFO() ? IFIFO : UNKNOWN;
    var normalizeCache = /* @__PURE__ */ new Map();
    var normalize = (s) => {
      const c = normalizeCache.get(s);
      if (c)
        return c;
      const n = s.normalize("NFKD");
      normalizeCache.set(s, n);
      return n;
    };
    var normalizeNocaseCache = /* @__PURE__ */ new Map();
    var normalizeNocase = (s) => {
      const c = normalizeNocaseCache.get(s);
      if (c)
        return c;
      const n = normalize(s.toLowerCase());
      normalizeNocaseCache.set(s, n);
      return n;
    };
    var ResolveCache = class extends lru_cache_1.LRUCache {
      constructor() {
        super({ max: 256 });
      }
    };
    exports2.ResolveCache = ResolveCache;
    var ChildrenCache = class extends lru_cache_1.LRUCache {
      constructor(maxSize = 16 * 1024) {
        super({
          maxSize,
          // parent + children
          sizeCalculation: (a) => a.length + 1
        });
      }
    };
    exports2.ChildrenCache = ChildrenCache;
    var setAsCwd = Symbol("PathScurry setAsCwd");
    var _fs, _dev, _mode, _nlink, _uid, _gid, _rdev, _blksize, _ino, _size, _blocks, _atimeMs, _mtimeMs, _ctimeMs, _birthtimeMs, _atime, _mtime, _ctime, _birthtime, _matchName, _depth, _fullpath, _fullpathPosix, _relative, _relativePosix, _type, _children, _linkTarget, _realpath, _PathBase_instances, resolveParts_fn, readdirSuccess_fn, markENOENT_fn, markChildrenENOENT_fn, markENOREALPATH_fn, markENOTDIR_fn, readdirFail_fn, lstatFail_fn, readlinkFail_fn, readdirAddChild_fn, readdirAddNewChild_fn, readdirMaybePromoteChild_fn, readdirPromoteChild_fn, applyStat_fn, _onReaddirCB, _readdirCBInFlight, callOnReaddirCB_fn, _asyncReaddirInFlight;
    var PathBase = class {
      /**
       * Do not create new Path objects directly.  They should always be accessed
       * via the PathScurry class or other methods on the Path class.
       *
       * @internal
       */
      constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
        __privateAdd(this, _PathBase_instances);
        /**
         * the basename of this path
         *
         * **Important**: *always* test the path name against any test string
         * usingthe {@link isNamed} method, and not by directly comparing this
         * string. Otherwise, unicode path strings that the system sees as identical
         * will not be properly treated as the same path, leading to incorrect
         * behavior and possible security issues.
         */
        __publicField(this, "name");
        /**
         * the Path entry corresponding to the path root.
         *
         * @internal
         */
        __publicField(this, "root");
        /**
         * All roots found within the current PathScurry family
         *
         * @internal
         */
        __publicField(this, "roots");
        /**
         * a reference to the parent path, or undefined in the case of root entries
         *
         * @internal
         */
        __publicField(this, "parent");
        /**
         * boolean indicating whether paths are compared case-insensitively
         * @internal
         */
        __publicField(this, "nocase");
        /**
         * boolean indicating that this path is the current working directory
         * of the PathScurry collection that contains it.
         */
        __publicField(this, "isCWD", false);
        // potential default fs override
        __privateAdd(this, _fs);
        // Stats fields
        __privateAdd(this, _dev);
        __privateAdd(this, _mode);
        __privateAdd(this, _nlink);
        __privateAdd(this, _uid);
        __privateAdd(this, _gid);
        __privateAdd(this, _rdev);
        __privateAdd(this, _blksize);
        __privateAdd(this, _ino);
        __privateAdd(this, _size);
        __privateAdd(this, _blocks);
        __privateAdd(this, _atimeMs);
        __privateAdd(this, _mtimeMs);
        __privateAdd(this, _ctimeMs);
        __privateAdd(this, _birthtimeMs);
        __privateAdd(this, _atime);
        __privateAdd(this, _mtime);
        __privateAdd(this, _ctime);
        __privateAdd(this, _birthtime);
        __privateAdd(this, _matchName);
        __privateAdd(this, _depth);
        __privateAdd(this, _fullpath);
        __privateAdd(this, _fullpathPosix);
        __privateAdd(this, _relative);
        __privateAdd(this, _relativePosix);
        __privateAdd(this, _type);
        __privateAdd(this, _children);
        __privateAdd(this, _linkTarget);
        __privateAdd(this, _realpath);
        __privateAdd(this, _onReaddirCB, []);
        __privateAdd(this, _readdirCBInFlight, false);
        __privateAdd(this, _asyncReaddirInFlight);
        this.name = name;
        __privateSet(this, _matchName, nocase ? normalizeNocase(name) : normalize(name));
        __privateSet(this, _type, type & TYPEMASK);
        this.nocase = nocase;
        this.roots = roots;
        this.root = root || this;
        __privateSet(this, _children, children);
        __privateSet(this, _fullpath, opts.fullpath);
        __privateSet(this, _relative, opts.relative);
        __privateSet(this, _relativePosix, opts.relativePosix);
        this.parent = opts.parent;
        if (this.parent) {
          __privateSet(this, _fs, __privateGet(this.parent, _fs));
        } else {
          __privateSet(this, _fs, fsFromOption(opts.fs));
        }
      }
      get dev() {
        return __privateGet(this, _dev);
      }
      get mode() {
        return __privateGet(this, _mode);
      }
      get nlink() {
        return __privateGet(this, _nlink);
      }
      get uid() {
        return __privateGet(this, _uid);
      }
      get gid() {
        return __privateGet(this, _gid);
      }
      get rdev() {
        return __privateGet(this, _rdev);
      }
      get blksize() {
        return __privateGet(this, _blksize);
      }
      get ino() {
        return __privateGet(this, _ino);
      }
      get size() {
        return __privateGet(this, _size);
      }
      get blocks() {
        return __privateGet(this, _blocks);
      }
      get atimeMs() {
        return __privateGet(this, _atimeMs);
      }
      get mtimeMs() {
        return __privateGet(this, _mtimeMs);
      }
      get ctimeMs() {
        return __privateGet(this, _ctimeMs);
      }
      get birthtimeMs() {
        return __privateGet(this, _birthtimeMs);
      }
      get atime() {
        return __privateGet(this, _atime);
      }
      get mtime() {
        return __privateGet(this, _mtime);
      }
      get ctime() {
        return __privateGet(this, _ctime);
      }
      get birthtime() {
        return __privateGet(this, _birthtime);
      }
      /**
       * This property is for compatibility with the Dirent class as of
       * Node v20, where Dirent['parentPath'] refers to the path of the
       * directory that was passed to readdir. For root entries, it's the path
       * to the entry itself.
       */
      get parentPath() {
        return (this.parent || this).fullpath();
      }
      /**
       * Deprecated alias for Dirent['parentPath'] Somewhat counterintuitively,
       * this property refers to the *parent* path, not the path object itself.
       */
      get path() {
        return this.parentPath;
      }
      /**
       * Returns the depth of the Path object from its root.
       *
       * For example, a path at `/foo/bar` would have a depth of 2.
       */
      depth() {
        if (__privateGet(this, _depth) !== void 0)
          return __privateGet(this, _depth);
        if (!this.parent)
          return __privateSet(this, _depth, 0);
        return __privateSet(this, _depth, this.parent.depth() + 1);
      }
      /**
       * @internal
       */
      childrenCache() {
        return __privateGet(this, _children);
      }
      /**
       * Get the Path object referenced by the string path, resolved from this Path
       */
      resolve(path) {
        var _a;
        if (!path) {
          return this;
        }
        const rootPath = this.getRootString(path);
        const dir = path.substring(rootPath.length);
        const dirParts = dir.split(this.splitSep);
        const result = rootPath ? __privateMethod(_a = this.getRoot(rootPath), _PathBase_instances, resolveParts_fn).call(_a, dirParts) : __privateMethod(this, _PathBase_instances, resolveParts_fn).call(this, dirParts);
        return result;
      }
      /**
       * Returns the cached children Path objects, if still available.  If they
       * have fallen out of the cache, then returns an empty array, and resets the
       * READDIR_CALLED bit, so that future calls to readdir() will require an fs
       * lookup.
       *
       * @internal
       */
      children() {
        const cached = __privateGet(this, _children).get(this);
        if (cached) {
          return cached;
        }
        const children = Object.assign([], { provisional: 0 });
        __privateGet(this, _children).set(this, children);
        __privateSet(this, _type, __privateGet(this, _type) & ~READDIR_CALLED);
        return children;
      }
      /**
       * Resolves a path portion and returns or creates the child Path.
       *
       * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
       * `'..'`.
       *
       * This should not be called directly.  If `pathPart` contains any path
       * separators, it will lead to unsafe undefined behavior.
       *
       * Use `Path.resolve()` instead.
       *
       * @internal
       */
      child(pathPart, opts) {
        if (pathPart === "" || pathPart === ".") {
          return this;
        }
        if (pathPart === "..") {
          return this.parent || this;
        }
        const children = this.children();
        const name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);
        for (const p of children) {
          if (__privateGet(p, _matchName) === name) {
            return p;
          }
        }
        const s = this.parent ? this.sep : "";
        const fullpath = __privateGet(this, _fullpath) ? __privateGet(this, _fullpath) + s + pathPart : void 0;
        const pchild = this.newChild(pathPart, UNKNOWN, {
          ...opts,
          parent: this,
          fullpath
        });
        if (!this.canReaddir()) {
          __privateSet(pchild, _type, __privateGet(pchild, _type) | ENOENT);
        }
        children.push(pchild);
        return pchild;
      }
      /**
       * The relative path from the cwd. If it does not share an ancestor with
       * the cwd, then this ends up being equivalent to the fullpath()
       */
      relative() {
        if (this.isCWD)
          return "";
        if (__privateGet(this, _relative) !== void 0) {
          return __privateGet(this, _relative);
        }
        const name = this.name;
        const p = this.parent;
        if (!p) {
          return __privateSet(this, _relative, this.name);
        }
        const pv = p.relative();
        return pv + (!pv || !p.parent ? "" : this.sep) + name;
      }
      /**
       * The relative path from the cwd, using / as the path separator.
       * If it does not share an ancestor with
       * the cwd, then this ends up being equivalent to the fullpathPosix()
       * On posix systems, this is identical to relative().
       */
      relativePosix() {
        if (this.sep === "/")
          return this.relative();
        if (this.isCWD)
          return "";
        if (__privateGet(this, _relativePosix) !== void 0)
          return __privateGet(this, _relativePosix);
        const name = this.name;
        const p = this.parent;
        if (!p) {
          return __privateSet(this, _relativePosix, this.fullpathPosix());
        }
        const pv = p.relativePosix();
        return pv + (!pv || !p.parent ? "" : "/") + name;
      }
      /**
       * The fully resolved path string for this Path entry
       */
      fullpath() {
        if (__privateGet(this, _fullpath) !== void 0) {
          return __privateGet(this, _fullpath);
        }
        const name = this.name;
        const p = this.parent;
        if (!p) {
          return __privateSet(this, _fullpath, this.name);
        }
        const pv = p.fullpath();
        const fp = pv + (!p.parent ? "" : this.sep) + name;
        return __privateSet(this, _fullpath, fp);
      }
      /**
       * On platforms other than windows, this is identical to fullpath.
       *
       * On windows, this is overridden to return the forward-slash form of the
       * full UNC path.
       */
      fullpathPosix() {
        if (__privateGet(this, _fullpathPosix) !== void 0)
          return __privateGet(this, _fullpathPosix);
        if (this.sep === "/")
          return __privateSet(this, _fullpathPosix, this.fullpath());
        if (!this.parent) {
          const p2 = this.fullpath().replace(/\\/g, "/");
          if (/^[a-z]:\//i.test(p2)) {
            return __privateSet(this, _fullpathPosix, `//?/${p2}`);
          } else {
            return __privateSet(this, _fullpathPosix, p2);
          }
        }
        const p = this.parent;
        const pfpp = p.fullpathPosix();
        const fpp = pfpp + (!pfpp || !p.parent ? "" : "/") + this.name;
        return __privateSet(this, _fullpathPosix, fpp);
      }
      /**
       * Is the Path of an unknown type?
       *
       * Note that we might know *something* about it if there has been a previous
       * filesystem operation, for example that it does not exist, or is not a
       * link, or whether it has child entries.
       */
      isUnknown() {
        return (__privateGet(this, _type) & IFMT) === UNKNOWN;
      }
      isType(type) {
        return this[`is${type}`]();
      }
      getType() {
        return this.isUnknown() ? "Unknown" : this.isDirectory() ? "Directory" : this.isFile() ? "File" : this.isSymbolicLink() ? "SymbolicLink" : this.isFIFO() ? "FIFO" : this.isCharacterDevice() ? "CharacterDevice" : this.isBlockDevice() ? "BlockDevice" : (
          /* c8 ignore start */
          this.isSocket() ? "Socket" : "Unknown"
        );
      }
      /**
       * Is the Path a regular file?
       */
      isFile() {
        return (__privateGet(this, _type) & IFMT) === IFREG;
      }
      /**
       * Is the Path a directory?
       */
      isDirectory() {
        return (__privateGet(this, _type) & IFMT) === IFDIR;
      }
      /**
       * Is the path a character device?
       */
      isCharacterDevice() {
        return (__privateGet(this, _type) & IFMT) === IFCHR;
      }
      /**
       * Is the path a block device?
       */
      isBlockDevice() {
        return (__privateGet(this, _type) & IFMT) === IFBLK;
      }
      /**
       * Is the path a FIFO pipe?
       */
      isFIFO() {
        return (__privateGet(this, _type) & IFMT) === IFIFO;
      }
      /**
       * Is the path a socket?
       */
      isSocket() {
        return (__privateGet(this, _type) & IFMT) === IFSOCK;
      }
      /**
       * Is the path a symbolic link?
       */
      isSymbolicLink() {
        return (__privateGet(this, _type) & IFLNK) === IFLNK;
      }
      /**
       * Return the entry if it has been subject of a successful lstat, or
       * undefined otherwise.
       *
       * Does not read the filesystem, so an undefined result *could* simply
       * mean that we haven't called lstat on it.
       */
      lstatCached() {
        return __privateGet(this, _type) & LSTAT_CALLED ? this : void 0;
      }
      /**
       * Return the cached link target if the entry has been the subject of a
       * successful readlink, or undefined otherwise.
       *
       * Does not read the filesystem, so an undefined result *could* just mean we
       * don't have any cached data. Only use it if you are very sure that a
       * readlink() has been called at some point.
       */
      readlinkCached() {
        return __privateGet(this, _linkTarget);
      }
      /**
       * Returns the cached realpath target if the entry has been the subject
       * of a successful realpath, or undefined otherwise.
       *
       * Does not read the filesystem, so an undefined result *could* just mean we
       * don't have any cached data. Only use it if you are very sure that a
       * realpath() has been called at some point.
       */
      realpathCached() {
        return __privateGet(this, _realpath);
      }
      /**
       * Returns the cached child Path entries array if the entry has been the
       * subject of a successful readdir(), or [] otherwise.
       *
       * Does not read the filesystem, so an empty array *could* just mean we
       * don't have any cached data. Only use it if you are very sure that a
       * readdir() has been called recently enough to still be valid.
       */
      readdirCached() {
        const children = this.children();
        return children.slice(0, children.provisional);
      }
      /**
       * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
       * any indication that readlink will definitely fail.
       *
       * Returns false if the path is known to not be a symlink, if a previous
       * readlink failed, or if the entry does not exist.
       */
      canReadlink() {
        if (__privateGet(this, _linkTarget))
          return true;
        if (!this.parent)
          return false;
        const ifmt = __privateGet(this, _type) & IFMT;
        return !(ifmt !== UNKNOWN && ifmt !== IFLNK || __privateGet(this, _type) & ENOREADLINK || __privateGet(this, _type) & ENOENT);
      }
      /**
       * Return true if readdir has previously been successfully called on this
       * path, indicating that cachedReaddir() is likely valid.
       */
      calledReaddir() {
        return !!(__privateGet(this, _type) & READDIR_CALLED);
      }
      /**
       * Returns true if the path is known to not exist. That is, a previous lstat
       * or readdir failed to verify its existence when that would have been
       * expected, or a parent entry was marked either enoent or enotdir.
       */
      isENOENT() {
        return !!(__privateGet(this, _type) & ENOENT);
      }
      /**
       * Return true if the path is a match for the given path name.  This handles
       * case sensitivity and unicode normalization.
       *
       * Note: even on case-sensitive systems, it is **not** safe to test the
       * equality of the `.name` property to determine whether a given pathname
       * matches, due to unicode normalization mismatches.
       *
       * Always use this method instead of testing the `path.name` property
       * directly.
       */
      isNamed(n) {
        return !this.nocase ? __privateGet(this, _matchName) === normalize(n) : __privateGet(this, _matchName) === normalizeNocase(n);
      }
      /**
       * Return the Path object corresponding to the target of a symbolic link.
       *
       * If the Path is not a symbolic link, or if the readlink call fails for any
       * reason, `undefined` is returned.
       *
       * Result is cached, and thus may be outdated if the filesystem is mutated.
       */
      async readlink() {
        const target = __privateGet(this, _linkTarget);
        if (target) {
          return target;
        }
        if (!this.canReadlink()) {
          return void 0;
        }
        if (!this.parent) {
          return void 0;
        }
        try {
          const read = await __privateGet(this, _fs).promises.readlink(this.fullpath());
          const linkTarget = (await this.parent.realpath())?.resolve(read);
          if (linkTarget) {
            return __privateSet(this, _linkTarget, linkTarget);
          }
        } catch (er) {
          __privateMethod(this, _PathBase_instances, readlinkFail_fn).call(this, er.code);
          return void 0;
        }
      }
      /**
       * Synchronous {@link PathBase.readlink}
       */
      readlinkSync() {
        const target = __privateGet(this, _linkTarget);
        if (target) {
          return target;
        }
        if (!this.canReadlink()) {
          return void 0;
        }
        if (!this.parent) {
          return void 0;
        }
        try {
          const read = __privateGet(this, _fs).readlinkSync(this.fullpath());
          const linkTarget = this.parent.realpathSync()?.resolve(read);
          if (linkTarget) {
            return __privateSet(this, _linkTarget, linkTarget);
          }
        } catch (er) {
          __privateMethod(this, _PathBase_instances, readlinkFail_fn).call(this, er.code);
          return void 0;
        }
      }
      /**
       * Call lstat() on this Path, and update all known information that can be
       * determined.
       *
       * Note that unlike `fs.lstat()`, the returned value does not contain some
       * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
       * information is required, you will need to call `fs.lstat` yourself.
       *
       * If the Path refers to a nonexistent file, or if the lstat call fails for
       * any reason, `undefined` is returned.  Otherwise the updated Path object is
       * returned.
       *
       * Results are cached, and thus may be out of date if the filesystem is
       * mutated.
       */
      async lstat() {
        if ((__privateGet(this, _type) & ENOENT) === 0) {
          try {
            __privateMethod(this, _PathBase_instances, applyStat_fn).call(this, await __privateGet(this, _fs).promises.lstat(this.fullpath()));
            return this;
          } catch (er) {
            __privateMethod(this, _PathBase_instances, lstatFail_fn).call(this, er.code);
          }
        }
      }
      /**
       * synchronous {@link PathBase.lstat}
       */
      lstatSync() {
        if ((__privateGet(this, _type) & ENOENT) === 0) {
          try {
            __privateMethod(this, _PathBase_instances, applyStat_fn).call(this, __privateGet(this, _fs).lstatSync(this.fullpath()));
            return this;
          } catch (er) {
            __privateMethod(this, _PathBase_instances, lstatFail_fn).call(this, er.code);
          }
        }
      }
      /**
       * Standard node-style callback interface to get list of directory entries.
       *
       * If the Path cannot or does not contain any children, then an empty array
       * is returned.
       *
       * Results are cached, and thus may be out of date if the filesystem is
       * mutated.
       *
       * @param cb The callback called with (er, entries).  Note that the `er`
       * param is somewhat extraneous, as all readdir() errors are handled and
       * simply result in an empty set of entries being returned.
       * @param allowZalgo Boolean indicating that immediately known results should
       * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
       * zalgo at your peril, the dark pony lord is devious and unforgiving.
       */
      readdirCB(cb, allowZalgo = false) {
        if (!this.canReaddir()) {
          if (allowZalgo)
            cb(null, []);
          else
            queueMicrotask(() => cb(null, []));
          return;
        }
        const children = this.children();
        if (this.calledReaddir()) {
          const c = children.slice(0, children.provisional);
          if (allowZalgo)
            cb(null, c);
          else
            queueMicrotask(() => cb(null, c));
          return;
        }
        __privateGet(this, _onReaddirCB).push(cb);
        if (__privateGet(this, _readdirCBInFlight)) {
          return;
        }
        __privateSet(this, _readdirCBInFlight, true);
        const fullpath = this.fullpath();
        __privateGet(this, _fs).readdir(fullpath, { withFileTypes: true }, (er, entries) => {
          if (er) {
            __privateMethod(this, _PathBase_instances, readdirFail_fn).call(this, er.code);
            children.provisional = 0;
          } else {
            for (const e of entries) {
              __privateMethod(this, _PathBase_instances, readdirAddChild_fn).call(this, e, children);
            }
            __privateMethod(this, _PathBase_instances, readdirSuccess_fn).call(this, children);
          }
          __privateMethod(this, _PathBase_instances, callOnReaddirCB_fn).call(this, children.slice(0, children.provisional));
          return;
        });
      }
      /**
       * Return an array of known child entries.
       *
       * If the Path cannot or does not contain any children, then an empty array
       * is returned.
       *
       * Results are cached, and thus may be out of date if the filesystem is
       * mutated.
       */
      async readdir() {
        if (!this.canReaddir()) {
          return [];
        }
        const children = this.children();
        if (this.calledReaddir()) {
          return children.slice(0, children.provisional);
        }
        const fullpath = this.fullpath();
        if (__privateGet(this, _asyncReaddirInFlight)) {
          await __privateGet(this, _asyncReaddirInFlight);
        } else {
          let resolve = () => {
          };
          __privateSet(this, _asyncReaddirInFlight, new Promise((res) => resolve = res));
          try {
            for (const e of await __privateGet(this, _fs).promises.readdir(fullpath, {
              withFileTypes: true
            })) {
              __privateMethod(this, _PathBase_instances, readdirAddChild_fn).call(this, e, children);
            }
            __privateMethod(this, _PathBase_instances, readdirSuccess_fn).call(this, children);
          } catch (er) {
            __privateMethod(this, _PathBase_instances, readdirFail_fn).call(this, er.code);
            children.provisional = 0;
          }
          __privateSet(this, _asyncReaddirInFlight, void 0);
          resolve();
        }
        return children.slice(0, children.provisional);
      }
      /**
       * synchronous {@link PathBase.readdir}
       */
      readdirSync() {
        if (!this.canReaddir()) {
          return [];
        }
        const children = this.children();
        if (this.calledReaddir()) {
          return children.slice(0, children.provisional);
        }
        const fullpath = this.fullpath();
        try {
          for (const e of __privateGet(this, _fs).readdirSync(fullpath, {
            withFileTypes: true
          })) {
            __privateMethod(this, _PathBase_instances, readdirAddChild_fn).call(this, e, children);
          }
          __privateMethod(this, _PathBase_instances, readdirSuccess_fn).call(this, children);
        } catch (er) {
          __privateMethod(this, _PathBase_instances, readdirFail_fn).call(this, er.code);
          children.provisional = 0;
        }
        return children.slice(0, children.provisional);
      }
      canReaddir() {
        if (__privateGet(this, _type) & ENOCHILD)
          return false;
        const ifmt = IFMT & __privateGet(this, _type);
        if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {
          return false;
        }
        return true;
      }
      shouldWalk(dirs, walkFilter) {
        return (__privateGet(this, _type) & IFDIR) === IFDIR && !(__privateGet(this, _type) & ENOCHILD) && !dirs.has(this) && (!walkFilter || walkFilter(this));
      }
      /**
       * Return the Path object corresponding to path as resolved
       * by realpath(3).
       *
       * If the realpath call fails for any reason, `undefined` is returned.
       *
       * Result is cached, and thus may be outdated if the filesystem is mutated.
       * On success, returns a Path object.
       */
      async realpath() {
        if (__privateGet(this, _realpath))
          return __privateGet(this, _realpath);
        if ((ENOREALPATH | ENOREADLINK | ENOENT) & __privateGet(this, _type))
          return void 0;
        try {
          const rp = await __privateGet(this, _fs).promises.realpath(this.fullpath());
          return __privateSet(this, _realpath, this.resolve(rp));
        } catch (_) {
          __privateMethod(this, _PathBase_instances, markENOREALPATH_fn).call(this);
        }
      }
      /**
       * Synchronous {@link realpath}
       */
      realpathSync() {
        if (__privateGet(this, _realpath))
          return __privateGet(this, _realpath);
        if ((ENOREALPATH | ENOREADLINK | ENOENT) & __privateGet(this, _type))
          return void 0;
        try {
          const rp = __privateGet(this, _fs).realpathSync(this.fullpath());
          return __privateSet(this, _realpath, this.resolve(rp));
        } catch (_) {
          __privateMethod(this, _PathBase_instances, markENOREALPATH_fn).call(this);
        }
      }
      /**
       * Internal method to mark this Path object as the scurry cwd,
       * called by {@link PathScurry#chdir}
       *
       * @internal
       */
      [setAsCwd](oldCwd) {
        if (oldCwd === this)
          return;
        oldCwd.isCWD = false;
        this.isCWD = true;
        const changed = /* @__PURE__ */ new Set([]);
        let rp = [];
        let p = this;
        while (p && p.parent) {
          changed.add(p);
          __privateSet(p, _relative, rp.join(this.sep));
          __privateSet(p, _relativePosix, rp.join("/"));
          p = p.parent;
          rp.push("..");
        }
        p = oldCwd;
        while (p && p.parent && !changed.has(p)) {
          __privateSet(p, _relative, void 0);
          __privateSet(p, _relativePosix, void 0);
          p = p.parent;
        }
      }
    };
    _fs = new WeakMap();
    _dev = new WeakMap();
    _mode = new WeakMap();
    _nlink = new WeakMap();
    _uid = new WeakMap();
    _gid = new WeakMap();
    _rdev = new WeakMap();
    _blksize = new WeakMap();
    _ino = new WeakMap();
    _size = new WeakMap();
    _blocks = new WeakMap();
    _atimeMs = new WeakMap();
    _mtimeMs = new WeakMap();
    _ctimeMs = new WeakMap();
    _birthtimeMs = new WeakMap();
    _atime = new WeakMap();
    _mtime = new WeakMap();
    _ctime = new WeakMap();
    _birthtime = new WeakMap();
    _matchName = new WeakMap();
    _depth = new WeakMap();
    _fullpath = new WeakMap();
    _fullpathPosix = new WeakMap();
    _relative = new WeakMap();
    _relativePosix = new WeakMap();
    _type = new WeakMap();
    _children = new WeakMap();
    _linkTarget = new WeakMap();
    _realpath = new WeakMap();
    _PathBase_instances = new WeakSet();
    resolveParts_fn = function(dirParts) {
      let p = this;
      for (const part of dirParts) {
        p = p.child(part);
      }
      return p;
    };
    readdirSuccess_fn = function(children) {
      var _a;
      __privateSet(this, _type, __privateGet(this, _type) | READDIR_CALLED);
      for (let p = children.provisional; p < children.length; p++) {
        const c = children[p];
        if (c)
          __privateMethod(_a = c, _PathBase_instances, markENOENT_fn).call(_a);
      }
    };
    markENOENT_fn = function() {
      if (__privateGet(this, _type) & ENOENT)
        return;
      __privateSet(this, _type, (__privateGet(this, _type) | ENOENT) & IFMT_UNKNOWN);
      __privateMethod(this, _PathBase_instances, markChildrenENOENT_fn).call(this);
    };
    markChildrenENOENT_fn = function() {
      var _a;
      const children = this.children();
      children.provisional = 0;
      for (const p of children) {
        __privateMethod(_a = p, _PathBase_instances, markENOENT_fn).call(_a);
      }
    };
    markENOREALPATH_fn = function() {
      __privateSet(this, _type, __privateGet(this, _type) | ENOREALPATH);
      __privateMethod(this, _PathBase_instances, markENOTDIR_fn).call(this);
    };
    // save the information when we know the entry is not a dir
    markENOTDIR_fn = function() {
      if (__privateGet(this, _type) & ENOTDIR)
        return;
      let t = __privateGet(this, _type);
      if ((t & IFMT) === IFDIR)
        t &= IFMT_UNKNOWN;
      __privateSet(this, _type, t | ENOTDIR);
      __privateMethod(this, _PathBase_instances, markChildrenENOENT_fn).call(this);
    };
    readdirFail_fn = function(code = "") {
      if (code === "ENOTDIR" || code === "EPERM") {
        __privateMethod(this, _PathBase_instances, markENOTDIR_fn).call(this);
      } else if (code === "ENOENT") {
        __privateMethod(this, _PathBase_instances, markENOENT_fn).call(this);
      } else {
        this.children().provisional = 0;
      }
    };
    lstatFail_fn = function(code = "") {
      var _a;
      if (code === "ENOTDIR") {
        const p = this.parent;
        __privateMethod(_a = p, _PathBase_instances, markENOTDIR_fn).call(_a);
      } else if (code === "ENOENT") {
        __privateMethod(this, _PathBase_instances, markENOENT_fn).call(this);
      }
    };
    readlinkFail_fn = function(code = "") {
      var _a;
      let ter = __privateGet(this, _type);
      ter |= ENOREADLINK;
      if (code === "ENOENT")
        ter |= ENOENT;
      if (code === "EINVAL" || code === "UNKNOWN") {
        ter &= IFMT_UNKNOWN;
      }
      __privateSet(this, _type, ter);
      if (code === "ENOTDIR" && this.parent) {
        __privateMethod(_a = this.parent, _PathBase_instances, markENOTDIR_fn).call(_a);
      }
    };
    readdirAddChild_fn = function(e, c) {
      return __privateMethod(this, _PathBase_instances, readdirMaybePromoteChild_fn).call(this, e, c) || __privateMethod(this, _PathBase_instances, readdirAddNewChild_fn).call(this, e, c);
    };
    readdirAddNewChild_fn = function(e, c) {
      const type = entToType(e);
      const child = this.newChild(e.name, type, { parent: this });
      const ifmt = __privateGet(child, _type) & IFMT;
      if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {
        __privateSet(child, _type, __privateGet(child, _type) | ENOTDIR);
      }
      c.unshift(child);
      c.provisional++;
      return child;
    };
    readdirMaybePromoteChild_fn = function(e, c) {
      for (let p = c.provisional; p < c.length; p++) {
        const pchild = c[p];
        const name = this.nocase ? normalizeNocase(e.name) : normalize(e.name);
        if (name !== __privateGet(pchild, _matchName)) {
          continue;
        }
        return __privateMethod(this, _PathBase_instances, readdirPromoteChild_fn).call(this, e, pchild, p, c);
      }
    };
    readdirPromoteChild_fn = function(e, p, index, c) {
      const v = p.name;
      __privateSet(p, _type, __privateGet(p, _type) & IFMT_UNKNOWN | entToType(e));
      if (v !== e.name)
        p.name = e.name;
      if (index !== c.provisional) {
        if (index === c.length - 1)
          c.pop();
        else
          c.splice(index, 1);
        c.unshift(p);
      }
      c.provisional++;
      return p;
    };
    applyStat_fn = function(st) {
      const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid } = st;
      __privateSet(this, _atime, atime);
      __privateSet(this, _atimeMs, atimeMs);
      __privateSet(this, _birthtime, birthtime);
      __privateSet(this, _birthtimeMs, birthtimeMs);
      __privateSet(this, _blksize, blksize);
      __privateSet(this, _blocks, blocks);
      __privateSet(this, _ctime, ctime);
      __privateSet(this, _ctimeMs, ctimeMs);
      __privateSet(this, _dev, dev);
      __privateSet(this, _gid, gid);
      __privateSet(this, _ino, ino);
      __privateSet(this, _mode, mode);
      __privateSet(this, _mtime, mtime);
      __privateSet(this, _mtimeMs, mtimeMs);
      __privateSet(this, _nlink, nlink);
      __privateSet(this, _rdev, rdev);
      __privateSet(this, _size, size);
      __privateSet(this, _uid, uid);
      const ifmt = entToType(st);
      __privateSet(this, _type, __privateGet(this, _type) & IFMT_UNKNOWN | ifmt | LSTAT_CALLED);
      if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {
        __privateSet(this, _type, __privateGet(this, _type) | ENOTDIR);
      }
    };
    _onReaddirCB = new WeakMap();
    _readdirCBInFlight = new WeakMap();
    callOnReaddirCB_fn = function(children) {
      __privateSet(this, _readdirCBInFlight, false);
      const cbs = __privateGet(this, _onReaddirCB).slice();
      __privateGet(this, _onReaddirCB).length = 0;
      cbs.forEach((cb) => cb(null, children));
    };
    _asyncReaddirInFlight = new WeakMap();
    exports2.PathBase = PathBase;
    var PathWin32 = class _PathWin32 extends PathBase {
      /**
       * Do not create new Path objects directly.  They should always be accessed
       * via the PathScurry class or other methods on the Path class.
       *
       * @internal
       */
      constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
        super(name, type, root, roots, nocase, children, opts);
        /**
         * Separator for generating path strings.
         */
        __publicField(this, "sep", "\\");
        /**
         * Separator for parsing path strings.
         */
        __publicField(this, "splitSep", eitherSep);
      }
      /**
       * @internal
       */
      newChild(name, type = UNKNOWN, opts = {}) {
        return new _PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
      }
      /**
       * @internal
       */
      getRootString(path) {
        return node_path_1.win32.parse(path).root;
      }
      /**
       * @internal
       */
      getRoot(rootPath) {
        rootPath = uncToDrive(rootPath.toUpperCase());
        if (rootPath === this.root.name) {
          return this.root;
        }
        for (const [compare, root] of Object.entries(this.roots)) {
          if (this.sameRoot(rootPath, compare)) {
            return this.roots[rootPath] = root;
          }
        }
        return this.roots[rootPath] = new PathScurryWin32(rootPath, this).root;
      }
      /**
       * @internal
       */
      sameRoot(rootPath, compare = this.root.name) {
        rootPath = rootPath.toUpperCase().replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
        return rootPath === compare;
      }
    };
    exports2.PathWin32 = PathWin32;
    var PathPosix = class _PathPosix extends PathBase {
      /**
       * Do not create new Path objects directly.  They should always be accessed
       * via the PathScurry class or other methods on the Path class.
       *
       * @internal
       */
      constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
        super(name, type, root, roots, nocase, children, opts);
        /**
         * separator for parsing path strings
         */
        __publicField(this, "splitSep", "/");
        /**
         * separator for generating path strings
         */
        __publicField(this, "sep", "/");
      }
      /**
       * @internal
       */
      getRootString(path) {
        return path.startsWith("/") ? "/" : "";
      }
      /**
       * @internal
       */
      getRoot(_rootPath) {
        return this.root;
      }
      /**
       * @internal
       */
      newChild(name, type = UNKNOWN, opts = {}) {
        return new _PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
      }
    };
    exports2.PathPosix = PathPosix;
    var _resolveCache, _resolvePosixCache, _children2, _fs2;
    var PathScurryBase = class {
      /**
       * This class should not be instantiated directly.
       *
       * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
       *
       * @internal
       */
      constructor(cwd = process.cwd(), pathImpl, sep, { nocase, childrenCacheSize = 16 * 1024, fs = defaultFS } = {}) {
        /**
         * The root Path entry for the current working directory of this Scurry
         */
        __publicField(this, "root");
        /**
         * The string path for the root of this Scurry's current working directory
         */
        __publicField(this, "rootPath");
        /**
         * A collection of all roots encountered, referenced by rootPath
         */
        __publicField(this, "roots");
        /**
         * The Path entry corresponding to this PathScurry's current working directory.
         */
        __publicField(this, "cwd");
        __privateAdd(this, _resolveCache);
        __privateAdd(this, _resolvePosixCache);
        __privateAdd(this, _children2);
        /**
         * Perform path comparisons case-insensitively.
         *
         * Defaults true on Darwin and Windows systems, false elsewhere.
         */
        __publicField(this, "nocase");
        __privateAdd(this, _fs2);
        __privateSet(this, _fs2, fsFromOption(fs));
        if (cwd instanceof URL || cwd.startsWith("file://")) {
          cwd = (0, node_url_1.fileURLToPath)(cwd);
        }
        const cwdPath = pathImpl.resolve(cwd);
        this.roots = /* @__PURE__ */ Object.create(null);
        this.rootPath = this.parseRootPath(cwdPath);
        __privateSet(this, _resolveCache, new ResolveCache());
        __privateSet(this, _resolvePosixCache, new ResolveCache());
        __privateSet(this, _children2, new ChildrenCache(childrenCacheSize));
        const split = cwdPath.substring(this.rootPath.length).split(sep);
        if (split.length === 1 && !split[0]) {
          split.pop();
        }
        if (nocase === void 0) {
          throw new TypeError("must provide nocase setting to PathScurryBase ctor");
        }
        this.nocase = nocase;
        this.root = this.newRoot(__privateGet(this, _fs2));
        this.roots[this.rootPath] = this.root;
        let prev = this.root;
        let len = split.length - 1;
        const joinSep = pathImpl.sep;
        let abs = this.rootPath;
        let sawFirst = false;
        for (const part of split) {
          const l = len--;
          prev = prev.child(part, {
            relative: new Array(l).fill("..").join(joinSep),
            relativePosix: new Array(l).fill("..").join("/"),
            fullpath: abs += (sawFirst ? "" : joinSep) + part
          });
          sawFirst = true;
        }
        this.cwd = prev;
      }
      /**
       * Get the depth of a provided path, string, or the cwd
       */
      depth(path = this.cwd) {
        if (typeof path === "string") {
          path = this.cwd.resolve(path);
        }
        return path.depth();
      }
      /**
       * Return the cache of child entries.  Exposed so subclasses can create
       * child Path objects in a platform-specific way.
       *
       * @internal
       */
      childrenCache() {
        return __privateGet(this, _children2);
      }
      /**
       * Resolve one or more path strings to a resolved string
       *
       * Same interface as require('path').resolve.
       *
       * Much faster than path.resolve() when called multiple times for the same
       * path, because the resolved Path objects are cached.  Much slower
       * otherwise.
       */
      resolve(...paths) {
        let r = "";
        for (let i = paths.length - 1; i >= 0; i--) {
          const p = paths[i];
          if (!p || p === ".")
            continue;
          r = r ? `${p}/${r}` : p;
          if (this.isAbsolute(p)) {
            break;
          }
        }
        const cached = __privateGet(this, _resolveCache).get(r);
        if (cached !== void 0) {
          return cached;
        }
        const result = this.cwd.resolve(r).fullpath();
        __privateGet(this, _resolveCache).set(r, result);
        return result;
      }
      /**
       * Resolve one or more path strings to a resolved string, returning
       * the posix path.  Identical to .resolve() on posix systems, but on
       * windows will return a forward-slash separated UNC path.
       *
       * Same interface as require('path').resolve.
       *
       * Much faster than path.resolve() when called multiple times for the same
       * path, because the resolved Path objects are cached.  Much slower
       * otherwise.
       */
      resolvePosix(...paths) {
        let r = "";
        for (let i = paths.length - 1; i >= 0; i--) {
          const p = paths[i];
          if (!p || p === ".")
            continue;
          r = r ? `${p}/${r}` : p;
          if (this.isAbsolute(p)) {
            break;
          }
        }
        const cached = __privateGet(this, _resolvePosixCache).get(r);
        if (cached !== void 0) {
          return cached;
        }
        const result = this.cwd.resolve(r).fullpathPosix();
        __privateGet(this, _resolvePosixCache).set(r, result);
        return result;
      }
      /**
       * find the relative path from the cwd to the supplied path string or entry
       */
      relative(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return entry.relative();
      }
      /**
       * find the relative path from the cwd to the supplied path string or
       * entry, using / as the path delimiter, even on Windows.
       */
      relativePosix(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return entry.relativePosix();
      }
      /**
       * Return the basename for the provided string or Path object
       */
      basename(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return entry.name;
      }
      /**
       * Return the dirname for the provided string or Path object
       */
      dirname(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return (entry.parent || entry).fullpath();
      }
      async readdir(entry = this.cwd, opts = {
        withFileTypes: true
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes } = opts;
        if (!entry.canReaddir()) {
          return [];
        } else {
          const p = await entry.readdir();
          return withFileTypes ? p : p.map((e) => e.name);
        }
      }
      readdirSync(entry = this.cwd, opts = {
        withFileTypes: true
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true } = opts;
        if (!entry.canReaddir()) {
          return [];
        } else if (withFileTypes) {
          return entry.readdirSync();
        } else {
          return entry.readdirSync().map((e) => e.name);
        }
      }
      /**
       * Call lstat() on the string or Path object, and update all known
       * information that can be determined.
       *
       * Note that unlike `fs.lstat()`, the returned value does not contain some
       * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
       * information is required, you will need to call `fs.lstat` yourself.
       *
       * If the Path refers to a nonexistent file, or if the lstat call fails for
       * any reason, `undefined` is returned.  Otherwise the updated Path object is
       * returned.
       *
       * Results are cached, and thus may be out of date if the filesystem is
       * mutated.
       */
      async lstat(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return entry.lstat();
      }
      /**
       * synchronous {@link PathScurryBase.lstat}
       */
      lstatSync(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return entry.lstatSync();
      }
      async readlink(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          withFileTypes = entry.withFileTypes;
          entry = this.cwd;
        }
        const e = await entry.readlink();
        return withFileTypes ? e : e?.fullpath();
      }
      readlinkSync(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          withFileTypes = entry.withFileTypes;
          entry = this.cwd;
        }
        const e = entry.readlinkSync();
        return withFileTypes ? e : e?.fullpath();
      }
      async realpath(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          withFileTypes = entry.withFileTypes;
          entry = this.cwd;
        }
        const e = await entry.realpath();
        return withFileTypes ? e : e?.fullpath();
      }
      realpathSync(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          withFileTypes = entry.withFileTypes;
          entry = this.cwd;
        }
        const e = entry.realpathSync();
        return withFileTypes ? e : e?.fullpath();
      }
      async walk(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;
        const results = [];
        if (!filter || filter(entry)) {
          results.push(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = /* @__PURE__ */ new Set();
        const walk = (dir, cb) => {
          dirs.add(dir);
          dir.readdirCB((er, entries) => {
            if (er) {
              return cb(er);
            }
            let len = entries.length;
            if (!len)
              return cb();
            const next = () => {
              if (--len === 0) {
                cb();
              }
            };
            for (const e of entries) {
              if (!filter || filter(e)) {
                results.push(withFileTypes ? e : e.fullpath());
              }
              if (follow && e.isSymbolicLink()) {
                e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r).then((r) => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());
              } else {
                if (e.shouldWalk(dirs, walkFilter)) {
                  walk(e, next);
                } else {
                  next();
                }
              }
            }
          }, true);
        };
        const start = entry;
        return new Promise((res, rej) => {
          walk(start, (er) => {
            if (er)
              return rej(er);
            res(results);
          });
        });
      }
      walkSync(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;
        const results = [];
        if (!filter || filter(entry)) {
          results.push(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = /* @__PURE__ */ new Set([entry]);
        for (const dir of dirs) {
          const entries = dir.readdirSync();
          for (const e of entries) {
            if (!filter || filter(e)) {
              results.push(withFileTypes ? e : e.fullpath());
            }
            let r = e;
            if (e.isSymbolicLink()) {
              if (!(follow && (r = e.realpathSync())))
                continue;
              if (r.isUnknown())
                r.lstatSync();
            }
            if (r.shouldWalk(dirs, walkFilter)) {
              dirs.add(r);
            }
          }
        }
        return results;
      }
      /**
       * Support for `for await`
       *
       * Alias for {@link PathScurryBase.iterate}
       *
       * Note: As of Node 19, this is very slow, compared to other methods of
       * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
       * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
       */
      [Symbol.asyncIterator]() {
        return this.iterate();
      }
      iterate(entry = this.cwd, options = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          options = entry;
          entry = this.cwd;
        }
        return this.stream(entry, options)[Symbol.asyncIterator]();
      }
      /**
       * Iterating over a PathScurry performs a synchronous walk.
       *
       * Alias for {@link PathScurryBase.iterateSync}
       */
      [Symbol.iterator]() {
        return this.iterateSync();
      }
      *iterateSync(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;
        if (!filter || filter(entry)) {
          yield withFileTypes ? entry : entry.fullpath();
        }
        const dirs = /* @__PURE__ */ new Set([entry]);
        for (const dir of dirs) {
          const entries = dir.readdirSync();
          for (const e of entries) {
            if (!filter || filter(e)) {
              yield withFileTypes ? e : e.fullpath();
            }
            let r = e;
            if (e.isSymbolicLink()) {
              if (!(follow && (r = e.realpathSync())))
                continue;
              if (r.isUnknown())
                r.lstatSync();
            }
            if (r.shouldWalk(dirs, walkFilter)) {
              dirs.add(r);
            }
          }
        }
      }
      stream(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;
        const results = new minipass_1.Minipass({ objectMode: true });
        if (!filter || filter(entry)) {
          results.write(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = /* @__PURE__ */ new Set();
        const queue = [entry];
        let processing = 0;
        const process2 = () => {
          let paused = false;
          while (!paused) {
            const dir = queue.shift();
            if (!dir) {
              if (processing === 0)
                results.end();
              return;
            }
            processing++;
            dirs.add(dir);
            const onReaddir = (er, entries, didRealpaths = false) => {
              if (er)
                return results.emit("error", er);
              if (follow && !didRealpaths) {
                const promises = [];
                for (const e of entries) {
                  if (e.isSymbolicLink()) {
                    promises.push(e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r));
                  }
                }
                if (promises.length) {
                  Promise.all(promises).then(() => onReaddir(null, entries, true));
                  return;
                }
              }
              for (const e of entries) {
                if (e && (!filter || filter(e))) {
                  if (!results.write(withFileTypes ? e : e.fullpath())) {
                    paused = true;
                  }
                }
              }
              processing--;
              for (const e of entries) {
                const r = e.realpathCached() || e;
                if (r.shouldWalk(dirs, walkFilter)) {
                  queue.push(r);
                }
              }
              if (paused && !results.flowing) {
                results.once("drain", process2);
              } else if (!sync) {
                process2();
              }
            };
            let sync = true;
            dir.readdirCB(onReaddir, true);
            sync = false;
          }
        };
        process2();
        return results;
      }
      streamSync(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;
        const results = new minipass_1.Minipass({ objectMode: true });
        const dirs = /* @__PURE__ */ new Set();
        if (!filter || filter(entry)) {
          results.write(withFileTypes ? entry : entry.fullpath());
        }
        const queue = [entry];
        let processing = 0;
        const process2 = () => {
          let paused = false;
          while (!paused) {
            const dir = queue.shift();
            if (!dir) {
              if (processing === 0)
                results.end();
              return;
            }
            processing++;
            dirs.add(dir);
            const entries = dir.readdirSync();
            for (const e of entries) {
              if (!filter || filter(e)) {
                if (!results.write(withFileTypes ? e : e.fullpath())) {
                  paused = true;
                }
              }
            }
            processing--;
            for (const e of entries) {
              let r = e;
              if (e.isSymbolicLink()) {
                if (!(follow && (r = e.realpathSync())))
                  continue;
                if (r.isUnknown())
                  r.lstatSync();
              }
              if (r.shouldWalk(dirs, walkFilter)) {
                queue.push(r);
              }
            }
          }
          if (paused && !results.flowing)
            results.once("drain", process2);
        };
        process2();
        return results;
      }
      chdir(path = this.cwd) {
        const oldCwd = this.cwd;
        this.cwd = typeof path === "string" ? this.cwd.resolve(path) : path;
        this.cwd[setAsCwd](oldCwd);
      }
    };
    _resolveCache = new WeakMap();
    _resolvePosixCache = new WeakMap();
    _children2 = new WeakMap();
    _fs2 = new WeakMap();
    exports2.PathScurryBase = PathScurryBase;
    var PathScurryWin32 = class extends PathScurryBase {
      constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = true } = opts;
        super(cwd, node_path_1.win32, "\\", { ...opts, nocase });
        /**
         * separator for generating path strings
         */
        __publicField(this, "sep", "\\");
        this.nocase = nocase;
        for (let p = this.cwd; p; p = p.parent) {
          p.nocase = this.nocase;
        }
      }
      /**
       * @internal
       */
      parseRootPath(dir) {
        return node_path_1.win32.parse(dir).root.toUpperCase();
      }
      /**
       * @internal
       */
      newRoot(fs) {
        return new PathWin32(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs });
      }
      /**
       * Return true if the provided path string is an absolute path
       */
      isAbsolute(p) {
        return p.startsWith("/") || p.startsWith("\\") || /^[a-z]:(\/|\\)/i.test(p);
      }
    };
    exports2.PathScurryWin32 = PathScurryWin32;
    var PathScurryPosix = class extends PathScurryBase {
      constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = false } = opts;
        super(cwd, node_path_1.posix, "/", { ...opts, nocase });
        /**
         * separator for generating path strings
         */
        __publicField(this, "sep", "/");
        this.nocase = nocase;
      }
      /**
       * @internal
       */
      parseRootPath(_dir) {
        return "/";
      }
      /**
       * @internal
       */
      newRoot(fs) {
        return new PathPosix(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs });
      }
      /**
       * Return true if the provided path string is an absolute path
       */
      isAbsolute(p) {
        return p.startsWith("/");
      }
    };
    exports2.PathScurryPosix = PathScurryPosix;
    var PathScurryDarwin = class extends PathScurryPosix {
      constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = true } = opts;
        super(cwd, { ...opts, nocase });
      }
    };
    exports2.PathScurryDarwin = PathScurryDarwin;
    exports2.Path = process.platform === "win32" ? PathWin32 : PathPosix;
    exports2.PathScurry = process.platform === "win32" ? PathScurryWin32 : process.platform === "darwin" ? PathScurryDarwin : PathScurryPosix;
  }
});

// node_modules/typeorm/node_modules/glob/dist/commonjs/pattern.js
var require_pattern = __commonJS({
  "node_modules/typeorm/node_modules/glob/dist/commonjs/pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Pattern = void 0;
    var minimatch_1 = require_commonjs();
    var isPatternList = (pl) => pl.length >= 1;
    var isGlobList = (gl) => gl.length >= 1;
    var _patternList, _globList, _index, _platform, _rest, _globString, _isDrive, _isUNC, _isAbsolute, _followGlobstar;
    var _Pattern = class _Pattern {
      constructor(patternList, globList, index, platform) {
        __privateAdd(this, _patternList);
        __privateAdd(this, _globList);
        __privateAdd(this, _index);
        __publicField(this, "length");
        __privateAdd(this, _platform);
        __privateAdd(this, _rest);
        __privateAdd(this, _globString);
        __privateAdd(this, _isDrive);
        __privateAdd(this, _isUNC);
        __privateAdd(this, _isAbsolute);
        __privateAdd(this, _followGlobstar, true);
        if (!isPatternList(patternList)) {
          throw new TypeError("empty pattern list");
        }
        if (!isGlobList(globList)) {
          throw new TypeError("empty glob list");
        }
        if (globList.length !== patternList.length) {
          throw new TypeError("mismatched pattern list and glob list lengths");
        }
        this.length = patternList.length;
        if (index < 0 || index >= this.length) {
          throw new TypeError("index out of range");
        }
        __privateSet(this, _patternList, patternList);
        __privateSet(this, _globList, globList);
        __privateSet(this, _index, index);
        __privateSet(this, _platform, platform);
        if (__privateGet(this, _index) === 0) {
          if (this.isUNC()) {
            const [p0, p1, p2, p3, ...prest] = __privateGet(this, _patternList);
            const [g0, g1, g2, g3, ...grest] = __privateGet(this, _globList);
            if (prest[0] === "") {
              prest.shift();
              grest.shift();
            }
            const p = [p0, p1, p2, p3, ""].join("/");
            const g = [g0, g1, g2, g3, ""].join("/");
            __privateSet(this, _patternList, [p, ...prest]);
            __privateSet(this, _globList, [g, ...grest]);
            this.length = __privateGet(this, _patternList).length;
          } else if (this.isDrive() || this.isAbsolute()) {
            const [p1, ...prest] = __privateGet(this, _patternList);
            const [g1, ...grest] = __privateGet(this, _globList);
            if (prest[0] === "") {
              prest.shift();
              grest.shift();
            }
            const p = p1 + "/";
            const g = g1 + "/";
            __privateSet(this, _patternList, [p, ...prest]);
            __privateSet(this, _globList, [g, ...grest]);
            this.length = __privateGet(this, _patternList).length;
          }
        }
      }
      /**
       * The first entry in the parsed list of patterns
       */
      pattern() {
        return __privateGet(this, _patternList)[__privateGet(this, _index)];
      }
      /**
       * true of if pattern() returns a string
       */
      isString() {
        return typeof __privateGet(this, _patternList)[__privateGet(this, _index)] === "string";
      }
      /**
       * true of if pattern() returns GLOBSTAR
       */
      isGlobstar() {
        return __privateGet(this, _patternList)[__privateGet(this, _index)] === minimatch_1.GLOBSTAR;
      }
      /**
       * true if pattern() returns a regexp
       */
      isRegExp() {
        return __privateGet(this, _patternList)[__privateGet(this, _index)] instanceof RegExp;
      }
      /**
       * The /-joined set of glob parts that make up this pattern
       */
      globString() {
        return __privateSet(this, _globString, __privateGet(this, _globString) || (__privateGet(this, _index) === 0 ? this.isAbsolute() ? __privateGet(this, _globList)[0] + __privateGet(this, _globList).slice(1).join("/") : __privateGet(this, _globList).join("/") : __privateGet(this, _globList).slice(__privateGet(this, _index)).join("/")));
      }
      /**
       * true if there are more pattern parts after this one
       */
      hasMore() {
        return this.length > __privateGet(this, _index) + 1;
      }
      /**
       * The rest of the pattern after this part, or null if this is the end
       */
      rest() {
        if (__privateGet(this, _rest) !== void 0)
          return __privateGet(this, _rest);
        if (!this.hasMore())
          return __privateSet(this, _rest, null);
        __privateSet(this, _rest, new _Pattern(__privateGet(this, _patternList), __privateGet(this, _globList), __privateGet(this, _index) + 1, __privateGet(this, _platform)));
        __privateSet(__privateGet(this, _rest), _isAbsolute, __privateGet(this, _isAbsolute));
        __privateSet(__privateGet(this, _rest), _isUNC, __privateGet(this, _isUNC));
        __privateSet(__privateGet(this, _rest), _isDrive, __privateGet(this, _isDrive));
        return __privateGet(this, _rest);
      }
      /**
       * true if the pattern represents a //unc/path/ on windows
       */
      isUNC() {
        const pl = __privateGet(this, _patternList);
        return __privateGet(this, _isUNC) !== void 0 ? __privateGet(this, _isUNC) : __privateSet(this, _isUNC, __privateGet(this, _platform) === "win32" && __privateGet(this, _index) === 0 && pl[0] === "" && pl[1] === "" && typeof pl[2] === "string" && !!pl[2] && typeof pl[3] === "string" && !!pl[3]);
      }
      // pattern like C:/...
      // split = ['C:', ...]
      // XXX: would be nice to handle patterns like `c:*` to test the cwd
      // in c: for *, but I don't know of a way to even figure out what that
      // cwd is without actually chdir'ing into it?
      /**
       * True if the pattern starts with a drive letter on Windows
       */
      isDrive() {
        const pl = __privateGet(this, _patternList);
        return __privateGet(this, _isDrive) !== void 0 ? __privateGet(this, _isDrive) : __privateSet(this, _isDrive, __privateGet(this, _platform) === "win32" && __privateGet(this, _index) === 0 && this.length > 1 && typeof pl[0] === "string" && /^[a-z]:$/i.test(pl[0]));
      }
      // pattern = '/' or '/...' or '/x/...'
      // split = ['', ''] or ['', ...] or ['', 'x', ...]
      // Drive and UNC both considered absolute on windows
      /**
       * True if the pattern is rooted on an absolute path
       */
      isAbsolute() {
        const pl = __privateGet(this, _patternList);
        return __privateGet(this, _isAbsolute) !== void 0 ? __privateGet(this, _isAbsolute) : __privateSet(this, _isAbsolute, pl[0] === "" && pl.length > 1 || this.isDrive() || this.isUNC());
      }
      /**
       * consume the root of the pattern, and return it
       */
      root() {
        const p = __privateGet(this, _patternList)[0];
        return typeof p === "string" && this.isAbsolute() && __privateGet(this, _index) === 0 ? p : "";
      }
      /**
       * Check to see if the current globstar pattern is allowed to follow
       * a symbolic link.
       */
      checkFollowGlobstar() {
        return !(__privateGet(this, _index) === 0 || !this.isGlobstar() || !__privateGet(this, _followGlobstar));
      }
      /**
       * Mark that the current globstar pattern is following a symbolic link
       */
      markFollowGlobstar() {
        if (__privateGet(this, _index) === 0 || !this.isGlobstar() || !__privateGet(this, _followGlobstar))
          return false;
        __privateSet(this, _followGlobstar, false);
        return true;
      }
    };
    _patternList = new WeakMap();
    _globList = new WeakMap();
    _index = new WeakMap();
    _platform = new WeakMap();
    _rest = new WeakMap();
    _globString = new WeakMap();
    _isDrive = new WeakMap();
    _isUNC = new WeakMap();
    _isAbsolute = new WeakMap();
    _followGlobstar = new WeakMap();
    var Pattern = _Pattern;
    exports2.Pattern = Pattern;
  }
});

// node_modules/typeorm/node_modules/glob/dist/commonjs/ignore.js
var require_ignore = __commonJS({
  "node_modules/typeorm/node_modules/glob/dist/commonjs/ignore.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Ignore = void 0;
    var minimatch_1 = require_commonjs();
    var pattern_js_1 = require_pattern();
    var defaultPlatform = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
    var Ignore = class {
      constructor(ignored, { nobrace, nocase, noext, noglobstar, platform = defaultPlatform }) {
        __publicField(this, "relative");
        __publicField(this, "relativeChildren");
        __publicField(this, "absolute");
        __publicField(this, "absoluteChildren");
        __publicField(this, "platform");
        __publicField(this, "mmopts");
        this.relative = [];
        this.absolute = [];
        this.relativeChildren = [];
        this.absoluteChildren = [];
        this.platform = platform;
        this.mmopts = {
          dot: true,
          nobrace,
          nocase,
          noext,
          noglobstar,
          optimizationLevel: 2,
          platform,
          nocomment: true,
          nonegate: true
        };
        for (const ign of ignored)
          this.add(ign);
      }
      add(ign) {
        const mm = new minimatch_1.Minimatch(ign, this.mmopts);
        for (let i = 0; i < mm.set.length; i++) {
          const parsed = mm.set[i];
          const globParts = mm.globParts[i];
          if (!parsed || !globParts) {
            throw new Error("invalid pattern object");
          }
          while (parsed[0] === "." && globParts[0] === ".") {
            parsed.shift();
            globParts.shift();
          }
          const p = new pattern_js_1.Pattern(parsed, globParts, 0, this.platform);
          const m = new minimatch_1.Minimatch(p.globString(), this.mmopts);
          const children = globParts[globParts.length - 1] === "**";
          const absolute = p.isAbsolute();
          if (absolute)
            this.absolute.push(m);
          else
            this.relative.push(m);
          if (children) {
            if (absolute)
              this.absoluteChildren.push(m);
            else
              this.relativeChildren.push(m);
          }
        }
      }
      ignored(p) {
        const fullpath = p.fullpath();
        const fullpaths = `${fullpath}/`;
        const relative = p.relative() || ".";
        const relatives = `${relative}/`;
        for (const m of this.relative) {
          if (m.match(relative) || m.match(relatives))
            return true;
        }
        for (const m of this.absolute) {
          if (m.match(fullpath) || m.match(fullpaths))
            return true;
        }
        return false;
      }
      childrenIgnored(p) {
        const fullpath = p.fullpath() + "/";
        const relative = (p.relative() || ".") + "/";
        for (const m of this.relativeChildren) {
          if (m.match(relative))
            return true;
        }
        for (const m of this.absoluteChildren) {
          if (m.match(fullpath))
            return true;
        }
        return false;
      }
    };
    exports2.Ignore = Ignore;
  }
});

// node_modules/typeorm/node_modules/glob/dist/commonjs/processor.js
var require_processor = __commonJS({
  "node_modules/typeorm/node_modules/glob/dist/commonjs/processor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Processor = exports2.SubWalks = exports2.MatchRecord = exports2.HasWalkedCache = void 0;
    var minimatch_1 = require_commonjs();
    var HasWalkedCache = class _HasWalkedCache {
      constructor(store = /* @__PURE__ */ new Map()) {
        __publicField(this, "store");
        this.store = store;
      }
      copy() {
        return new _HasWalkedCache(new Map(this.store));
      }
      hasWalked(target, pattern) {
        return this.store.get(target.fullpath())?.has(pattern.globString());
      }
      storeWalked(target, pattern) {
        const fullpath = target.fullpath();
        const cached = this.store.get(fullpath);
        if (cached)
          cached.add(pattern.globString());
        else
          this.store.set(fullpath, /* @__PURE__ */ new Set([pattern.globString()]));
      }
    };
    exports2.HasWalkedCache = HasWalkedCache;
    var MatchRecord = class {
      constructor() {
        __publicField(this, "store", /* @__PURE__ */ new Map());
      }
      add(target, absolute, ifDir) {
        const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
        const current = this.store.get(target);
        this.store.set(target, current === void 0 ? n : n & current);
      }
      // match, absolute, ifdir
      entries() {
        return [...this.store.entries()].map(([path, n]) => [
          path,
          !!(n & 2),
          !!(n & 1)
        ]);
      }
    };
    exports2.MatchRecord = MatchRecord;
    var SubWalks = class {
      constructor() {
        __publicField(this, "store", /* @__PURE__ */ new Map());
      }
      add(target, pattern) {
        if (!target.canReaddir()) {
          return;
        }
        const subs = this.store.get(target);
        if (subs) {
          if (!subs.find((p) => p.globString() === pattern.globString())) {
            subs.push(pattern);
          }
        } else
          this.store.set(target, [pattern]);
      }
      get(target) {
        const subs = this.store.get(target);
        if (!subs) {
          throw new Error("attempting to walk unknown path");
        }
        return subs;
      }
      entries() {
        return this.keys().map((k) => [k, this.store.get(k)]);
      }
      keys() {
        return [...this.store.keys()].filter((t) => t.canReaddir());
      }
    };
    exports2.SubWalks = SubWalks;
    var Processor = class _Processor {
      constructor(opts, hasWalkedCache) {
        __publicField(this, "hasWalkedCache");
        __publicField(this, "matches", new MatchRecord());
        __publicField(this, "subwalks", new SubWalks());
        __publicField(this, "patterns");
        __publicField(this, "follow");
        __publicField(this, "dot");
        __publicField(this, "opts");
        this.opts = opts;
        this.follow = !!opts.follow;
        this.dot = !!opts.dot;
        this.hasWalkedCache = hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();
      }
      processPatterns(target, patterns) {
        this.patterns = patterns;
        const processingSet = patterns.map((p) => [target, p]);
        for (let [t, pattern] of processingSet) {
          this.hasWalkedCache.storeWalked(t, pattern);
          const root = pattern.root();
          const absolute = pattern.isAbsolute() && this.opts.absolute !== false;
          if (root) {
            t = t.resolve(root === "/" && this.opts.root !== void 0 ? this.opts.root : root);
            const rest2 = pattern.rest();
            if (!rest2) {
              this.matches.add(t, true, false);
              continue;
            } else {
              pattern = rest2;
            }
          }
          if (t.isENOENT())
            continue;
          let p;
          let rest;
          let changed = false;
          while (typeof (p = pattern.pattern()) === "string" && (rest = pattern.rest())) {
            const c = t.resolve(p);
            t = c;
            pattern = rest;
            changed = true;
          }
          p = pattern.pattern();
          rest = pattern.rest();
          if (changed) {
            if (this.hasWalkedCache.hasWalked(t, pattern))
              continue;
            this.hasWalkedCache.storeWalked(t, pattern);
          }
          if (typeof p === "string") {
            const ifDir = p === ".." || p === "" || p === ".";
            this.matches.add(t.resolve(p), absolute, ifDir);
            continue;
          } else if (p === minimatch_1.GLOBSTAR) {
            if (!t.isSymbolicLink() || this.follow || pattern.checkFollowGlobstar()) {
              this.subwalks.add(t, pattern);
            }
            const rp = rest?.pattern();
            const rrest = rest?.rest();
            if (!rest || (rp === "" || rp === ".") && !rrest) {
              this.matches.add(t, absolute, rp === "" || rp === ".");
            } else {
              if (rp === "..") {
                const tp = t.parent || t;
                if (!rrest)
                  this.matches.add(tp, absolute, true);
                else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {
                  this.subwalks.add(tp, rrest);
                }
              }
            }
          } else if (p instanceof RegExp) {
            this.subwalks.add(t, pattern);
          }
        }
        return this;
      }
      subwalkTargets() {
        return this.subwalks.keys();
      }
      child() {
        return new _Processor(this.opts, this.hasWalkedCache);
      }
      // return a new Processor containing the subwalks for each
      // child entry, and a set of matches, and
      // a hasWalkedCache that's a copy of this one
      // then we're going to call
      filterEntries(parent, entries) {
        const patterns = this.subwalks.get(parent);
        const results = this.child();
        for (const e of entries) {
          for (const pattern of patterns) {
            const absolute = pattern.isAbsolute();
            const p = pattern.pattern();
            const rest = pattern.rest();
            if (p === minimatch_1.GLOBSTAR) {
              results.testGlobstar(e, pattern, rest, absolute);
            } else if (p instanceof RegExp) {
              results.testRegExp(e, p, rest, absolute);
            } else {
              results.testString(e, p, rest, absolute);
            }
          }
        }
        return results;
      }
      testGlobstar(e, pattern, rest, absolute) {
        if (this.dot || !e.name.startsWith(".")) {
          if (!pattern.hasMore()) {
            this.matches.add(e, absolute, false);
          }
          if (e.canReaddir()) {
            if (this.follow || !e.isSymbolicLink()) {
              this.subwalks.add(e, pattern);
            } else if (e.isSymbolicLink()) {
              if (rest && pattern.checkFollowGlobstar()) {
                this.subwalks.add(e, rest);
              } else if (pattern.markFollowGlobstar()) {
                this.subwalks.add(e, pattern);
              }
            }
          }
        }
        if (rest) {
          const rp = rest.pattern();
          if (typeof rp === "string" && // dots and empty were handled already
          rp !== ".." && rp !== "" && rp !== ".") {
            this.testString(e, rp, rest.rest(), absolute);
          } else if (rp === "..") {
            const ep = e.parent || e;
            this.subwalks.add(ep, rest);
          } else if (rp instanceof RegExp) {
            this.testRegExp(e, rp, rest.rest(), absolute);
          }
        }
      }
      testRegExp(e, p, rest, absolute) {
        if (!p.test(e.name))
          return;
        if (!rest) {
          this.matches.add(e, absolute, false);
        } else {
          this.subwalks.add(e, rest);
        }
      }
      testString(e, p, rest, absolute) {
        if (!e.isNamed(p))
          return;
        if (!rest) {
          this.matches.add(e, absolute, false);
        } else {
          this.subwalks.add(e, rest);
        }
      }
    };
    exports2.Processor = Processor;
  }
});

// node_modules/typeorm/node_modules/glob/dist/commonjs/walker.js
var require_walker = __commonJS({
  "node_modules/typeorm/node_modules/glob/dist/commonjs/walker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GlobStream = exports2.GlobWalker = exports2.GlobUtil = void 0;
    var minipass_1 = require_commonjs3();
    var ignore_js_1 = require_ignore();
    var processor_js_1 = require_processor();
    var makeIgnore = (ignore, opts) => typeof ignore === "string" ? new ignore_js_1.Ignore([ignore], opts) : Array.isArray(ignore) ? new ignore_js_1.Ignore(ignore, opts) : ignore;
    var _onResume, _ignore, _sep, _GlobUtil_instances, ignored_fn, childrenIgnored_fn;
    var GlobUtil = class {
      constructor(patterns, path, opts) {
        __privateAdd(this, _GlobUtil_instances);
        __publicField(this, "path");
        __publicField(this, "patterns");
        __publicField(this, "opts");
        __publicField(this, "seen", /* @__PURE__ */ new Set());
        __publicField(this, "paused", false);
        __publicField(this, "aborted", false);
        __privateAdd(this, _onResume, []);
        __privateAdd(this, _ignore);
        __privateAdd(this, _sep);
        __publicField(this, "signal");
        __publicField(this, "maxDepth");
        __publicField(this, "includeChildMatches");
        this.patterns = patterns;
        this.path = path;
        this.opts = opts;
        __privateSet(this, _sep, !opts.posix && opts.platform === "win32" ? "\\" : "/");
        this.includeChildMatches = opts.includeChildMatches !== false;
        if (opts.ignore || !this.includeChildMatches) {
          __privateSet(this, _ignore, makeIgnore(opts.ignore ?? [], opts));
          if (!this.includeChildMatches && typeof __privateGet(this, _ignore).add !== "function") {
            const m = "cannot ignore child matches, ignore lacks add() method.";
            throw new Error(m);
          }
        }
        this.maxDepth = opts.maxDepth || Infinity;
        if (opts.signal) {
          this.signal = opts.signal;
          this.signal.addEventListener("abort", () => {
            __privateGet(this, _onResume).length = 0;
          });
        }
      }
      // backpressure mechanism
      pause() {
        this.paused = true;
      }
      resume() {
        if (this.signal?.aborted)
          return;
        this.paused = false;
        let fn = void 0;
        while (!this.paused && (fn = __privateGet(this, _onResume).shift())) {
          fn();
        }
      }
      onResume(fn) {
        if (this.signal?.aborted)
          return;
        if (!this.paused) {
          fn();
        } else {
          __privateGet(this, _onResume).push(fn);
        }
      }
      // do the requisite realpath/stat checking, and return the path
      // to add or undefined to filter it out.
      async matchCheck(e, ifDir) {
        if (ifDir && this.opts.nodir)
          return void 0;
        let rpc;
        if (this.opts.realpath) {
          rpc = e.realpathCached() || await e.realpath();
          if (!rpc)
            return void 0;
          e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        const s = needStat ? await e.lstat() : e;
        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
          const target = await s.realpath();
          if (target && (target.isUnknown() || this.opts.stat)) {
            await target.lstat();
          }
        }
        return this.matchCheckTest(s, ifDir);
      }
      matchCheckTest(e, ifDir) {
        return e && (this.maxDepth === Infinity || e.depth() <= this.maxDepth) && (!ifDir || e.canReaddir()) && (!this.opts.nodir || !e.isDirectory()) && (!this.opts.nodir || !this.opts.follow || !e.isSymbolicLink() || !e.realpathCached()?.isDirectory()) && !__privateMethod(this, _GlobUtil_instances, ignored_fn).call(this, e) ? e : void 0;
      }
      matchCheckSync(e, ifDir) {
        if (ifDir && this.opts.nodir)
          return void 0;
        let rpc;
        if (this.opts.realpath) {
          rpc = e.realpathCached() || e.realpathSync();
          if (!rpc)
            return void 0;
          e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        const s = needStat ? e.lstatSync() : e;
        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
          const target = s.realpathSync();
          if (target && (target?.isUnknown() || this.opts.stat)) {
            target.lstatSync();
          }
        }
        return this.matchCheckTest(s, ifDir);
      }
      matchFinish(e, absolute) {
        if (__privateMethod(this, _GlobUtil_instances, ignored_fn).call(this, e))
          return;
        if (!this.includeChildMatches && __privateGet(this, _ignore)?.add) {
          const ign = `${e.relativePosix()}/**`;
          __privateGet(this, _ignore).add(ign);
        }
        const abs = this.opts.absolute === void 0 ? absolute : this.opts.absolute;
        this.seen.add(e);
        const mark = this.opts.mark && e.isDirectory() ? __privateGet(this, _sep) : "";
        if (this.opts.withFileTypes) {
          this.matchEmit(e);
        } else if (abs) {
          const abs2 = this.opts.posix ? e.fullpathPosix() : e.fullpath();
          this.matchEmit(abs2 + mark);
        } else {
          const rel = this.opts.posix ? e.relativePosix() : e.relative();
          const pre = this.opts.dotRelative && !rel.startsWith(".." + __privateGet(this, _sep)) ? "." + __privateGet(this, _sep) : "";
          this.matchEmit(!rel ? "." + mark : pre + rel + mark);
        }
      }
      async match(e, absolute, ifDir) {
        const p = await this.matchCheck(e, ifDir);
        if (p)
          this.matchFinish(p, absolute);
      }
      matchSync(e, absolute, ifDir) {
        const p = this.matchCheckSync(e, ifDir);
        if (p)
          this.matchFinish(p, absolute);
      }
      walkCB(target, patterns, cb) {
        if (this.signal?.aborted)
          cb();
        this.walkCB2(target, patterns, new processor_js_1.Processor(this.opts), cb);
      }
      walkCB2(target, patterns, processor, cb) {
        if (__privateMethod(this, _GlobUtil_instances, childrenIgnored_fn).call(this, target))
          return cb();
        if (this.signal?.aborted)
          cb();
        if (this.paused) {
          this.onResume(() => this.walkCB2(target, patterns, processor, cb));
          return;
        }
        processor.processPatterns(target, patterns);
        let tasks = 1;
        const next = () => {
          if (--tasks === 0)
            cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
          if (__privateMethod(this, _GlobUtil_instances, ignored_fn).call(this, m))
            continue;
          tasks++;
          this.match(m, absolute, ifDir).then(() => next());
        }
        for (const t of processor.subwalkTargets()) {
          if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
            continue;
          }
          tasks++;
          const childrenCached = t.readdirCached();
          if (t.calledReaddir())
            this.walkCB3(t, childrenCached, processor, next);
          else {
            t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);
          }
        }
        next();
      }
      walkCB3(target, entries, processor, cb) {
        processor = processor.filterEntries(target, entries);
        let tasks = 1;
        const next = () => {
          if (--tasks === 0)
            cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
          if (__privateMethod(this, _GlobUtil_instances, ignored_fn).call(this, m))
            continue;
          tasks++;
          this.match(m, absolute, ifDir).then(() => next());
        }
        for (const [target2, patterns] of processor.subwalks.entries()) {
          tasks++;
          this.walkCB2(target2, patterns, processor.child(), next);
        }
        next();
      }
      walkCBSync(target, patterns, cb) {
        if (this.signal?.aborted)
          cb();
        this.walkCB2Sync(target, patterns, new processor_js_1.Processor(this.opts), cb);
      }
      walkCB2Sync(target, patterns, processor, cb) {
        if (__privateMethod(this, _GlobUtil_instances, childrenIgnored_fn).call(this, target))
          return cb();
        if (this.signal?.aborted)
          cb();
        if (this.paused) {
          this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
          return;
        }
        processor.processPatterns(target, patterns);
        let tasks = 1;
        const next = () => {
          if (--tasks === 0)
            cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
          if (__privateMethod(this, _GlobUtil_instances, ignored_fn).call(this, m))
            continue;
          this.matchSync(m, absolute, ifDir);
        }
        for (const t of processor.subwalkTargets()) {
          if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
            continue;
          }
          tasks++;
          const children = t.readdirSync();
          this.walkCB3Sync(t, children, processor, next);
        }
        next();
      }
      walkCB3Sync(target, entries, processor, cb) {
        processor = processor.filterEntries(target, entries);
        let tasks = 1;
        const next = () => {
          if (--tasks === 0)
            cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
          if (__privateMethod(this, _GlobUtil_instances, ignored_fn).call(this, m))
            continue;
          this.matchSync(m, absolute, ifDir);
        }
        for (const [target2, patterns] of processor.subwalks.entries()) {
          tasks++;
          this.walkCB2Sync(target2, patterns, processor.child(), next);
        }
        next();
      }
    };
    _onResume = new WeakMap();
    _ignore = new WeakMap();
    _sep = new WeakMap();
    _GlobUtil_instances = new WeakSet();
    ignored_fn = function(path) {
      return this.seen.has(path) || !!__privateGet(this, _ignore)?.ignored?.(path);
    };
    childrenIgnored_fn = function(path) {
      return !!__privateGet(this, _ignore)?.childrenIgnored?.(path);
    };
    exports2.GlobUtil = GlobUtil;
    var GlobWalker = class extends GlobUtil {
      constructor(patterns, path, opts) {
        super(patterns, path, opts);
        __publicField(this, "matches", /* @__PURE__ */ new Set());
      }
      matchEmit(e) {
        this.matches.add(e);
      }
      async walk() {
        if (this.signal?.aborted)
          throw this.signal.reason;
        if (this.path.isUnknown()) {
          await this.path.lstat();
        }
        await new Promise((res, rej) => {
          this.walkCB(this.path, this.patterns, () => {
            if (this.signal?.aborted) {
              rej(this.signal.reason);
            } else {
              res(this.matches);
            }
          });
        });
        return this.matches;
      }
      walkSync() {
        if (this.signal?.aborted)
          throw this.signal.reason;
        if (this.path.isUnknown()) {
          this.path.lstatSync();
        }
        this.walkCBSync(this.path, this.patterns, () => {
          if (this.signal?.aborted)
            throw this.signal.reason;
        });
        return this.matches;
      }
    };
    exports2.GlobWalker = GlobWalker;
    var GlobStream = class extends GlobUtil {
      constructor(patterns, path, opts) {
        super(patterns, path, opts);
        __publicField(this, "results");
        this.results = new minipass_1.Minipass({
          signal: this.signal,
          objectMode: true
        });
        this.results.on("drain", () => this.resume());
        this.results.on("resume", () => this.resume());
      }
      matchEmit(e) {
        this.results.write(e);
        if (!this.results.flowing)
          this.pause();
      }
      stream() {
        const target = this.path;
        if (target.isUnknown()) {
          target.lstat().then(() => {
            this.walkCB(target, this.patterns, () => this.results.end());
          });
        } else {
          this.walkCB(target, this.patterns, () => this.results.end());
        }
        return this.results;
      }
      streamSync() {
        if (this.path.isUnknown()) {
          this.path.lstatSync();
        }
        this.walkCBSync(this.path, this.patterns, () => this.results.end());
        return this.results;
      }
    };
    exports2.GlobStream = GlobStream;
  }
});

// node_modules/typeorm/node_modules/glob/dist/commonjs/glob.js
var require_glob = __commonJS({
  "node_modules/typeorm/node_modules/glob/dist/commonjs/glob.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Glob = void 0;
    var minimatch_1 = require_commonjs();
    var node_url_1 = require("node:url");
    var path_scurry_1 = require_commonjs4();
    var pattern_js_1 = require_pattern();
    var walker_js_1 = require_walker();
    var defaultPlatform = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
    var Glob = class {
      /**
       * All options are stored as properties on the `Glob` object.
       *
       * See {@link GlobOptions} for full options descriptions.
       *
       * Note that a previous `Glob` object can be passed as the
       * `GlobOptions` to another `Glob` instantiation to re-use settings
       * and caches with a new pattern.
       *
       * Traversal functions can be called multiple times to run the walk
       * again.
       */
      constructor(pattern, opts) {
        __publicField(this, "absolute");
        __publicField(this, "cwd");
        __publicField(this, "root");
        __publicField(this, "dot");
        __publicField(this, "dotRelative");
        __publicField(this, "follow");
        __publicField(this, "ignore");
        __publicField(this, "magicalBraces");
        __publicField(this, "mark");
        __publicField(this, "matchBase");
        __publicField(this, "maxDepth");
        __publicField(this, "nobrace");
        __publicField(this, "nocase");
        __publicField(this, "nodir");
        __publicField(this, "noext");
        __publicField(this, "noglobstar");
        __publicField(this, "pattern");
        __publicField(this, "platform");
        __publicField(this, "realpath");
        __publicField(this, "scurry");
        __publicField(this, "stat");
        __publicField(this, "signal");
        __publicField(this, "windowsPathsNoEscape");
        __publicField(this, "withFileTypes");
        __publicField(this, "includeChildMatches");
        /**
         * The options provided to the constructor.
         */
        __publicField(this, "opts");
        /**
         * An array of parsed immutable {@link Pattern} objects.
         */
        __publicField(this, "patterns");
        if (!opts)
          throw new TypeError("glob options required");
        this.withFileTypes = !!opts.withFileTypes;
        this.signal = opts.signal;
        this.follow = !!opts.follow;
        this.dot = !!opts.dot;
        this.dotRelative = !!opts.dotRelative;
        this.nodir = !!opts.nodir;
        this.mark = !!opts.mark;
        if (!opts.cwd) {
          this.cwd = "";
        } else if (opts.cwd instanceof URL || opts.cwd.startsWith("file://")) {
          opts.cwd = (0, node_url_1.fileURLToPath)(opts.cwd);
        }
        this.cwd = opts.cwd || "";
        this.root = opts.root;
        this.magicalBraces = !!opts.magicalBraces;
        this.nobrace = !!opts.nobrace;
        this.noext = !!opts.noext;
        this.realpath = !!opts.realpath;
        this.absolute = opts.absolute;
        this.includeChildMatches = opts.includeChildMatches !== false;
        this.noglobstar = !!opts.noglobstar;
        this.matchBase = !!opts.matchBase;
        this.maxDepth = typeof opts.maxDepth === "number" ? opts.maxDepth : Infinity;
        this.stat = !!opts.stat;
        this.ignore = opts.ignore;
        if (this.withFileTypes && this.absolute !== void 0) {
          throw new Error("cannot set absolute and withFileTypes:true");
        }
        if (typeof pattern === "string") {
          pattern = [pattern];
        }
        this.windowsPathsNoEscape = !!opts.windowsPathsNoEscape || opts.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
          pattern = pattern.map((p) => p.replace(/\\/g, "/"));
        }
        if (this.matchBase) {
          if (opts.noglobstar) {
            throw new TypeError("base matching requires globstar");
          }
          pattern = pattern.map((p) => p.includes("/") ? p : `./**/${p}`);
        }
        this.pattern = pattern;
        this.platform = opts.platform || defaultPlatform;
        this.opts = { ...opts, platform: this.platform };
        if (opts.scurry) {
          this.scurry = opts.scurry;
          if (opts.nocase !== void 0 && opts.nocase !== opts.scurry.nocase) {
            throw new Error("nocase option contradicts provided scurry option");
          }
        } else {
          const Scurry = opts.platform === "win32" ? path_scurry_1.PathScurryWin32 : opts.platform === "darwin" ? path_scurry_1.PathScurryDarwin : opts.platform ? path_scurry_1.PathScurryPosix : path_scurry_1.PathScurry;
          this.scurry = new Scurry(this.cwd, {
            nocase: opts.nocase,
            fs: opts.fs
          });
        }
        this.nocase = this.scurry.nocase;
        const nocaseMagicOnly = this.platform === "darwin" || this.platform === "win32";
        const mmo = {
          // default nocase based on platform
          ...opts,
          dot: this.dot,
          matchBase: this.matchBase,
          nobrace: this.nobrace,
          nocase: this.nocase,
          nocaseMagicOnly,
          nocomment: true,
          noext: this.noext,
          nonegate: true,
          optimizationLevel: 2,
          platform: this.platform,
          windowsPathsNoEscape: this.windowsPathsNoEscape,
          debug: !!this.opts.debug
        };
        const mms = this.pattern.map((p) => new minimatch_1.Minimatch(p, mmo));
        const [matchSet, globParts] = mms.reduce((set, m) => {
          set[0].push(...m.set);
          set[1].push(...m.globParts);
          return set;
        }, [[], []]);
        this.patterns = matchSet.map((set, i) => {
          const g = globParts[i];
          if (!g)
            throw new Error("invalid pattern object");
          return new pattern_js_1.Pattern(set, g, 0, this.platform);
        });
      }
      async walk() {
        return [
          ...await new walker_js_1.GlobWalker(this.patterns, this.scurry.cwd, {
            ...this.opts,
            maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
            platform: this.platform,
            nocase: this.nocase,
            includeChildMatches: this.includeChildMatches
          }).walk()
        ];
      }
      walkSync() {
        return [
          ...new walker_js_1.GlobWalker(this.patterns, this.scurry.cwd, {
            ...this.opts,
            maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
            platform: this.platform,
            nocase: this.nocase,
            includeChildMatches: this.includeChildMatches
          }).walkSync()
        ];
      }
      stream() {
        return new walker_js_1.GlobStream(this.patterns, this.scurry.cwd, {
          ...this.opts,
          maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
          platform: this.platform,
          nocase: this.nocase,
          includeChildMatches: this.includeChildMatches
        }).stream();
      }
      streamSync() {
        return new walker_js_1.GlobStream(this.patterns, this.scurry.cwd, {
          ...this.opts,
          maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
          platform: this.platform,
          nocase: this.nocase,
          includeChildMatches: this.includeChildMatches
        }).streamSync();
      }
      /**
       * Default sync iteration function. Returns a Generator that
       * iterates over the results.
       */
      iterateSync() {
        return this.streamSync()[Symbol.iterator]();
      }
      [Symbol.iterator]() {
        return this.iterateSync();
      }
      /**
       * Default async iteration function. Returns an AsyncGenerator that
       * iterates over the results.
       */
      iterate() {
        return this.stream()[Symbol.asyncIterator]();
      }
      [Symbol.asyncIterator]() {
        return this.iterate();
      }
    };
    exports2.Glob = Glob;
  }
});

// node_modules/typeorm/node_modules/glob/dist/commonjs/has-magic.js
var require_has_magic = __commonJS({
  "node_modules/typeorm/node_modules/glob/dist/commonjs/has-magic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasMagic = void 0;
    var minimatch_1 = require_commonjs();
    var hasMagic = (pattern, options = {}) => {
      if (!Array.isArray(pattern)) {
        pattern = [pattern];
      }
      for (const p of pattern) {
        if (new minimatch_1.Minimatch(p, options).hasMagic())
          return true;
      }
      return false;
    };
    exports2.hasMagic = hasMagic;
  }
});

// node_modules/typeorm/node_modules/glob/dist/commonjs/index.js
var require_commonjs5 = __commonJS({
  "node_modules/typeorm/node_modules/glob/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.glob = exports2.sync = exports2.iterate = exports2.iterateSync = exports2.stream = exports2.streamSync = exports2.Ignore = exports2.hasMagic = exports2.Glob = exports2.unescape = exports2.escape = void 0;
    exports2.globStreamSync = globStreamSync;
    exports2.globStream = globStream;
    exports2.globSync = globSync;
    exports2.globIterateSync = globIterateSync;
    exports2.globIterate = globIterate;
    var minimatch_1 = require_commonjs();
    var glob_js_1 = require_glob();
    var has_magic_js_1 = require_has_magic();
    var minimatch_2 = require_commonjs();
    Object.defineProperty(exports2, "escape", { enumerable: true, get: function() {
      return minimatch_2.escape;
    } });
    Object.defineProperty(exports2, "unescape", { enumerable: true, get: function() {
      return minimatch_2.unescape;
    } });
    var glob_js_2 = require_glob();
    Object.defineProperty(exports2, "Glob", { enumerable: true, get: function() {
      return glob_js_2.Glob;
    } });
    var has_magic_js_2 = require_has_magic();
    Object.defineProperty(exports2, "hasMagic", { enumerable: true, get: function() {
      return has_magic_js_2.hasMagic;
    } });
    var ignore_js_1 = require_ignore();
    Object.defineProperty(exports2, "Ignore", { enumerable: true, get: function() {
      return ignore_js_1.Ignore;
    } });
    function globStreamSync(pattern, options = {}) {
      return new glob_js_1.Glob(pattern, options).streamSync();
    }
    function globStream(pattern, options = {}) {
      return new glob_js_1.Glob(pattern, options).stream();
    }
    function globSync(pattern, options = {}) {
      return new glob_js_1.Glob(pattern, options).walkSync();
    }
    async function glob_(pattern, options = {}) {
      return new glob_js_1.Glob(pattern, options).walk();
    }
    function globIterateSync(pattern, options = {}) {
      return new glob_js_1.Glob(pattern, options).iterateSync();
    }
    function globIterate(pattern, options = {}) {
      return new glob_js_1.Glob(pattern, options).iterate();
    }
    exports2.streamSync = globStreamSync;
    exports2.stream = Object.assign(globStream, { sync: globStreamSync });
    exports2.iterateSync = globIterateSync;
    exports2.iterate = Object.assign(globIterate, {
      sync: globIterateSync
    });
    exports2.sync = Object.assign(globSync, {
      stream: globStreamSync,
      iterate: globIterateSync
    });
    exports2.glob = Object.assign(glob_, {
      glob: glob_,
      globSync,
      sync: exports2.sync,
      globStream,
      stream: exports2.stream,
      globStreamSync,
      streamSync: exports2.streamSync,
      globIterate,
      iterate: exports2.iterate,
      globIterateSync,
      iterateSync: exports2.iterateSync,
      Glob: glob_js_1.Glob,
      hasMagic: has_magic_js_1.hasMagic,
      escape: minimatch_1.escape,
      unescape: minimatch_1.unescape
    });
    exports2.glob.glob = exports2.glob;
  }
});

// node_modules/typeorm/util/DirectoryExportedClassesLoader.js
var require_DirectoryExportedClassesLoader = __commonJS({
  "node_modules/typeorm/util/DirectoryExportedClassesLoader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.importClassesFromDirectories = importClassesFromDirectories;
    exports2.importJsonsFromDirectories = importJsonsFromDirectories;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var glob = tslib_1.__importStar(require_commonjs5());
    var PlatformTools_1 = require_PlatformTools();
    var ImportUtils_1 = require_ImportUtils();
    var ObjectUtils_1 = require_ObjectUtils();
    var InstanceChecker_1 = require_InstanceChecker();
    async function importClassesFromDirectories(logger, directories, formats = [".js", ".mjs", ".cjs", ".ts", ".mts", ".cts"]) {
      const logLevel = "info";
      const classesNotFoundMessage = "No classes were found using the provided glob pattern: ";
      const classesFoundMessage = "All classes found using provided glob pattern";
      function loadFileClasses(exported, allLoaded) {
        if (typeof exported === "function" || InstanceChecker_1.InstanceChecker.isEntitySchema(exported)) {
          allLoaded.push(exported);
        } else if (Array.isArray(exported)) {
          exported.forEach((value) => loadFileClasses(value, allLoaded));
        } else if (ObjectUtils_1.ObjectUtils.isObject(exported)) {
          Object.values(exported).forEach((value) => loadFileClasses(value, allLoaded));
        }
        return allLoaded;
      }
      const allFiles = directories.reduce((allDirs, dir) => {
        return allDirs.concat(glob.sync(PlatformTools_1.PlatformTools.pathNormalize(dir)));
      }, []);
      if (directories.length > 0 && allFiles.length === 0) {
        logger.log(logLevel, `${classesNotFoundMessage} "${directories}"`);
      } else if (allFiles.length > 0) {
        logger.log(logLevel, `${classesFoundMessage} "${directories}" : "${allFiles}"`);
      }
      const dirPromises = allFiles.filter((file) => {
        const dtsExtension = file.substring(file.length - 5, file.length);
        return formats.indexOf(PlatformTools_1.PlatformTools.pathExtname(file)) !== -1 && dtsExtension !== ".d.ts";
      }).map(async (file) => {
        const [importOrRequireResult] = await (0, ImportUtils_1.importOrRequireFile)(PlatformTools_1.PlatformTools.pathResolve(file));
        return importOrRequireResult;
      });
      const dirs = await Promise.all(dirPromises);
      return loadFileClasses(dirs, []);
    }
    function importJsonsFromDirectories(directories, format = ".json") {
      const allFiles = directories.reduce((allDirs, dir) => {
        return allDirs.concat(glob.sync(PlatformTools_1.PlatformTools.pathNormalize(dir)));
      }, []);
      return allFiles.filter((file) => PlatformTools_1.PlatformTools.pathExtname(file) === format).map((file) => require(PlatformTools_1.PlatformTools.pathResolve(file)));
    }
  }
});

// node_modules/typeorm/container.js
var require_container = __commonJS({
  "node_modules/typeorm/container.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.useContainer = useContainer2;
    exports2.getFromContainer = getFromContainer2;
    var defaultContainer = new class {
      constructor() {
        this.instances = [];
      }
      get(someClass) {
        let instance = this.instances.find((i) => i.type === someClass);
        if (!instance) {
          instance = {
            type: someClass,
            object: new someClass()
          };
          this.instances.push(instance);
        }
        return instance.object;
      }
    }();
    var userContainer;
    var userContainerOptions;
    function useContainer2(iocContainer, options) {
      userContainer = iocContainer;
      userContainerOptions = options;
    }
    function getFromContainer2(someClass) {
      if (userContainer) {
        try {
          const instance = userContainer.get(someClass);
          if (instance)
            return instance;
          if (!userContainerOptions || !userContainerOptions.fallback)
            return instance;
        } catch (error) {
          if (!userContainerOptions || !userContainerOptions.fallbackOnErrors)
            throw error;
        }
      }
      return defaultContainer.get(someClass);
    }
  }
});

// node_modules/typeorm/metadata/ColumnMetadata.js
var require_ColumnMetadata = __commonJS({
  "node_modules/typeorm/metadata/ColumnMetadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ColumnMetadata = void 0;
    var OrmUtils_1 = require_OrmUtils();
    var ApplyValueTransformers_1 = require_ApplyValueTransformers();
    var ObjectUtils_1 = require_ObjectUtils();
    var InstanceChecker_1 = require_InstanceChecker();
    var ColumnMetadata = class {
      // ---------------------------------------------------------------------
      // Constructor
      // ---------------------------------------------------------------------
      constructor(options) {
        this["@instanceof"] = Symbol.for("ColumnMetadata");
        this.length = "";
        this.isPrimary = false;
        this.isGenerated = false;
        this.isNullable = false;
        this.isSelect = true;
        this.isInsert = true;
        this.isUpdate = true;
        this.zerofill = false;
        this.unsigned = false;
        this.isArray = false;
        this.isVirtual = false;
        this.isVirtualProperty = false;
        this.isDiscriminator = false;
        this.isTreeLevel = false;
        this.isCreateDate = false;
        this.isUpdateDate = false;
        this.isDeleteDate = false;
        this.isVersion = false;
        this.isObjectId = false;
        this.isNestedSetLeft = false;
        this.isNestedSetRight = false;
        this.isMaterializedPath = false;
        this.entityMetadata = options.entityMetadata;
        this.embeddedMetadata = options.embeddedMetadata;
        this.referencedColumn = options.referencedColumn;
        if (options.args.target)
          this.target = options.args.target;
        if (options.args.propertyName)
          this.propertyName = options.args.propertyName;
        if (options.args.options.name)
          this.givenDatabaseName = options.args.options.name;
        if (options.args.options.type)
          this.type = options.args.options.type;
        if (options.args.options.length)
          this.length = options.args.options.length ? options.args.options.length.toString() : "";
        if (options.args.options.width)
          this.width = options.args.options.width;
        if (options.args.options.charset)
          this.charset = options.args.options.charset;
        if (options.args.options.collation)
          this.collation = options.args.options.collation;
        if (options.args.options.primary)
          this.isPrimary = options.args.options.primary;
        if (options.args.options.default === null)
          this.isNullable = true;
        if (options.args.options.nullable !== void 0)
          this.isNullable = options.args.options.nullable;
        if (options.args.options.select !== void 0)
          this.isSelect = options.args.options.select;
        if (options.args.options.insert !== void 0)
          this.isInsert = options.args.options.insert;
        if (options.args.options.update !== void 0)
          this.isUpdate = options.args.options.update;
        if (options.args.options.readonly !== void 0)
          this.isUpdate = !options.args.options.readonly;
        if (options.args.options.comment)
          this.comment = options.args.options.comment;
        if (options.args.options.default !== void 0)
          this.default = options.args.options.default;
        if (options.args.options.onUpdate)
          this.onUpdate = options.args.options.onUpdate;
        if (options.args.options.generatedIdentity)
          this.generatedIdentity = options.args.options.generatedIdentity;
        if (options.args.options.scale !== null && options.args.options.scale !== void 0)
          this.scale = options.args.options.scale;
        if (options.args.options.zerofill) {
          this.zerofill = options.args.options.zerofill;
          this.unsigned = true;
        }
        if (options.args.options.unsigned)
          this.unsigned = options.args.options.unsigned;
        if (options.args.options.precision !== null)
          this.precision = options.args.options.precision;
        if (options.args.options.enum) {
          if (ObjectUtils_1.ObjectUtils.isObject(options.args.options.enum) && !Array.isArray(options.args.options.enum)) {
            this.enum = Object.keys(options.args.options.enum).filter((key) => isNaN(+key) && typeof options.args.options.enum[key] !== "function").map((key) => options.args.options.enum[key]);
          } else {
            this.enum = options.args.options.enum;
          }
        }
        if (options.args.options.enumName) {
          this.enumName = options.args.options.enumName;
        }
        if (options.args.options.primaryKeyConstraintName) {
          this.primaryKeyConstraintName = options.args.options.primaryKeyConstraintName;
        }
        if (options.args.options.foreignKeyConstraintName) {
          this.foreignKeyConstraintName = options.args.options.foreignKeyConstraintName;
        }
        if (options.args.options.asExpression) {
          this.asExpression = options.args.options.asExpression;
          this.generatedType = options.args.options.generatedType ? options.args.options.generatedType : "VIRTUAL";
        }
        if (options.args.options.hstoreType)
          this.hstoreType = options.args.options.hstoreType;
        if (options.args.options.array)
          this.isArray = options.args.options.array;
        if (options.args.mode) {
          this.isVirtualProperty = options.args.mode === "virtual-property";
          this.isVirtual = options.args.mode === "virtual";
          this.isTreeLevel = options.args.mode === "treeLevel";
          this.isCreateDate = options.args.mode === "createDate";
          this.isUpdateDate = options.args.mode === "updateDate";
          this.isDeleteDate = options.args.mode === "deleteDate";
          this.isVersion = options.args.mode === "version";
          this.isObjectId = options.args.mode === "objectId";
        }
        if (this.isVirtualProperty) {
          this.isInsert = false;
          this.isUpdate = false;
        }
        if (options.args.options.transformer)
          this.transformer = options.args.options.transformer;
        if (options.args.options.spatialFeatureType)
          this.spatialFeatureType = options.args.options.spatialFeatureType;
        if (options.args.options.srid !== void 0)
          this.srid = options.args.options.srid;
        if (options.args.options.query)
          this.query = options.args.options.query;
        if (this.isTreeLevel)
          this.type = options.connection.driver.mappedDataTypes.treeLevel;
        if (this.isCreateDate) {
          if (!this.type)
            this.type = options.connection.driver.mappedDataTypes.createDate;
          if (!this.default)
            this.default = () => options.connection.driver.mappedDataTypes.createDateDefault;
          if (this.precision === void 0 && options.args.options.precision === void 0 && options.connection.driver.mappedDataTypes.createDatePrecision)
            this.precision = options.connection.driver.mappedDataTypes.createDatePrecision;
        }
        if (this.isUpdateDate) {
          if (!this.type)
            this.type = options.connection.driver.mappedDataTypes.updateDate;
          if (!this.default)
            this.default = () => options.connection.driver.mappedDataTypes.updateDateDefault;
          if (!this.onUpdate)
            this.onUpdate = options.connection.driver.mappedDataTypes.updateDateDefault;
          if (this.precision === void 0 && options.args.options.precision === void 0 && options.connection.driver.mappedDataTypes.updateDatePrecision)
            this.precision = options.connection.driver.mappedDataTypes.updateDatePrecision;
        }
        if (this.isDeleteDate) {
          if (!this.type)
            this.type = options.connection.driver.mappedDataTypes.deleteDate;
          if (!this.isNullable)
            this.isNullable = options.connection.driver.mappedDataTypes.deleteDateNullable;
          if (this.precision === void 0 && options.args.options.precision === void 0 && options.connection.driver.mappedDataTypes.deleteDatePrecision)
            this.precision = options.connection.driver.mappedDataTypes.deleteDatePrecision;
        }
        if (this.isVersion)
          this.type = options.connection.driver.mappedDataTypes.version;
        if (options.closureType)
          this.closureType = options.closureType;
        if (options.nestedSetLeft)
          this.isNestedSetLeft = options.nestedSetLeft;
        if (options.nestedSetRight)
          this.isNestedSetRight = options.nestedSetRight;
        if (options.materializedPath)
          this.isMaterializedPath = options.materializedPath;
      }
      // ---------------------------------------------------------------------
      // Public Methods
      // ---------------------------------------------------------------------
      /**
       * Creates entity id map from the given entity ids array.
       */
      createValueMap(value, useDatabaseName = false) {
        if (this.embeddedMetadata) {
          const propertyNames = [...this.embeddedMetadata.parentPropertyNames];
          const extractEmbeddedColumnValue = (propertyNames2, map) => {
            const propertyName = propertyNames2.shift();
            if (propertyName) {
              map[propertyName] = {};
              extractEmbeddedColumnValue(propertyNames2, map[propertyName]);
              return map;
            }
            if ((this.generationStrategy === "increment" || this.generationStrategy === "rowid") && this.type === "bigint" && value !== null)
              value = String(value);
            map[useDatabaseName ? this.databaseName : this.propertyName] = value;
            return map;
          };
          return extractEmbeddedColumnValue(propertyNames, {});
        } else {
          if ((this.generationStrategy === "increment" || this.generationStrategy === "rowid") && this.type === "bigint" && value !== null)
            value = String(value);
          return {
            [useDatabaseName ? this.databaseName : this.propertyName]: value
          };
        }
      }
      /**
       * Extracts column value and returns its column name with this value in a literal object.
       * If column is in embedded (or recursive embedded) it returns complex literal object.
       *
       * Examples what this method can return depend if this column is in embeds.
       * { id: 1 } or { title: "hello" }, { counters: { code: 1 } }, { data: { information: { counters: { code: 1 } } } }
       */
      getEntityValueMap(entity, options) {
        const returnNulls = false;
        if (this.embeddedMetadata) {
          const propertyNames = [...this.embeddedMetadata.parentPropertyNames];
          const isEmbeddedArray = this.embeddedMetadata.isArray;
          const extractEmbeddedColumnValue = (propertyNames2, value) => {
            if (value === void 0) {
              return {};
            }
            const propertyName = propertyNames2.shift();
            if (propertyName) {
              const submap = extractEmbeddedColumnValue(propertyNames2, value[propertyName]);
              if (Object.keys(submap).length > 0) {
                return { [propertyName]: submap };
              }
              return {};
            }
            if (isEmbeddedArray && Array.isArray(value)) {
              return value.map((v) => ({
                [this.propertyName]: v[this.propertyName]
              }));
            }
            if (value[this.propertyName] !== void 0 && (returnNulls === false || value[this.propertyName] !== null)) {
              return { [this.propertyName]: value[this.propertyName] };
            }
            return {};
          };
          const map = extractEmbeddedColumnValue(propertyNames, entity);
          return Object.keys(map).length > 0 ? map : void 0;
        } else {
          if (this.relationMetadata && !Object.getOwnPropertyDescriptor(entity, this.relationMetadata.propertyName)?.get && entity[this.relationMetadata.propertyName] && ObjectUtils_1.ObjectUtils.isObject(entity[this.relationMetadata.propertyName])) {
            if (this.relationMetadata.joinColumns.length > 1) {
              const map = this.relationMetadata.joinColumns.reduce((map2, joinColumn) => {
                const value = joinColumn.referencedColumn.getEntityValueMap(entity[this.relationMetadata.propertyName]);
                if (value === void 0)
                  return map2;
                return OrmUtils_1.OrmUtils.mergeDeep(map2, value);
              }, {});
              if (Object.keys(map).length > 0)
                return { [this.propertyName]: map };
            } else {
              const value = this.relationMetadata.joinColumns[0].referencedColumn.getEntityValue(entity[this.relationMetadata.propertyName]);
              if (value) {
                return { [this.propertyName]: value };
              }
            }
            return void 0;
          } else {
            if (entity[this.propertyName] !== void 0 && (returnNulls === false || entity[this.propertyName] !== null)) {
              return { [this.propertyName]: entity[this.propertyName] };
            }
            return void 0;
          }
        }
      }
      /**
       * Extracts column value from the given entity.
       * If column is in embedded (or recursive embedded) it extracts its value from there.
       */
      getEntityValue(entity, transform = false) {
        if (entity === void 0 || entity === null)
          return void 0;
        let value = void 0;
        if (this.embeddedMetadata) {
          const propertyNames = [...this.embeddedMetadata.parentPropertyNames];
          const isEmbeddedArray = this.embeddedMetadata.isArray;
          const extractEmbeddedColumnValue = (propertyNames2, value2) => {
            const propertyName = propertyNames2.shift();
            return propertyName && value2 ? extractEmbeddedColumnValue(propertyNames2, value2[propertyName]) : value2;
          };
          const embeddedObject = extractEmbeddedColumnValue(propertyNames, entity);
          if (embeddedObject) {
            if (this.relationMetadata && this.referencedColumn) {
              const relatedEntity = this.relationMetadata.getEntityValue(embeddedObject);
              if (relatedEntity && ObjectUtils_1.ObjectUtils.isObject(relatedEntity) && !InstanceChecker_1.InstanceChecker.isFindOperator(relatedEntity) && !Buffer.isBuffer(relatedEntity)) {
                value = this.referencedColumn.getEntityValue(relatedEntity);
              } else if (embeddedObject[this.propertyName] && ObjectUtils_1.ObjectUtils.isObject(embeddedObject[this.propertyName]) && !InstanceChecker_1.InstanceChecker.isFindOperator(embeddedObject[this.propertyName]) && !Buffer.isBuffer(embeddedObject[this.propertyName]) && !(embeddedObject[this.propertyName] instanceof Date)) {
                value = this.referencedColumn.getEntityValue(embeddedObject[this.propertyName]);
              } else {
                value = embeddedObject[this.propertyName];
              }
            } else if (this.referencedColumn) {
              value = this.referencedColumn.getEntityValue(embeddedObject[this.propertyName]);
            } else if (isEmbeddedArray && Array.isArray(embeddedObject)) {
              value = embeddedObject.map((o) => o[this.propertyName]);
            } else {
              value = embeddedObject[this.propertyName];
            }
          }
        } else {
          if (this.relationMetadata && this.referencedColumn) {
            const relatedEntity = this.relationMetadata.getEntityValue(entity);
            if (relatedEntity && ObjectUtils_1.ObjectUtils.isObject(relatedEntity) && !InstanceChecker_1.InstanceChecker.isFindOperator(relatedEntity) && !(typeof relatedEntity === "function") && !Buffer.isBuffer(relatedEntity)) {
              value = this.referencedColumn.getEntityValue(relatedEntity);
            } else if (entity[this.propertyName] && ObjectUtils_1.ObjectUtils.isObject(entity[this.propertyName]) && !InstanceChecker_1.InstanceChecker.isFindOperator(entity[this.propertyName]) && !(typeof entity[this.propertyName] === "function") && !Buffer.isBuffer(entity[this.propertyName]) && !(entity[this.propertyName] instanceof Date)) {
              value = this.referencedColumn.getEntityValue(entity[this.propertyName]);
            } else {
              value = entity[this.propertyName];
            }
          } else if (this.referencedColumn) {
            value = this.referencedColumn.getEntityValue(entity[this.propertyName]);
          } else {
            value = entity[this.propertyName];
          }
        }
        if (transform && this.transformer)
          value = ApplyValueTransformers_1.ApplyValueTransformers.transformTo(this.transformer, value);
        return value;
      }
      /**
       * Sets given entity's column value.
       * Using of this method helps to set entity relation's value of the lazy and non-lazy relations.
       */
      setEntityValue(entity, value) {
        if (this.embeddedMetadata) {
          const extractEmbeddedColumnValue = (embeddedMetadatas, map) => {
            const embeddedMetadata = embeddedMetadatas.shift();
            if (embeddedMetadata) {
              if (!map[embeddedMetadata.propertyName])
                map[embeddedMetadata.propertyName] = embeddedMetadata.create();
              extractEmbeddedColumnValue(embeddedMetadatas, map[embeddedMetadata.propertyName]);
              return map;
            }
            map[this.propertyName] = value;
            return map;
          };
          return extractEmbeddedColumnValue([...this.embeddedMetadata.embeddedMetadataTree], entity);
        } else {
          if (!this.entityMetadata.isJunction && this.isVirtual && this.referencedColumn && this.referencedColumn.propertyName !== this.propertyName) {
            if (!(this.propertyName in entity)) {
              entity[this.propertyName] = {};
            }
            entity[this.propertyName][this.referencedColumn.propertyName] = value;
          } else {
            entity[this.propertyName] = value;
          }
        }
      }
      /**
       * Compares given entity's column value with a given value.
       */
      compareEntityValue(entity, valueToCompareWith) {
        const columnValue = this.getEntityValue(entity);
        if (typeof columnValue?.equals === "function") {
          return columnValue.equals(valueToCompareWith);
        }
        return columnValue === valueToCompareWith;
      }
      // ---------------------------------------------------------------------
      // Builder Methods
      // ---------------------------------------------------------------------
      build(connection) {
        this.propertyPath = this.buildPropertyPath();
        this.propertyAliasName = this.propertyPath.replace(".", "_");
        this.databaseName = this.buildDatabaseName(connection);
        this.databasePath = this.buildDatabasePath();
        this.databaseNameWithoutPrefixes = connection.namingStrategy.columnName(this.propertyName, this.givenDatabaseName, []);
        return this;
      }
      buildPropertyPath() {
        let path = "";
        if (this.embeddedMetadata && this.embeddedMetadata.parentPropertyNames.length)
          path = this.embeddedMetadata.parentPropertyNames.join(".") + ".";
        path += this.propertyName;
        if (!this.entityMetadata.isJunction && this.isVirtual && this.referencedColumn && this.referencedColumn.propertyName !== this.propertyName)
          path += "." + this.referencedColumn.propertyName;
        return path;
      }
      buildDatabasePath() {
        let path = "";
        if (this.embeddedMetadata && this.embeddedMetadata.parentPropertyNames.length)
          path = this.embeddedMetadata.parentPropertyNames.join(".") + ".";
        path += this.databaseName;
        if (!this.entityMetadata.isJunction && this.isVirtual && this.referencedColumn && this.referencedColumn.databaseName !== this.databaseName)
          path += "." + this.referencedColumn.databaseName;
        return path;
      }
      buildDatabaseName(connection) {
        let propertyNames = this.embeddedMetadata ? this.embeddedMetadata.parentPrefixes : [];
        if (connection.driver.options.type === "mongodb")
          propertyNames = [];
        return connection.namingStrategy.columnName(this.propertyName, this.givenDatabaseName, propertyNames);
      }
    };
    exports2.ColumnMetadata = ColumnMetadata;
  }
});

// node_modules/typeorm/metadata/IndexMetadata.js
var require_IndexMetadata = __commonJS({
  "node_modules/typeorm/metadata/IndexMetadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IndexMetadata = void 0;
    var error_1 = require_error();
    var IndexMetadata = class {
      // ---------------------------------------------------------------------
      // Constructor
      // ---------------------------------------------------------------------
      constructor(options) {
        this.isUnique = false;
        this.isSpatial = false;
        this.isFulltext = false;
        this.isNullFiltered = false;
        this.synchronize = true;
        this.columns = [];
        this.columnNamesWithOrderingMap = {};
        this.entityMetadata = options.entityMetadata;
        this.embeddedMetadata = options.embeddedMetadata;
        if (options.columns)
          this.columns = options.columns;
        if (options.args) {
          this.target = options.args.target;
          if (options.args.synchronize !== null && options.args.synchronize !== void 0)
            this.synchronize = options.args.synchronize;
          this.isUnique = !!options.args.unique;
          this.isSpatial = !!options.args.spatial;
          this.isFulltext = !!options.args.fulltext;
          this.isNullFiltered = !!options.args.nullFiltered;
          this.parser = options.args.parser;
          this.where = options.args.where;
          this.isSparse = options.args.sparse;
          this.isBackground = options.args.background;
          this.isConcurrent = options.args.concurrent;
          this.expireAfterSeconds = options.args.expireAfterSeconds;
          this.givenName = options.args.name;
          this.givenColumnNames = options.args.columns;
        }
      }
      // ---------------------------------------------------------------------
      // Public Build Methods
      // ---------------------------------------------------------------------
      /**
       * Builds some depend index properties.
       * Must be called after all entity metadata's properties map, columns and relations are built.
       */
      build(namingStrategy) {
        if (this.synchronize === false) {
          this.name = this.givenName;
          return this;
        }
        const map = {};
        if (this.givenColumnNames) {
          let columnPropertyPaths = [];
          if (Array.isArray(this.givenColumnNames)) {
            columnPropertyPaths = this.givenColumnNames.map((columnName) => {
              if (this.embeddedMetadata)
                return this.embeddedMetadata.propertyPath + "." + columnName;
              return columnName.trim();
            });
            columnPropertyPaths.forEach((propertyPath) => map[propertyPath] = 1);
          } else {
            const columnsFnResult = this.givenColumnNames(this.entityMetadata.propertiesMap);
            if (Array.isArray(columnsFnResult)) {
              columnPropertyPaths = columnsFnResult.map((i) => String(i));
              columnPropertyPaths.forEach((name) => map[name] = 1);
            } else {
              columnPropertyPaths = Object.keys(columnsFnResult).map((i) => String(i));
              Object.keys(columnsFnResult).forEach((columnName) => map[columnName] = columnsFnResult[columnName]);
            }
          }
          this.columns = columnPropertyPaths.map((propertyPath) => {
            const columnWithSameName = this.entityMetadata.columns.find((column) => column.propertyPath === propertyPath);
            if (columnWithSameName) {
              return [columnWithSameName];
            }
            const relationWithSameName = this.entityMetadata.relations.find((relation) => relation.isWithJoinColumn && relation.propertyName === propertyPath);
            if (relationWithSameName) {
              return relationWithSameName.joinColumns;
            }
            const indexName = this.givenName ? '"' + this.givenName + '" ' : "";
            const entityName = this.entityMetadata.targetName;
            throw new error_1.TypeORMError(`Index ${indexName}contains column that is missing in the entity (${entityName}): ` + propertyPath);
          }).reduce((a, b) => a.concat(b));
        }
        this.columnNamesWithOrderingMap = Object.keys(map).reduce((updatedMap, key) => {
          const column = this.entityMetadata.columns.find((column2) => column2.propertyPath === key);
          if (column)
            updatedMap[column.databasePath] = map[key];
          return updatedMap;
        }, {});
        this.name = this.givenName ? this.givenName : namingStrategy.indexName(this.entityMetadata.tableName, this.columns.map((column) => column.databaseName), this.where);
        return this;
      }
    };
    exports2.IndexMetadata = IndexMetadata;
  }
});

// node_modules/typeorm/metadata/RelationMetadata.js
var require_RelationMetadata = __commonJS({
  "node_modules/typeorm/metadata/RelationMetadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RelationMetadata = void 0;
    var EntityMetadata_1 = require_EntityMetadata();
    var error_1 = require_error();
    var ObjectUtils_1 = require_ObjectUtils();
    var InstanceChecker_1 = require_InstanceChecker();
    var RelationMetadata = class {
      // ---------------------------------------------------------------------
      // Constructor
      // ---------------------------------------------------------------------
      constructor(options) {
        this.isTreeParent = false;
        this.isTreeChildren = false;
        this.isPrimary = false;
        this.isLazy = false;
        this.isEager = false;
        this.persistenceEnabled = true;
        this.isCascadeInsert = false;
        this.isCascadeUpdate = false;
        this.isCascadeRemove = false;
        this.isCascadeSoftRemove = false;
        this.isCascadeRecover = false;
        this.isNullable = true;
        this.createForeignKeyConstraints = true;
        this.isOwning = false;
        this.isOneToOne = false;
        this.isOneToOneOwner = false;
        this.isWithJoinColumn = false;
        this.isOneToOneNotOwner = false;
        this.isOneToMany = false;
        this.isManyToOne = false;
        this.isManyToMany = false;
        this.isManyToManyOwner = false;
        this.isManyToManyNotOwner = false;
        this.foreignKeys = [];
        this.joinColumns = [];
        this.inverseJoinColumns = [];
        this.entityMetadata = options.entityMetadata;
        this.embeddedMetadata = options.embeddedMetadata;
        const args = options.args;
        this.target = args.target;
        this.propertyName = args.propertyName;
        this.relationType = args.relationType;
        if (args.inverseSideProperty)
          this.givenInverseSidePropertyFactory = args.inverseSideProperty;
        this.isLazy = args.isLazy || false;
        this.isCascadeInsert = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf("insert") !== -1;
        this.isCascadeUpdate = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf("update") !== -1;
        this.isCascadeRemove = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf("remove") !== -1;
        this.isCascadeSoftRemove = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf("soft-remove") !== -1;
        this.isCascadeRecover = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf("recover") !== -1;
        this.isNullable = args.options.nullable === false || this.isPrimary ? false : true;
        this.onDelete = args.options.onDelete;
        this.onUpdate = args.options.onUpdate;
        this.deferrable = args.options.deferrable;
        this.createForeignKeyConstraints = args.options.createForeignKeyConstraints === false ? false : true;
        this.isEager = args.options.eager || false;
        this.persistenceEnabled = args.options.persistence === false ? false : true;
        this.orphanedRowAction = args.options.orphanedRowAction || "nullify";
        this.isTreeParent = args.isTreeParent || false;
        this.isTreeChildren = args.isTreeChildren || false;
        if (typeof args.type === "function") {
          this.type = typeof args.type === "function" ? args.type() : args.type;
        } else if (InstanceChecker_1.InstanceChecker.isEntitySchema(args.type)) {
          this.type = args.type.options.name;
        } else if (ObjectUtils_1.ObjectUtils.isObject(args.type) && typeof args.type.name === "string") {
          this.type = args.type.name;
        } else {
          this.type = args.type;
        }
        this.isOneToOne = this.relationType === "one-to-one";
        this.isOneToMany = this.relationType === "one-to-many";
        this.isManyToOne = this.relationType === "many-to-one";
        this.isManyToMany = this.relationType === "many-to-many";
        this.isOneToOneNotOwner = this.isOneToOne ? true : false;
        this.isManyToManyNotOwner = this.isManyToMany ? true : false;
      }
      // ---------------------------------------------------------------------
      // Public Methods
      // ---------------------------------------------------------------------
      /**
       * Creates join column ids map from the given related entity ids array.
       */
      getRelationIdMap(entity) {
        const joinColumns = this.isOwning ? this.joinColumns : this.inverseRelation.joinColumns;
        const referencedColumns = joinColumns.map((joinColumn) => joinColumn.referencedColumn);
        return EntityMetadata_1.EntityMetadata.getValueMap(entity, referencedColumns);
      }
      /**
       * Ensures that given object is an entity id map.
       * If given id is an object then it means its already id map.
       * If given id isn't an object then it means its a value of the id column
       * and it creates a new id map with this value and name of the primary column.
       */
      ensureRelationIdMap(id) {
        if (ObjectUtils_1.ObjectUtils.isObject(id))
          return id;
        const joinColumns = this.isOwning ? this.joinColumns : this.inverseRelation.joinColumns;
        const referencedColumns = joinColumns.map((joinColumn) => joinColumn.referencedColumn);
        if (referencedColumns.length > 1)
          throw new error_1.TypeORMError(`Cannot create relation id map for a single value because relation contains multiple referenced columns.`);
        return referencedColumns[0].createValueMap(id);
      }
      /**
       * Extracts column value from the given entity.
       * If column is in embedded (or recursive embedded) it extracts its value from there.
       */
      getEntityValue(entity, getLazyRelationsPromiseValue = false) {
        if (entity === null || entity === void 0)
          return void 0;
        if (this.embeddedMetadata) {
          const propertyNames = [...this.embeddedMetadata.parentPropertyNames];
          const extractEmbeddedColumnValue = (propertyNames2, value) => {
            const propertyName = propertyNames2.shift();
            if (propertyName) {
              if (value[propertyName]) {
                return extractEmbeddedColumnValue(propertyNames2, value[propertyName]);
              }
              return void 0;
            }
            return value;
          };
          const embeddedObject = extractEmbeddedColumnValue(propertyNames, entity);
          if (this.isLazy) {
            if (embeddedObject["__" + this.propertyName + "__"] !== void 0)
              return embeddedObject["__" + this.propertyName + "__"];
            if (getLazyRelationsPromiseValue === true)
              return embeddedObject[this.propertyName];
            return void 0;
          }
          return embeddedObject ? embeddedObject[this.isLazy ? "__" + this.propertyName + "__" : this.propertyName] : void 0;
        } else {
          if (this.isLazy) {
            if (entity["__" + this.propertyName + "__"] !== void 0)
              return entity["__" + this.propertyName + "__"];
            if (getLazyRelationsPromiseValue === true)
              return entity[this.propertyName];
            return void 0;
          }
          return entity[this.propertyName];
        }
      }
      /**
       * Sets given entity's relation's value.
       * Using of this method helps to set entity relation's value of the lazy and non-lazy relations.
       *
       * If merge is set to true, it merges given value into currently
       */
      setEntityValue(entity, value) {
        const propertyName = this.isLazy ? "__" + this.propertyName + "__" : this.propertyName;
        if (this.embeddedMetadata) {
          const extractEmbeddedColumnValue = (embeddedMetadatas, map) => {
            const embeddedMetadata = embeddedMetadatas.shift();
            if (embeddedMetadata) {
              if (!map[embeddedMetadata.propertyName])
                map[embeddedMetadata.propertyName] = embeddedMetadata.create();
              extractEmbeddedColumnValue(embeddedMetadatas, map[embeddedMetadata.propertyName]);
              return map;
            }
            map[propertyName] = value;
            return map;
          };
          return extractEmbeddedColumnValue([...this.embeddedMetadata.embeddedMetadataTree], entity);
        } else {
          entity[propertyName] = value;
        }
      }
      /**
       * Creates entity id map from the given entity ids array.
       */
      createValueMap(value) {
        if (this.embeddedMetadata) {
          const propertyNames = [...this.embeddedMetadata.parentPropertyNames];
          const extractEmbeddedColumnValue = (propertyNames2, map) => {
            const propertyName = propertyNames2.shift();
            if (propertyName) {
              map[propertyName] = {};
              extractEmbeddedColumnValue(propertyNames2, map[propertyName]);
              return map;
            }
            map[this.propertyName] = value;
            return map;
          };
          return extractEmbeddedColumnValue(propertyNames, {});
        } else {
          return { [this.propertyName]: value };
        }
      }
      // ---------------------------------------------------------------------
      // Builder Methods
      // ---------------------------------------------------------------------
      /**
       * Builds some depend relation metadata properties.
       * This builder method should be used only after embedded metadata tree was build.
       */
      build() {
        this.propertyPath = this.buildPropertyPath();
      }
      /**
       * Registers given foreign keys in the relation.
       * This builder method should be used to register foreign key in the relation.
       */
      registerForeignKeys(...foreignKeys) {
        this.foreignKeys.push(...foreignKeys);
      }
      /**
       * Registers given join columns in the relation.
       * This builder method should be used to register join column in the relation.
       */
      registerJoinColumns(joinColumns = [], inverseJoinColumns = []) {
        this.joinColumns = joinColumns;
        this.inverseJoinColumns = inverseJoinColumns;
        this.isOwning = this.isManyToOne || (this.isManyToMany || this.isOneToOne) && this.joinColumns.length > 0;
        this.isOneToOneOwner = this.isOneToOne && this.isOwning;
        this.isOneToOneNotOwner = this.isOneToOne && !this.isOwning;
        this.isManyToManyOwner = this.isManyToMany && this.isOwning;
        this.isManyToManyNotOwner = this.isManyToMany && !this.isOwning;
        this.isWithJoinColumn = this.isManyToOne || this.isOneToOneOwner;
      }
      /**
       * Registers a given junction entity metadata.
       * This builder method can be called after junction entity metadata for the many-to-many relation was created.
       */
      registerJunctionEntityMetadata(junctionEntityMetadata) {
        this.junctionEntityMetadata = junctionEntityMetadata;
        this.joinTableName = junctionEntityMetadata.tableName;
        if (this.inverseRelation) {
          this.inverseRelation.junctionEntityMetadata = junctionEntityMetadata;
          this.joinTableName = junctionEntityMetadata.tableName;
        }
      }
      /**
       * Builds inverse side property path based on given inverse side property factory.
       * This builder method should be used only after properties map of the inverse entity metadata was build.
       */
      buildInverseSidePropertyPath() {
        if (this.givenInverseSidePropertyFactory) {
          const ownerEntityPropertiesMap = this.inverseEntityMetadata.propertiesMap;
          if (typeof this.givenInverseSidePropertyFactory === "function")
            return this.givenInverseSidePropertyFactory(ownerEntityPropertiesMap);
          if (typeof this.givenInverseSidePropertyFactory === "string")
            return this.givenInverseSidePropertyFactory;
        } else if (this.isTreeParent && this.entityMetadata.treeChildrenRelation) {
          return this.entityMetadata.treeChildrenRelation.propertyName;
        } else if (this.isTreeChildren && this.entityMetadata.treeParentRelation) {
          return this.entityMetadata.treeParentRelation.propertyName;
        }
        return "";
      }
      /**
       * Builds relation's property path based on its embedded tree.
       */
      buildPropertyPath() {
        if (!this.embeddedMetadata || !this.embeddedMetadata.parentPropertyNames.length)
          return this.propertyName;
        return this.embeddedMetadata.parentPropertyNames.join(".") + "." + this.propertyName;
      }
    };
    exports2.RelationMetadata = RelationMetadata;
  }
});

// node_modules/typeorm/metadata/EmbeddedMetadata.js
var require_EmbeddedMetadata = __commonJS({
  "node_modules/typeorm/metadata/EmbeddedMetadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EmbeddedMetadata = void 0;
    var error_1 = require_error();
    var EmbeddedMetadata = class {
      // ---------------------------------------------------------------------
      // Constructor
      // ---------------------------------------------------------------------
      constructor(options) {
        this.columns = [];
        this.relations = [];
        this.listeners = [];
        this.indices = [];
        this.uniques = [];
        this.relationIds = [];
        this.relationCounts = [];
        this.embeddeds = [];
        this.isAlwaysUsingConstructor = true;
        this.isArray = false;
        this.parentPropertyNames = [];
        this.parentPrefixes = [];
        this.embeddedMetadataTree = [];
        this.columnsFromTree = [];
        this.relationsFromTree = [];
        this.listenersFromTree = [];
        this.indicesFromTree = [];
        this.uniquesFromTree = [];
        this.relationIdsFromTree = [];
        this.relationCountsFromTree = [];
        this.entityMetadata = options.entityMetadata;
        this.type = options.args.type();
        this.propertyName = options.args.propertyName;
        this.customPrefix = options.args.prefix;
        this.isArray = options.args.isArray;
      }
      // ---------------------------------------------------------------------
      // Public Methods
      // ---------------------------------------------------------------------
      /**
       * Creates a new embedded object.
       */
      create(options) {
        if (!(typeof this.type === "function")) {
          return {};
        }
        if (options?.fromDeserializer || !this.isAlwaysUsingConstructor) {
          return Object.create(this.type.prototype);
        } else {
          return new this.type();
        }
      }
      // ---------------------------------------------------------------------
      // Builder Methods
      // ---------------------------------------------------------------------
      build(connection) {
        this.embeddeds.forEach((embedded) => embedded.build(connection));
        this.prefix = this.buildPrefix(connection);
        this.parentPropertyNames = this.buildParentPropertyNames();
        this.parentPrefixes = this.buildParentPrefixes();
        this.propertyPath = this.parentPropertyNames.join(".");
        this.embeddedMetadataTree = this.buildEmbeddedMetadataTree();
        this.columnsFromTree = this.buildColumnsFromTree();
        this.relationsFromTree = this.buildRelationsFromTree();
        this.listenersFromTree = this.buildListenersFromTree();
        this.indicesFromTree = this.buildIndicesFromTree();
        this.uniquesFromTree = this.buildUniquesFromTree();
        this.relationIdsFromTree = this.buildRelationIdsFromTree();
        this.relationCountsFromTree = this.buildRelationCountsFromTree();
        if (connection.options.entitySkipConstructor) {
          this.isAlwaysUsingConstructor = !connection.options.entitySkipConstructor;
        }
        return this;
      }
      // ---------------------------------------------------------------------
      // Protected Methods
      // ---------------------------------------------------------------------
      buildPartialPrefix() {
        if (this.customPrefix === void 0 || this.customPrefix === true) {
          return [this.propertyName];
        }
        if (this.customPrefix === "" || this.customPrefix === false) {
          return [];
        }
        if (typeof this.customPrefix === "string") {
          return [this.customPrefix];
        }
        throw new error_1.TypeORMError(`Invalid prefix option given for ${this.entityMetadata.targetName}#${this.propertyName}`);
      }
      buildPrefix(connection) {
        if (connection.driver.options.type === "mongodb")
          return this.propertyName;
        const prefixes = [];
        if (this.parentEmbeddedMetadata)
          prefixes.push(this.parentEmbeddedMetadata.buildPrefix(connection));
        prefixes.push(...this.buildPartialPrefix());
        return prefixes.join("_");
      }
      buildParentPropertyNames() {
        return this.parentEmbeddedMetadata ? this.parentEmbeddedMetadata.buildParentPropertyNames().concat(this.propertyName) : [this.propertyName];
      }
      buildParentPrefixes() {
        return this.parentEmbeddedMetadata ? this.parentEmbeddedMetadata.buildParentPrefixes().concat(this.buildPartialPrefix()) : this.buildPartialPrefix();
      }
      buildEmbeddedMetadataTree() {
        return this.parentEmbeddedMetadata ? this.parentEmbeddedMetadata.buildEmbeddedMetadataTree().concat(this) : [this];
      }
      buildColumnsFromTree() {
        return this.embeddeds.reduce((columns, embedded) => columns.concat(embedded.buildColumnsFromTree()), this.columns);
      }
      buildRelationsFromTree() {
        return this.embeddeds.reduce((relations, embedded) => relations.concat(embedded.buildRelationsFromTree()), this.relations);
      }
      buildListenersFromTree() {
        return this.embeddeds.reduce((relations, embedded) => relations.concat(embedded.buildListenersFromTree()), this.listeners);
      }
      buildIndicesFromTree() {
        return this.embeddeds.reduce((relations, embedded) => relations.concat(embedded.buildIndicesFromTree()), this.indices);
      }
      buildUniquesFromTree() {
        return this.embeddeds.reduce((relations, embedded) => relations.concat(embedded.buildUniquesFromTree()), this.uniques);
      }
      buildRelationIdsFromTree() {
        return this.embeddeds.reduce((relations, embedded) => relations.concat(embedded.buildRelationIdsFromTree()), this.relationIds);
      }
      buildRelationCountsFromTree() {
        return this.embeddeds.reduce((relations, embedded) => relations.concat(embedded.buildRelationCountsFromTree()), this.relationCounts);
      }
    };
    exports2.EmbeddedMetadata = EmbeddedMetadata;
  }
});

// node_modules/typeorm/metadata/RelationIdMetadata.js
var require_RelationIdMetadata = __commonJS({
  "node_modules/typeorm/metadata/RelationIdMetadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RelationIdMetadata = void 0;
    var error_1 = require_error();
    var RelationIdMetadata = class {
      // ---------------------------------------------------------------------
      // Constructor
      // ---------------------------------------------------------------------
      constructor(options) {
        this.entityMetadata = options.entityMetadata;
        this.target = options.args.target;
        this.propertyName = options.args.propertyName;
        this.relationNameOrFactory = options.args.relation;
        this.alias = options.args.alias;
        this.queryBuilderFactory = options.args.queryBuilderFactory;
      }
      // ---------------------------------------------------------------------
      // Public Methods
      // ---------------------------------------------------------------------
      /**
       * Sets relation id value from the given entity.
       *
       * todo: make it to work in embeds as well.
       */
      setValue(entity) {
        const inverseEntity = this.relation.getEntityValue(entity);
        if (Array.isArray(inverseEntity)) {
          entity[this.propertyName] = inverseEntity.map((item) => {
            return this.relation.inverseEntityMetadata.getEntityIdMixedMap(item);
          }).filter((item) => item !== null && item !== void 0);
        } else {
          const value = this.relation.inverseEntityMetadata.getEntityIdMixedMap(inverseEntity);
          if (value !== void 0)
            entity[this.propertyName] = value;
        }
      }
      // ---------------------------------------------------------------------
      // Public Builder Methods
      // ---------------------------------------------------------------------
      /**
       * Builds some depend relation id properties.
       * This builder method should be used only after entity metadata, its properties map and all relations are build.
       */
      build() {
        const propertyPath = typeof this.relationNameOrFactory === "function" ? this.relationNameOrFactory(this.entityMetadata.propertiesMap) : this.relationNameOrFactory;
        const relation = this.entityMetadata.findRelationWithPropertyPath(propertyPath);
        if (!relation)
          throw new error_1.TypeORMError(`Cannot find relation ${propertyPath}. Wrong relation specified for @RelationId decorator.`);
        this.relation = relation;
      }
    };
    exports2.RelationIdMetadata = RelationIdMetadata;
  }
});

// node_modules/typeorm/metadata/RelationCountMetadata.js
var require_RelationCountMetadata = __commonJS({
  "node_modules/typeorm/metadata/RelationCountMetadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RelationCountMetadata = void 0;
    var error_1 = require_error();
    var RelationCountMetadata = class {
      // ---------------------------------------------------------------------
      // Constructor
      // ---------------------------------------------------------------------
      constructor(options) {
        this.entityMetadata = options.entityMetadata;
        this.target = options.args.target;
        this.propertyName = options.args.propertyName;
        this.relationNameOrFactory = options.args.relation;
        this.alias = options.args.alias;
        this.queryBuilderFactory = options.args.queryBuilderFactory;
      }
      // ---------------------------------------------------------------------
      // Public Builder Methods
      // ---------------------------------------------------------------------
      /**
       * Builds some depend relation count metadata properties.
       * This builder method should be used only after entity metadata, its properties map and all relations are build.
       */
      build() {
        const propertyPath = typeof this.relationNameOrFactory === "function" ? this.relationNameOrFactory(this.entityMetadata.propertiesMap) : this.relationNameOrFactory;
        const relation = this.entityMetadata.findRelationWithPropertyPath(propertyPath);
        if (!relation)
          throw new error_1.TypeORMError(`Cannot find relation ${propertyPath}. Wrong relation specified for @RelationCount decorator.`);
        this.relation = relation;
      }
    };
    exports2.RelationCountMetadata = RelationCountMetadata;
  }
});

// node_modules/typeorm/metadata/types/EventListenerTypes.js
var require_EventListenerTypes = __commonJS({
  "node_modules/typeorm/metadata/types/EventListenerTypes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EventListenerTypes = void 0;
    var EventListenerTypes = class {
    };
    exports2.EventListenerTypes = EventListenerTypes;
    EventListenerTypes.AFTER_LOAD = "after-load";
    EventListenerTypes.BEFORE_INSERT = "before-insert";
    EventListenerTypes.AFTER_INSERT = "after-insert";
    EventListenerTypes.BEFORE_UPDATE = "before-update";
    EventListenerTypes.AFTER_UPDATE = "after-update";
    EventListenerTypes.BEFORE_REMOVE = "before-remove";
    EventListenerTypes.AFTER_REMOVE = "after-remove";
    EventListenerTypes.BEFORE_SOFT_REMOVE = "before-soft-remove";
    EventListenerTypes.AFTER_SOFT_REMOVE = "after-soft-remove";
    EventListenerTypes.BEFORE_RECOVER = "before-recover";
    EventListenerTypes.AFTER_RECOVER = "after-recover";
  }
});

// node_modules/typeorm/metadata/ForeignKeyMetadata.js
var require_ForeignKeyMetadata = __commonJS({
  "node_modules/typeorm/metadata/ForeignKeyMetadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ForeignKeyMetadata = void 0;
    var ForeignKeyMetadata = class {
      // ---------------------------------------------------------------------
      // Constructor
      // ---------------------------------------------------------------------
      constructor(options) {
        this.columns = [];
        this.referencedColumns = [];
        this.columnNames = [];
        this.referencedColumnNames = [];
        this.entityMetadata = options.entityMetadata;
        this.referencedEntityMetadata = options.referencedEntityMetadata;
        this.columns = options.columns;
        this.referencedColumns = options.referencedColumns;
        this.onDelete = options.onDelete || "NO ACTION";
        this.onUpdate = options.onUpdate || "NO ACTION";
        this.deferrable = options.deferrable;
        this.givenName = options.name;
        if (options.namingStrategy)
          this.build(options.namingStrategy);
      }
      // ---------------------------------------------------------------------
      // Public Methods
      // ---------------------------------------------------------------------
      /**
       * Builds some depend foreign key properties.
       * Must be called after all entity metadatas and their columns are built.
       */
      build(namingStrategy) {
        this.columnNames = this.columns.map((column) => column.databaseName);
        this.referencedColumnNames = this.referencedColumns.map((column) => column.databaseName);
        this.referencedTablePath = this.referencedEntityMetadata.tablePath;
        this.name = this.givenName ? this.givenName : namingStrategy.foreignKeyName(this.entityMetadata.tableName, this.columnNames, this.referencedEntityMetadata.tableName, this.referencedColumnNames);
      }
    };
    exports2.ForeignKeyMetadata = ForeignKeyMetadata;
  }
});

// node_modules/typeorm/metadata-builder/JunctionEntityMetadataBuilder.js
var require_JunctionEntityMetadataBuilder = __commonJS({
  "node_modules/typeorm/metadata-builder/JunctionEntityMetadataBuilder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.JunctionEntityMetadataBuilder = void 0;
    var ColumnMetadata_1 = require_ColumnMetadata();
    var EntityMetadata_1 = require_EntityMetadata();
    var ForeignKeyMetadata_1 = require_ForeignKeyMetadata();
    var IndexMetadata_1 = require_IndexMetadata();
    var error_1 = require_error();
    var DriverUtils_1 = require_DriverUtils();
    var JunctionEntityMetadataBuilder = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection) {
        this.connection = connection;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Builds EntityMetadata for the junction of the given many-to-many relation.
       */
      build(relation, joinTable) {
        const referencedColumns = this.collectReferencedColumns(relation, joinTable);
        const inverseReferencedColumns = this.collectInverseReferencedColumns(relation, joinTable);
        const joinTableName = joinTable.name || this.connection.namingStrategy.joinTableName(relation.entityMetadata.tableNameWithoutPrefix, relation.inverseEntityMetadata.tableNameWithoutPrefix, relation.propertyPath, relation.inverseRelation ? relation.inverseRelation.propertyName : "");
        const entityMetadata = new EntityMetadata_1.EntityMetadata({
          connection: this.connection,
          args: {
            target: "",
            name: joinTableName,
            type: "junction",
            database: joinTable.database || relation.entityMetadata.database,
            schema: joinTable.schema || relation.entityMetadata.schema,
            synchronize: joinTable.synchronize
          }
        });
        entityMetadata.build();
        const junctionColumns = referencedColumns.map((referencedColumn) => {
          const joinColumn = joinTable.joinColumns ? joinTable.joinColumns.find((joinColumnArgs) => {
            return (!joinColumnArgs.referencedColumnName || joinColumnArgs.referencedColumnName === referencedColumn.propertyName) && !!joinColumnArgs.name;
          }) : void 0;
          const columnName = joinColumn && joinColumn.name ? joinColumn.name : this.connection.namingStrategy.joinTableColumnName(relation.entityMetadata.tableNameWithoutPrefix, referencedColumn.propertyName, referencedColumn.databaseName);
          return new ColumnMetadata_1.ColumnMetadata({
            connection: this.connection,
            entityMetadata,
            referencedColumn,
            args: {
              target: "",
              mode: "virtual",
              propertyName: columnName,
              options: {
                name: columnName,
                length: !referencedColumn.length && (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql") && // some versions of mariadb support the column type and should not try to provide the length property
                this.connection.driver.normalizeType(referencedColumn) !== "uuid" && (referencedColumn.generationStrategy === "uuid" || referencedColumn.type === "uuid") ? "36" : referencedColumn.length,
                // fix https://github.com/typeorm/typeorm/issues/3604
                width: referencedColumn.width,
                type: referencedColumn.type,
                precision: referencedColumn.precision,
                scale: referencedColumn.scale,
                charset: referencedColumn.charset,
                collation: referencedColumn.collation,
                zerofill: referencedColumn.zerofill,
                unsigned: referencedColumn.zerofill ? true : referencedColumn.unsigned,
                enum: referencedColumn.enum,
                enumName: referencedColumn.enumName,
                foreignKeyConstraintName: joinColumn?.foreignKeyConstraintName,
                nullable: false,
                primary: true
              }
            }
          });
        });
        const inverseJunctionColumns = inverseReferencedColumns.map((inverseReferencedColumn) => {
          const joinColumn = joinTable.inverseJoinColumns ? joinTable.inverseJoinColumns.find((joinColumnArgs) => {
            return (!joinColumnArgs.referencedColumnName || joinColumnArgs.referencedColumnName === inverseReferencedColumn.propertyName) && !!joinColumnArgs.name;
          }) : void 0;
          const columnName = joinColumn && joinColumn.name ? joinColumn.name : this.connection.namingStrategy.joinTableInverseColumnName(relation.inverseEntityMetadata.tableNameWithoutPrefix, inverseReferencedColumn.propertyName, inverseReferencedColumn.databaseName);
          return new ColumnMetadata_1.ColumnMetadata({
            connection: this.connection,
            entityMetadata,
            referencedColumn: inverseReferencedColumn,
            args: {
              target: "",
              mode: "virtual",
              propertyName: columnName,
              options: {
                length: !inverseReferencedColumn.length && (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql") && // some versions of mariadb support the column type and should not try to provide the length property
                this.connection.driver.normalizeType(inverseReferencedColumn) !== "uuid" && (inverseReferencedColumn.generationStrategy === "uuid" || inverseReferencedColumn.type === "uuid") ? "36" : inverseReferencedColumn.length,
                // fix https://github.com/typeorm/typeorm/issues/3604
                width: inverseReferencedColumn.width,
                // fix https://github.com/typeorm/typeorm/issues/6442
                type: inverseReferencedColumn.type,
                precision: inverseReferencedColumn.precision,
                scale: inverseReferencedColumn.scale,
                charset: inverseReferencedColumn.charset,
                collation: inverseReferencedColumn.collation,
                zerofill: inverseReferencedColumn.zerofill,
                unsigned: inverseReferencedColumn.zerofill ? true : inverseReferencedColumn.unsigned,
                enum: inverseReferencedColumn.enum,
                enumName: inverseReferencedColumn.enumName,
                foreignKeyConstraintName: joinColumn?.foreignKeyConstraintName,
                name: columnName,
                nullable: false,
                primary: true
              }
            }
          });
        });
        this.changeDuplicatedColumnNames(junctionColumns, inverseJunctionColumns);
        entityMetadata.ownerColumns = junctionColumns;
        entityMetadata.inverseColumns = inverseJunctionColumns;
        entityMetadata.ownColumns = [
          ...junctionColumns,
          ...inverseJunctionColumns
        ];
        entityMetadata.ownColumns.forEach((column) => column.relationMetadata = relation);
        entityMetadata.foreignKeys = relation.createForeignKeyConstraints ? [
          new ForeignKeyMetadata_1.ForeignKeyMetadata({
            entityMetadata,
            referencedEntityMetadata: relation.entityMetadata,
            columns: junctionColumns,
            referencedColumns,
            name: junctionColumns[0]?.foreignKeyConstraintName,
            onDelete: this.connection.driver.options.type === "spanner" ? "NO ACTION" : relation.onDelete || "CASCADE",
            onUpdate: this.connection.driver.options.type === "oracle" || this.connection.driver.options.type === "spanner" ? "NO ACTION" : relation.onUpdate || "CASCADE"
          }),
          new ForeignKeyMetadata_1.ForeignKeyMetadata({
            entityMetadata,
            referencedEntityMetadata: relation.inverseEntityMetadata,
            columns: inverseJunctionColumns,
            referencedColumns: inverseReferencedColumns,
            name: inverseJunctionColumns[0]?.foreignKeyConstraintName,
            onDelete: this.connection.driver.options.type === "spanner" ? "NO ACTION" : relation.inverseRelation ? relation.inverseRelation.onDelete : "CASCADE",
            onUpdate: this.connection.driver.options.type === "oracle" || this.connection.driver.options.type === "spanner" ? "NO ACTION" : relation.inverseRelation ? relation.inverseRelation.onUpdate : "CASCADE"
          })
        ] : [];
        entityMetadata.ownIndices = [
          new IndexMetadata_1.IndexMetadata({
            entityMetadata,
            columns: junctionColumns,
            args: {
              target: entityMetadata.target,
              synchronize: true
            }
          }),
          new IndexMetadata_1.IndexMetadata({
            entityMetadata,
            columns: inverseJunctionColumns,
            args: {
              target: entityMetadata.target,
              synchronize: true
            }
          })
        ];
        return entityMetadata;
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Collects referenced columns from the given join column args.
       */
      collectReferencedColumns(relation, joinTable) {
        const hasAnyReferencedColumnName = joinTable.joinColumns ? joinTable.joinColumns.find((joinColumn) => !!joinColumn.referencedColumnName) : false;
        if (!joinTable.joinColumns || joinTable.joinColumns && !hasAnyReferencedColumnName) {
          return relation.entityMetadata.columns.filter((column) => column.isPrimary);
        } else {
          return joinTable.joinColumns.map((joinColumn) => {
            const referencedColumn = relation.entityMetadata.columns.find((column) => column.propertyName === joinColumn.referencedColumnName);
            if (!referencedColumn)
              throw new error_1.TypeORMError(`Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.entityMetadata.name}`);
            return referencedColumn;
          });
        }
      }
      /**
       * Collects inverse referenced columns from the given join column args.
       */
      collectInverseReferencedColumns(relation, joinTable) {
        const hasInverseJoinColumns = !!joinTable.inverseJoinColumns;
        const hasAnyInverseReferencedColumnName = hasInverseJoinColumns ? joinTable.inverseJoinColumns.find((joinColumn) => !!joinColumn.referencedColumnName) : false;
        if (!hasInverseJoinColumns || hasInverseJoinColumns && !hasAnyInverseReferencedColumnName) {
          return relation.inverseEntityMetadata.primaryColumns;
        } else {
          return joinTable.inverseJoinColumns.map((joinColumn) => {
            const referencedColumn = relation.inverseEntityMetadata.ownColumns.find((column) => column.propertyName === joinColumn.referencedColumnName);
            if (!referencedColumn)
              throw new error_1.TypeORMError(`Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.inverseEntityMetadata.name}`);
            return referencedColumn;
          });
        }
      }
      changeDuplicatedColumnNames(junctionColumns, inverseJunctionColumns) {
        junctionColumns.forEach((junctionColumn) => {
          inverseJunctionColumns.forEach((inverseJunctionColumn) => {
            if (junctionColumn.givenDatabaseName === inverseJunctionColumn.givenDatabaseName) {
              const junctionColumnName = this.connection.namingStrategy.joinTableColumnDuplicationPrefix(junctionColumn.propertyName, 1);
              junctionColumn.propertyName = junctionColumnName;
              junctionColumn.givenDatabaseName = junctionColumnName;
              const inverseJunctionColumnName = this.connection.namingStrategy.joinTableColumnDuplicationPrefix(inverseJunctionColumn.propertyName, 2);
              inverseJunctionColumn.propertyName = inverseJunctionColumnName;
              inverseJunctionColumn.givenDatabaseName = inverseJunctionColumnName;
            }
          });
        });
      }
    };
    exports2.JunctionEntityMetadataBuilder = JunctionEntityMetadataBuilder;
  }
});

// node_modules/typeorm/metadata-builder/ClosureJunctionEntityMetadataBuilder.js
var require_ClosureJunctionEntityMetadataBuilder = __commonJS({
  "node_modules/typeorm/metadata-builder/ClosureJunctionEntityMetadataBuilder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ClosureJunctionEntityMetadataBuilder = void 0;
    var EntityMetadata_1 = require_EntityMetadata();
    var ColumnMetadata_1 = require_ColumnMetadata();
    var ForeignKeyMetadata_1 = require_ForeignKeyMetadata();
    var IndexMetadata_1 = require_IndexMetadata();
    var ClosureJunctionEntityMetadataBuilder = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection) {
        this.connection = connection;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Builds EntityMetadata for the closure junction of the given closure entity.
       */
      build(parentClosureEntityMetadata) {
        const entityMetadata = new EntityMetadata_1.EntityMetadata({
          parentClosureEntityMetadata,
          connection: this.connection,
          args: {
            target: "",
            name: parentClosureEntityMetadata.treeOptions && parentClosureEntityMetadata.treeOptions.closureTableName ? parentClosureEntityMetadata.treeOptions.closureTableName : parentClosureEntityMetadata.tableNameWithoutPrefix,
            type: "closure-junction"
          }
        });
        entityMetadata.build();
        parentClosureEntityMetadata.primaryColumns.forEach((primaryColumn) => {
          entityMetadata.ownColumns.push(new ColumnMetadata_1.ColumnMetadata({
            connection: this.connection,
            entityMetadata,
            closureType: "ancestor",
            referencedColumn: primaryColumn,
            args: {
              target: "",
              mode: "virtual",
              propertyName: parentClosureEntityMetadata.treeOptions && parentClosureEntityMetadata.treeOptions.ancestorColumnName ? parentClosureEntityMetadata.treeOptions.ancestorColumnName(primaryColumn) : primaryColumn.propertyName + "_ancestor",
              options: {
                primary: true,
                length: primaryColumn.length,
                type: primaryColumn.type,
                unsigned: primaryColumn.unsigned,
                width: primaryColumn.width,
                precision: primaryColumn.precision,
                scale: primaryColumn.scale,
                zerofill: primaryColumn.zerofill,
                charset: primaryColumn.charset,
                collation: primaryColumn.collation
              }
            }
          }));
          entityMetadata.ownColumns.push(new ColumnMetadata_1.ColumnMetadata({
            connection: this.connection,
            entityMetadata,
            closureType: "descendant",
            referencedColumn: primaryColumn,
            args: {
              target: "",
              mode: "virtual",
              propertyName: parentClosureEntityMetadata.treeOptions && parentClosureEntityMetadata.treeOptions.descendantColumnName ? parentClosureEntityMetadata.treeOptions.descendantColumnName(primaryColumn) : primaryColumn.propertyName + "_descendant",
              options: {
                primary: true,
                length: primaryColumn.length,
                type: primaryColumn.type,
                unsigned: primaryColumn.unsigned,
                width: primaryColumn.width,
                precision: primaryColumn.precision,
                scale: primaryColumn.scale,
                zerofill: primaryColumn.zerofill,
                charset: primaryColumn.charset,
                collation: primaryColumn.collation
              }
            }
          }));
        });
        entityMetadata.ownIndices = [
          new IndexMetadata_1.IndexMetadata({
            entityMetadata,
            columns: [entityMetadata.ownColumns[0]],
            args: {
              target: entityMetadata.target,
              synchronize: true
            }
          }),
          new IndexMetadata_1.IndexMetadata({
            entityMetadata,
            columns: [entityMetadata.ownColumns[1]],
            args: {
              target: entityMetadata.target,
              synchronize: true
            }
          })
        ];
        if (parentClosureEntityMetadata.treeLevelColumn) {
          entityMetadata.ownColumns.push(new ColumnMetadata_1.ColumnMetadata({
            connection: this.connection,
            entityMetadata,
            args: {
              target: "",
              mode: "virtual",
              propertyName: "level",
              options: {
                type: this.connection.driver.mappedDataTypes.treeLevel
              }
            }
          }));
        }
        entityMetadata.foreignKeys = [
          new ForeignKeyMetadata_1.ForeignKeyMetadata({
            entityMetadata,
            referencedEntityMetadata: parentClosureEntityMetadata,
            columns: [entityMetadata.ownColumns[0]],
            referencedColumns: parentClosureEntityMetadata.primaryColumns,
            onDelete: this.connection.driver.options.type === "mssql" ? "NO ACTION" : "CASCADE"
          }),
          new ForeignKeyMetadata_1.ForeignKeyMetadata({
            entityMetadata,
            referencedEntityMetadata: parentClosureEntityMetadata,
            columns: [entityMetadata.ownColumns[1]],
            referencedColumns: parentClosureEntityMetadata.primaryColumns,
            onDelete: this.connection.driver.options.type === "mssql" ? "NO ACTION" : "CASCADE"
          })
        ];
        return entityMetadata;
      }
    };
    exports2.ClosureJunctionEntityMetadataBuilder = ClosureJunctionEntityMetadataBuilder;
  }
});

// node_modules/typeorm/metadata/UniqueMetadata.js
var require_UniqueMetadata = __commonJS({
  "node_modules/typeorm/metadata/UniqueMetadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UniqueMetadata = void 0;
    var error_1 = require_error();
    var UniqueMetadata = class {
      // ---------------------------------------------------------------------
      // Constructor
      // ---------------------------------------------------------------------
      constructor(options) {
        this.columns = [];
        this.columnNamesWithOrderingMap = {};
        this.entityMetadata = options.entityMetadata;
        this.embeddedMetadata = options.embeddedMetadata;
        if (options.columns)
          this.columns = options.columns;
        if (options.args) {
          this.target = options.args.target;
          this.givenName = options.args.name;
          this.givenColumnNames = options.args.columns;
          this.deferrable = options.args.deferrable;
        }
      }
      // ---------------------------------------------------------------------
      // Public Build Methods
      // ---------------------------------------------------------------------
      /**
       * Builds some depend unique constraint properties.
       * Must be called after all entity metadata's properties map, columns and relations are built.
       */
      build(namingStrategy) {
        const map = {};
        if (this.givenColumnNames) {
          let columnPropertyPaths = [];
          if (Array.isArray(this.givenColumnNames)) {
            columnPropertyPaths = this.givenColumnNames.map((columnName) => {
              if (this.embeddedMetadata)
                return this.embeddedMetadata.propertyPath + "." + columnName;
              return columnName.trim();
            });
            columnPropertyPaths.forEach((propertyPath) => map[propertyPath] = 1);
          } else {
            const columnsFnResult = this.givenColumnNames(this.entityMetadata.propertiesMap);
            if (Array.isArray(columnsFnResult)) {
              columnPropertyPaths = columnsFnResult.map((i) => String(i));
              columnPropertyPaths.forEach((name) => map[name] = 1);
            } else {
              columnPropertyPaths = Object.keys(columnsFnResult).map((i) => String(i));
              Object.keys(columnsFnResult).forEach((columnName) => map[columnName] = columnsFnResult[columnName]);
            }
          }
          this.columns = columnPropertyPaths.map((propertyName) => {
            const columnWithSameName = this.entityMetadata.columns.find((column) => column.propertyPath === propertyName);
            if (columnWithSameName) {
              return [columnWithSameName];
            }
            const relationWithSameName = this.entityMetadata.relations.find((relation) => relation.isWithJoinColumn && relation.propertyName === propertyName);
            if (relationWithSameName) {
              return relationWithSameName.joinColumns;
            }
            const indexName = this.givenName ? '"' + this.givenName + '" ' : "";
            const entityName = this.entityMetadata.targetName;
            throw new error_1.TypeORMError(`Unique constraint ${indexName}contains column that is missing in the entity (${entityName}): ` + propertyName);
          }).reduce((a, b) => a.concat(b));
        }
        this.columnNamesWithOrderingMap = Object.keys(map).reduce((updatedMap, key) => {
          const column = this.entityMetadata.columns.find((column2) => column2.propertyPath === key);
          if (column)
            updatedMap[column.databasePath] = map[key];
          return updatedMap;
        }, {});
        this.name = this.givenName ? this.givenName : namingStrategy.uniqueConstraintName(this.entityMetadata.tableName, this.columns.map((column) => column.databaseName));
        return this;
      }
    };
    exports2.UniqueMetadata = UniqueMetadata;
  }
});

// node_modules/typeorm/metadata-builder/RelationJoinColumnBuilder.js
var require_RelationJoinColumnBuilder = __commonJS({
  "node_modules/typeorm/metadata-builder/RelationJoinColumnBuilder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RelationJoinColumnBuilder = void 0;
    var ColumnMetadata_1 = require_ColumnMetadata();
    var UniqueMetadata_1 = require_UniqueMetadata();
    var ForeignKeyMetadata_1 = require_ForeignKeyMetadata();
    var error_1 = require_error();
    var DriverUtils_1 = require_DriverUtils();
    var OrmUtils_1 = require_OrmUtils();
    var RelationJoinColumnBuilder = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection) {
        this.connection = connection;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Builds a foreign key of the many-to-one or one-to-one owner relations.
       */
      build(joinColumns, relation) {
        const referencedColumns = this.collectReferencedColumns(joinColumns, relation);
        const columns = this.collectColumns(joinColumns, relation, referencedColumns);
        if (!referencedColumns.length || !relation.createForeignKeyConstraints)
          return {
            foreignKey: void 0,
            columns,
            uniqueConstraint: void 0
          };
        const foreignKey = new ForeignKeyMetadata_1.ForeignKeyMetadata({
          name: joinColumns[0]?.foreignKeyConstraintName,
          entityMetadata: relation.entityMetadata,
          referencedEntityMetadata: relation.inverseEntityMetadata,
          namingStrategy: this.connection.namingStrategy,
          columns,
          referencedColumns,
          onDelete: relation.onDelete,
          onUpdate: relation.onUpdate,
          deferrable: relation.deferrable
        });
        if (columns.every((column) => column.isPrimary) || !relation.isOneToOne) {
          return { foreignKey, columns, uniqueConstraint: void 0 };
        }
        const uniqueConstraint = new UniqueMetadata_1.UniqueMetadata({
          entityMetadata: relation.entityMetadata,
          columns: foreignKey.columns,
          args: {
            name: this.connection.namingStrategy.relationConstraintName(relation.entityMetadata.tableName, foreignKey.columns.map((column) => column.databaseName)),
            target: relation.entityMetadata.target
          }
        });
        uniqueConstraint.build(this.connection.namingStrategy);
        return { foreignKey, columns, uniqueConstraint };
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Collects referenced columns from the given join column args.
       */
      collectReferencedColumns(joinColumns, relation) {
        const hasAnyReferencedColumnName = joinColumns.find((joinColumnArgs) => !!joinColumnArgs.referencedColumnName);
        const manyToOneWithoutJoinColumn = joinColumns.length === 0 && relation.isManyToOne;
        const hasJoinColumnWithoutAnyReferencedColumnName = joinColumns.length > 0 && !hasAnyReferencedColumnName;
        if (manyToOneWithoutJoinColumn || hasJoinColumnWithoutAnyReferencedColumnName) {
          return relation.inverseEntityMetadata.primaryColumns;
        } else {
          return joinColumns.map((joinColumn) => {
            const referencedColumn = relation.inverseEntityMetadata.ownColumns.find((column) => column.propertyName === joinColumn.referencedColumnName);
            if (!referencedColumn)
              throw new error_1.TypeORMError(`Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.inverseEntityMetadata.name}`);
            return referencedColumn;
          });
        }
      }
      /**
       * Collects columns from the given join column args.
       */
      collectColumns(joinColumns, relation, referencedColumns) {
        return referencedColumns.map((referencedColumn) => {
          const joinColumnMetadataArg = joinColumns.find((joinColumn) => {
            return (!joinColumn.referencedColumnName || joinColumn.referencedColumnName === referencedColumn.propertyName) && !!joinColumn.name;
          });
          const joinColumnName = joinColumnMetadataArg ? joinColumnMetadataArg.name : this.connection.namingStrategy.joinColumnName(relation.propertyName, referencedColumn.propertyName);
          const relationalColumns = relation.embeddedMetadata ? relation.embeddedMetadata.columns : relation.entityMetadata.ownColumns;
          let relationalColumn = relationalColumns.find((column) => column.databaseNameWithoutPrefixes === joinColumnName);
          if (!relationalColumn) {
            relationalColumn = new ColumnMetadata_1.ColumnMetadata({
              connection: this.connection,
              entityMetadata: relation.entityMetadata,
              embeddedMetadata: relation.embeddedMetadata,
              args: {
                target: "",
                mode: "virtual",
                propertyName: relation.propertyName,
                options: {
                  name: joinColumnName,
                  type: referencedColumn.type,
                  length: !referencedColumn.length && (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql") && // some versions of mariadb support the column type and should not try to provide the length property
                  this.connection.driver.normalizeType(referencedColumn) !== "uuid" && (referencedColumn.generationStrategy === "uuid" || referencedColumn.type === "uuid") ? "36" : referencedColumn.length,
                  // fix https://github.com/typeorm/typeorm/issues/3604
                  width: referencedColumn.width,
                  charset: referencedColumn.charset,
                  collation: referencedColumn.collation,
                  precision: referencedColumn.precision,
                  scale: referencedColumn.scale,
                  zerofill: referencedColumn.zerofill,
                  unsigned: referencedColumn.unsigned,
                  comment: referencedColumn.comment,
                  enum: referencedColumn.enum,
                  enumName: referencedColumn.enumName,
                  primary: relation.isPrimary,
                  nullable: relation.isNullable
                }
              }
            });
            relation.entityMetadata.registerColumn(relationalColumn);
          } else if (relationalColumn.referencedColumn) {
            relationalColumn = OrmUtils_1.OrmUtils.cloneObject(relationalColumn);
          }
          relationalColumn.referencedColumn = referencedColumn;
          relationalColumn.type = referencedColumn.type;
          relationalColumn.relationMetadata = relation;
          relationalColumn.build(this.connection);
          return relationalColumn;
        });
      }
    };
    exports2.RelationJoinColumnBuilder = RelationJoinColumnBuilder;
  }
});

// node_modules/typeorm/metadata/EntityListenerMetadata.js
var require_EntityListenerMetadata = __commonJS({
  "node_modules/typeorm/metadata/EntityListenerMetadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EntityListenerMetadata = void 0;
    var EntityListenerMetadata = class {
      // ---------------------------------------------------------------------
      // Constructor
      // ---------------------------------------------------------------------
      constructor(options) {
        this.entityMetadata = options.entityMetadata;
        this.embeddedMetadata = options.embeddedMetadata;
        this.target = options.args.target;
        this.propertyName = options.args.propertyName;
        this.type = options.args.type;
      }
      // ---------------------------------------------------------------------
      // Public Methods
      // ---------------------------------------------------------------------
      /**
       * Checks if entity listener is allowed to be executed on the given entity.
       */
      isAllowed(entity) {
        return this.entityMetadata.target === entity.constructor || // todo: .constructor won't work for entity schemas, but there are no entity listeners in schemas since there are no objects, right?
        typeof this.entityMetadata.target === "function" && entity.constructor.prototype instanceof this.entityMetadata.target;
      }
      /**
       * Executes listener method of the given entity.
       */
      execute(entity) {
        if (!this.embeddedMetadata) {
          const entityMethod = entity[this.propertyName];
          if (!entityMethod)
            throw new Error(`Entity listener method "${this.propertyName}" does not exist in entity "${entity.constructor.name}".`);
          if (typeof entityMethod !== "function")
            throw new Error(`Entity listener method "${this.propertyName}" in entity "${entity.constructor.name}" must be a function but got "${typeof entityMethod}".`);
          return entityMethod.call(entity);
        }
        this.callEntityEmbeddedMethod(entity, this.embeddedMetadata.propertyPath.split("."));
      }
      // ---------------------------------------------------------------------
      // Protected Methods
      // ---------------------------------------------------------------------
      /**
       * Calls embedded entity listener method no matter how nested it is.
       */
      callEntityEmbeddedMethod(entity, propertyPaths) {
        const propertyPath = propertyPaths.shift();
        if (!propertyPath || !entity[propertyPath])
          return;
        if (propertyPaths.length === 0) {
          if (Array.isArray(entity[propertyPath])) {
            entity[propertyPath].map((embedded) => embedded[this.propertyName]());
          } else {
            entity[propertyPath][this.propertyName]();
          }
        } else {
          if (entity[propertyPath])
            this.callEntityEmbeddedMethod(entity[propertyPath], propertyPaths);
        }
      }
    };
    exports2.EntityListenerMetadata = EntityListenerMetadata;
  }
});

// node_modules/typeorm/metadata/CheckMetadata.js
var require_CheckMetadata = __commonJS({
  "node_modules/typeorm/metadata/CheckMetadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CheckMetadata = void 0;
    var CheckMetadata = class {
      // ---------------------------------------------------------------------
      // Constructor
      // ---------------------------------------------------------------------
      constructor(options) {
        this.entityMetadata = options.entityMetadata;
        if (options.args) {
          this.target = options.args.target;
          this.expression = options.args.expression;
          this.givenName = options.args.name;
        }
      }
      // ---------------------------------------------------------------------
      // Public Build Methods
      // ---------------------------------------------------------------------
      /**
       * Builds some depend check constraint properties.
       * Must be called after all entity metadata's properties map, columns and relations are built.
       */
      build(namingStrategy) {
        this.name = this.givenName ? this.givenName : namingStrategy.checkConstraintName(this.entityMetadata.tableName, this.expression);
        return this;
      }
    };
    exports2.CheckMetadata = CheckMetadata;
  }
});

// node_modules/typeorm/metadata/ExclusionMetadata.js
var require_ExclusionMetadata = __commonJS({
  "node_modules/typeorm/metadata/ExclusionMetadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExclusionMetadata = void 0;
    var ExclusionMetadata = class {
      // ---------------------------------------------------------------------
      // Constructor
      // ---------------------------------------------------------------------
      constructor(options) {
        this.entityMetadata = options.entityMetadata;
        if (options.args) {
          this.target = options.args.target;
          this.expression = options.args.expression;
          this.givenName = options.args.name;
        }
      }
      // ---------------------------------------------------------------------
      // Public Build Methods
      // ---------------------------------------------------------------------
      /**
       * Builds some depend exclusion constraint properties.
       * Must be called after all entity metadata's properties map, columns and relations are built.
       */
      build(namingStrategy) {
        this.name = this.givenName ? this.givenName : namingStrategy.exclusionConstraintName(this.entityMetadata.tableName, this.expression);
        return this;
      }
    };
    exports2.ExclusionMetadata = ExclusionMetadata;
  }
});

// node_modules/typeorm/metadata-builder/EntityMetadataBuilder.js
var require_EntityMetadataBuilder = __commonJS({
  "node_modules/typeorm/metadata-builder/EntityMetadataBuilder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EntityMetadataBuilder = void 0;
    var EntityMetadata_1 = require_EntityMetadata();
    var ColumnMetadata_1 = require_ColumnMetadata();
    var IndexMetadata_1 = require_IndexMetadata();
    var RelationMetadata_1 = require_RelationMetadata();
    var EmbeddedMetadata_1 = require_EmbeddedMetadata();
    var RelationIdMetadata_1 = require_RelationIdMetadata();
    var RelationCountMetadata_1 = require_RelationCountMetadata();
    var EventListenerTypes_1 = require_EventListenerTypes();
    var MetadataUtils_1 = require_MetadataUtils();
    var JunctionEntityMetadataBuilder_1 = require_JunctionEntityMetadataBuilder();
    var ClosureJunctionEntityMetadataBuilder_1 = require_ClosureJunctionEntityMetadataBuilder();
    var RelationJoinColumnBuilder_1 = require_RelationJoinColumnBuilder();
    var EntityListenerMetadata_1 = require_EntityListenerMetadata();
    var UniqueMetadata_1 = require_UniqueMetadata();
    var CheckMetadata_1 = require_CheckMetadata();
    var ExclusionMetadata_1 = require_ExclusionMetadata();
    var error_1 = require_error();
    var DriverUtils_1 = require_DriverUtils();
    var ForeignKeyMetadata_1 = require_ForeignKeyMetadata();
    var InstanceChecker_1 = require_InstanceChecker();
    var EntityMetadataBuilder = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection, metadataArgsStorage) {
        this.connection = connection;
        this.metadataArgsStorage = metadataArgsStorage;
        this.junctionEntityMetadataBuilder = new JunctionEntityMetadataBuilder_1.JunctionEntityMetadataBuilder(connection);
        this.closureJunctionEntityMetadataBuilder = new ClosureJunctionEntityMetadataBuilder_1.ClosureJunctionEntityMetadataBuilder(connection);
        this.relationJoinColumnBuilder = new RelationJoinColumnBuilder_1.RelationJoinColumnBuilder(connection);
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Builds a complete entity metadatas for the given entity classes.
       */
      build(entityClasses) {
        const allTables = entityClasses ? this.metadataArgsStorage.filterTables(entityClasses) : this.metadataArgsStorage.tables;
        const realTables = allTables.filter((table) => table.type === "regular" || table.type === "closure" || table.type === "entity-child" || table.type === "view");
        const entityMetadatas = realTables.map((tableArgs) => this.createEntityMetadata(tableArgs));
        entityMetadatas.forEach((entityMetadata) => this.computeParentEntityMetadata(entityMetadatas, entityMetadata));
        entityMetadatas.forEach((metadata) => {
          metadata.childEntityMetadatas = entityMetadatas.filter((childMetadata) => {
            return typeof metadata.target === "function" && typeof childMetadata.target === "function" && MetadataUtils_1.MetadataUtils.isInherited(childMetadata.target, metadata.target);
          });
        });
        entityMetadatas.filter((entityMetadata) => entityMetadata.tableType !== "entity-child").forEach((entityMetadata) => entityMetadata.build());
        entityMetadatas.filter((entityMetadata) => entityMetadata.tableType === "entity-child").forEach((entityMetadata) => entityMetadata.build());
        entityMetadatas.filter((entityMetadata) => entityMetadata.tableType !== "entity-child").forEach((entityMetadata) => this.computeEntityMetadataStep1(entityMetadatas, entityMetadata));
        entityMetadatas.filter((entityMetadata) => entityMetadata.tableType === "entity-child").forEach((entityMetadata) => this.computeEntityMetadataStep1(entityMetadatas, entityMetadata));
        entityMetadatas.forEach((entityMetadata) => this.computeEntityMetadataStep2(entityMetadata));
        entityMetadatas.forEach((entityMetadata) => this.computeInverseProperties(entityMetadata, entityMetadatas));
        entityMetadatas.filter((entityMetadata) => entityMetadata.tableType !== "entity-child").forEach((entityMetadata) => {
          entityMetadata.relations.filter((relation) => relation.isOneToOne || relation.isManyToOne).forEach((relation) => {
            const joinColumns = this.metadataArgsStorage.filterJoinColumns(relation.target, relation.propertyName);
            const { foreignKey, columns, uniqueConstraint } = this.relationJoinColumnBuilder.build(joinColumns, relation);
            if (foreignKey) {
              relation.registerForeignKeys(foreignKey);
              entityMetadata.foreignKeys.push(foreignKey);
            }
            if (columns) {
              relation.registerJoinColumns(columns);
            }
            if (uniqueConstraint) {
              if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql" || this.connection.driver.options.type === "mssql" || this.connection.driver.options.type === "sap" || this.connection.driver.options.type === "spanner") {
                const index = new IndexMetadata_1.IndexMetadata({
                  entityMetadata: uniqueConstraint.entityMetadata,
                  columns: uniqueConstraint.columns,
                  args: {
                    target: uniqueConstraint.target,
                    name: uniqueConstraint.name,
                    unique: true,
                    synchronize: true
                  }
                });
                if (this.connection.driver.options.type === "mssql") {
                  index.where = index.columns.map((column) => {
                    return `${this.connection.driver.escape(column.databaseName)} IS NOT NULL`;
                  }).join(" AND ");
                }
                if (this.connection.driver.options.type === "spanner") {
                  index.isNullFiltered = true;
                }
                if (relation.embeddedMetadata) {
                  relation.embeddedMetadata.indices.push(index);
                } else {
                  relation.entityMetadata.ownIndices.push(index);
                }
                this.computeEntityMetadataStep2(entityMetadata);
              } else {
                if (relation.embeddedMetadata) {
                  relation.embeddedMetadata.uniques.push(uniqueConstraint);
                } else {
                  relation.entityMetadata.ownUniques.push(uniqueConstraint);
                }
                this.computeEntityMetadataStep2(entityMetadata);
              }
            }
            if (foreignKey && this.connection.driver.options.type === "cockroachdb") {
              const index = new IndexMetadata_1.IndexMetadata({
                entityMetadata: relation.entityMetadata,
                columns: foreignKey.columns,
                args: {
                  target: relation.entityMetadata.target,
                  synchronize: true
                }
              });
              if (relation.embeddedMetadata) {
                relation.embeddedMetadata.indices.push(index);
              } else {
                relation.entityMetadata.ownIndices.push(index);
              }
              this.computeEntityMetadataStep2(entityMetadata);
            }
          });
          entityMetadata.relations.filter((relation) => relation.isManyToMany).forEach((relation) => {
            const joinTable = this.metadataArgsStorage.findJoinTable(relation.target, relation.propertyName);
            if (!joinTable)
              return;
            const junctionEntityMetadata = this.junctionEntityMetadataBuilder.build(relation, joinTable);
            relation.registerForeignKeys(...junctionEntityMetadata.foreignKeys);
            relation.registerJoinColumns(junctionEntityMetadata.ownIndices[0].columns, junctionEntityMetadata.ownIndices[1].columns);
            relation.registerJunctionEntityMetadata(junctionEntityMetadata);
            this.computeEntityMetadataStep2(junctionEntityMetadata);
            this.computeInverseProperties(junctionEntityMetadata, entityMetadatas);
            const hasUserDefinedTable = entityMetadatas.some((metadata) => metadata.tableName === junctionEntityMetadata.tableName && !metadata.isJunction);
            if (!hasUserDefinedTable) {
              entityMetadatas.push(junctionEntityMetadata);
            }
          });
        });
        entityMetadatas.forEach((entityMetadata) => {
          entityMetadata.relationsWithJoinColumns = entityMetadata.relations.filter((relation) => relation.isWithJoinColumn);
          entityMetadata.hasNonNullableRelations = entityMetadata.relationsWithJoinColumns.some((relation) => !relation.isNullable || relation.isPrimary);
        });
        entityMetadatas.filter((metadata) => metadata.treeType === "closure-table").forEach((entityMetadata) => {
          const closureJunctionEntityMetadata = this.closureJunctionEntityMetadataBuilder.build(entityMetadata);
          entityMetadata.closureJunctionTable = closureJunctionEntityMetadata;
          this.computeEntityMetadataStep2(closureJunctionEntityMetadata);
          this.computeInverseProperties(closureJunctionEntityMetadata, entityMetadatas);
          entityMetadatas.push(closureJunctionEntityMetadata);
        });
        entityMetadatas.filter((metadata) => metadata.inheritancePattern === "STI" && metadata.discriminatorColumn).forEach((entityMetadata) => this.createKeysForTableInheritance(entityMetadata));
        entityMetadatas.forEach((entityMetadata) => {
          entityMetadata.indices.forEach((index) => index.build(this.connection.namingStrategy));
        });
        entityMetadatas.forEach((entityMetadata) => {
          entityMetadata.uniques.forEach((unique) => unique.build(this.connection.namingStrategy));
        });
        entityMetadatas.forEach((entityMetadata) => {
          entityMetadata.checks.forEach((check) => check.build(this.connection.namingStrategy));
        });
        entityMetadatas.forEach((entityMetadata) => {
          entityMetadata.exclusions.forEach((exclusion) => exclusion.build(this.connection.namingStrategy));
        });
        entityMetadatas.forEach((entityMetadata) => this.createForeignKeys(entityMetadata, entityMetadatas));
        entityMetadatas.filter((metadata) => typeof metadata.target === "function").forEach((entityMetadata) => {
          entityMetadata.relations.filter((relation) => relation.isLazy).forEach((relation) => {
            this.connection.relationLoader.enableLazyLoad(relation, entityMetadata.target.prototype);
          });
        });
        entityMetadatas.forEach((entityMetadata) => {
          entityMetadata.columns.forEach((column) => {
            const generated = this.metadataArgsStorage.findGenerated(column.target, column.propertyName);
            if (generated) {
              column.isGenerated = true;
              column.generationStrategy = generated.strategy;
              if (generated.strategy === "uuid") {
                column.type = "uuid";
              } else if (generated.strategy === "rowid") {
                column.type = "int";
              } else {
                column.type = column.type || Number;
              }
              column.build(this.connection);
              this.computeEntityMetadataStep2(entityMetadata);
            }
          });
        });
        return entityMetadatas;
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Creates entity metadata from the given table args.
       * Creates column, relation, etc. metadatas for everything this entity metadata owns.
       */
      createEntityMetadata(tableArgs) {
        const inheritanceTree = typeof tableArgs.target === "function" ? MetadataUtils_1.MetadataUtils.getInheritanceTree(tableArgs.target) : [tableArgs.target];
        const tableInheritance = this.metadataArgsStorage.findInheritanceType(tableArgs.target);
        const tableTree = this.metadataArgsStorage.findTree(tableArgs.target);
        let singleTableChildrenTargets;
        if (tableInheritance && tableInheritance.pattern === "STI" || tableArgs.type === "entity-child") {
          singleTableChildrenTargets = this.metadataArgsStorage.filterSingleTableChildren(tableArgs.target).map((args) => args.target).filter((target) => typeof target === "function");
          inheritanceTree.push(...singleTableChildrenTargets);
        }
        return new EntityMetadata_1.EntityMetadata({
          connection: this.connection,
          args: tableArgs,
          inheritanceTree,
          tableTree,
          inheritancePattern: tableInheritance ? tableInheritance.pattern : void 0
        });
      }
      computeParentEntityMetadata(allEntityMetadatas, entityMetadata) {
        if (entityMetadata.tableType === "entity-child") {
          entityMetadata.parentEntityMetadata = allEntityMetadatas.find((allEntityMetadata) => {
            return allEntityMetadata.inheritanceTree.indexOf(entityMetadata.target) !== -1 && allEntityMetadata.inheritancePattern === "STI";
          });
        }
      }
      computeEntityMetadataStep1(allEntityMetadatas, entityMetadata) {
        const entityInheritance = this.metadataArgsStorage.findInheritanceType(entityMetadata.target);
        const discriminatorValue = this.metadataArgsStorage.findDiscriminatorValue(entityMetadata.target);
        if (typeof discriminatorValue !== "undefined") {
          entityMetadata.discriminatorValue = discriminatorValue.value;
        } else {
          entityMetadata.discriminatorValue = entityMetadata.target.name;
        }
        entityMetadata.embeddeds = this.createEmbeddedsRecursively(entityMetadata, this.metadataArgsStorage.filterEmbeddeds(entityMetadata.inheritanceTree)).map((embedded) => {
          if (entityMetadata.inheritancePattern === "STI") {
            embedded.columns = embedded.columns.map((column) => {
              column.isNullable = true;
              return column;
            });
          }
          return embedded;
        });
        entityMetadata.ownColumns = this.metadataArgsStorage.filterColumns(entityMetadata.inheritanceTree).map((args) => {
          if (entityMetadata.tableType === "entity-child")
            return entityMetadata.parentEntityMetadata.ownColumns.find((column2) => column2.propertyName === args.propertyName);
          if (entityMetadata.tableType === "regular" && args.target !== entityMetadata.target) {
            const childArgs = this.metadataArgsStorage.columns.find((c) => c.propertyName === args.propertyName && c.target === entityMetadata.target);
            if (childArgs && childArgs.options.default) {
              args.options.default = childArgs.options.default;
            }
          }
          const column = new ColumnMetadata_1.ColumnMetadata({
            connection: this.connection,
            entityMetadata,
            args
          });
          const columnInSingleTableInheritedChild = allEntityMetadatas.find((otherEntityMetadata) => otherEntityMetadata.tableType === "entity-child" && otherEntityMetadata.target === args.target);
          if (columnInSingleTableInheritedChild)
            column.isNullable = true;
          return column;
        });
        if (entityInheritance && entityInheritance.column) {
          const discriminatorColumnName = entityInheritance.column && entityInheritance.column.name ? entityInheritance.column.name : "type";
          let discriminatorColumn = entityMetadata.ownColumns.find((column) => column.propertyName === discriminatorColumnName);
          if (!discriminatorColumn) {
            discriminatorColumn = new ColumnMetadata_1.ColumnMetadata({
              connection: this.connection,
              entityMetadata,
              args: {
                target: entityMetadata.target,
                mode: "virtual",
                propertyName: discriminatorColumnName,
                options: entityInheritance.column || {
                  name: discriminatorColumnName,
                  type: "varchar",
                  nullable: false
                }
              }
            });
            discriminatorColumn.isVirtual = true;
            discriminatorColumn.isDiscriminator = true;
            entityMetadata.ownColumns.push(discriminatorColumn);
          } else {
            discriminatorColumn.isDiscriminator = true;
          }
        }
        if (entityMetadata.tableType === "entity-child") {
          const discriminatorColumn = entityMetadata.parentEntityMetadata.ownColumns.find((column) => column.isDiscriminator);
          if (discriminatorColumn && !entityMetadata.ownColumns.find((column) => column === discriminatorColumn)) {
            entityMetadata.ownColumns.push(discriminatorColumn);
          }
          entityMetadata.inheritancePattern = entityMetadata.parentEntityMetadata.inheritancePattern;
          if (!entityMetadata.treeType && !!entityMetadata.parentEntityMetadata.treeType) {
            entityMetadata.treeType = entityMetadata.parentEntityMetadata.treeType;
            entityMetadata.treeOptions = entityMetadata.parentEntityMetadata.treeOptions;
            entityMetadata.treeParentRelation = entityMetadata.parentEntityMetadata.treeParentRelation;
            entityMetadata.treeLevelColumn = entityMetadata.parentEntityMetadata.treeLevelColumn;
          }
        }
        const { namingStrategy } = this.connection;
        if (entityMetadata.treeType === "materialized-path") {
          entityMetadata.ownColumns.push(new ColumnMetadata_1.ColumnMetadata({
            connection: this.connection,
            entityMetadata,
            materializedPath: true,
            args: {
              target: entityMetadata.target,
              mode: "virtual",
              propertyName: "mpath",
              options: (
                /*tree.column || */
                {
                  name: namingStrategy.materializedPathColumnName,
                  type: String,
                  nullable: true,
                  default: ""
                }
              )
            }
          }));
        } else if (entityMetadata.treeType === "nested-set") {
          const { left, right } = namingStrategy.nestedSetColumnNames;
          entityMetadata.ownColumns.push(new ColumnMetadata_1.ColumnMetadata({
            connection: this.connection,
            entityMetadata,
            nestedSetLeft: true,
            args: {
              target: entityMetadata.target,
              mode: "virtual",
              propertyName: left,
              options: (
                /*tree.column || */
                {
                  name: left,
                  type: Number,
                  nullable: false,
                  default: 1
                }
              )
            }
          }));
          entityMetadata.ownColumns.push(new ColumnMetadata_1.ColumnMetadata({
            connection: this.connection,
            entityMetadata,
            nestedSetRight: true,
            args: {
              target: entityMetadata.target,
              mode: "virtual",
              propertyName: right,
              options: (
                /*tree.column || */
                {
                  name: right,
                  type: Number,
                  nullable: false,
                  default: 2
                }
              )
            }
          }));
        }
        entityMetadata.ownRelations = this.metadataArgsStorage.filterRelations(entityMetadata.inheritanceTree).map((args) => {
          if (entityMetadata.tableType === "entity-child") {
            const parentRelation = entityMetadata.parentEntityMetadata.ownRelations.find((relation) => relation.propertyName === args.propertyName);
            const type = typeof args.type === "function" ? args.type() : args.type;
            if (parentRelation.type !== type) {
              const clone = Object.create(parentRelation);
              clone.type = type;
              return clone;
            }
            return parentRelation;
          }
          return new RelationMetadata_1.RelationMetadata({ entityMetadata, args });
        });
        entityMetadata.relationIds = this.metadataArgsStorage.filterRelationIds(entityMetadata.inheritanceTree).map((args) => {
          if (entityMetadata.tableType === "entity-child")
            return entityMetadata.parentEntityMetadata.relationIds.find((relationId) => relationId.propertyName === args.propertyName);
          return new RelationIdMetadata_1.RelationIdMetadata({ entityMetadata, args });
        });
        entityMetadata.relationCounts = this.metadataArgsStorage.filterRelationCounts(entityMetadata.inheritanceTree).map((args) => {
          if (entityMetadata.tableType === "entity-child")
            return entityMetadata.parentEntityMetadata.relationCounts.find((relationCount) => relationCount.propertyName === args.propertyName);
          return new RelationCountMetadata_1.RelationCountMetadata({ entityMetadata, args });
        });
        entityMetadata.ownListeners = this.metadataArgsStorage.filterListeners(entityMetadata.inheritanceTree).map((args) => {
          return new EntityListenerMetadata_1.EntityListenerMetadata({
            entityMetadata,
            args
          });
        });
        entityMetadata.checks = this.metadataArgsStorage.filterChecks(entityMetadata.inheritanceTree).map((args) => {
          return new CheckMetadata_1.CheckMetadata({ entityMetadata, args });
        });
        if (this.connection.driver.options.type === "postgres") {
          entityMetadata.exclusions = this.metadataArgsStorage.filterExclusions(entityMetadata.inheritanceTree).map((args) => {
            return new ExclusionMetadata_1.ExclusionMetadata({ entityMetadata, args });
          });
        }
        if (this.connection.driver.options.type === "cockroachdb") {
          entityMetadata.ownIndices = this.metadataArgsStorage.filterIndices(entityMetadata.inheritanceTree).filter((args) => !args.unique).map((args) => {
            return new IndexMetadata_1.IndexMetadata({ entityMetadata, args });
          });
          const uniques = this.metadataArgsStorage.filterIndices(entityMetadata.inheritanceTree).filter((args) => args.unique).map((args) => {
            return new UniqueMetadata_1.UniqueMetadata({
              entityMetadata,
              args: {
                target: args.target,
                name: args.name,
                columns: args.columns
              }
            });
          });
          entityMetadata.ownUniques.push(...uniques);
        } else {
          entityMetadata.ownIndices = this.metadataArgsStorage.filterIndices(entityMetadata.inheritanceTree).map((args) => {
            return new IndexMetadata_1.IndexMetadata({ entityMetadata, args });
          });
        }
        if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql" || this.connection.driver.options.type === "sap" || this.connection.driver.options.type === "spanner") {
          const indices = this.metadataArgsStorage.filterUniques(entityMetadata.inheritanceTree).map((args) => {
            return new IndexMetadata_1.IndexMetadata({
              entityMetadata,
              args: {
                target: args.target,
                name: args.name,
                columns: args.columns,
                unique: true,
                synchronize: true
              }
            });
          });
          entityMetadata.ownIndices.push(...indices);
        } else {
          const uniques = this.metadataArgsStorage.filterUniques(entityMetadata.inheritanceTree).map((args) => {
            return new UniqueMetadata_1.UniqueMetadata({ entityMetadata, args });
          });
          entityMetadata.ownUniques.push(...uniques);
        }
      }
      /**
       * Creates from the given embedded metadata args real embedded metadatas with its columns and relations,
       * and does the same for all its sub-embeddeds (goes recursively).
       */
      createEmbeddedsRecursively(entityMetadata, embeddedArgs) {
        return embeddedArgs.map((embeddedArgs2) => {
          const embeddedMetadata = new EmbeddedMetadata_1.EmbeddedMetadata({
            entityMetadata,
            args: embeddedArgs2
          });
          const targets = typeof embeddedMetadata.type === "function" ? MetadataUtils_1.MetadataUtils.getInheritanceTree(embeddedMetadata.type) : [embeddedMetadata.type];
          embeddedMetadata.columns = this.metadataArgsStorage.filterColumns(targets).map((args) => {
            return new ColumnMetadata_1.ColumnMetadata({
              connection: this.connection,
              entityMetadata,
              embeddedMetadata,
              args
            });
          });
          embeddedMetadata.relations = this.metadataArgsStorage.filterRelations(targets).map((args) => {
            return new RelationMetadata_1.RelationMetadata({
              entityMetadata,
              embeddedMetadata,
              args
            });
          });
          embeddedMetadata.listeners = this.metadataArgsStorage.filterListeners(targets).map((args) => {
            return new EntityListenerMetadata_1.EntityListenerMetadata({
              entityMetadata,
              embeddedMetadata,
              args
            });
          });
          embeddedMetadata.indices = this.metadataArgsStorage.filterIndices(targets).map((args) => {
            return new IndexMetadata_1.IndexMetadata({
              entityMetadata,
              embeddedMetadata,
              args
            });
          });
          embeddedMetadata.uniques = this.metadataArgsStorage.filterUniques(targets).map((args) => {
            return new UniqueMetadata_1.UniqueMetadata({
              entityMetadata,
              embeddedMetadata,
              args
            });
          });
          embeddedMetadata.relationIds = this.metadataArgsStorage.filterRelationIds(targets).map((args) => {
            return new RelationIdMetadata_1.RelationIdMetadata({ entityMetadata, args });
          });
          embeddedMetadata.relationCounts = this.metadataArgsStorage.filterRelationCounts(targets).map((args) => {
            return new RelationCountMetadata_1.RelationCountMetadata({ entityMetadata, args });
          });
          embeddedMetadata.embeddeds = this.createEmbeddedsRecursively(entityMetadata, this.metadataArgsStorage.filterEmbeddeds(targets));
          embeddedMetadata.embeddeds.forEach((subEmbedded) => subEmbedded.parentEmbeddedMetadata = embeddedMetadata);
          entityMetadata.allEmbeddeds.push(embeddedMetadata);
          return embeddedMetadata;
        });
      }
      /**
       * Computes all entity metadata's computed properties, and all its sub-metadatas (relations, columns, embeds, etc).
       */
      computeEntityMetadataStep2(entityMetadata) {
        entityMetadata.embeddeds.forEach((embedded) => embedded.build(this.connection));
        entityMetadata.embeddeds.forEach((embedded) => {
          embedded.columnsFromTree.forEach((column) => column.build(this.connection));
          embedded.relationsFromTree.forEach((relation) => relation.build());
        });
        entityMetadata.ownColumns.forEach((column) => column.build(this.connection));
        entityMetadata.ownRelations.forEach((relation) => relation.build());
        entityMetadata.relations = entityMetadata.embeddeds.reduce((relations, embedded) => relations.concat(embedded.relationsFromTree), entityMetadata.ownRelations);
        entityMetadata.eagerRelations = entityMetadata.relations.filter((relation) => relation.isEager);
        entityMetadata.lazyRelations = entityMetadata.relations.filter((relation) => relation.isLazy);
        entityMetadata.oneToOneRelations = entityMetadata.relations.filter((relation) => relation.isOneToOne);
        entityMetadata.oneToManyRelations = entityMetadata.relations.filter((relation) => relation.isOneToMany);
        entityMetadata.manyToOneRelations = entityMetadata.relations.filter((relation) => relation.isManyToOne);
        entityMetadata.manyToManyRelations = entityMetadata.relations.filter((relation) => relation.isManyToMany);
        entityMetadata.ownerOneToOneRelations = entityMetadata.relations.filter((relation) => relation.isOneToOneOwner);
        entityMetadata.ownerManyToManyRelations = entityMetadata.relations.filter((relation) => relation.isManyToManyOwner);
        entityMetadata.treeParentRelation = entityMetadata.relations.find((relation) => relation.isTreeParent);
        entityMetadata.treeChildrenRelation = entityMetadata.relations.find((relation) => relation.isTreeChildren);
        entityMetadata.columns = entityMetadata.embeddeds.reduce((columns, embedded) => columns.concat(embedded.columnsFromTree), entityMetadata.ownColumns);
        entityMetadata.listeners = entityMetadata.embeddeds.reduce((listeners, embedded) => listeners.concat(embedded.listenersFromTree), entityMetadata.ownListeners);
        entityMetadata.afterLoadListeners = entityMetadata.listeners.filter((listener) => listener.type === EventListenerTypes_1.EventListenerTypes.AFTER_LOAD);
        entityMetadata.afterInsertListeners = entityMetadata.listeners.filter((listener) => listener.type === EventListenerTypes_1.EventListenerTypes.AFTER_INSERT);
        entityMetadata.afterUpdateListeners = entityMetadata.listeners.filter((listener) => listener.type === EventListenerTypes_1.EventListenerTypes.AFTER_UPDATE);
        entityMetadata.afterRemoveListeners = entityMetadata.listeners.filter((listener) => listener.type === EventListenerTypes_1.EventListenerTypes.AFTER_REMOVE);
        entityMetadata.afterSoftRemoveListeners = entityMetadata.listeners.filter((listener) => listener.type === EventListenerTypes_1.EventListenerTypes.AFTER_SOFT_REMOVE);
        entityMetadata.afterRecoverListeners = entityMetadata.listeners.filter((listener) => listener.type === EventListenerTypes_1.EventListenerTypes.AFTER_RECOVER);
        entityMetadata.beforeInsertListeners = entityMetadata.listeners.filter((listener) => listener.type === EventListenerTypes_1.EventListenerTypes.BEFORE_INSERT);
        entityMetadata.beforeUpdateListeners = entityMetadata.listeners.filter((listener) => listener.type === EventListenerTypes_1.EventListenerTypes.BEFORE_UPDATE);
        entityMetadata.beforeRemoveListeners = entityMetadata.listeners.filter((listener) => listener.type === EventListenerTypes_1.EventListenerTypes.BEFORE_REMOVE);
        entityMetadata.beforeSoftRemoveListeners = entityMetadata.listeners.filter((listener) => listener.type === EventListenerTypes_1.EventListenerTypes.BEFORE_SOFT_REMOVE);
        entityMetadata.beforeRecoverListeners = entityMetadata.listeners.filter((listener) => listener.type === EventListenerTypes_1.EventListenerTypes.BEFORE_RECOVER);
        entityMetadata.indices = entityMetadata.embeddeds.reduce((indices, embedded) => indices.concat(embedded.indicesFromTree), entityMetadata.ownIndices);
        entityMetadata.uniques = entityMetadata.embeddeds.reduce((uniques, embedded) => uniques.concat(embedded.uniquesFromTree), entityMetadata.ownUniques);
        entityMetadata.primaryColumns = entityMetadata.columns.filter((column) => column.isPrimary);
        entityMetadata.nonVirtualColumns = entityMetadata.columns.filter((column) => !column.isVirtual);
        entityMetadata.ancestorColumns = entityMetadata.columns.filter((column) => column.closureType === "ancestor");
        entityMetadata.descendantColumns = entityMetadata.columns.filter((column) => column.closureType === "descendant");
        entityMetadata.hasMultiplePrimaryKeys = entityMetadata.primaryColumns.length > 1;
        entityMetadata.generatedColumns = entityMetadata.columns.filter((column) => column.isGenerated || column.isObjectId);
        entityMetadata.hasUUIDGeneratedColumns = entityMetadata.columns.filter((column) => column.isGenerated || column.generationStrategy === "uuid").length > 0;
        entityMetadata.createDateColumn = entityMetadata.columns.find((column) => column.isCreateDate);
        entityMetadata.updateDateColumn = entityMetadata.columns.find((column) => column.isUpdateDate);
        entityMetadata.deleteDateColumn = entityMetadata.columns.find((column) => column.isDeleteDate);
        entityMetadata.versionColumn = entityMetadata.columns.find((column) => column.isVersion);
        entityMetadata.discriminatorColumn = entityMetadata.columns.find((column) => column.isDiscriminator);
        entityMetadata.treeLevelColumn = entityMetadata.columns.find((column) => column.isTreeLevel);
        entityMetadata.nestedSetLeftColumn = entityMetadata.columns.find((column) => column.isNestedSetLeft);
        entityMetadata.nestedSetRightColumn = entityMetadata.columns.find((column) => column.isNestedSetRight);
        entityMetadata.materializedPathColumn = entityMetadata.columns.find((column) => column.isMaterializedPath);
        entityMetadata.objectIdColumn = entityMetadata.columns.find((column) => column.isObjectId);
        entityMetadata.foreignKeys.forEach((foreignKey) => foreignKey.build(this.connection.namingStrategy));
        entityMetadata.propertiesMap = entityMetadata.createPropertiesMap();
        entityMetadata.relationIds.forEach((relationId) => relationId.build());
        entityMetadata.relationCounts.forEach((relationCount) => relationCount.build());
        entityMetadata.embeddeds.forEach((embedded) => {
          embedded.relationIdsFromTree.forEach((relationId) => relationId.build());
          embedded.relationCountsFromTree.forEach((relationCount) => relationCount.build());
        });
      }
      /**
       * Computes entity metadata's relations inverse side properties.
       */
      computeInverseProperties(entityMetadata, entityMetadatas) {
        entityMetadata.relations.forEach((relation) => {
          const inverseEntityMetadata = entityMetadatas.find((m) => m.target === relation.type || typeof relation.type === "string" && (m.targetName === relation.type || m.givenTableName === relation.type));
          if (!inverseEntityMetadata)
            throw new error_1.TypeORMError("Entity metadata for " + entityMetadata.name + "#" + relation.propertyPath + " was not found. Check if you specified a correct entity object and if it's connected in the connection options.");
          relation.inverseEntityMetadata = inverseEntityMetadata;
          relation.inverseSidePropertyPath = relation.buildInverseSidePropertyPath();
          relation.inverseRelation = inverseEntityMetadata.relations.find((foundRelation) => foundRelation.propertyPath === relation.inverseSidePropertyPath);
        });
      }
      /**
       * Creates indices for the table of single table inheritance.
       */
      createKeysForTableInheritance(entityMetadata) {
        const isDiscriminatorColumnAlreadyIndexed = entityMetadata.indices.some(({ givenColumnNames }) => !!givenColumnNames && Array.isArray(givenColumnNames) && givenColumnNames.length === 1 && givenColumnNames[0] === entityMetadata.discriminatorColumn?.databaseName);
        if (isDiscriminatorColumnAlreadyIndexed) {
          return;
        }
        entityMetadata.indices.push(new IndexMetadata_1.IndexMetadata({
          entityMetadata,
          columns: [entityMetadata.discriminatorColumn],
          args: {
            target: entityMetadata.target,
            unique: false
          }
        }));
      }
      /**
       * Creates from the given foreign key metadata args real foreign key metadatas.
       */
      createForeignKeys(entityMetadata, entityMetadatas) {
        this.metadataArgsStorage.filterForeignKeys(entityMetadata.inheritanceTree).forEach((foreignKeyArgs) => {
          const foreignKeyType = typeof foreignKeyArgs.type === "function" ? foreignKeyArgs.type() : foreignKeyArgs.type;
          const referencedEntityMetadata = entityMetadatas.find((m) => typeof foreignKeyType === "string" ? m.targetName === foreignKeyType || m.givenTableName === foreignKeyType : InstanceChecker_1.InstanceChecker.isEntitySchema(foreignKeyType) ? m.target === foreignKeyType.options.name || m.target === foreignKeyType.options.target : m.target === foreignKeyType);
          if (!referencedEntityMetadata) {
            throw new error_1.TypeORMError("Entity metadata for " + entityMetadata.name + (foreignKeyArgs.propertyName ? "#" + foreignKeyArgs.propertyName : "") + " was not found. Check if you specified a correct entity object and if it's connected in the connection options.");
          }
          const columnNames = foreignKeyArgs.columnNames ?? [];
          const referencedColumnNames = foreignKeyArgs.referencedColumnNames ?? [];
          const columns = [];
          const referencedColumns = [];
          if (foreignKeyArgs.propertyName) {
            columnNames.push(foreignKeyArgs.propertyName);
            if (foreignKeyArgs.inverseSide) {
              if (typeof foreignKeyArgs.inverseSide === "function") {
                referencedColumnNames.push(foreignKeyArgs.inverseSide(referencedEntityMetadata.propertiesMap));
              } else {
                referencedColumnNames.push(foreignKeyArgs.inverseSide);
              }
            }
          }
          if (!referencedColumnNames.length) {
            referencedColumns.push(...referencedEntityMetadata.primaryColumns);
          }
          const columnNameToColumn = (columnName, entityMetadata2) => {
            const column = entityMetadata2.columns.find((column2) => column2.propertyName === columnName || column2.databaseName === columnName);
            if (column)
              return column;
            const foreignKeyName = foreignKeyArgs.name ? '"' + foreignKeyArgs.name + '" ' : "";
            const entityName = entityMetadata2.targetName;
            throw new error_1.TypeORMError(`Foreign key constraint ${foreignKeyName}contains column that is missing in the entity (${entityName}): ${columnName}`);
          };
          columns.push(...columnNames.map((columnName) => columnNameToColumn(columnName, entityMetadata)));
          referencedColumns.push(...referencedColumnNames.map((columnName) => columnNameToColumn(columnName, referencedEntityMetadata)));
          entityMetadata.foreignKeys.push(new ForeignKeyMetadata_1.ForeignKeyMetadata({
            entityMetadata,
            referencedEntityMetadata,
            namingStrategy: this.connection.namingStrategy,
            columns,
            referencedColumns,
            ...foreignKeyArgs
          }));
        });
      }
    };
    exports2.EntityMetadataBuilder = EntityMetadataBuilder;
  }
});

// node_modules/typeorm/entity-schema/EntitySchemaEmbeddedError.js
var require_EntitySchemaEmbeddedError = __commonJS({
  "node_modules/typeorm/entity-schema/EntitySchemaEmbeddedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EntitySchemaEmbeddedError = void 0;
    var error_1 = require_error();
    var EntitySchemaEmbeddedError = class _EntitySchemaEmbeddedError extends error_1.TypeORMError {
      static createEntitySchemaIsRequiredException(field) {
        return new _EntitySchemaEmbeddedError(`EntitySchema is required for ${field} embedded field`);
      }
      static createTargetIsRequired(field) {
        return new _EntitySchemaEmbeddedError(`Target field is required for ${field} embedded EntitySchema`);
      }
      constructor(message) {
        super(message);
      }
    };
    exports2.EntitySchemaEmbeddedError = EntitySchemaEmbeddedError;
  }
});

// node_modules/typeorm/entity-schema/EntitySchemaTransformer.js
var require_EntitySchemaTransformer = __commonJS({
  "node_modules/typeorm/entity-schema/EntitySchemaTransformer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EntitySchemaTransformer = void 0;
    var MetadataArgsStorage_1 = require_MetadataArgsStorage();
    var EntitySchemaEmbeddedError_1 = require_EntitySchemaEmbeddedError();
    var EntitySchemaTransformer = class {
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Transforms entity schema into new metadata args storage object.
       */
      transform(schemas) {
        const metadataArgsStorage = new MetadataArgsStorage_1.MetadataArgsStorage();
        schemas.forEach((entitySchema) => {
          const options = entitySchema.options;
          const tableMetadata = {
            target: options.target || options.name,
            name: options.tableName,
            database: options.database,
            schema: options.schema,
            type: options.type || "regular",
            orderBy: options.orderBy,
            synchronize: options.synchronize,
            withoutRowid: !!options.withoutRowid,
            expression: options.expression
          };
          metadataArgsStorage.tables.push(tableMetadata);
          const { inheritance } = options;
          if (inheritance) {
            metadataArgsStorage.inheritances.push({
              target: options.target,
              pattern: inheritance.pattern ?? "STI",
              column: inheritance.column ? typeof inheritance.column === "string" ? { name: inheritance.column } : inheritance.column : void 0
            });
          }
          const { discriminatorValue } = options;
          if (discriminatorValue) {
            metadataArgsStorage.discriminatorValues.push({
              target: options.target || options.name,
              value: discriminatorValue
            });
          }
          this.transformColumnsRecursive(options, metadataArgsStorage);
        });
        return metadataArgsStorage;
      }
      transformColumnsRecursive(options, metadataArgsStorage) {
        Object.keys(options.columns).forEach((columnName) => {
          const column = options.columns[columnName];
          const regularColumn = column;
          let mode = "regular";
          if (regularColumn.createDate)
            mode = "createDate";
          if (regularColumn.updateDate)
            mode = "updateDate";
          if (regularColumn.deleteDate)
            mode = "deleteDate";
          if (regularColumn.version)
            mode = "version";
          if (regularColumn.treeChildrenCount)
            mode = "treeChildrenCount";
          if (regularColumn.treeLevel)
            mode = "treeLevel";
          if (regularColumn.objectId)
            mode = "objectId";
          if (regularColumn.virtualProperty)
            mode = "virtual-property";
          const columnArgs = {
            target: options.target || options.name,
            mode,
            propertyName: columnName,
            options: {
              type: regularColumn.type,
              name: regularColumn.objectId ? "_id" : regularColumn.name,
              primaryKeyConstraintName: regularColumn.primaryKeyConstraintName,
              length: regularColumn.length,
              width: regularColumn.width,
              nullable: regularColumn.nullable,
              readonly: regularColumn.readonly,
              update: regularColumn.update,
              select: regularColumn.select,
              insert: regularColumn.insert,
              primary: regularColumn.primary,
              unique: regularColumn.unique,
              comment: regularColumn.comment,
              default: regularColumn.default,
              onUpdate: regularColumn.onUpdate,
              precision: regularColumn.precision,
              scale: regularColumn.scale,
              zerofill: regularColumn.zerofill,
              unsigned: regularColumn.unsigned,
              charset: regularColumn.charset,
              collation: regularColumn.collation,
              enum: regularColumn.enum,
              enumName: regularColumn.enumName,
              asExpression: regularColumn.asExpression,
              generatedType: regularColumn.generatedType,
              hstoreType: regularColumn.hstoreType,
              array: regularColumn.array,
              transformer: regularColumn.transformer,
              spatialFeatureType: regularColumn.spatialFeatureType,
              srid: regularColumn.srid,
              query: regularColumn.query
            }
          };
          metadataArgsStorage.columns.push(columnArgs);
          if (regularColumn.generated) {
            const generationArgs = {
              target: options.target || options.name,
              propertyName: columnName,
              strategy: typeof regularColumn.generated === "string" ? regularColumn.generated : "increment"
            };
            metadataArgsStorage.generations.push(generationArgs);
          }
          if (regularColumn.unique)
            metadataArgsStorage.uniques.push({
              target: options.target || options.name,
              columns: [columnName]
            });
          if (regularColumn.foreignKey) {
            const foreignKey = regularColumn.foreignKey;
            const foreignKeyArgs = {
              target: options.target || options.name,
              type: foreignKey.target,
              propertyName: columnName,
              inverseSide: foreignKey.inverseSide,
              name: foreignKey.name,
              onDelete: foreignKey.onDelete,
              onUpdate: foreignKey.onUpdate,
              deferrable: foreignKey.deferrable
            };
            metadataArgsStorage.foreignKeys.push(foreignKeyArgs);
          }
        });
        if (options.relations) {
          Object.keys(options.relations).forEach((relationName) => {
            const relationSchema = options.relations[relationName];
            const relation = {
              target: options.target || options.name,
              propertyName: relationName,
              relationType: relationSchema.type,
              isLazy: relationSchema.lazy || false,
              type: relationSchema.target,
              inverseSideProperty: relationSchema.inverseSide,
              isTreeParent: relationSchema.treeParent,
              isTreeChildren: relationSchema.treeChildren,
              options: {
                eager: relationSchema.eager || false,
                cascade: relationSchema.cascade,
                nullable: relationSchema.nullable,
                onDelete: relationSchema.onDelete,
                onUpdate: relationSchema.onUpdate,
                deferrable: relationSchema.deferrable,
                // primary: relationSchema.primary,
                createForeignKeyConstraints: relationSchema.createForeignKeyConstraints,
                persistence: relationSchema.persistence,
                orphanedRowAction: relationSchema.orphanedRowAction
              }
            };
            metadataArgsStorage.relations.push(relation);
            if (relationSchema.joinColumn) {
              if (typeof relationSchema.joinColumn === "boolean") {
                const joinColumn = {
                  target: options.target || options.name,
                  propertyName: relationName
                };
                metadataArgsStorage.joinColumns.push(joinColumn);
              } else {
                const joinColumnsOptions = Array.isArray(relationSchema.joinColumn) ? relationSchema.joinColumn : [relationSchema.joinColumn];
                for (const joinColumnOption of joinColumnsOptions) {
                  const joinColumn = {
                    target: options.target || options.name,
                    propertyName: relationName,
                    name: joinColumnOption.name,
                    referencedColumnName: joinColumnOption.referencedColumnName,
                    foreignKeyConstraintName: joinColumnOption.foreignKeyConstraintName
                  };
                  metadataArgsStorage.joinColumns.push(joinColumn);
                }
              }
            }
            if (relationSchema.joinTable) {
              if (typeof relationSchema.joinTable === "boolean") {
                const joinTable = {
                  target: options.target || options.name,
                  propertyName: relationName
                };
                metadataArgsStorage.joinTables.push(joinTable);
              } else {
                const joinTable = {
                  target: options.target || options.name,
                  propertyName: relationName,
                  name: relationSchema.joinTable.name,
                  database: relationSchema.joinTable.database,
                  schema: relationSchema.joinTable.schema,
                  joinColumns: relationSchema.joinTable.joinColumn ? [
                    relationSchema.joinTable.joinColumn
                  ] : relationSchema.joinTable.joinColumns,
                  inverseJoinColumns: relationSchema.joinTable.inverseJoinColumn ? [
                    relationSchema.joinTable.inverseJoinColumn
                  ] : relationSchema.joinTable.inverseJoinColumns
                };
                metadataArgsStorage.joinTables.push(joinTable);
              }
            }
          });
        }
        if (options.relationIds) {
          Object.keys(options.relationIds).forEach((relationIdName) => {
            const relationIdOptions = options.relationIds[relationIdName];
            const relationId = {
              propertyName: relationIdName,
              relation: relationIdOptions.relationName,
              target: options.target || options.name,
              alias: relationIdOptions.alias,
              queryBuilderFactory: relationIdOptions.queryBuilderFactory
            };
            metadataArgsStorage.relationIds.push(relationId);
          });
        }
        if (options.indices) {
          options.indices.forEach((index) => {
            const indexArgs = {
              target: options.target || options.name,
              name: index.name,
              unique: index.unique === true ? true : false,
              spatial: index.spatial === true ? true : false,
              fulltext: index.fulltext === true ? true : false,
              nullFiltered: index.nullFiltered === true ? true : false,
              parser: index.parser,
              synchronize: index.synchronize === false ? false : true,
              where: index.where,
              sparse: index.sparse,
              columns: index.columns
            };
            metadataArgsStorage.indices.push(indexArgs);
          });
        }
        if (options.foreignKeys) {
          options.foreignKeys.forEach((foreignKey) => {
            const foreignKeyArgs = {
              target: options.target || options.name,
              type: foreignKey.target,
              columnNames: foreignKey.columnNames,
              referencedColumnNames: foreignKey.referencedColumnNames,
              name: foreignKey.name,
              onDelete: foreignKey.onDelete,
              onUpdate: foreignKey.onUpdate,
              deferrable: foreignKey.deferrable
            };
            metadataArgsStorage.foreignKeys.push(foreignKeyArgs);
          });
        }
        if (options.uniques) {
          options.uniques.forEach((unique) => {
            const uniqueArgs = {
              target: options.target || options.name,
              name: unique.name,
              columns: unique.columns,
              deferrable: unique.deferrable
            };
            metadataArgsStorage.uniques.push(uniqueArgs);
          });
        }
        if (options.checks) {
          options.checks.forEach((check) => {
            const checkArgs = {
              target: options.target || options.name,
              name: check.name,
              expression: check.expression
            };
            metadataArgsStorage.checks.push(checkArgs);
          });
        }
        if (options.exclusions) {
          options.exclusions.forEach((exclusion) => {
            const exclusionArgs = {
              target: options.target || options.name,
              name: exclusion.name,
              expression: exclusion.expression
            };
            metadataArgsStorage.exclusions.push(exclusionArgs);
          });
        }
        if (options.embeddeds) {
          Object.keys(options.embeddeds).forEach((columnName) => {
            const embeddedOptions = options.embeddeds[columnName];
            if (!embeddedOptions.schema)
              throw EntitySchemaEmbeddedError_1.EntitySchemaEmbeddedError.createEntitySchemaIsRequiredException(columnName);
            const embeddedSchema = embeddedOptions.schema.options;
            metadataArgsStorage.embeddeds.push({
              target: options.target || options.name,
              propertyName: columnName,
              isArray: embeddedOptions.array === true,
              prefix: embeddedOptions.prefix !== void 0 ? embeddedOptions.prefix : void 0,
              type: () => embeddedSchema?.target || embeddedSchema.name
            });
            this.transformColumnsRecursive(embeddedSchema, metadataArgsStorage);
          });
        }
      }
    };
    exports2.EntitySchemaTransformer = EntitySchemaTransformer;
  }
});

// node_modules/typeorm/connection/ConnectionMetadataBuilder.js
var require_ConnectionMetadataBuilder = __commonJS({
  "node_modules/typeorm/connection/ConnectionMetadataBuilder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectionMetadataBuilder = void 0;
    var DirectoryExportedClassesLoader_1 = require_DirectoryExportedClassesLoader();
    var OrmUtils_1 = require_OrmUtils();
    var container_1 = require_container();
    var globals_1 = require_globals();
    var EntityMetadataBuilder_1 = require_EntityMetadataBuilder();
    var EntitySchemaTransformer_1 = require_EntitySchemaTransformer();
    var InstanceChecker_1 = require_InstanceChecker();
    var ConnectionMetadataBuilder = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection) {
        this.connection = connection;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Builds migration instances for the given classes or directories.
       */
      async buildMigrations(migrations) {
        const [migrationClasses, migrationDirectories] = OrmUtils_1.OrmUtils.splitClassesAndStrings(migrations);
        const allMigrationClasses = [
          ...migrationClasses,
          ...await (0, DirectoryExportedClassesLoader_1.importClassesFromDirectories)(this.connection.logger, migrationDirectories)
        ];
        return allMigrationClasses.map((migrationClass) => (0, container_1.getFromContainer)(migrationClass));
      }
      /**
       * Builds subscriber instances for the given classes or directories.
       */
      async buildSubscribers(subscribers) {
        const [subscriberClasses, subscriberDirectories] = OrmUtils_1.OrmUtils.splitClassesAndStrings(subscribers || []);
        const allSubscriberClasses = [
          ...subscriberClasses,
          ...await (0, DirectoryExportedClassesLoader_1.importClassesFromDirectories)(this.connection.logger, subscriberDirectories)
        ];
        return (0, globals_1.getMetadataArgsStorage)().filterSubscribers(allSubscriberClasses).map((metadata) => (0, container_1.getFromContainer)(metadata.target));
      }
      /**
       * Builds entity metadatas for the given classes or directories.
       */
      async buildEntityMetadatas(entities) {
        const [entityClassesOrSchemas, entityDirectories] = OrmUtils_1.OrmUtils.splitClassesAndStrings(entities || []);
        const entityClasses = entityClassesOrSchemas.filter((entityClass) => !InstanceChecker_1.InstanceChecker.isEntitySchema(entityClass));
        const entitySchemas = entityClassesOrSchemas.filter((entityClass) => InstanceChecker_1.InstanceChecker.isEntitySchema(entityClass));
        const allEntityClasses = [
          ...entityClasses,
          ...await (0, DirectoryExportedClassesLoader_1.importClassesFromDirectories)(this.connection.logger, entityDirectories)
        ];
        allEntityClasses.forEach((entityClass) => {
          if (InstanceChecker_1.InstanceChecker.isEntitySchema(entityClass)) {
            entitySchemas.push(entityClass);
          }
        });
        const decoratorEntityMetadatas = new EntityMetadataBuilder_1.EntityMetadataBuilder(this.connection, (0, globals_1.getMetadataArgsStorage)()).build(allEntityClasses);
        const metadataArgsStorageFromSchema = new EntitySchemaTransformer_1.EntitySchemaTransformer().transform(entitySchemas);
        const schemaEntityMetadatas = new EntityMetadataBuilder_1.EntityMetadataBuilder(this.connection, metadataArgsStorageFromSchema).build();
        return [...decoratorEntityMetadatas, ...schemaEntityMetadatas];
      }
    };
    exports2.ConnectionMetadataBuilder = ConnectionMetadataBuilder;
  }
});

// node_modules/typeorm/logger/AbstractLogger.js
var require_AbstractLogger = __commonJS({
  "node_modules/typeorm/logger/AbstractLogger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractLogger = void 0;
    var PlatformTools_1 = require_PlatformTools();
    var AbstractLogger2 = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(options) {
        this.options = options;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Logs query and parameters used in it.
       */
      logQuery(query, parameters, queryRunner) {
        if (!this.isLogEnabledFor("query")) {
          return;
        }
        this.writeLog("query", {
          type: "query",
          prefix: "query",
          message: query,
          format: "sql",
          parameters
        }, queryRunner);
      }
      /**
       * Logs query that is failed.
       */
      logQueryError(error, query, parameters, queryRunner) {
        if (!this.isLogEnabledFor("query-error")) {
          return;
        }
        this.writeLog("warn", [
          {
            type: "query-error",
            prefix: "query failed",
            message: query,
            format: "sql",
            parameters
          },
          {
            type: "query-error",
            prefix: "error",
            message: error
          }
        ], queryRunner);
      }
      /**
       * Logs query that is slow.
       */
      logQuerySlow(time, query, parameters, queryRunner) {
        if (!this.isLogEnabledFor("query-slow")) {
          return;
        }
        this.writeLog("warn", [
          {
            type: "query-slow",
            prefix: "query is slow",
            message: query,
            format: "sql",
            parameters,
            additionalInfo: {
              time
            }
          },
          {
            type: "query-slow",
            prefix: "execution time",
            message: time
          }
        ], queryRunner);
      }
      /**
       * Logs events from the schema build process.
       */
      logSchemaBuild(message, queryRunner) {
        if (!this.isLogEnabledFor("schema-build")) {
          return;
        }
        this.writeLog("schema", {
          type: "schema-build",
          message
        }, queryRunner);
      }
      /**
       * Logs events from the migration run process.
       */
      logMigration(message, queryRunner) {
        if (!this.isLogEnabledFor("migration")) {
          return;
        }
        this.writeLog("log", {
          type: "migration",
          message
        }, queryRunner);
      }
      /**
       * Perform logging using given logger, or by default to the console.
       * Log has its own level and message.
       */
      log(level, message, queryRunner) {
        switch (level) {
          case "log":
            if (!this.isLogEnabledFor("log")) {
              return;
            }
            this.writeLog("log", {
              type: "log",
              message
            }, queryRunner);
            break;
          case "info":
            if (!this.isLogEnabledFor("info")) {
              return;
            }
            this.writeLog("info", {
              type: "info",
              prefix: "info",
              message
            }, queryRunner);
            break;
          case "warn":
            if (!this.isLogEnabledFor("warn")) {
              return;
            }
            this.writeLog("warn", {
              type: "warn",
              message
            }, queryRunner);
            break;
        }
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Check is logging for level or message type is enabled.
       */
      isLogEnabledFor(type) {
        switch (type) {
          case "query":
            return this.options === "all" || this.options === true || Array.isArray(this.options) && this.options.indexOf("query") !== -1;
          case "error":
          case "query-error":
            return this.options === "all" || this.options === true || Array.isArray(this.options) && this.options.indexOf("error") !== -1;
          case "query-slow":
            return true;
          case "schema":
          case "schema-build":
            return this.options === "all" || Array.isArray(this.options) && this.options.indexOf("schema") !== -1;
          case "migration":
            return true;
          case "log":
            return this.options === "all" || Array.isArray(this.options) && this.options.indexOf("log") !== -1;
          case "info":
            return this.options === "all" || Array.isArray(this.options) && this.options.indexOf("info") !== -1;
          case "warn":
            return this.options === "all" || Array.isArray(this.options) && this.options.indexOf("warn") !== -1;
          default:
            return false;
        }
      }
      /**
       * Prepare and format log messages
       */
      prepareLogMessages(logMessage, options, queryRunner) {
        options = {
          ...{
            addColonToPrefix: true,
            appendParameterAsComment: true,
            highlightSql: true,
            formatSql: false
          },
          ...options
        };
        const messages = Array.isArray(logMessage) ? logMessage : [logMessage];
        for (let message of messages) {
          if (typeof message !== "object") {
            message = {
              message
            };
          }
          if (message.format === "sql") {
            let sql = String(message.message);
            if (options.formatSql) {
              sql = PlatformTools_1.PlatformTools.formatSql(sql, queryRunner?.connection?.options.type);
            }
            if (options.appendParameterAsComment && message.parameters && message.parameters.length) {
              sql += ` -- PARAMETERS: ${this.stringifyParams(message.parameters)}`;
            }
            if (options.highlightSql) {
              sql = PlatformTools_1.PlatformTools.highlightSql(sql);
            }
            message.message = sql;
          }
          if (options.addColonToPrefix && message.prefix) {
            message.prefix += ":";
          }
        }
        return messages;
      }
      /**
       * Converts parameters to a string.
       * Sometimes parameters can have circular objects and therefor we are handle this case too.
       */
      stringifyParams(parameters) {
        try {
          return JSON.stringify(parameters);
        } catch (error) {
          return parameters;
        }
      }
    };
    exports2.AbstractLogger = AbstractLogger2;
  }
});

// node_modules/typeorm/logger/SimpleConsoleLogger.js
var require_SimpleConsoleLogger = __commonJS({
  "node_modules/typeorm/logger/SimpleConsoleLogger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SimpleConsoleLogger = void 0;
    var AbstractLogger_1 = require_AbstractLogger();
    var SimpleConsoleLogger2 = class extends AbstractLogger_1.AbstractLogger {
      /**
       * Write log to specific output.
       */
      writeLog(level, logMessage, queryRunner) {
        const messages = this.prepareLogMessages(logMessage, {
          highlightSql: false
        });
        for (const message of messages) {
          switch (message.type ?? level) {
            case "log":
            case "schema-build":
            case "migration":
              console.log(message.message);
              break;
            case "info":
            case "query":
              if (message.prefix) {
                console.info(message.prefix, message.message);
              } else {
                console.info(message.message);
              }
              break;
            case "warn":
            case "query-slow":
              if (message.prefix) {
                console.warn(message.prefix, message.message);
              } else {
                console.warn(message.message);
              }
              break;
            case "error":
            case "query-error":
              if (message.prefix) {
                console.error(message.prefix, message.message);
              } else {
                console.error(message.message);
              }
              break;
          }
        }
      }
    };
    exports2.SimpleConsoleLogger = SimpleConsoleLogger2;
  }
});

// node_modules/typeorm/logger/AdvancedConsoleLogger.js
var require_AdvancedConsoleLogger = __commonJS({
  "node_modules/typeorm/logger/AdvancedConsoleLogger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AdvancedConsoleLogger = void 0;
    var PlatformTools_1 = require_PlatformTools();
    var AbstractLogger_1 = require_AbstractLogger();
    var AdvancedConsoleLogger2 = class extends AbstractLogger_1.AbstractLogger {
      /**
       * Write log to specific output.
       */
      writeLog(level, logMessage, queryRunner) {
        const messages = this.prepareLogMessages(logMessage);
        for (const message of messages) {
          switch (message.type ?? level) {
            case "log":
            case "schema-build":
            case "migration":
              PlatformTools_1.PlatformTools.log(String(message.message));
              break;
            case "info":
            case "query":
              if (message.prefix) {
                PlatformTools_1.PlatformTools.logInfo(message.prefix, message.message);
              } else {
                PlatformTools_1.PlatformTools.log(String(message.message));
              }
              break;
            case "warn":
            case "query-slow":
              if (message.prefix) {
                PlatformTools_1.PlatformTools.logWarn(message.prefix, message.message);
              } else {
                console.warn(PlatformTools_1.PlatformTools.warn(String(message.message)));
              }
              break;
            case "error":
            case "query-error":
              if (message.prefix) {
                PlatformTools_1.PlatformTools.logError(message.prefix, String(message.message));
              } else {
                console.error(PlatformTools_1.PlatformTools.error(String(message.message)));
              }
              break;
          }
        }
      }
    };
    exports2.AdvancedConsoleLogger = AdvancedConsoleLogger2;
  }
});

// node_modules/typeorm/logger/FileLogger.js
var require_FileLogger = __commonJS({
  "node_modules/typeorm/logger/FileLogger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FileLogger = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var app_root_path_1 = tslib_1.__importDefault(require_app_root_path2());
    var PlatformTools_1 = require_PlatformTools();
    var AbstractLogger_1 = require_AbstractLogger();
    var FileLogger2 = class extends AbstractLogger_1.AbstractLogger {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(options, fileLoggerOptions) {
        super(options);
        this.fileLoggerOptions = fileLoggerOptions;
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Write log to specific output.
       */
      writeLog(level, logMessage, queryRunner) {
        const messages = this.prepareLogMessages(logMessage, {
          highlightSql: false,
          addColonToPrefix: false
        });
        const strings = [];
        for (const message of messages) {
          switch (message.type ?? level) {
            case "log":
              strings.push(`[LOG]: ${message.message}`);
              break;
            case "schema-build":
            case "migration":
              strings.push(String(message.message));
              break;
            case "info":
              strings.push(`[INFO]: ${message.message}`);
              break;
            case "query":
              strings.push(`[QUERY]: ${message.message}`);
              break;
            case "warn":
              strings.push(`[WARN]: ${message.message}`);
              break;
            case "query-slow":
              if (message.prefix === "execution time") {
                continue;
              }
              this.write(`[SLOW QUERY: ${message.additionalInfo?.time} ms]: ${message.message}`);
              break;
            case "error":
            case "query-error":
              if (message.prefix === "query failed") {
                strings.push(`[FAILED QUERY]: ${message.message}`);
              } else if (message.type === "query-error") {
                strings.push(`[QUERY ERROR]: ${message.message}`);
              } else {
                strings.push(`[ERROR]: ${message.message}`);
              }
              break;
          }
        }
        this.write(strings);
      }
      /**
       * Writes given strings into the log file.
       */
      write(strings) {
        strings = Array.isArray(strings) ? strings : [strings];
        const basePath = app_root_path_1.default.path + "/";
        let logPath = "ormlogs.log";
        if (this.fileLoggerOptions && this.fileLoggerOptions.logPath) {
          logPath = PlatformTools_1.PlatformTools.pathNormalize(this.fileLoggerOptions.logPath);
        }
        strings = strings.map((str) => "[" + (/* @__PURE__ */ new Date()).toISOString() + "]" + str);
        PlatformTools_1.PlatformTools.appendFileSync(basePath + logPath, strings.join("\r\n") + "\r\n");
      }
    };
    exports2.FileLogger = FileLogger2;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug") || exports2.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/typeorm/logger/DebugLogger.js
var require_DebugLogger = __commonJS({
  "node_modules/typeorm/logger/DebugLogger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DebugLogger = void 0;
    var AbstractLogger_1 = require_AbstractLogger();
    var debug_1 = require_src();
    var DebugLogger = class extends AbstractLogger_1.AbstractLogger {
      constructor() {
        super(...arguments);
        this.logger = {
          log: (0, debug_1.debug)("typeorm:log"),
          info: (0, debug_1.debug)("typeorm:info"),
          warn: (0, debug_1.debug)("typeorm:warn"),
          error: (0, debug_1.debug)("typeorm:error"),
          query: (0, debug_1.debug)("typeorm:query:log"),
          "query-error": (0, debug_1.debug)("typeorm:query:error"),
          "query-slow": (0, debug_1.debug)("typeorm:query:slow"),
          "schema-build": (0, debug_1.debug)("typeorm:schema"),
          migration: (0, debug_1.debug)("typeorm:migration")
        };
      }
      /**
       * Check is logging for level or message type is enabled.
       */
      isLogEnabledFor(type) {
        switch (type) {
          case "query":
            return this.logger["query"].enabled;
          case "query-error":
            return this.logger["query-error"].enabled;
          case "query-slow":
            return true;
          case "schema":
          case "schema-build":
            return this.logger["schema-build"].enabled;
          case "migration":
            return this.logger["migration"].enabled;
          case "log":
            return this.logger["log"].enabled;
          case "info":
            return this.logger["info"].enabled;
          case "warn":
            return this.logger["warn"].enabled;
          default:
            return false;
        }
      }
      /**
       * Write log to specific output.
       */
      writeLog(level, logMessage, queryRunner) {
        const messages = this.prepareLogMessages(logMessage, {
          appendParameterAsComment: false
        });
        for (const message of messages) {
          const messageTypeOrLevel = message.type ?? level;
          if (messageTypeOrLevel in this.logger) {
            if (message.prefix) {
              this.logger[messageTypeOrLevel](message.prefix, message.message);
            } else {
              this.logger[messageTypeOrLevel](message.message);
            }
            if (message.parameters && message.parameters.length) {
              this.logger[messageTypeOrLevel]("parameters:", message.parameters);
            }
          }
        }
      }
    };
    exports2.DebugLogger = DebugLogger;
  }
});

// node_modules/typeorm/logger/FormattedConsoleLogger.js
var require_FormattedConsoleLogger = __commonJS({
  "node_modules/typeorm/logger/FormattedConsoleLogger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FormattedConsoleLogger = void 0;
    var PlatformTools_1 = require_PlatformTools();
    var AbstractLogger_1 = require_AbstractLogger();
    var FormattedConsoleLogger2 = class extends AbstractLogger_1.AbstractLogger {
      /**
       * Write log to specific output.
       */
      writeLog(level, logMessage, queryRunner) {
        const messages = this.prepareLogMessages(logMessage, {
          highlightSql: true,
          formatSql: true
        }, queryRunner);
        for (const message of messages) {
          switch (message.type ?? level) {
            case "log":
            case "schema-build":
            case "migration":
              PlatformTools_1.PlatformTools.log(String(message.message));
              break;
            case "info":
            case "query":
              if (message.prefix) {
                PlatformTools_1.PlatformTools.logInfo(message.prefix, message.message);
              } else {
                PlatformTools_1.PlatformTools.log(String(message.message));
              }
              break;
            case "warn":
            case "query-slow":
              if (message.prefix) {
                PlatformTools_1.PlatformTools.logWarn(message.prefix, message.message);
              } else {
                console.warn(PlatformTools_1.PlatformTools.warn(String(message.message)));
              }
              break;
            case "error":
            case "query-error":
              if (message.prefix) {
                PlatformTools_1.PlatformTools.logError(message.prefix, String(message.message));
              } else {
                console.error(PlatformTools_1.PlatformTools.error(String(message.message)));
              }
              break;
          }
        }
      }
    };
    exports2.FormattedConsoleLogger = FormattedConsoleLogger2;
  }
});

// node_modules/typeorm/logger/LoggerFactory.js
var require_LoggerFactory = __commonJS({
  "node_modules/typeorm/logger/LoggerFactory.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LoggerFactory = void 0;
    var SimpleConsoleLogger_1 = require_SimpleConsoleLogger();
    var AdvancedConsoleLogger_1 = require_AdvancedConsoleLogger();
    var FileLogger_1 = require_FileLogger();
    var DebugLogger_1 = require_DebugLogger();
    var ObjectUtils_1 = require_ObjectUtils();
    var FormattedConsoleLogger_1 = require_FormattedConsoleLogger();
    var LoggerFactory = class {
      /**
       * Creates a new logger depend on a given connection's driver.
       */
      create(logger, options) {
        if (ObjectUtils_1.ObjectUtils.isObject(logger))
          return logger;
        if (logger) {
          switch (logger) {
            case "simple-console":
              return new SimpleConsoleLogger_1.SimpleConsoleLogger(options);
            case "file":
              return new FileLogger_1.FileLogger(options);
            case "advanced-console":
              return new AdvancedConsoleLogger_1.AdvancedConsoleLogger(options);
            case "formatted-console":
              return new FormattedConsoleLogger_1.FormattedConsoleLogger(options);
            case "debug":
              return new DebugLogger_1.DebugLogger();
          }
        }
        return new AdvancedConsoleLogger_1.AdvancedConsoleLogger(options);
      }
    };
    exports2.LoggerFactory = LoggerFactory;
  }
});

// node_modules/typeorm/cache/RedisQueryResultCache.js
var require_RedisQueryResultCache = __commonJS({
  "node_modules/typeorm/cache/RedisQueryResultCache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RedisQueryResultCache = void 0;
    var PlatformTools_1 = require_PlatformTools();
    var TypeORMError_1 = require_TypeORMError();
    var RedisQueryResultCache = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection, clientType) {
        this.connection = connection;
        this.clientType = clientType;
        this.redis = this.loadRedis();
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Creates a connection with given cache provider.
       */
      async connect() {
        const cacheOptions = this.connection.options.cache;
        if (this.clientType === "redis") {
          const clientOptions = {
            ...cacheOptions?.options
          };
          let tempClient = this.redis.createClient(clientOptions);
          const isRedis4Plus = typeof tempClient.connect === "function";
          if (isRedis4Plus) {
            clientOptions.legacyMode = true;
            tempClient = this.redis.createClient(clientOptions);
          }
          this.client = tempClient;
          if (typeof this.connection.options.cache === "object" && this.connection.options.cache.ignoreErrors) {
            this.client.on("error", (err) => {
              this.connection.logger.log("warn", err);
            });
          }
          if (typeof this.client.connect === "function") {
            await this.client.connect();
          }
          this.detectRedisVersion();
        } else if (this.clientType === "ioredis") {
          if (cacheOptions && cacheOptions.port) {
            if (cacheOptions.options) {
              this.client = new this.redis(cacheOptions.port, cacheOptions.options);
            } else {
              this.client = new this.redis(cacheOptions.port);
            }
          } else if (cacheOptions && cacheOptions.options) {
            this.client = new this.redis(cacheOptions.options);
          } else {
            this.client = new this.redis();
          }
        } else if (this.clientType === "ioredis/cluster") {
          if (cacheOptions && cacheOptions.options && Array.isArray(cacheOptions.options)) {
            this.client = new this.redis.Cluster(cacheOptions.options);
          } else if (cacheOptions && cacheOptions.options && cacheOptions.options.startupNodes) {
            this.client = new this.redis.Cluster(cacheOptions.options.startupNodes, cacheOptions.options.options);
          } else {
            throw new TypeORMError_1.TypeORMError(`options.startupNodes required for ${this.clientType}.`);
          }
        }
      }
      /**
       * Disconnects the connection
       */
      async disconnect() {
        if (this.isRedis5OrHigher()) {
          await this.client.quit();
          this.client = void 0;
          return;
        }
        return new Promise((ok, fail) => {
          this.client.quit((err, result) => {
            if (err)
              return fail(err);
            ok();
            this.client = void 0;
          });
        });
      }
      /**
       * Creates table for storing cache if it does not exist yet.
       */
      async synchronize(queryRunner) {
      }
      /**
       * Get data from cache.
       * Returns cache result if found.
       * Returns undefined if result is not cached.
       */
      getFromCache(options, queryRunner) {
        const key = options.identifier || options.query;
        if (!key)
          return Promise.resolve(void 0);
        if (this.isRedis5OrHigher()) {
          return this.client.get(key).then((result) => {
            return result ? JSON.parse(result) : void 0;
          });
        }
        return new Promise((ok, fail) => {
          this.client.get(key, (err, result) => {
            if (err)
              return fail(err);
            ok(result ? JSON.parse(result) : void 0);
          });
        });
      }
      /**
       * Checks if cache is expired or not.
       */
      isExpired(savedCache) {
        return savedCache.time + savedCache.duration < Date.now();
      }
      /**
       * Stores given query result in the cache.
       */
      async storeInCache(options, savedCache, queryRunner) {
        const key = options.identifier || options.query;
        if (!key)
          return;
        const value = JSON.stringify(options);
        const duration = options.duration;
        if (this.isRedis5OrHigher()) {
          await this.client.set(key, value, {
            PX: duration
          });
          return;
        }
        return new Promise((ok, fail) => {
          this.client.set(key, value, "PX", duration, (err, result) => {
            if (err)
              return fail(err);
            ok();
          });
        });
      }
      /**
       * Clears everything stored in the cache.
       */
      async clear(queryRunner) {
        if (this.isRedis5OrHigher()) {
          await this.client.flushDb();
          return;
        }
        return new Promise((ok, fail) => {
          this.client.flushdb((err, result) => {
            if (err)
              return fail(err);
            ok();
          });
        });
      }
      /**
       * Removes all cached results by given identifiers from cache.
       */
      async remove(identifiers, queryRunner) {
        await Promise.all(identifiers.map((identifier) => {
          return this.deleteKey(identifier);
        }));
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Removes a single key from redis database.
       */
      async deleteKey(key) {
        if (this.isRedis5OrHigher()) {
          await this.client.del(key);
          return;
        }
        return new Promise((ok, fail) => {
          this.client.del(key, (err, result) => {
            if (err)
              return fail(err);
            ok();
          });
        });
      }
      /**
       * Loads redis dependency.
       */
      loadRedis() {
        try {
          if (this.clientType === "ioredis/cluster") {
            return PlatformTools_1.PlatformTools.load("ioredis");
          } else {
            return PlatformTools_1.PlatformTools.load(this.clientType);
          }
        } catch {
          throw new TypeORMError_1.TypeORMError(`Cannot use cache because ${this.clientType} is not installed. Please run "npm i ${this.clientType}".`);
        }
      }
      /**
       * Detects the Redis version based on the connected client's API characteristics
       * without creating test keys in the database
       */
      detectRedisVersion() {
        if (this.clientType !== "redis")
          return;
        try {
          const setMethod = this.client.set;
          if (setMethod && setMethod.length <= 3) {
            this.redisMajorVersion = 5;
          } else {
            this.redisMajorVersion = 3;
          }
        } catch {
          this.redisMajorVersion = 3;
        }
      }
      /**
       * Checks if Redis version is 5.x or higher
       */
      isRedis5OrHigher() {
        if (this.clientType !== "redis")
          return false;
        return this.redisMajorVersion !== void 0 && this.redisMajorVersion >= 5;
      }
    };
    exports2.RedisQueryResultCache = RedisQueryResultCache;
  }
});

// node_modules/typeorm/cache/DbQueryResultCache.js
var require_DbQueryResultCache = __commonJS({
  "node_modules/typeorm/cache/DbQueryResultCache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DbQueryResultCache = void 0;
    var MssqlParameter_1 = require_MssqlParameter();
    var Table_1 = require_Table();
    var uuid_1 = require_cjs();
    var DbQueryResultCache = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection) {
        this.connection = connection;
        const { schema } = this.connection.driver.options;
        const database = this.connection.driver.database;
        const cacheOptions = typeof this.connection.options.cache === "object" ? this.connection.options.cache : {};
        const cacheTableName = cacheOptions.tableName || "query-result-cache";
        this.queryResultCacheDatabase = database;
        this.queryResultCacheSchema = schema;
        this.queryResultCacheTable = this.connection.driver.buildTableName(cacheTableName, schema, database);
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Creates a connection with given cache provider.
       */
      async connect() {
      }
      /**
       * Disconnects with given cache provider.
       */
      async disconnect() {
      }
      /**
       * Creates table for storing cache if it does not exist yet.
       */
      async synchronize(queryRunner) {
        queryRunner = this.getQueryRunner(queryRunner);
        const driver = this.connection.driver;
        const tableExist = await queryRunner.hasTable(this.queryResultCacheTable);
        if (tableExist)
          return;
        await queryRunner.createTable(new Table_1.Table({
          database: this.queryResultCacheDatabase,
          schema: this.queryResultCacheSchema,
          name: this.queryResultCacheTable,
          columns: [
            {
              name: "id",
              isPrimary: true,
              isNullable: false,
              type: driver.normalizeType({
                type: driver.mappedDataTypes.cacheId
              }),
              generationStrategy: driver.options.type === "spanner" ? "uuid" : "increment",
              isGenerated: true
            },
            {
              name: "identifier",
              type: driver.normalizeType({
                type: driver.mappedDataTypes.cacheIdentifier
              }),
              isNullable: true
            },
            {
              name: "time",
              type: driver.normalizeType({
                type: driver.mappedDataTypes.cacheTime
              }),
              isPrimary: false,
              isNullable: false
            },
            {
              name: "duration",
              type: driver.normalizeType({
                type: driver.mappedDataTypes.cacheDuration
              }),
              isPrimary: false,
              isNullable: false
            },
            {
              name: "query",
              type: driver.normalizeType({
                type: driver.mappedDataTypes.cacheQuery
              }),
              isPrimary: false,
              isNullable: false
            },
            {
              name: "result",
              type: driver.normalizeType({
                type: driver.mappedDataTypes.cacheResult
              }),
              isNullable: false
            }
          ]
        }));
      }
      /**
       * Get data from cache.
       * Returns cache result if found.
       * Returns undefined if result is not cached.
       */
      getFromCache(options, queryRunner) {
        queryRunner = this.getQueryRunner(queryRunner);
        const qb = this.connection.createQueryBuilder(queryRunner).select().from(this.queryResultCacheTable, "cache");
        if (options.identifier) {
          return qb.where(`${qb.escape("cache")}.${qb.escape("identifier")} = :identifier`).setParameters({
            identifier: this.connection.driver.options.type === "mssql" ? new MssqlParameter_1.MssqlParameter(options.identifier, "nvarchar") : options.identifier
          }).cache(false).getRawOne();
        } else if (options.query) {
          if (this.connection.driver.options.type === "oracle") {
            return qb.where(`dbms_lob.compare(${qb.escape("cache")}.${qb.escape("query")}, :query) = 0`, { query: options.query }).cache(false).getRawOne();
          }
          return qb.where(`${qb.escape("cache")}.${qb.escape("query")} = :query`).setParameters({
            query: this.connection.driver.options.type === "mssql" ? new MssqlParameter_1.MssqlParameter(options.query, "nvarchar") : options.query
          }).cache(false).getRawOne();
        }
        return Promise.resolve(void 0);
      }
      /**
       * Checks if cache is expired or not.
       */
      isExpired(savedCache) {
        const duration = typeof savedCache.duration === "string" ? parseInt(savedCache.duration) : savedCache.duration;
        return (typeof savedCache.time === "string" ? parseInt(savedCache.time) : savedCache.time) + duration < Date.now();
      }
      /**
       * Stores given query result in the cache.
       */
      async storeInCache(options, savedCache, queryRunner) {
        const shouldCreateQueryRunner = queryRunner === void 0 || queryRunner?.getReplicationMode() === "slave";
        if (queryRunner === void 0 || shouldCreateQueryRunner) {
          queryRunner = this.connection.createQueryRunner("master");
        }
        let insertedValues = options;
        if (this.connection.driver.options.type === "mssql") {
          insertedValues = {
            identifier: new MssqlParameter_1.MssqlParameter(options.identifier, "nvarchar"),
            time: new MssqlParameter_1.MssqlParameter(options.time, "bigint"),
            duration: new MssqlParameter_1.MssqlParameter(options.duration, "int"),
            query: new MssqlParameter_1.MssqlParameter(options.query, "nvarchar"),
            result: new MssqlParameter_1.MssqlParameter(options.result, "nvarchar")
          };
        }
        if (savedCache && savedCache.identifier) {
          const qb = queryRunner.manager.createQueryBuilder().update(this.queryResultCacheTable).set(insertedValues);
          qb.where(`${qb.escape("identifier")} = :condition`, {
            condition: insertedValues.identifier
          });
          await qb.execute();
        } else if (savedCache && savedCache.query) {
          const qb = queryRunner.manager.createQueryBuilder().update(this.queryResultCacheTable).set(insertedValues);
          if (this.connection.driver.options.type === "oracle") {
            qb.where(`dbms_lob.compare("query", :condition) = 0`, {
              condition: insertedValues.query
            });
          } else {
            qb.where(`${qb.escape("query")} = :condition`, {
              condition: insertedValues.query
            });
          }
          await qb.execute();
        } else {
          if (this.connection.driver.options.type === "spanner" && !insertedValues.id) {
            insertedValues.id = (0, uuid_1.v4)();
          }
          await queryRunner.manager.createQueryBuilder().insert().into(this.queryResultCacheTable).values(insertedValues).execute();
        }
        if (shouldCreateQueryRunner) {
          await queryRunner.release();
        }
      }
      /**
       * Clears everything stored in the cache.
       */
      async clear(queryRunner) {
        return this.getQueryRunner(queryRunner).clearTable(this.queryResultCacheTable);
      }
      /**
       * Removes all cached results by given identifiers from cache.
       */
      async remove(identifiers, queryRunner) {
        const _queryRunner = queryRunner || this.getQueryRunner();
        await Promise.all(identifiers.map((identifier) => {
          const qb = _queryRunner.manager.createQueryBuilder();
          return qb.delete().from(this.queryResultCacheTable).where(`${qb.escape("identifier")} = :identifier`, {
            identifier
          }).execute();
        }));
        if (!queryRunner) {
          await _queryRunner.release();
        }
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Gets a query runner to work with.
       */
      getQueryRunner(queryRunner) {
        if (queryRunner)
          return queryRunner;
        return this.connection.createQueryRunner();
      }
    };
    exports2.DbQueryResultCache = DbQueryResultCache;
  }
});

// node_modules/typeorm/cache/QueryResultCacheFactory.js
var require_QueryResultCacheFactory = __commonJS({
  "node_modules/typeorm/cache/QueryResultCacheFactory.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryResultCacheFactory = void 0;
    var RedisQueryResultCache_1 = require_RedisQueryResultCache();
    var DbQueryResultCache_1 = require_DbQueryResultCache();
    var TypeORMError_1 = require_TypeORMError();
    var QueryResultCacheFactory = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection) {
        this.connection = connection;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Creates a new query result cache based on connection options.
       */
      create() {
        if (!this.connection.options.cache)
          throw new TypeORMError_1.TypeORMError(`To use cache you need to enable it in connection options by setting cache: true or providing some caching options. Example: { host: ..., username: ..., cache: true }`);
        const cache = this.connection.options.cache;
        if (cache.provider && typeof cache.provider === "function") {
          return cache.provider(this.connection);
        }
        if (cache.type === "redis" || cache.type === "ioredis" || cache.type === "ioredis/cluster") {
          return new RedisQueryResultCache_1.RedisQueryResultCache(this.connection, cache.type);
        } else {
          return new DbQueryResultCache_1.DbQueryResultCache(this.connection);
        }
      }
    };
    exports2.QueryResultCacheFactory = QueryResultCacheFactory;
  }
});

// node_modules/typeorm/query-builder/RelationLoader.js
var require_RelationLoader = __commonJS({
  "node_modules/typeorm/query-builder/RelationLoader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RelationLoader = void 0;
    var FindOptionsUtils_1 = require_FindOptionsUtils();
    var RelationLoader = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(connection) {
        this.connection = connection;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Loads relation data for the given entity and its relation.
       */
      load(relation, entityOrEntities, queryRunner, queryBuilder) {
        if (queryRunner && queryRunner.isReleased)
          queryRunner = void 0;
        if (relation.isManyToOne || relation.isOneToOneOwner) {
          return this.loadManyToOneOrOneToOneOwner(relation, entityOrEntities, queryRunner, queryBuilder);
        } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {
          return this.loadOneToManyOrOneToOneNotOwner(relation, entityOrEntities, queryRunner, queryBuilder);
        } else if (relation.isManyToManyOwner) {
          return this.loadManyToManyOwner(relation, entityOrEntities, queryRunner, queryBuilder);
        } else {
          return this.loadManyToManyNotOwner(relation, entityOrEntities, queryRunner, queryBuilder);
        }
      }
      /**
       * Loads data for many-to-one and one-to-one owner relations.
       *
       * (ow) post.category<=>category.post
       * loaded: category from post
       * example: SELECT category.id AS category_id, category.name AS category_name FROM category category
       *              INNER JOIN post Post ON Post.category=category.id WHERE Post.id=1
       */
      loadManyToOneOrOneToOneOwner(relation, entityOrEntities, queryRunner, queryBuilder) {
        const entities = Array.isArray(entityOrEntities) ? entityOrEntities : [entityOrEntities];
        const joinAliasName = relation.entityMetadata.name;
        const qb = queryBuilder ? queryBuilder : this.connection.createQueryBuilder(queryRunner).select(relation.propertyName).from(relation.type, relation.propertyName);
        const mainAlias = qb.expressionMap.mainAlias.name;
        const columns = relation.entityMetadata.primaryColumns;
        const joinColumns = relation.isOwning ? relation.joinColumns : relation.inverseRelation.joinColumns;
        const conditions = joinColumns.map((joinColumn) => {
          return `${relation.entityMetadata.name}.${joinColumn.propertyName} = ${mainAlias}.${joinColumn.referencedColumn.propertyName}`;
        }).join(" AND ");
        qb.innerJoin(relation.entityMetadata.target, joinAliasName, conditions);
        if (columns.length === 1) {
          qb.where(`${joinAliasName}.${columns[0].propertyPath} IN (:...${joinAliasName + "_" + columns[0].propertyName})`);
          qb.setParameter(joinAliasName + "_" + columns[0].propertyName, entities.map((entity) => columns[0].getEntityValue(entity, true)));
        } else {
          const condition = entities.map((entity, entityIndex) => {
            return columns.map((column, columnIndex) => {
              const paramName = joinAliasName + "_entity_" + entityIndex + "_" + columnIndex;
              qb.setParameter(paramName, column.getEntityValue(entity, true));
              return joinAliasName + "." + column.propertyPath + " = :" + paramName;
            }).join(" AND ");
          }).map((condition2) => "(" + condition2 + ")").join(" OR ");
          qb.where(condition);
        }
        FindOptionsUtils_1.FindOptionsUtils.joinEagerRelations(qb, qb.alias, qb.expressionMap.mainAlias.metadata);
        return qb.getMany();
      }
      /**
       * Loads data for one-to-many and one-to-one not owner relations.
       *
       * SELECT post
       * FROM post post
       * WHERE post.[joinColumn.name] = entity[joinColumn.referencedColumn]
       */
      loadOneToManyOrOneToOneNotOwner(relation, entityOrEntities, queryRunner, queryBuilder) {
        const entities = Array.isArray(entityOrEntities) ? entityOrEntities : [entityOrEntities];
        const columns = relation.inverseRelation.joinColumns;
        const qb = queryBuilder ? queryBuilder : this.connection.createQueryBuilder(queryRunner).select(relation.propertyName).from(relation.inverseRelation.entityMetadata.target, relation.propertyName);
        const aliasName = qb.expressionMap.mainAlias.name;
        if (columns.length === 1) {
          qb.where(`${aliasName}.${columns[0].propertyPath} IN (:...${aliasName + "_" + columns[0].propertyName})`);
          qb.setParameter(aliasName + "_" + columns[0].propertyName, entities.map((entity) => columns[0].referencedColumn.getEntityValue(entity, true)));
        } else {
          const condition = entities.map((entity, entityIndex) => {
            return columns.map((column, columnIndex) => {
              const paramName = aliasName + "_entity_" + entityIndex + "_" + columnIndex;
              qb.setParameter(paramName, column.referencedColumn.getEntityValue(entity, true));
              return aliasName + "." + column.propertyPath + " = :" + paramName;
            }).join(" AND ");
          }).map((condition2) => "(" + condition2 + ")").join(" OR ");
          qb.where(condition);
        }
        FindOptionsUtils_1.FindOptionsUtils.joinEagerRelations(qb, qb.alias, qb.expressionMap.mainAlias.metadata);
        return qb.getMany();
      }
      /**
       * Loads data for many-to-many owner relations.
       *
       * SELECT category
       * FROM category category
       * INNER JOIN post_categories post_categories
       * ON post_categories.postId = :postId
       * AND post_categories.categoryId = category.id
       */
      loadManyToManyOwner(relation, entityOrEntities, queryRunner, queryBuilder) {
        const entities = Array.isArray(entityOrEntities) ? entityOrEntities : [entityOrEntities];
        const parameters = relation.joinColumns.reduce((parameters2, joinColumn) => {
          parameters2[joinColumn.propertyName] = entities.map((entity) => joinColumn.referencedColumn.getEntityValue(entity, true));
          return parameters2;
        }, {});
        const qb = queryBuilder ? queryBuilder : this.connection.createQueryBuilder(queryRunner).select(relation.propertyName).from(relation.type, relation.propertyName);
        const mainAlias = qb.expressionMap.mainAlias.name;
        const joinAlias = relation.junctionEntityMetadata.tableName;
        const joinColumnConditions = relation.joinColumns.map((joinColumn) => {
          return `${joinAlias}.${joinColumn.propertyName} IN (:...${joinColumn.propertyName})`;
        });
        const inverseJoinColumnConditions = relation.inverseJoinColumns.map((inverseJoinColumn) => {
          return `${joinAlias}.${inverseJoinColumn.propertyName}=${mainAlias}.${inverseJoinColumn.referencedColumn.propertyName}`;
        });
        qb.innerJoin(joinAlias, joinAlias, [...joinColumnConditions, ...inverseJoinColumnConditions].join(" AND ")).setParameters(parameters);
        FindOptionsUtils_1.FindOptionsUtils.joinEagerRelations(qb, qb.alias, qb.expressionMap.mainAlias.metadata);
        return qb.getMany();
      }
      /**
       * Loads data for many-to-many not owner relations.
       *
       * SELECT post
       * FROM post post
       * INNER JOIN post_categories post_categories
       * ON post_categories.postId = post.id
       * AND post_categories.categoryId = post_categories.categoryId
       */
      loadManyToManyNotOwner(relation, entityOrEntities, queryRunner, queryBuilder) {
        const entities = Array.isArray(entityOrEntities) ? entityOrEntities : [entityOrEntities];
        const qb = queryBuilder ? queryBuilder : this.connection.createQueryBuilder(queryRunner).select(relation.propertyName).from(relation.type, relation.propertyName);
        const mainAlias = qb.expressionMap.mainAlias.name;
        const joinAlias = relation.junctionEntityMetadata.tableName;
        const joinColumnConditions = relation.inverseRelation.joinColumns.map((joinColumn) => {
          return `${joinAlias}.${joinColumn.propertyName} = ${mainAlias}.${joinColumn.referencedColumn.propertyName}`;
        });
        const inverseJoinColumnConditions = relation.inverseRelation.inverseJoinColumns.map((inverseJoinColumn) => {
          return `${joinAlias}.${inverseJoinColumn.propertyName} IN (:...${inverseJoinColumn.propertyName})`;
        });
        const parameters = relation.inverseRelation.inverseJoinColumns.reduce((parameters2, joinColumn) => {
          parameters2[joinColumn.propertyName] = entities.map((entity) => joinColumn.referencedColumn.getEntityValue(entity, true));
          return parameters2;
        }, {});
        qb.innerJoin(joinAlias, joinAlias, [...joinColumnConditions, ...inverseJoinColumnConditions].join(" AND ")).setParameters(parameters);
        FindOptionsUtils_1.FindOptionsUtils.joinEagerRelations(qb, qb.alias, qb.expressionMap.mainAlias.metadata);
        return qb.getMany();
      }
      /**
       * Wraps given entity and creates getters/setters for its given relation
       * to be able to lazily load data when accessing this relation.
       */
      enableLazyLoad(relation, entity, queryRunner) {
        const relationLoader = this;
        const dataIndex = "__" + relation.propertyName + "__";
        const promiseIndex = "__promise_" + relation.propertyName + "__";
        const resolveIndex = "__has_" + relation.propertyName + "__";
        const setData = (entity2, value) => {
          entity2[dataIndex] = value;
          entity2[resolveIndex] = true;
          delete entity2[promiseIndex];
          return value;
        };
        const setPromise = (entity2, value) => {
          delete entity2[resolveIndex];
          delete entity2[dataIndex];
          entity2[promiseIndex] = value;
          value.then(
            // ensure different value is not assigned yet
            (result) => entity2[promiseIndex] === value ? setData(entity2, result) : result
          );
          return value;
        };
        Object.defineProperty(entity, relation.propertyName, {
          get: function() {
            if (this[resolveIndex] === true || this[dataIndex] !== void 0)
              return Promise.resolve(this[dataIndex]);
            if (this[promiseIndex])
              return this[promiseIndex];
            const loader = relationLoader.load(relation, this, queryRunner).then((result) => relation.isOneToOne || relation.isManyToOne ? result.length === 0 ? null : result[0] : result);
            return setPromise(this, loader);
          },
          set: function(value) {
            if (value instanceof Promise) {
              setPromise(this, value);
            } else {
              setData(this, value);
            }
          },
          configurable: true,
          enumerable: false
        });
      }
    };
    exports2.RelationLoader = RelationLoader;
  }
});

// node_modules/typeorm/data-source/DataSource.js
var require_DataSource = __commonJS({
  "node_modules/typeorm/data-source/DataSource.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DataSource = void 0;
    var query_builder_1 = require_query_builder();
    var DefaultNamingStrategy_1 = require_DefaultNamingStrategy();
    var error_1 = require_error();
    var MigrationExecutor_1 = require_MigrationExecutor();
    var EntityMetadataValidator_1 = require_EntityMetadataValidator();
    var EntityManagerFactory_1 = require_EntityManagerFactory();
    var DriverFactory_1 = require_DriverFactory();
    var ConnectionMetadataBuilder_1 = require_ConnectionMetadataBuilder();
    var SelectQueryBuilder_1 = require_SelectQueryBuilder();
    var LoggerFactory_1 = require_LoggerFactory();
    var QueryResultCacheFactory_1 = require_QueryResultCacheFactory();
    var RelationLoader_1 = require_RelationLoader();
    var ObjectUtils_1 = require_ObjectUtils();
    var RelationIdLoader_1 = require_RelationIdLoader2();
    var DriverUtils_1 = require_DriverUtils();
    var InstanceChecker_1 = require_InstanceChecker();
    var SqlTagUtils_1 = require_SqlTagUtils();
    (0, query_builder_1.registerQueryBuilders)();
    var DataSource2 = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(options) {
        this["@instanceof"] = Symbol.for("DataSource");
        this.migrations = [];
        this.subscribers = [];
        this.entityMetadatas = [];
        this.entityMetadatasMap = /* @__PURE__ */ new Map();
        (0, query_builder_1.registerQueryBuilders)();
        this.name = options.name || "default";
        this.options = options;
        this.logger = new LoggerFactory_1.LoggerFactory().create(this.options.logger, this.options.logging);
        this.driver = new DriverFactory_1.DriverFactory().create(this);
        this.manager = this.createEntityManager();
        this.namingStrategy = options.namingStrategy || new DefaultNamingStrategy_1.DefaultNamingStrategy();
        this.metadataTableName = options.metadataTableName || "typeorm_metadata";
        this.queryResultCache = options.cache ? new QueryResultCacheFactory_1.QueryResultCacheFactory(this).create() : void 0;
        this.relationLoader = new RelationLoader_1.RelationLoader(this);
        this.relationIdLoader = new RelationIdLoader_1.RelationIdLoader(this);
        this.isInitialized = false;
      }
      // -------------------------------------------------------------------------
      // Public Accessors
      // -------------------------------------------------------------------------
      /**
       Indicates if DataSource is initialized or not.
       *
       * @deprecated use .isInitialized instead
       */
      get isConnected() {
        return this.isInitialized;
      }
      /**
       * Gets the mongodb entity manager that allows to perform mongodb-specific repository operations
       * with any entity in this connection.
       *
       * Available only in mongodb connections.
       */
      get mongoManager() {
        if (!InstanceChecker_1.InstanceChecker.isMongoEntityManager(this.manager))
          throw new error_1.TypeORMError(`MongoEntityManager is only available for MongoDB databases.`);
        return this.manager;
      }
      /**
       * Gets a sql.js specific Entity Manager that allows to perform special load and save operations
       *
       * Available only in connection with the sqljs driver.
       */
      get sqljsManager() {
        if (!InstanceChecker_1.InstanceChecker.isSqljsEntityManager(this.manager))
          throw new error_1.TypeORMError(`SqljsEntityManager is only available for Sqljs databases.`);
        return this.manager;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Updates current connection options with provided options.
       */
      setOptions(options) {
        Object.assign(this.options, options);
        if (options.logger || options.logging) {
          this.logger = new LoggerFactory_1.LoggerFactory().create(options.logger || this.options.logger, options.logging || this.options.logging);
        }
        if (options.namingStrategy) {
          this.namingStrategy = options.namingStrategy;
        }
        if (options.cache) {
          this.queryResultCache = new QueryResultCacheFactory_1.QueryResultCacheFactory(this).create();
        }
        if (options.database) {
          this.driver.database = DriverUtils_1.DriverUtils.buildDriverOptions(this.options).database;
        }
        return this;
      }
      /**
       * Performs connection to the database.
       * This method should be called once on application bootstrap.
       * This method not necessarily creates database connection (depend on database type),
       * but it also can setup a connection pool with database to use.
       */
      async initialize() {
        if (this.isInitialized)
          throw new error_1.CannotConnectAlreadyConnectedError(this.name);
        await this.driver.connect();
        if (this.queryResultCache)
          await this.queryResultCache.connect();
        ObjectUtils_1.ObjectUtils.assign(this, { isInitialized: true });
        try {
          await this.buildMetadatas();
          await this.driver.afterConnect();
          if (this.options.dropSchema)
            await this.dropDatabase();
          if (this.options.migrationsRun)
            await this.runMigrations({
              transaction: this.options.migrationsTransactionMode
            });
          if (this.options.synchronize)
            await this.synchronize();
        } catch (error) {
          await this.destroy();
          throw error;
        }
        return this;
      }
      /**
       * Performs connection to the database.
       * This method should be called once on application bootstrap.
       * This method not necessarily creates database connection (depend on database type),
       * but it also can setup a connection pool with database to use.
       *
       * @deprecated use .initialize method instead
       */
      async connect() {
        return this.initialize();
      }
      /**
       * Closes connection with the database.
       * Once connection is closed, you cannot use repositories or perform any operations except opening connection again.
       */
      async destroy() {
        if (!this.isInitialized)
          throw new error_1.CannotExecuteNotConnectedError(this.name);
        await this.driver.disconnect();
        if (this.queryResultCache)
          await this.queryResultCache.disconnect();
        ObjectUtils_1.ObjectUtils.assign(this, { isInitialized: false });
      }
      /**
       * Closes connection with the database.
       * Once connection is closed, you cannot use repositories or perform any operations except opening connection again.
       *
       * @deprecated use .destroy method instead
       */
      async close() {
        return this.destroy();
      }
      /**
       * Creates database schema for all entities registered in this connection.
       * Can be used only after connection to the database is established.
       *
       * @param dropBeforeSync If set to true then it drops the database with all its tables and data
       */
      async synchronize(dropBeforeSync = false) {
        if (!this.isInitialized)
          throw new error_1.CannotExecuteNotConnectedError(this.name);
        if (dropBeforeSync)
          await this.dropDatabase();
        const schemaBuilder = this.driver.createSchemaBuilder();
        await schemaBuilder.build();
      }
      /**
       * Drops the database and all its data.
       * Be careful with this method on production since this method will erase all your database tables and their data.
       * Can be used only after connection to the database is established.
       */
      // TODO rename
      async dropDatabase() {
        const queryRunner = this.createQueryRunner();
        try {
          if (this.driver.options.type === "mssql" || DriverUtils_1.DriverUtils.isMySQLFamily(this.driver) || this.driver.options.type === "aurora-mysql" || DriverUtils_1.DriverUtils.isSQLiteFamily(this.driver)) {
            const databases = [];
            this.entityMetadatas.forEach((metadata) => {
              if (metadata.database && databases.indexOf(metadata.database) === -1)
                databases.push(metadata.database);
            });
            if (databases.length === 0 && this.driver.database) {
              databases.push(this.driver.database);
            }
            if (databases.length === 0) {
              await queryRunner.clearDatabase();
            } else {
              for (const database of databases) {
                await queryRunner.clearDatabase(database);
              }
            }
          } else {
            await queryRunner.clearDatabase();
          }
        } finally {
          await queryRunner.release();
        }
      }
      /**
       * Runs all pending migrations.
       * Can be used only after connection to the database is established.
       */
      async runMigrations(options) {
        if (!this.isInitialized)
          throw new error_1.CannotExecuteNotConnectedError(this.name);
        const migrationExecutor = new MigrationExecutor_1.MigrationExecutor(this);
        migrationExecutor.transaction = options?.transaction || this.options?.migrationsTransactionMode || "all";
        migrationExecutor.fake = options && options.fake || false;
        const successMigrations = await migrationExecutor.executePendingMigrations();
        return successMigrations;
      }
      /**
       * Reverts last executed migration.
       * Can be used only after connection to the database is established.
       */
      async undoLastMigration(options) {
        if (!this.isInitialized)
          throw new error_1.CannotExecuteNotConnectedError(this.name);
        const migrationExecutor = new MigrationExecutor_1.MigrationExecutor(this);
        migrationExecutor.transaction = options && options.transaction || "all";
        migrationExecutor.fake = options && options.fake || false;
        await migrationExecutor.undoLastMigration();
      }
      /**
       * Lists all migrations and whether they have been run.
       * Returns true if there are pending migrations
       */
      async showMigrations() {
        if (!this.isInitialized) {
          throw new error_1.CannotExecuteNotConnectedError(this.name);
        }
        const migrationExecutor = new MigrationExecutor_1.MigrationExecutor(this);
        return await migrationExecutor.showMigrations();
      }
      /**
       * Checks if entity metadata exist for the given entity class, target name or table name.
       */
      hasMetadata(target) {
        return !!this.findMetadata(target);
      }
      /**
       * Gets entity metadata for the given entity class or schema name.
       */
      getMetadata(target) {
        const metadata = this.findMetadata(target);
        if (!metadata)
          throw new error_1.EntityMetadataNotFoundError(target);
        return metadata;
      }
      /**
       * Gets repository for the given entity.
       */
      getRepository(target) {
        return this.manager.getRepository(target);
      }
      /**
       * Gets tree repository for the given entity class or name.
       * Only tree-type entities can have a TreeRepository, like ones decorated with @Tree decorator.
       */
      getTreeRepository(target) {
        return this.manager.getTreeRepository(target);
      }
      /**
       * Gets mongodb-specific repository for the given entity class or name.
       * Works only if connection is mongodb-specific.
       */
      getMongoRepository(target) {
        if (!(this.driver.options.type === "mongodb"))
          throw new error_1.TypeORMError(`You can use getMongoRepository only for MongoDB connections.`);
        return this.manager.getRepository(target);
      }
      /**
       * Gets custom entity repository marked with @EntityRepository decorator.
       *
       * @deprecated use Repository.extend function to create a custom repository
       */
      getCustomRepository(customRepository) {
        return this.manager.getCustomRepository(customRepository);
      }
      async transaction(isolationOrRunInTransaction, runInTransactionParam) {
        return this.manager.transaction(isolationOrRunInTransaction, runInTransactionParam);
      }
      /**
       * Executes raw SQL query and returns raw database results.
       *
       * @see [Official docs](https://typeorm.io/data-source-api) for examples.
       */
      async query(query, parameters, queryRunner) {
        if (InstanceChecker_1.InstanceChecker.isMongoEntityManager(this.manager))
          throw new error_1.TypeORMError(`Queries aren't supported by MongoDB.`);
        if (queryRunner && queryRunner.isReleased)
          throw new error_1.QueryRunnerProviderAlreadyReleasedError();
        const usedQueryRunner = queryRunner || this.createQueryRunner();
        try {
          return await usedQueryRunner.query(query, parameters);
        } finally {
          if (!queryRunner)
            await usedQueryRunner.release();
        }
      }
      /**
       * Tagged template function that executes raw SQL query and returns raw database results.
       * Template expressions are automatically transformed into database parameters.
       * Raw query execution is supported only by relational databases (MongoDB is not supported).
       * Note: Don't call this as a regular function, it is meant to be used with backticks to tag a template literal.
       * Example: dataSource.sql`SELECT * FROM table_name WHERE id = ${id}`
       */
      async sql(strings, ...values) {
        const { query, parameters } = (0, SqlTagUtils_1.buildSqlTag)({
          driver: this.driver,
          strings,
          expressions: values
        });
        return await this.query(query, parameters);
      }
      /**
       * Creates a new query builder that can be used to build a SQL query.
       */
      createQueryBuilder(entityOrRunner, alias, queryRunner) {
        if (InstanceChecker_1.InstanceChecker.isMongoEntityManager(this.manager))
          throw new error_1.TypeORMError(`Query Builder is not supported by MongoDB.`);
        if (alias) {
          alias = DriverUtils_1.DriverUtils.buildAlias(this.driver, void 0, alias);
          const metadata = this.getMetadata(entityOrRunner);
          return new SelectQueryBuilder_1.SelectQueryBuilder(this, queryRunner).select(alias).from(metadata.target, alias);
        } else {
          return new SelectQueryBuilder_1.SelectQueryBuilder(this, entityOrRunner);
        }
      }
      /**
       * Creates a query runner used for perform queries on a single database connection.
       * Using query runners you can control your queries to execute using single database connection and
       * manually control your database transaction.
       *
       * Mode is used in replication mode and indicates whatever you want to connect
       * to master database or any of slave databases.
       * If you perform writes you must use master database,
       * if you perform reads you can use slave databases.
       */
      createQueryRunner(mode = "master") {
        const queryRunner = this.driver.createQueryRunner(mode);
        const manager = this.createEntityManager(queryRunner);
        Object.assign(queryRunner, { manager });
        return queryRunner;
      }
      /**
       * Gets entity metadata of the junction table (many-to-many table).
       */
      getManyToManyMetadata(entityTarget, relationPropertyPath) {
        const relationMetadata = this.getMetadata(entityTarget).findRelationWithPropertyPath(relationPropertyPath);
        if (!relationMetadata)
          throw new error_1.TypeORMError(`Relation "${relationPropertyPath}" was not found in ${entityTarget} entity.`);
        if (!relationMetadata.isManyToMany)
          throw new error_1.TypeORMError(`Relation "${entityTarget}#${relationPropertyPath}" does not have a many-to-many relationship.You can use this method only on many-to-many relations.`);
        return relationMetadata.junctionEntityMetadata;
      }
      /**
       * Creates an Entity Manager for the current connection with the help of the EntityManagerFactory.
       */
      createEntityManager(queryRunner) {
        return new EntityManagerFactory_1.EntityManagerFactory().create(this, queryRunner);
      }
      // -------------------------------------------------------------------------
      // Protected Methods
      // -------------------------------------------------------------------------
      /**
       * Finds exist entity metadata by the given entity class, target name or table name.
       */
      findMetadata(target) {
        const metadataFromMap = this.entityMetadatasMap.get(target);
        if (metadataFromMap)
          return metadataFromMap;
        for (const [_, metadata] of this.entityMetadatasMap) {
          if (InstanceChecker_1.InstanceChecker.isEntitySchema(target) && metadata.name === target.options.name) {
            return metadata;
          }
          if (typeof target === "string") {
            if (target.indexOf(".") !== -1) {
              if (metadata.tablePath === target) {
                return metadata;
              }
            } else {
              if (metadata.name === target || metadata.tableName === target) {
                return metadata;
              }
            }
          }
          if (ObjectUtils_1.ObjectUtils.isObjectWithName(target) && typeof target.name === "string") {
            if (target.name.indexOf(".") !== -1) {
              if (metadata.tablePath === target.name) {
                return metadata;
              }
            } else {
              if (metadata.name === target.name || metadata.tableName === target.name) {
                return metadata;
              }
            }
          }
        }
        return void 0;
      }
      /**
       * Builds metadatas for all registered classes inside this connection.
       */
      async buildMetadatas() {
        const connectionMetadataBuilder = new ConnectionMetadataBuilder_1.ConnectionMetadataBuilder(this);
        const entityMetadataValidator = new EntityMetadataValidator_1.EntityMetadataValidator();
        const flattenedSubscribers = ObjectUtils_1.ObjectUtils.mixedListToArray(this.options.subscribers || []);
        const subscribers = await connectionMetadataBuilder.buildSubscribers(flattenedSubscribers);
        ObjectUtils_1.ObjectUtils.assign(this, { subscribers });
        const flattenedEntities = ObjectUtils_1.ObjectUtils.mixedListToArray(this.options.entities || []);
        const entityMetadatas = await connectionMetadataBuilder.buildEntityMetadatas(flattenedEntities);
        ObjectUtils_1.ObjectUtils.assign(this, {
          entityMetadatas,
          entityMetadatasMap: new Map(entityMetadatas.map((metadata) => [metadata.target, metadata]))
        });
        const flattenedMigrations = ObjectUtils_1.ObjectUtils.mixedListToArray(this.options.migrations || []);
        const migrations = await connectionMetadataBuilder.buildMigrations(flattenedMigrations);
        ObjectUtils_1.ObjectUtils.assign(this, { migrations });
        entityMetadataValidator.validateMany(this.entityMetadatas.filter((metadata) => metadata.tableType !== "view"), this.driver);
        for (const entityMetadata of entityMetadatas) {
          if (InstanceChecker_1.InstanceChecker.isBaseEntityConstructor(entityMetadata.target)) {
            entityMetadata.target.useDataSource(this);
          }
        }
      }
      /**
       * Get the replication mode SELECT queries should use for this datasource by default
       */
      defaultReplicationModeForReads() {
        if ("replication" in this.driver.options && this.driver.options.replication) {
          const value = this.driver.options.replication.defaultMode;
          if (value) {
            return value;
          }
        }
        return "slave";
      }
    };
    exports2.DataSource = DataSource2;
  }
});

// node_modules/typeorm/connection/ConnectionManager.js
var require_ConnectionManager = __commonJS({
  "node_modules/typeorm/connection/ConnectionManager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectionManager = void 0;
    var DataSource_1 = require_DataSource();
    var ConnectionNotFoundError_1 = require_ConnectionNotFoundError();
    var AlreadyHasActiveConnectionError_1 = require_AlreadyHasActiveConnectionError();
    var ConnectionManager2 = class {
      constructor() {
        this.connectionMap = /* @__PURE__ */ new Map();
      }
      /**
       * List of connections registered in this connection manager.
       */
      get connections() {
        return Array.from(this.connectionMap.values());
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Checks if connection with the given name exist in the manager.
       */
      has(name) {
        return this.connectionMap.has(name);
      }
      /**
       * Gets registered connection with the given name.
       * If connection name is not given then it will get a default connection.
       * Throws error if connection with the given name was not found.
       */
      get(name = "default") {
        const connection = this.connectionMap.get(name);
        if (!connection)
          throw new ConnectionNotFoundError_1.ConnectionNotFoundError(name);
        return connection;
      }
      /**
       * Creates a new connection based on the given connection options and registers it in the manager.
       * Connection won't be established, you'll need to manually call connect method to establish connection.
       */
      create(options) {
        const existConnection = this.connectionMap.get(options.name || "default");
        if (existConnection) {
          if (existConnection.isInitialized)
            throw new AlreadyHasActiveConnectionError_1.AlreadyHasActiveConnectionError(options.name || "default");
        }
        const connection = new DataSource_1.DataSource(options);
        this.connectionMap.set(connection.name, connection);
        return connection;
      }
    };
    exports2.ConnectionManager = ConnectionManager2;
  }
});

// node_modules/typeorm/globals.js
var require_globals = __commonJS({
  "node_modules/typeorm/globals.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMetadataArgsStorage = getMetadataArgsStorage2;
    exports2.getConnectionOptions = getConnectionOptions2;
    exports2.getConnectionManager = getConnectionManager2;
    exports2.createConnection = createConnection2;
    exports2.createConnections = createConnections2;
    exports2.getConnection = getConnection2;
    exports2.getManager = getManager2;
    exports2.getMongoManager = getMongoManager2;
    exports2.getSqljsManager = getSqljsManager2;
    exports2.getRepository = getRepository2;
    exports2.getTreeRepository = getTreeRepository2;
    exports2.getCustomRepository = getCustomRepository2;
    exports2.getMongoRepository = getMongoRepository2;
    exports2.createQueryBuilder = createQueryBuilder2;
    var MetadataArgsStorage_1 = require_MetadataArgsStorage();
    var PlatformTools_1 = require_PlatformTools();
    var ConnectionOptionsReader_1 = require_ConnectionOptionsReader();
    var ConnectionManager_1 = require_ConnectionManager();
    var container_1 = require_container();
    var ObjectUtils_1 = require_ObjectUtils();
    function getMetadataArgsStorage2() {
      const globalScope = PlatformTools_1.PlatformTools.getGlobalVariable();
      if (!globalScope.typeormMetadataArgsStorage)
        globalScope.typeormMetadataArgsStorage = new MetadataArgsStorage_1.MetadataArgsStorage();
      return globalScope.typeormMetadataArgsStorage;
    }
    async function getConnectionOptions2(connectionName = "default") {
      return new ConnectionOptionsReader_1.ConnectionOptionsReader().get(connectionName);
    }
    function getConnectionManager2() {
      return (0, container_1.getFromContainer)(ConnectionManager_1.ConnectionManager);
    }
    async function createConnection2(optionsOrName) {
      const connectionName = typeof optionsOrName === "string" ? optionsOrName : "default";
      const options = ObjectUtils_1.ObjectUtils.isObject(optionsOrName) ? optionsOrName : await getConnectionOptions2(connectionName);
      return getConnectionManager2().create(options).connect();
    }
    async function createConnections2(options) {
      if (!options)
        options = await new ConnectionOptionsReader_1.ConnectionOptionsReader().all();
      const connections = options.map((options2) => getConnectionManager2().create(options2));
      for (const connection of connections) {
        await connection.connect();
      }
      return connections;
    }
    function getConnection2(connectionName = "default") {
      return getConnectionManager2().get(connectionName);
    }
    function getManager2(connectionName = "default") {
      return getConnectionManager2().get(connectionName).manager;
    }
    function getMongoManager2(connectionName = "default") {
      return getConnectionManager2().get(connectionName).manager;
    }
    function getSqljsManager2(connectionName = "default") {
      return getConnectionManager2().get(connectionName).manager;
    }
    function getRepository2(entityClass, connectionName = "default") {
      return getConnectionManager2().get(connectionName).getRepository(entityClass);
    }
    function getTreeRepository2(entityClass, connectionName = "default") {
      return getConnectionManager2().get(connectionName).getTreeRepository(entityClass);
    }
    function getCustomRepository2(customRepository, connectionName = "default") {
      return getConnectionManager2().get(connectionName).getCustomRepository(customRepository);
    }
    function getMongoRepository2(entityClass, connectionName = "default") {
      return getConnectionManager2().get(connectionName).getMongoRepository(entityClass);
    }
    function createQueryBuilder2(entityClass, alias, connectionName = "default") {
      if (entityClass) {
        return getRepository2(entityClass, connectionName).createQueryBuilder(alias);
      }
      return getConnection2(connectionName).createQueryBuilder();
    }
  }
});

// node_modules/typeorm/common/EntityTarget.js
var require_EntityTarget = __commonJS({
  "node_modules/typeorm/common/EntityTarget.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/common/ObjectType.js
var require_ObjectType = __commonJS({
  "node_modules/typeorm/common/ObjectType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/common/ObjectLiteral.js
var require_ObjectLiteral = __commonJS({
  "node_modules/typeorm/common/ObjectLiteral.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/common/MixedList.js
var require_MixedList = __commonJS({
  "node_modules/typeorm/common/MixedList.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/common/DeepPartial.js
var require_DeepPartial = __commonJS({
  "node_modules/typeorm/common/DeepPartial.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/common/RelationType.js
var require_RelationType = __commonJS({
  "node_modules/typeorm/common/RelationType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/decorator/columns/Column.js
var require_Column = __commonJS({
  "node_modules/typeorm/decorator/columns/Column.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Column = Column2;
    var globals_1 = require_globals();
    var ColumnTypeUndefinedError_1 = require_ColumnTypeUndefinedError();
    function Column2(typeOrOptions, options) {
      return function(object, propertyName) {
        let type;
        if (typeof typeOrOptions === "string" || typeof typeOrOptions === "function") {
          type = typeOrOptions;
        } else if (typeOrOptions) {
          options = typeOrOptions;
          type = typeOrOptions.type;
        }
        if (!options)
          options = {};
        const reflectMetadataType = Reflect && Reflect.getMetadata ? Reflect.getMetadata("design:type", object, propertyName) : void 0;
        if (!type && reflectMetadataType)
          type = reflectMetadataType;
        if (!options.type && type)
          options.type = type;
        if (options.type === "hstore" && !options.hstoreType)
          options.hstoreType = reflectMetadataType === Object ? "object" : "string";
        if (typeof typeOrOptions === "function") {
          (0, globals_1.getMetadataArgsStorage)().embeddeds.push({
            target: object.constructor,
            propertyName,
            isArray: reflectMetadataType === Array || options.array === true,
            prefix: options.prefix !== void 0 ? options.prefix : void 0,
            type: typeOrOptions
          });
        } else {
          if (!options.type)
            throw new ColumnTypeUndefinedError_1.ColumnTypeUndefinedError(object, propertyName);
          if (options.unique === true)
            (0, globals_1.getMetadataArgsStorage)().uniques.push({
              target: object.constructor,
              columns: [propertyName]
            });
          (0, globals_1.getMetadataArgsStorage)().columns.push({
            target: object.constructor,
            propertyName,
            mode: "regular",
            options
          });
          if (options.generated) {
            (0, globals_1.getMetadataArgsStorage)().generations.push({
              target: object.constructor,
              propertyName,
              strategy: typeof options.generated === "string" ? options.generated : "increment"
            });
          }
        }
      };
    }
  }
});

// node_modules/typeorm/decorator/columns/CreateDateColumn.js
var require_CreateDateColumn = __commonJS({
  "node_modules/typeorm/decorator/columns/CreateDateColumn.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CreateDateColumn = CreateDateColumn2;
    var globals_1 = require_globals();
    function CreateDateColumn2(options) {
      return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().columns.push({
          target: object.constructor,
          propertyName,
          mode: "createDate",
          options: options || {}
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/columns/DeleteDateColumn.js
var require_DeleteDateColumn = __commonJS({
  "node_modules/typeorm/decorator/columns/DeleteDateColumn.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeleteDateColumn = DeleteDateColumn2;
    var globals_1 = require_globals();
    function DeleteDateColumn2(options) {
      return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().columns.push({
          target: object.constructor,
          propertyName,
          mode: "deleteDate",
          options: options || {}
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/columns/PrimaryGeneratedColumn.js
var require_PrimaryGeneratedColumn = __commonJS({
  "node_modules/typeorm/decorator/columns/PrimaryGeneratedColumn.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PrimaryGeneratedColumn = PrimaryGeneratedColumn2;
    var globals_1 = require_globals();
    var ObjectUtils_1 = require_ObjectUtils();
    function PrimaryGeneratedColumn2(strategyOrOptions, maybeOptions) {
      const options = {};
      let strategy;
      if (strategyOrOptions) {
        if (typeof strategyOrOptions === "string")
          strategy = strategyOrOptions;
        if (ObjectUtils_1.ObjectUtils.isObject(strategyOrOptions)) {
          strategy = "increment";
          Object.assign(options, strategyOrOptions);
        }
      } else {
        strategy = "increment";
      }
      if (ObjectUtils_1.ObjectUtils.isObject(maybeOptions))
        Object.assign(options, maybeOptions);
      return function(object, propertyName) {
        if (!options.type) {
          if (strategy === "increment" || strategy === "identity") {
            options.type = Number;
          } else if (strategy === "uuid") {
            options.type = "uuid";
          } else if (strategy === "rowid") {
            options.type = "int";
          }
        }
        options.primary = true;
        (0, globals_1.getMetadataArgsStorage)().columns.push({
          target: object.constructor,
          propertyName,
          mode: "regular",
          options
        });
        (0, globals_1.getMetadataArgsStorage)().generations.push({
          target: object.constructor,
          propertyName,
          strategy
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/columns/PrimaryColumn.js
var require_PrimaryColumn = __commonJS({
  "node_modules/typeorm/decorator/columns/PrimaryColumn.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PrimaryColumn = PrimaryColumn2;
    var globals_1 = require_globals();
    var ColumnTypeUndefinedError_1 = require_ColumnTypeUndefinedError();
    var PrimaryColumnCannotBeNullableError_1 = require_PrimaryColumnCannotBeNullableError();
    function PrimaryColumn2(typeOrOptions, options) {
      return function(object, propertyName) {
        let type;
        if (typeof typeOrOptions === "string" || typeOrOptions === String || typeOrOptions === Boolean || typeOrOptions === Number) {
          type = typeOrOptions;
        } else {
          options = Object.assign({}, typeOrOptions);
        }
        if (!options)
          options = {};
        const reflectMetadataType = Reflect && Reflect.getMetadata ? Reflect.getMetadata("design:type", object, propertyName) : void 0;
        if (!type && reflectMetadataType)
          type = reflectMetadataType;
        if (!options.type && type)
          options.type = type;
        if (!options.type)
          throw new ColumnTypeUndefinedError_1.ColumnTypeUndefinedError(object, propertyName);
        if (options.nullable)
          throw new PrimaryColumnCannotBeNullableError_1.PrimaryColumnCannotBeNullableError(object, propertyName);
        options.primary = true;
        (0, globals_1.getMetadataArgsStorage)().columns.push({
          target: object.constructor,
          propertyName,
          mode: "regular",
          options
        });
        if (options.generated) {
          (0, globals_1.getMetadataArgsStorage)().generations.push({
            target: object.constructor,
            propertyName,
            strategy: typeof options.generated === "string" ? options.generated : "increment"
          });
        }
      };
    }
  }
});

// node_modules/typeorm/decorator/columns/UpdateDateColumn.js
var require_UpdateDateColumn = __commonJS({
  "node_modules/typeorm/decorator/columns/UpdateDateColumn.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UpdateDateColumn = UpdateDateColumn2;
    var globals_1 = require_globals();
    function UpdateDateColumn2(options) {
      return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().columns.push({
          target: object.constructor,
          propertyName,
          mode: "updateDate",
          options: options ? options : {}
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/columns/VersionColumn.js
var require_VersionColumn = __commonJS({
  "node_modules/typeorm/decorator/columns/VersionColumn.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VersionColumn = VersionColumn2;
    var globals_1 = require_globals();
    function VersionColumn2(options) {
      return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().columns.push({
          target: object.constructor,
          propertyName,
          mode: "version",
          options: options || {}
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/columns/VirtualColumn.js
var require_VirtualColumn = __commonJS({
  "node_modules/typeorm/decorator/columns/VirtualColumn.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VirtualColumn = VirtualColumn2;
    var error_1 = require_error();
    var globals_1 = require_globals();
    function VirtualColumn2(typeOrOptions, options) {
      return function(object, propertyName) {
        let type;
        if (typeof typeOrOptions === "string") {
          type = typeOrOptions;
        } else {
          options = typeOrOptions;
          type = options.type;
        }
        if (!options?.query) {
          throw new Error("Column options must be defined for calculated columns.");
        }
        const reflectMetadataType = Reflect && Reflect.getMetadata ? Reflect.getMetadata("design:type", object, propertyName) : void 0;
        if (!type && reflectMetadataType)
          type = reflectMetadataType;
        if (type)
          options.type = type;
        if (options.type === "hstore" && !options.hstoreType)
          options.hstoreType = reflectMetadataType === Object ? "object" : "string";
        if (!options.type)
          throw new error_1.ColumnTypeUndefinedError(object, propertyName);
        (0, globals_1.getMetadataArgsStorage)().columns.push({
          target: object.constructor,
          propertyName,
          mode: "virtual-property",
          options: options || {}
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/columns/ViewColumn.js
var require_ViewColumn = __commonJS({
  "node_modules/typeorm/decorator/columns/ViewColumn.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ViewColumn = ViewColumn2;
    var globals_1 = require_globals();
    function ViewColumn2(options) {
      return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().columns.push({
          target: object.constructor,
          propertyName,
          mode: "regular",
          options: options || {}
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/columns/ObjectIdColumn.js
var require_ObjectIdColumn = __commonJS({
  "node_modules/typeorm/decorator/columns/ObjectIdColumn.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ObjectIdColumn = ObjectIdColumn2;
    var globals_1 = require_globals();
    function ObjectIdColumn2(options) {
      return function(object, propertyName) {
        if (!options)
          options = {};
        options.primary = true;
        if (!options.name)
          options.name = "_id";
        (0, globals_1.getMetadataArgsStorage)().columns.push({
          target: object.constructor,
          propertyName,
          mode: "objectId",
          options
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/listeners/AfterInsert.js
var require_AfterInsert = __commonJS({
  "node_modules/typeorm/decorator/listeners/AfterInsert.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AfterInsert = AfterInsert2;
    var globals_1 = require_globals();
    var EventListenerTypes_1 = require_EventListenerTypes();
    function AfterInsert2() {
      return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().entityListeners.push({
          target: object.constructor,
          propertyName,
          type: EventListenerTypes_1.EventListenerTypes.AFTER_INSERT
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/listeners/AfterLoad.js
var require_AfterLoad = __commonJS({
  "node_modules/typeorm/decorator/listeners/AfterLoad.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AfterLoad = AfterLoad2;
    var globals_1 = require_globals();
    var EventListenerTypes_1 = require_EventListenerTypes();
    function AfterLoad2() {
      return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().entityListeners.push({
          target: object.constructor,
          propertyName,
          type: EventListenerTypes_1.EventListenerTypes.AFTER_LOAD
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/listeners/AfterRemove.js
var require_AfterRemove = __commonJS({
  "node_modules/typeorm/decorator/listeners/AfterRemove.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AfterRemove = AfterRemove2;
    var globals_1 = require_globals();
    var EventListenerTypes_1 = require_EventListenerTypes();
    function AfterRemove2() {
      return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().entityListeners.push({
          target: object.constructor,
          propertyName,
          type: EventListenerTypes_1.EventListenerTypes.AFTER_REMOVE
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/listeners/AfterSoftRemove.js
var require_AfterSoftRemove = __commonJS({
  "node_modules/typeorm/decorator/listeners/AfterSoftRemove.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AfterSoftRemove = AfterSoftRemove2;
    var globals_1 = require_globals();
    var EventListenerTypes_1 = require_EventListenerTypes();
    function AfterSoftRemove2() {
      return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().entityListeners.push({
          target: object.constructor,
          propertyName,
          type: EventListenerTypes_1.EventListenerTypes.AFTER_SOFT_REMOVE
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/listeners/AfterRecover.js
var require_AfterRecover = __commonJS({
  "node_modules/typeorm/decorator/listeners/AfterRecover.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AfterRecover = AfterRecover2;
    var globals_1 = require_globals();
    var EventListenerTypes_1 = require_EventListenerTypes();
    function AfterRecover2() {
      return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().entityListeners.push({
          target: object.constructor,
          propertyName,
          type: EventListenerTypes_1.EventListenerTypes.AFTER_RECOVER
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/listeners/AfterUpdate.js
var require_AfterUpdate = __commonJS({
  "node_modules/typeorm/decorator/listeners/AfterUpdate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AfterUpdate = AfterUpdate2;
    var globals_1 = require_globals();
    var EventListenerTypes_1 = require_EventListenerTypes();
    function AfterUpdate2() {
      return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().entityListeners.push({
          target: object.constructor,
          propertyName,
          type: EventListenerTypes_1.EventListenerTypes.AFTER_UPDATE
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/listeners/BeforeInsert.js
var require_BeforeInsert = __commonJS({
  "node_modules/typeorm/decorator/listeners/BeforeInsert.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BeforeInsert = BeforeInsert2;
    var globals_1 = require_globals();
    var EventListenerTypes_1 = require_EventListenerTypes();
    function BeforeInsert2() {
      return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().entityListeners.push({
          target: object.constructor,
          propertyName,
          type: EventListenerTypes_1.EventListenerTypes.BEFORE_INSERT
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/listeners/BeforeRemove.js
var require_BeforeRemove = __commonJS({
  "node_modules/typeorm/decorator/listeners/BeforeRemove.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BeforeRemove = BeforeRemove2;
    var globals_1 = require_globals();
    var EventListenerTypes_1 = require_EventListenerTypes();
    function BeforeRemove2() {
      return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().entityListeners.push({
          target: object.constructor,
          propertyName,
          type: EventListenerTypes_1.EventListenerTypes.BEFORE_REMOVE
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/listeners/BeforeSoftRemove.js
var require_BeforeSoftRemove = __commonJS({
  "node_modules/typeorm/decorator/listeners/BeforeSoftRemove.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BeforeSoftRemove = BeforeSoftRemove2;
    var globals_1 = require_globals();
    var EventListenerTypes_1 = require_EventListenerTypes();
    function BeforeSoftRemove2() {
      return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().entityListeners.push({
          target: object.constructor,
          propertyName,
          type: EventListenerTypes_1.EventListenerTypes.BEFORE_SOFT_REMOVE
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/listeners/BeforeRecover.js
var require_BeforeRecover = __commonJS({
  "node_modules/typeorm/decorator/listeners/BeforeRecover.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BeforeRecover = BeforeRecover2;
    var globals_1 = require_globals();
    var EventListenerTypes_1 = require_EventListenerTypes();
    function BeforeRecover2() {
      return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().entityListeners.push({
          target: object.constructor,
          propertyName,
          type: EventListenerTypes_1.EventListenerTypes.BEFORE_RECOVER
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/listeners/BeforeUpdate.js
var require_BeforeUpdate = __commonJS({
  "node_modules/typeorm/decorator/listeners/BeforeUpdate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BeforeUpdate = BeforeUpdate2;
    var globals_1 = require_globals();
    var EventListenerTypes_1 = require_EventListenerTypes();
    function BeforeUpdate2() {
      return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().entityListeners.push({
          target: object.constructor,
          propertyName,
          type: EventListenerTypes_1.EventListenerTypes.BEFORE_UPDATE
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/listeners/EventSubscriber.js
var require_EventSubscriber = __commonJS({
  "node_modules/typeorm/decorator/listeners/EventSubscriber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EventSubscriber = EventSubscriber2;
    var globals_1 = require_globals();
    function EventSubscriber2() {
      return function(target) {
        (0, globals_1.getMetadataArgsStorage)().entitySubscribers.push({
          target
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/options/ColumnOptions.js
var require_ColumnOptions = __commonJS({
  "node_modules/typeorm/decorator/options/ColumnOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/decorator/options/IndexOptions.js
var require_IndexOptions = __commonJS({
  "node_modules/typeorm/decorator/options/IndexOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/decorator/options/JoinColumnOptions.js
var require_JoinColumnOptions = __commonJS({
  "node_modules/typeorm/decorator/options/JoinColumnOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/decorator/options/JoinTableOptions.js
var require_JoinTableOptions = __commonJS({
  "node_modules/typeorm/decorator/options/JoinTableOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/decorator/options/RelationOptions.js
var require_RelationOptions = __commonJS({
  "node_modules/typeorm/decorator/options/RelationOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/decorator/options/EntityOptions.js
var require_EntityOptions = __commonJS({
  "node_modules/typeorm/decorator/options/EntityOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/decorator/options/ValueTransformer.js
var require_ValueTransformer = __commonJS({
  "node_modules/typeorm/decorator/options/ValueTransformer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/decorator/relations/JoinColumn.js
var require_JoinColumn = __commonJS({
  "node_modules/typeorm/decorator/relations/JoinColumn.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.JoinColumn = JoinColumn2;
    var globals_1 = require_globals();
    function JoinColumn2(optionsOrOptionsArray) {
      return function(object, propertyName) {
        const options = Array.isArray(optionsOrOptionsArray) ? optionsOrOptionsArray : [optionsOrOptionsArray || {}];
        options.forEach((options2) => {
          (0, globals_1.getMetadataArgsStorage)().joinColumns.push({
            target: object.constructor,
            propertyName,
            name: options2.name,
            referencedColumnName: options2.referencedColumnName,
            foreignKeyConstraintName: options2.foreignKeyConstraintName
          });
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/relations/JoinTable.js
var require_JoinTable = __commonJS({
  "node_modules/typeorm/decorator/relations/JoinTable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.JoinTable = JoinTable2;
    var globals_1 = require_globals();
    function JoinTable2(options) {
      return function(object, propertyName) {
        options = options || {};
        (0, globals_1.getMetadataArgsStorage)().joinTables.push({
          target: object.constructor,
          propertyName,
          name: options.name,
          joinColumns: options && options.joinColumn ? [options.joinColumn] : options.joinColumns,
          inverseJoinColumns: options && options.inverseJoinColumn ? [options.inverseJoinColumn] : options.inverseJoinColumns,
          schema: options && options.schema ? options.schema : void 0,
          database: options && options.database ? options.database : void 0,
          synchronize: !(options && options.synchronize === false)
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/relations/ManyToMany.js
var require_ManyToMany = __commonJS({
  "node_modules/typeorm/decorator/relations/ManyToMany.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ManyToMany = ManyToMany2;
    var globals_1 = require_globals();
    var ObjectUtils_1 = require_ObjectUtils();
    function ManyToMany2(typeFunctionOrTarget, inverseSideOrOptions, options) {
      let inverseSideProperty;
      if (ObjectUtils_1.ObjectUtils.isObject(inverseSideOrOptions)) {
        options = inverseSideOrOptions;
      } else {
        inverseSideProperty = inverseSideOrOptions;
      }
      return function(object, propertyName) {
        if (!options)
          options = {};
        let isLazy = options.lazy === true;
        if (!isLazy && Reflect && Reflect.getMetadata) {
          const reflectedType = Reflect.getMetadata("design:type", object, propertyName);
          if (reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise")
            isLazy = true;
        }
        (0, globals_1.getMetadataArgsStorage)().relations.push({
          target: object.constructor,
          propertyName,
          // propertyType: reflectedType,
          relationType: "many-to-many",
          isLazy,
          type: typeFunctionOrTarget,
          inverseSideProperty,
          options
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/relations/ManyToOne.js
var require_ManyToOne = __commonJS({
  "node_modules/typeorm/decorator/relations/ManyToOne.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ManyToOne = ManyToOne2;
    var globals_1 = require_globals();
    var ObjectUtils_1 = require_ObjectUtils();
    function ManyToOne2(typeFunctionOrTarget, inverseSideOrOptions, options) {
      let inverseSideProperty;
      if (ObjectUtils_1.ObjectUtils.isObject(inverseSideOrOptions)) {
        options = inverseSideOrOptions;
      } else {
        inverseSideProperty = inverseSideOrOptions;
      }
      return function(object, propertyName) {
        if (!options)
          options = {};
        let isLazy = options && options.lazy === true;
        if (!isLazy && Reflect && Reflect.getMetadata) {
          const reflectedType = Reflect.getMetadata("design:type", object, propertyName);
          if (reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise")
            isLazy = true;
        }
        (0, globals_1.getMetadataArgsStorage)().relations.push({
          target: object.constructor,
          propertyName,
          // propertyType: reflectedType,
          relationType: "many-to-one",
          isLazy,
          type: typeFunctionOrTarget,
          inverseSideProperty,
          options
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/relations/OneToMany.js
var require_OneToMany = __commonJS({
  "node_modules/typeorm/decorator/relations/OneToMany.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OneToMany = OneToMany2;
    var globals_1 = require_globals();
    function OneToMany2(typeFunctionOrTarget, inverseSide, options) {
      return function(object, propertyName) {
        if (!options)
          options = {};
        let isLazy = options && options.lazy === true;
        if (!isLazy && Reflect && Reflect.getMetadata) {
          const reflectedType = Reflect.getMetadata("design:type", object, propertyName);
          if (reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise")
            isLazy = true;
        }
        (0, globals_1.getMetadataArgsStorage)().relations.push({
          target: object.constructor,
          propertyName,
          // propertyType: reflectedType,
          isLazy,
          relationType: "one-to-many",
          type: typeFunctionOrTarget,
          inverseSideProperty: inverseSide,
          options
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/relations/OneToOne.js
var require_OneToOne = __commonJS({
  "node_modules/typeorm/decorator/relations/OneToOne.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OneToOne = OneToOne2;
    var globals_1 = require_globals();
    var ObjectUtils_1 = require_ObjectUtils();
    function OneToOne2(typeFunctionOrTarget, inverseSideOrOptions, options) {
      let inverseSideProperty;
      if (ObjectUtils_1.ObjectUtils.isObject(inverseSideOrOptions)) {
        options = inverseSideOrOptions;
      } else {
        inverseSideProperty = inverseSideOrOptions;
      }
      return function(object, propertyName) {
        if (!options)
          options = {};
        let isLazy = options && options.lazy === true ? true : false;
        if (!isLazy && Reflect && Reflect.getMetadata) {
          const reflectedType = Reflect.getMetadata("design:type", object, propertyName);
          if (reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise")
            isLazy = true;
        }
        (0, globals_1.getMetadataArgsStorage)().relations.push({
          target: object.constructor,
          propertyName,
          // propertyType: reflectedType,
          isLazy,
          relationType: "one-to-one",
          type: typeFunctionOrTarget,
          inverseSideProperty,
          options
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/relations/RelationCount.js
var require_RelationCount = __commonJS({
  "node_modules/typeorm/decorator/relations/RelationCount.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RelationCount = RelationCount2;
    var globals_1 = require_globals();
    function RelationCount2(relation, alias, queryBuilderFactory) {
      return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().relationCounts.push({
          target: object.constructor,
          propertyName,
          relation,
          alias,
          queryBuilderFactory
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/relations/RelationId.js
var require_RelationId = __commonJS({
  "node_modules/typeorm/decorator/relations/RelationId.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RelationId = RelationId2;
    var globals_1 = require_globals();
    function RelationId2(relation, alias, queryBuilderFactory) {
      return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().relationIds.push({
          target: object.constructor,
          propertyName,
          relation,
          alias,
          queryBuilderFactory
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/entity/Entity.js
var require_Entity = __commonJS({
  "node_modules/typeorm/decorator/entity/Entity.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Entity = Entity2;
    var globals_1 = require_globals();
    var ObjectUtils_1 = require_ObjectUtils();
    function Entity2(nameOrOptions, maybeOptions) {
      const options = (ObjectUtils_1.ObjectUtils.isObject(nameOrOptions) ? nameOrOptions : maybeOptions) || {};
      const name = typeof nameOrOptions === "string" ? nameOrOptions : options.name;
      return function(target) {
        (0, globals_1.getMetadataArgsStorage)().tables.push({
          target,
          name,
          type: "regular",
          orderBy: options.orderBy ? options.orderBy : void 0,
          engine: options.engine ? options.engine : void 0,
          database: options.database ? options.database : void 0,
          schema: options.schema ? options.schema : void 0,
          synchronize: options.synchronize,
          withoutRowid: options.withoutRowid,
          comment: options.comment ? options.comment : void 0
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/entity/ChildEntity.js
var require_ChildEntity = __commonJS({
  "node_modules/typeorm/decorator/entity/ChildEntity.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChildEntity = ChildEntity2;
    var globals_1 = require_globals();
    function ChildEntity2(discriminatorValue) {
      return function(target) {
        (0, globals_1.getMetadataArgsStorage)().tables.push({
          target,
          type: "entity-child"
        });
        if (typeof discriminatorValue !== "undefined") {
          (0, globals_1.getMetadataArgsStorage)().discriminatorValues.push({
            target,
            value: discriminatorValue
          });
        }
      };
    }
  }
});

// node_modules/typeorm/decorator/entity/TableInheritance.js
var require_TableInheritance = __commonJS({
  "node_modules/typeorm/decorator/entity/TableInheritance.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TableInheritance = TableInheritance2;
    var globals_1 = require_globals();
    function TableInheritance2(options) {
      return function(target) {
        (0, globals_1.getMetadataArgsStorage)().inheritances.push({
          target,
          pattern: options && options.pattern ? options.pattern : "STI",
          column: options && options.column ? typeof options.column === "string" ? { name: options.column } : options.column : void 0
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/entity-view/ViewEntity.js
var require_ViewEntity = __commonJS({
  "node_modules/typeorm/decorator/entity-view/ViewEntity.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ViewEntity = ViewEntity2;
    var globals_1 = require_globals();
    var ObjectUtils_1 = require_ObjectUtils();
    function ViewEntity2(nameOrOptions, maybeOptions) {
      const options = (ObjectUtils_1.ObjectUtils.isObject(nameOrOptions) ? nameOrOptions : maybeOptions) || {};
      const name = typeof nameOrOptions === "string" ? nameOrOptions : options.name;
      return function(target) {
        (0, globals_1.getMetadataArgsStorage)().tables.push({
          target,
          name,
          expression: options.expression,
          dependsOn: options.dependsOn ? new Set(options.dependsOn) : void 0,
          type: "view",
          database: options.database ? options.database : void 0,
          schema: options.schema ? options.schema : void 0,
          synchronize: options.synchronize === false ? false : true,
          materialized: !!options.materialized
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/tree/TreeLevelColumn.js
var require_TreeLevelColumn = __commonJS({
  "node_modules/typeorm/decorator/tree/TreeLevelColumn.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TreeLevelColumn = TreeLevelColumn2;
    var globals_1 = require_globals();
    function TreeLevelColumn2() {
      return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().columns.push({
          target: object.constructor,
          propertyName,
          mode: "treeLevel",
          options: {}
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/tree/TreeParent.js
var require_TreeParent = __commonJS({
  "node_modules/typeorm/decorator/tree/TreeParent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TreeParent = TreeParent2;
    var globals_1 = require_globals();
    function TreeParent2(options) {
      return function(object, propertyName) {
        if (!options)
          options = {};
        const reflectedType = Reflect && Reflect.getMetadata ? Reflect.getMetadata("design:type", object, propertyName) : void 0;
        const isLazy = reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise" || false;
        (0, globals_1.getMetadataArgsStorage)().relations.push({
          isTreeParent: true,
          target: object.constructor,
          propertyName,
          isLazy,
          relationType: "many-to-one",
          type: () => object.constructor,
          options
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/tree/TreeChildren.js
var require_TreeChildren = __commonJS({
  "node_modules/typeorm/decorator/tree/TreeChildren.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TreeChildren = TreeChildren2;
    var globals_1 = require_globals();
    function TreeChildren2(options) {
      return function(object, propertyName) {
        if (!options)
          options = {};
        const reflectedType = Reflect && Reflect.getMetadata ? Reflect.getMetadata("design:type", object, propertyName) : void 0;
        const isLazy = reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise" || false;
        (0, globals_1.getMetadataArgsStorage)().relations.push({
          isTreeChildren: true,
          target: object.constructor,
          propertyName,
          isLazy,
          relationType: "one-to-many",
          type: () => object.constructor,
          options
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/tree/Tree.js
var require_Tree = __commonJS({
  "node_modules/typeorm/decorator/tree/Tree.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Tree = Tree2;
    var globals_1 = require_globals();
    function Tree2(type, options) {
      return function(target) {
        (0, globals_1.getMetadataArgsStorage)().trees.push({
          target,
          type,
          options: type === "closure-table" ? options : void 0
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/Index.js
var require_Index = __commonJS({
  "node_modules/typeorm/decorator/Index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Index = Index2;
    var globals_1 = require_globals();
    var ObjectUtils_1 = require_ObjectUtils();
    function Index2(nameOrFieldsOrOptions, maybeFieldsOrOptions, maybeOptions) {
      const name = typeof nameOrFieldsOrOptions === "string" ? nameOrFieldsOrOptions : void 0;
      const fields = typeof nameOrFieldsOrOptions === "string" ? maybeFieldsOrOptions : nameOrFieldsOrOptions;
      let options = ObjectUtils_1.ObjectUtils.isObject(nameOrFieldsOrOptions) && !Array.isArray(nameOrFieldsOrOptions) ? nameOrFieldsOrOptions : maybeOptions;
      if (!options)
        options = ObjectUtils_1.ObjectUtils.isObject(maybeFieldsOrOptions) && !Array.isArray(maybeFieldsOrOptions) ? maybeFieldsOrOptions : maybeOptions;
      return function(clsOrObject, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().indices.push({
          target: propertyName ? clsOrObject.constructor : clsOrObject,
          name,
          columns: propertyName ? [propertyName] : fields,
          synchronize: options && options.synchronize === false ? false : true,
          where: options ? options.where : void 0,
          unique: options && options.unique ? true : false,
          spatial: options && options.spatial ? true : false,
          fulltext: options && options.fulltext ? true : false,
          nullFiltered: options && options.nullFiltered ? true : false,
          parser: options ? options.parser : void 0,
          sparse: options && options.sparse ? true : false,
          background: options && options.background ? true : false,
          concurrent: options && options.concurrent ? true : false,
          expireAfterSeconds: options ? options.expireAfterSeconds : void 0
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/ForeignKey.js
var require_ForeignKey = __commonJS({
  "node_modules/typeorm/decorator/ForeignKey.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ForeignKey = ForeignKey2;
    var globals_1 = require_globals();
    var ObjectUtils_1 = require_ObjectUtils();
    function ForeignKey2(typeFunctionOrTarget, inverseSideOrColumnNamesOrOptions, referencedColumnNamesOrOptions, maybeOptions) {
      const inverseSide = typeof inverseSideOrColumnNamesOrOptions === "string" || typeof inverseSideOrColumnNamesOrOptions === "function" ? inverseSideOrColumnNamesOrOptions : void 0;
      const columnNames = Array.isArray(inverseSideOrColumnNamesOrOptions) ? inverseSideOrColumnNamesOrOptions : void 0;
      const referencedColumnNames = Array.isArray(referencedColumnNamesOrOptions) ? referencedColumnNamesOrOptions : void 0;
      const options = ObjectUtils_1.ObjectUtils.isObject(inverseSideOrColumnNamesOrOptions) && !Array.isArray(inverseSideOrColumnNamesOrOptions) ? inverseSideOrColumnNamesOrOptions : ObjectUtils_1.ObjectUtils.isObject(referencedColumnNamesOrOptions) && !Array.isArray(referencedColumnNamesOrOptions) ? referencedColumnNamesOrOptions : maybeOptions;
      return function(clsOrObject, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().foreignKeys.push({
          target: propertyName ? clsOrObject.constructor : clsOrObject,
          propertyName,
          type: typeFunctionOrTarget,
          inverseSide,
          columnNames,
          referencedColumnNames,
          ...options
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/Unique.js
var require_Unique = __commonJS({
  "node_modules/typeorm/decorator/Unique.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Unique = Unique2;
    var globals_1 = require_globals();
    var ObjectUtils_1 = require_ObjectUtils();
    function Unique2(nameOrFieldsOrOptions, maybeFieldsOrOptions, maybeOptions) {
      const name = typeof nameOrFieldsOrOptions === "string" ? nameOrFieldsOrOptions : void 0;
      const fields = typeof nameOrFieldsOrOptions === "string" ? maybeFieldsOrOptions : nameOrFieldsOrOptions;
      let options = ObjectUtils_1.ObjectUtils.isObject(nameOrFieldsOrOptions) && !Array.isArray(nameOrFieldsOrOptions) ? nameOrFieldsOrOptions : maybeOptions;
      if (!options)
        options = ObjectUtils_1.ObjectUtils.isObject(nameOrFieldsOrOptions) && !Array.isArray(maybeFieldsOrOptions) ? maybeFieldsOrOptions : maybeOptions;
      return function(clsOrObject, propertyName) {
        let columns = fields;
        if (propertyName !== void 0) {
          switch (typeof propertyName) {
            case "string":
              columns = [propertyName];
              break;
            case "symbol":
              columns = [propertyName.toString()];
              break;
          }
        }
        const args = {
          target: propertyName ? clsOrObject.constructor : clsOrObject,
          name,
          columns,
          deferrable: options ? options.deferrable : void 0
        };
        (0, globals_1.getMetadataArgsStorage)().uniques.push(args);
      };
    }
  }
});

// node_modules/typeorm/decorator/Check.js
var require_Check = __commonJS({
  "node_modules/typeorm/decorator/Check.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Check = Check2;
    var globals_1 = require_globals();
    var error_1 = require_error();
    function Check2(nameOrExpression, maybeExpression) {
      const name = maybeExpression ? nameOrExpression : void 0;
      const expression = maybeExpression ? maybeExpression : nameOrExpression;
      if (!expression)
        throw new error_1.TypeORMError(`Check expression is required`);
      return function(clsOrObject, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().checks.push({
          target: propertyName ? clsOrObject.constructor : clsOrObject,
          name,
          expression
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/Exclusion.js
var require_Exclusion = __commonJS({
  "node_modules/typeorm/decorator/Exclusion.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Exclusion = Exclusion2;
    var globals_1 = require_globals();
    var error_1 = require_error();
    function Exclusion2(nameOrExpression, maybeExpression) {
      const name = maybeExpression ? nameOrExpression : void 0;
      const expression = maybeExpression ? maybeExpression : nameOrExpression;
      if (!expression)
        throw new error_1.TypeORMError(`Exclusion expression is required`);
      return function(clsOrObject, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().exclusions.push({
          target: propertyName ? clsOrObject.constructor : clsOrObject,
          name,
          expression
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/Generated.js
var require_Generated = __commonJS({
  "node_modules/typeorm/decorator/Generated.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Generated = Generated2;
    var globals_1 = require_globals();
    function Generated2(strategy = "increment") {
      return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().generations.push({
          target: object.constructor,
          propertyName,
          strategy
        });
      };
    }
  }
});

// node_modules/typeorm/decorator/EntityRepository.js
var require_EntityRepository = __commonJS({
  "node_modules/typeorm/decorator/EntityRepository.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EntityRepository = EntityRepository2;
    var globals_1 = require_globals();
    function EntityRepository2(entity) {
      return function(target) {
        (0, globals_1.getMetadataArgsStorage)().entityRepositories.push({
          target,
          entity
        });
      };
    }
  }
});

// node_modules/typeorm/find-options/operator/And.js
var require_And = __commonJS({
  "node_modules/typeorm/find-options/operator/And.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.And = And2;
    var FindOperator_1 = require_FindOperator();
    function And2(...values) {
      return new FindOperator_1.FindOperator("and", values, true, true);
    }
  }
});

// node_modules/typeorm/find-options/operator/Or.js
var require_Or = __commonJS({
  "node_modules/typeorm/find-options/operator/Or.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Or = Or2;
    var FindOperator_1 = require_FindOperator();
    function Or2(...values) {
      return new FindOperator_1.FindOperator("or", values, true, true);
    }
  }
});

// node_modules/typeorm/find-options/operator/Any.js
var require_Any = __commonJS({
  "node_modules/typeorm/find-options/operator/Any.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Any = Any2;
    var FindOperator_1 = require_FindOperator();
    function Any2(value) {
      return new FindOperator_1.FindOperator("any", value);
    }
  }
});

// node_modules/typeorm/find-options/operator/ArrayContainedBy.js
var require_ArrayContainedBy = __commonJS({
  "node_modules/typeorm/find-options/operator/ArrayContainedBy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ArrayContainedBy = ArrayContainedBy2;
    var FindOperator_1 = require_FindOperator();
    function ArrayContainedBy2(value) {
      return new FindOperator_1.FindOperator("arrayContainedBy", value);
    }
  }
});

// node_modules/typeorm/find-options/operator/ArrayContains.js
var require_ArrayContains = __commonJS({
  "node_modules/typeorm/find-options/operator/ArrayContains.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ArrayContains = ArrayContains2;
    var FindOperator_1 = require_FindOperator();
    function ArrayContains2(value) {
      return new FindOperator_1.FindOperator("arrayContains", value);
    }
  }
});

// node_modules/typeorm/find-options/operator/ArrayOverlap.js
var require_ArrayOverlap = __commonJS({
  "node_modules/typeorm/find-options/operator/ArrayOverlap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ArrayOverlap = ArrayOverlap2;
    var FindOperator_1 = require_FindOperator();
    function ArrayOverlap2(value) {
      return new FindOperator_1.FindOperator("arrayOverlap", value);
    }
  }
});

// node_modules/typeorm/find-options/operator/Between.js
var require_Between = __commonJS({
  "node_modules/typeorm/find-options/operator/Between.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Between = Between2;
    var FindOperator_1 = require_FindOperator();
    function Between2(from, to) {
      return new FindOperator_1.FindOperator("between", [from, to], true, true);
    }
  }
});

// node_modules/typeorm/find-options/EqualOperator.js
var require_EqualOperator = __commonJS({
  "node_modules/typeorm/find-options/EqualOperator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EqualOperator = void 0;
    var FindOperator_1 = require_FindOperator();
    var EqualOperator2 = class extends FindOperator_1.FindOperator {
      constructor(value) {
        super("equal", value);
        this["@instanceof"] = Symbol.for("EqualOperator");
      }
    };
    exports2.EqualOperator = EqualOperator2;
  }
});

// node_modules/typeorm/find-options/operator/Equal.js
var require_Equal = __commonJS({
  "node_modules/typeorm/find-options/operator/Equal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Equal = Equal2;
    var EqualOperator_1 = require_EqualOperator();
    function Equal2(value) {
      return new EqualOperator_1.EqualOperator(value);
    }
  }
});

// node_modules/typeorm/find-options/operator/IsNull.js
var require_IsNull = __commonJS({
  "node_modules/typeorm/find-options/operator/IsNull.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsNull = IsNull2;
    var FindOperator_1 = require_FindOperator();
    function IsNull2() {
      return new FindOperator_1.FindOperator("isNull", void 0, false);
    }
  }
});

// node_modules/typeorm/find-options/operator/LessThan.js
var require_LessThan = __commonJS({
  "node_modules/typeorm/find-options/operator/LessThan.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LessThan = LessThan2;
    var FindOperator_1 = require_FindOperator();
    function LessThan2(value) {
      return new FindOperator_1.FindOperator("lessThan", value);
    }
  }
});

// node_modules/typeorm/find-options/operator/LessThanOrEqual.js
var require_LessThanOrEqual = __commonJS({
  "node_modules/typeorm/find-options/operator/LessThanOrEqual.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LessThanOrEqual = LessThanOrEqual2;
    var FindOperator_1 = require_FindOperator();
    function LessThanOrEqual2(value) {
      return new FindOperator_1.FindOperator("lessThanOrEqual", value);
    }
  }
});

// node_modules/typeorm/find-options/operator/ILike.js
var require_ILike = __commonJS({
  "node_modules/typeorm/find-options/operator/ILike.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ILike = ILike2;
    var FindOperator_1 = require_FindOperator();
    function ILike2(value) {
      return new FindOperator_1.FindOperator("ilike", value);
    }
  }
});

// node_modules/typeorm/find-options/operator/Like.js
var require_Like = __commonJS({
  "node_modules/typeorm/find-options/operator/Like.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Like = Like2;
    var FindOperator_1 = require_FindOperator();
    function Like2(value) {
      return new FindOperator_1.FindOperator("like", value);
    }
  }
});

// node_modules/typeorm/find-options/operator/MoreThan.js
var require_MoreThan = __commonJS({
  "node_modules/typeorm/find-options/operator/MoreThan.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MoreThan = MoreThan2;
    var FindOperator_1 = require_FindOperator();
    function MoreThan2(value) {
      return new FindOperator_1.FindOperator("moreThan", value);
    }
  }
});

// node_modules/typeorm/find-options/operator/MoreThanOrEqual.js
var require_MoreThanOrEqual = __commonJS({
  "node_modules/typeorm/find-options/operator/MoreThanOrEqual.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MoreThanOrEqual = MoreThanOrEqual2;
    var FindOperator_1 = require_FindOperator();
    function MoreThanOrEqual2(value) {
      return new FindOperator_1.FindOperator("moreThanOrEqual", value);
    }
  }
});

// node_modules/typeorm/find-options/operator/Not.js
var require_Not = __commonJS({
  "node_modules/typeorm/find-options/operator/Not.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Not = Not2;
    var FindOperator_1 = require_FindOperator();
    function Not2(value) {
      return new FindOperator_1.FindOperator("not", value);
    }
  }
});

// node_modules/typeorm/find-options/operator/Raw.js
var require_Raw = __commonJS({
  "node_modules/typeorm/find-options/operator/Raw.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Raw = Raw2;
    var FindOperator_1 = require_FindOperator();
    function Raw2(valueOrSqlGenerator, sqlGeneratorParameters) {
      if (typeof valueOrSqlGenerator !== "function") {
        return new FindOperator_1.FindOperator("raw", valueOrSqlGenerator, false);
      }
      return new FindOperator_1.FindOperator("raw", [], true, true, valueOrSqlGenerator, sqlGeneratorParameters);
    }
  }
});

// node_modules/typeorm/find-options/operator/JsonContains.js
var require_JsonContains = __commonJS({
  "node_modules/typeorm/find-options/operator/JsonContains.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.JsonContains = JsonContains2;
    var FindOperator_1 = require_FindOperator();
    function JsonContains2(value) {
      return new FindOperator_1.FindOperator("jsonContains", value);
    }
  }
});

// node_modules/typeorm/find-options/FindManyOptions.js
var require_FindManyOptions = __commonJS({
  "node_modules/typeorm/find-options/FindManyOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/find-options/FindOneOptions.js
var require_FindOneOptions = __commonJS({
  "node_modules/typeorm/find-options/FindOneOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/find-options/FindOperatorType.js
var require_FindOperatorType = __commonJS({
  "node_modules/typeorm/find-options/FindOperatorType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/find-options/FindOptionsOrder.js
var require_FindOptionsOrder = __commonJS({
  "node_modules/typeorm/find-options/FindOptionsOrder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/find-options/FindOptionsRelations.js
var require_FindOptionsRelations = __commonJS({
  "node_modules/typeorm/find-options/FindOptionsRelations.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/find-options/FindOptionsSelect.js
var require_FindOptionsSelect = __commonJS({
  "node_modules/typeorm/find-options/FindOptionsSelect.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/find-options/FindOptionsWhere.js
var require_FindOptionsWhere = __commonJS({
  "node_modules/typeorm/find-options/FindOptionsWhere.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/find-options/FindTreeOptions.js
var require_FindTreeOptions = __commonJS({
  "node_modules/typeorm/find-options/FindTreeOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/find-options/JoinOptions.js
var require_JoinOptions = __commonJS({
  "node_modules/typeorm/find-options/JoinOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/find-options/OrderByCondition.js
var require_OrderByCondition = __commonJS({
  "node_modules/typeorm/find-options/OrderByCondition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/logger/Logger.js
var require_Logger = __commonJS({
  "node_modules/typeorm/logger/Logger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/logger/LoggerOptions.js
var require_LoggerOptions = __commonJS({
  "node_modules/typeorm/logger/LoggerOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/repository/BaseEntity.js
var require_BaseEntity = __commonJS({
  "node_modules/typeorm/repository/BaseEntity.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseEntity = void 0;
    var ObjectUtils_1 = require_ObjectUtils();
    var BaseEntity2 = class {
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Checks if entity has an id.
       * If entity composite compose ids, it will check them all.
       */
      hasId() {
        const baseEntity = this.constructor;
        return baseEntity.getRepository().hasId(this);
      }
      /**
       * Saves current entity in the database.
       * If entity does not exist in the database then inserts, otherwise updates.
       */
      save(options) {
        const baseEntity = this.constructor;
        return baseEntity.getRepository().save(this, options);
      }
      /**
       * Removes current entity from the database.
       */
      remove(options) {
        const baseEntity = this.constructor;
        return baseEntity.getRepository().remove(this, options);
      }
      /**
       * Records the delete date of current entity.
       */
      softRemove(options) {
        const baseEntity = this.constructor;
        return baseEntity.getRepository().softRemove(this, options);
      }
      /**
       * Recovers a given entity in the database.
       */
      recover(options) {
        const baseEntity = this.constructor;
        return baseEntity.getRepository().recover(this, options);
      }
      /**
       * Reloads entity data from the database.
       */
      async reload() {
        const baseEntity = this.constructor;
        const id = baseEntity.getRepository().metadata.getEntityIdMap(this);
        if (!id) {
          throw new Error(`Entity doesn't have id-s set, cannot reload entity`);
        }
        const reloadedEntity = await baseEntity.getRepository().findOneByOrFail(id);
        ObjectUtils_1.ObjectUtils.assign(this, reloadedEntity);
      }
      // -------------------------------------------------------------------------
      // Public Static Methods
      // -------------------------------------------------------------------------
      /**
       * Sets DataSource to be used by entity.
       */
      static useDataSource(dataSource) {
        this.dataSource = dataSource;
      }
      /**
       * Gets current entity's Repository.
       */
      static getRepository() {
        const dataSource = this.dataSource;
        if (!dataSource)
          throw new Error(`DataSource is not set for this entity.`);
        return dataSource.getRepository(this);
      }
      /**
       * Returns object that is managed by this repository.
       * If this repository manages entity from schema,
       * then it returns a name of that schema instead.
       */
      static get target() {
        return this.getRepository().target;
      }
      /**
       * Checks entity has an id.
       * If entity composite compose ids, it will check them all.
       */
      static hasId(entity) {
        return this.getRepository().hasId(entity);
      }
      /**
       * Gets entity mixed id.
       */
      static getId(entity) {
        return this.getRepository().getId(entity);
      }
      /**
       * Creates a new query builder that can be used to build a SQL query.
       */
      static createQueryBuilder(alias) {
        return this.getRepository().createQueryBuilder(alias);
      }
      /**
       * Creates a new entity instance and copies all entity properties from this object into a new entity.
       * Note that it copies only properties that present in entity schema.
       */
      static create(entityOrEntities) {
        return this.getRepository().create(entityOrEntities);
      }
      /**
       * Merges multiple entities (or entity-like objects) into a given entity.
       */
      static merge(mergeIntoEntity, ...entityLikes) {
        return this.getRepository().merge(mergeIntoEntity, ...entityLikes);
      }
      /**
       * Creates a new entity from the given plain javascript object. If entity already exist in the database, then
       * it loads it (and everything related to it), replaces all values with the new ones from the given object
       * and returns this new entity. This new entity is actually a loaded from the db entity with all properties
       * replaced from the new object.
       *
       * Note that given entity-like object must have an entity id / primary key to find entity by.
       * Returns undefined if entity with given id was not found.
       */
      static preload(entityLike) {
        const thisRepository = this.getRepository();
        return thisRepository.preload(entityLike);
      }
      /**
       * Saves one or many given entities.
       */
      static save(entityOrEntities, options) {
        return this.getRepository().save(entityOrEntities, options);
      }
      /**
       * Removes one or many given entities.
       */
      static remove(entityOrEntities, options) {
        return this.getRepository().remove(entityOrEntities, options);
      }
      /**
       * Records the delete date of one or many given entities.
       */
      static softRemove(entityOrEntities, options) {
        return this.getRepository().softRemove(entityOrEntities, options);
      }
      /**
       * Inserts a given entity into the database.
       * Unlike save method executes a primitive operation without cascades, relations and other operations included.
       * Executes fast and efficient INSERT query.
       * Does not check if entity exist in the database, so query will fail if duplicate entity is being inserted.
       */
      static insert(entity) {
        return this.getRepository().insert(entity);
      }
      /**
       * Updates entity partially. Entity can be found by a given conditions.
       * Unlike save method executes a primitive operation without cascades, relations and other operations included.
       * Executes fast and efficient UPDATE query.
       * Does not check if entity exist in the database.
       */
      static update(criteria, partialEntity) {
        return this.getRepository().update(criteria, partialEntity);
      }
      /**
       * Inserts a given entity into the database, unless a unique constraint conflicts then updates the entity
       * Unlike save method executes a primitive operation without cascades, relations and other operations included.
       * Executes fast and efficient INSERT ... ON CONFLICT DO UPDATE/ON DUPLICATE KEY UPDATE query.
       */
      static upsert(entityOrEntities, conflictPathsOrOptions) {
        return this.getRepository().upsert(entityOrEntities, conflictPathsOrOptions);
      }
      /**
       * Deletes entities by a given criteria.
       * Unlike remove method executes a primitive operation without cascades, relations and other operations included.
       * Executes fast and efficient DELETE query.
       * Does not check if entity exist in the database.
       */
      static delete(criteria) {
        return this.getRepository().delete(criteria);
      }
      /**
       * Checks whether any entity exists that matches the given options.
       */
      static exists(options) {
        return this.getRepository().exists(options);
      }
      /**
       * Checks whether any entity exists that matches the given conditions.
       */
      static existsBy(where) {
        return this.getRepository().existsBy(where);
      }
      /**
       * Counts entities that match given options.
       */
      static count(options) {
        return this.getRepository().count(options);
      }
      /**
       * Counts entities that match given WHERE conditions.
       */
      static countBy(where) {
        return this.getRepository().countBy(where);
      }
      /**
       * Return the SUM of a column
       */
      static sum(columnName, where) {
        return this.getRepository().sum(columnName, where);
      }
      /**
       * Return the AVG of a column
       */
      static average(columnName, where) {
        return this.getRepository().average(columnName, where);
      }
      /**
       * Return the MIN of a column
       */
      static minimum(columnName, where) {
        return this.getRepository().minimum(columnName, where);
      }
      /**
       * Return the MAX of a column
       */
      static maximum(columnName, where) {
        return this.getRepository().maximum(columnName, where);
      }
      /**
       * Finds entities that match given options.
       */
      static find(options) {
        return this.getRepository().find(options);
      }
      /**
       * Finds entities that match given WHERE conditions.
       */
      static findBy(where) {
        return this.getRepository().findBy(where);
      }
      /**
       * Finds entities that match given find options.
       * Also counts all entities that match given conditions,
       * but ignores pagination settings (from and take options).
       */
      static findAndCount(options) {
        return this.getRepository().findAndCount(options);
      }
      /**
       * Finds entities that match given WHERE conditions.
       * Also counts all entities that match given conditions,
       * but ignores pagination settings (from and take options).
       */
      static findAndCountBy(where) {
        return this.getRepository().findAndCountBy(where);
      }
      /**
       * Finds entities by ids.
       * Optionally find options can be applied.
       *
       * @deprecated use `findBy` method instead in conjunction with `In` operator, for example:
       *
       * .findBy({
       *     id: In([1, 2, 3])
       * })
       */
      static findByIds(ids) {
        return this.getRepository().findByIds(ids);
      }
      /**
       * Finds first entity that matches given conditions.
       */
      static findOne(options) {
        return this.getRepository().findOne(options);
      }
      /**
       * Finds first entity that matches given conditions.
       */
      static findOneBy(where) {
        return this.getRepository().findOneBy(where);
      }
      /**
       * Finds first entity that matches given options.
       *
       * @deprecated use `findOneBy` method instead in conjunction with `In` operator, for example:
       *
       * .findOneBy({
       *     id: 1 // where "id" is your primary column name
       * })
       */
      static findOneById(id) {
        return this.getRepository().findOneById(id);
      }
      /**
       * Finds first entity that matches given conditions.
       */
      static findOneOrFail(options) {
        return this.getRepository().findOneOrFail(options);
      }
      /**
       * Finds first entity that matches given conditions.
       */
      static findOneByOrFail(where) {
        return this.getRepository().findOneByOrFail(where);
      }
      /**
       * Executes a raw SQL query and returns a raw database results.
       * Raw query execution is supported only by relational databases (MongoDB is not supported).
       */
      static query(query, parameters) {
        return this.getRepository().query(query, parameters);
      }
      /**
       * Clears all the data from the given table/collection (truncates/drops it).
       */
      static clear() {
        return this.getRepository().clear();
      }
    };
    exports2.BaseEntity = BaseEntity2;
  }
});

// node_modules/typeorm/repository/RemoveOptions.js
var require_RemoveOptions = __commonJS({
  "node_modules/typeorm/repository/RemoveOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/repository/SaveOptions.js
var require_SaveOptions = __commonJS({
  "node_modules/typeorm/repository/SaveOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/schema-builder/options/TableCheckOptions.js
var require_TableCheckOptions = __commonJS({
  "node_modules/typeorm/schema-builder/options/TableCheckOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/schema-builder/options/TableColumnOptions.js
var require_TableColumnOptions = __commonJS({
  "node_modules/typeorm/schema-builder/options/TableColumnOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/schema-builder/options/TableExclusionOptions.js
var require_TableExclusionOptions = __commonJS({
  "node_modules/typeorm/schema-builder/options/TableExclusionOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/schema-builder/options/TableForeignKeyOptions.js
var require_TableForeignKeyOptions = __commonJS({
  "node_modules/typeorm/schema-builder/options/TableForeignKeyOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/schema-builder/options/TableIndexOptions.js
var require_TableIndexOptions = __commonJS({
  "node_modules/typeorm/schema-builder/options/TableIndexOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/schema-builder/options/TableOptions.js
var require_TableOptions = __commonJS({
  "node_modules/typeorm/schema-builder/options/TableOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/schema-builder/options/TableUniqueOptions.js
var require_TableUniqueOptions = __commonJS({
  "node_modules/typeorm/schema-builder/options/TableUniqueOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/schema-builder/options/ViewOptions.js
var require_ViewOptions = __commonJS({
  "node_modules/typeorm/schema-builder/options/ViewOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/driver/mongodb/bson.typings.js
var require_bson_typings = __commonJS({
  "node_modules/typeorm/driver/mongodb/bson.typings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/driver/mongodb/typings.js
var require_typings = __commonJS({
  "node_modules/typeorm/driver/mongodb/typings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Timestamp = exports2.serialize = exports2.ObjectId = exports2.MinKey = exports2.MaxKey = exports2.Long = exports2.Int32 = exports2.Double = exports2.deserialize = exports2.Decimal128 = exports2.DBRef = exports2.Code = exports2.BSONType = exports2.BSONSymbol = exports2.BSONRegExp = exports2.Binary = exports2.BSON = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var bson_typings_1 = require_bson_typings();
    Object.defineProperty(exports2, "BSONRegExp", { enumerable: true, get: function() {
      return bson_typings_1.BSONRegExp;
    } });
    Object.defineProperty(exports2, "BSONSymbol", { enumerable: true, get: function() {
      return bson_typings_1.BSONSymbol;
    } });
    Object.defineProperty(exports2, "BSONType", { enumerable: true, get: function() {
      return bson_typings_1.BSONType;
    } });
    Object.defineProperty(exports2, "Binary", { enumerable: true, get: function() {
      return bson_typings_1.Binary;
    } });
    Object.defineProperty(exports2, "Code", { enumerable: true, get: function() {
      return bson_typings_1.Code;
    } });
    Object.defineProperty(exports2, "DBRef", { enumerable: true, get: function() {
      return bson_typings_1.DBRef;
    } });
    Object.defineProperty(exports2, "Decimal128", { enumerable: true, get: function() {
      return bson_typings_1.Decimal128;
    } });
    Object.defineProperty(exports2, "Double", { enumerable: true, get: function() {
      return bson_typings_1.Double;
    } });
    Object.defineProperty(exports2, "Int32", { enumerable: true, get: function() {
      return bson_typings_1.Int32;
    } });
    Object.defineProperty(exports2, "Long", { enumerable: true, get: function() {
      return bson_typings_1.Long;
    } });
    Object.defineProperty(exports2, "MaxKey", { enumerable: true, get: function() {
      return bson_typings_1.MaxKey;
    } });
    Object.defineProperty(exports2, "MinKey", { enumerable: true, get: function() {
      return bson_typings_1.MinKey;
    } });
    Object.defineProperty(exports2, "ObjectId", { enumerable: true, get: function() {
      return bson_typings_1.ObjectId;
    } });
    Object.defineProperty(exports2, "Timestamp", { enumerable: true, get: function() {
      return bson_typings_1.Timestamp;
    } });
    Object.defineProperty(exports2, "deserialize", { enumerable: true, get: function() {
      return bson_typings_1.deserialize;
    } });
    Object.defineProperty(exports2, "serialize", { enumerable: true, get: function() {
      return bson_typings_1.serialize;
    } });
    exports2.BSON = tslib_1.__importStar(require_bson_typings());
  }
});

// node_modules/typeorm/driver/types/DatabaseType.js
var require_DatabaseType = __commonJS({
  "node_modules/typeorm/driver/types/DatabaseType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/driver/types/GeoJsonTypes.js
var require_GeoJsonTypes = __commonJS({
  "node_modules/typeorm/driver/types/GeoJsonTypes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/driver/types/ReplicationMode.js
var require_ReplicationMode = __commonJS({
  "node_modules/typeorm/driver/types/ReplicationMode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/subscriber/event/QueryEvent.js
var require_QueryEvent = __commonJS({
  "node_modules/typeorm/subscriber/event/QueryEvent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/typeorm/connection/Connection.js
var require_Connection = __commonJS({
  "node_modules/typeorm/connection/Connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Connection = void 0;
    var DataSource_1 = require_DataSource();
    var Connection2 = class extends DataSource_1.DataSource {
    };
    exports2.Connection = Connection2;
  }
});

// node_modules/typeorm/query-builder/NotBrackets.js
var require_NotBrackets = __commonJS({
  "node_modules/typeorm/query-builder/NotBrackets.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NotBrackets = void 0;
    var Brackets_1 = require_Brackets();
    var NotBrackets2 = class extends Brackets_1.Brackets {
      constructor() {
        super(...arguments);
        this["@instanceof"] = Symbol.for("NotBrackets");
      }
    };
    exports2.NotBrackets = NotBrackets2;
  }
});

// node_modules/typeorm/naming-strategy/LegacyOracleNamingStrategy.js
var require_LegacyOracleNamingStrategy = __commonJS({
  "node_modules/typeorm/naming-strategy/LegacyOracleNamingStrategy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LegacyOracleNamingStrategy = void 0;
    var RandomGenerator_1 = require_RandomGenerator();
    var DefaultNamingStrategy_1 = require_DefaultNamingStrategy();
    var error_1 = require_error();
    var LegacyOracleNamingStrategy2 = class extends DefaultNamingStrategy_1.DefaultNamingStrategy {
      constructor(shortenStrategy = "hash") {
        super();
        this.IDENTIFIER_MAX_SIZE = 30;
        this.DEFAULT_COLUMN_PREFIX = "COL_";
        this.shortenStrategy = shortenStrategy;
      }
      columnName(propertyName, customName, embeddedPrefixes) {
        const longName = super.columnName(propertyName, customName, embeddedPrefixes);
        if (this.shortenStrategy === "truncate") {
          return this.truncateIdentifier(longName);
        } else if (this.shortenStrategy === "hash") {
          return this.hashIdentifier(longName, this.DEFAULT_COLUMN_PREFIX);
        } else {
          throw new error_1.TypeORMError(`Invalid shortenStrategy`);
        }
      }
      hashIdentifier(input, prefix) {
        if (prefix.length >= this.IDENTIFIER_MAX_SIZE) {
          throw new error_1.TypeORMError(`Prefix must be shorter than IDENTIFIER_MAX_SIZE`);
        }
        return prefix + RandomGenerator_1.RandomGenerator.sha1(input).substring(0, this.IDENTIFIER_MAX_SIZE - prefix.length);
      }
      truncateIdentifier(input) {
        if (input.length > this.IDENTIFIER_MAX_SIZE) {
          return input.substring(0, this.IDENTIFIER_MAX_SIZE);
        } else {
          return input;
        }
      }
    };
    exports2.LegacyOracleNamingStrategy = LegacyOracleNamingStrategy2;
  }
});

// node_modules/typeorm/entity-schema/EntitySchema.js
var require_EntitySchema = __commonJS({
  "node_modules/typeorm/entity-schema/EntitySchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EntitySchema = void 0;
    var EntitySchema2 = class {
      constructor(options) {
        this.options = options;
        this["@instanceof"] = Symbol.for("EntitySchema");
      }
    };
    exports2.EntitySchema = EntitySchema2;
  }
});

// node_modules/typeorm/entity-schema/EntitySchemaEmbeddedColumnOptions.js
var require_EntitySchemaEmbeddedColumnOptions = __commonJS({
  "node_modules/typeorm/entity-schema/EntitySchemaEmbeddedColumnOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EntitySchemaEmbeddedColumnOptions = void 0;
    var EntitySchemaEmbeddedColumnOptions2 = class {
    };
    exports2.EntitySchemaEmbeddedColumnOptions = EntitySchemaEmbeddedColumnOptions2;
  }
});

// node_modules/typeorm/entity-schema/EntitySchemaOptions.js
var require_EntitySchemaOptions = __commonJS({
  "node_modules/typeorm/entity-schema/EntitySchemaOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EntitySchemaOptions = void 0;
    var EntitySchemaOptions2 = class {
    };
    exports2.EntitySchemaOptions = EntitySchemaOptions2;
  }
});

// node_modules/typeorm/index.js
var require_typeorm = __commonJS({
  "node_modules/typeorm/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TreeRepositoryUtils = exports2.InstanceChecker = exports2.EntitySchemaOptions = exports2.EntitySchemaEmbeddedColumnOptions = exports2.EntitySchema = exports2.LegacyOracleNamingStrategy = exports2.DefaultNamingStrategy = exports2.MigrationExecutor = exports2.Migration = exports2.MongoEntityManager = exports2.QueryResult = exports2.DeleteResult = exports2.UpdateResult = exports2.InsertResult = exports2.NotBrackets = exports2.Brackets = exports2.RelationQueryBuilder = exports2.UpdateQueryBuilder = exports2.InsertQueryBuilder = exports2.DeleteQueryBuilder = exports2.SelectQueryBuilder = exports2.QueryBuilder = exports2.ConnectionManager = exports2.Connection = exports2.DataSource = exports2.ConnectionOptionsReader = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    require_Reflect();
    tslib_1.__exportStar(require_globals(), exports2);
    tslib_1.__exportStar(require_container(), exports2);
    tslib_1.__exportStar(require_EntityTarget(), exports2);
    tslib_1.__exportStar(require_ObjectType(), exports2);
    tslib_1.__exportStar(require_ObjectLiteral(), exports2);
    tslib_1.__exportStar(require_MixedList(), exports2);
    tslib_1.__exportStar(require_DeepPartial(), exports2);
    tslib_1.__exportStar(require_RelationType(), exports2);
    tslib_1.__exportStar(require_error(), exports2);
    tslib_1.__exportStar(require_Column(), exports2);
    tslib_1.__exportStar(require_CreateDateColumn(), exports2);
    tslib_1.__exportStar(require_DeleteDateColumn(), exports2);
    tslib_1.__exportStar(require_PrimaryGeneratedColumn(), exports2);
    tslib_1.__exportStar(require_PrimaryColumn(), exports2);
    tslib_1.__exportStar(require_UpdateDateColumn(), exports2);
    tslib_1.__exportStar(require_VersionColumn(), exports2);
    tslib_1.__exportStar(require_VirtualColumn(), exports2);
    tslib_1.__exportStar(require_ViewColumn(), exports2);
    tslib_1.__exportStar(require_ObjectIdColumn(), exports2);
    tslib_1.__exportStar(require_AfterInsert(), exports2);
    tslib_1.__exportStar(require_AfterLoad(), exports2);
    tslib_1.__exportStar(require_AfterRemove(), exports2);
    tslib_1.__exportStar(require_AfterSoftRemove(), exports2);
    tslib_1.__exportStar(require_AfterRecover(), exports2);
    tslib_1.__exportStar(require_AfterUpdate(), exports2);
    tslib_1.__exportStar(require_BeforeInsert(), exports2);
    tslib_1.__exportStar(require_BeforeRemove(), exports2);
    tslib_1.__exportStar(require_BeforeSoftRemove(), exports2);
    tslib_1.__exportStar(require_BeforeRecover(), exports2);
    tslib_1.__exportStar(require_BeforeUpdate(), exports2);
    tslib_1.__exportStar(require_EventSubscriber(), exports2);
    tslib_1.__exportStar(require_ColumnOptions(), exports2);
    tslib_1.__exportStar(require_IndexOptions(), exports2);
    tslib_1.__exportStar(require_JoinColumnOptions(), exports2);
    tslib_1.__exportStar(require_JoinTableOptions(), exports2);
    tslib_1.__exportStar(require_RelationOptions(), exports2);
    tslib_1.__exportStar(require_EntityOptions(), exports2);
    tslib_1.__exportStar(require_ValueTransformer(), exports2);
    tslib_1.__exportStar(require_JoinColumn(), exports2);
    tslib_1.__exportStar(require_JoinTable(), exports2);
    tslib_1.__exportStar(require_ManyToMany(), exports2);
    tslib_1.__exportStar(require_ManyToOne(), exports2);
    tslib_1.__exportStar(require_OneToMany(), exports2);
    tslib_1.__exportStar(require_OneToOne(), exports2);
    tslib_1.__exportStar(require_RelationCount(), exports2);
    tslib_1.__exportStar(require_RelationId(), exports2);
    tslib_1.__exportStar(require_Entity(), exports2);
    tslib_1.__exportStar(require_ChildEntity(), exports2);
    tslib_1.__exportStar(require_TableInheritance(), exports2);
    tslib_1.__exportStar(require_ViewEntity(), exports2);
    tslib_1.__exportStar(require_TreeLevelColumn(), exports2);
    tslib_1.__exportStar(require_TreeParent(), exports2);
    tslib_1.__exportStar(require_TreeChildren(), exports2);
    tslib_1.__exportStar(require_Tree(), exports2);
    tslib_1.__exportStar(require_Index(), exports2);
    tslib_1.__exportStar(require_ForeignKey(), exports2);
    tslib_1.__exportStar(require_Unique(), exports2);
    tslib_1.__exportStar(require_Check(), exports2);
    tslib_1.__exportStar(require_Exclusion(), exports2);
    tslib_1.__exportStar(require_Generated(), exports2);
    tslib_1.__exportStar(require_EntityRepository(), exports2);
    tslib_1.__exportStar(require_And(), exports2);
    tslib_1.__exportStar(require_Or(), exports2);
    tslib_1.__exportStar(require_Any(), exports2);
    tslib_1.__exportStar(require_ArrayContainedBy(), exports2);
    tslib_1.__exportStar(require_ArrayContains(), exports2);
    tslib_1.__exportStar(require_ArrayOverlap(), exports2);
    tslib_1.__exportStar(require_Between(), exports2);
    tslib_1.__exportStar(require_Equal(), exports2);
    tslib_1.__exportStar(require_In(), exports2);
    tslib_1.__exportStar(require_IsNull(), exports2);
    tslib_1.__exportStar(require_LessThan(), exports2);
    tslib_1.__exportStar(require_LessThanOrEqual(), exports2);
    tslib_1.__exportStar(require_ILike(), exports2);
    tslib_1.__exportStar(require_Like(), exports2);
    tslib_1.__exportStar(require_MoreThan(), exports2);
    tslib_1.__exportStar(require_MoreThanOrEqual(), exports2);
    tslib_1.__exportStar(require_Not(), exports2);
    tslib_1.__exportStar(require_Raw(), exports2);
    tslib_1.__exportStar(require_JsonContains(), exports2);
    tslib_1.__exportStar(require_EqualOperator(), exports2);
    tslib_1.__exportStar(require_FindManyOptions(), exports2);
    tslib_1.__exportStar(require_FindOneOptions(), exports2);
    tslib_1.__exportStar(require_FindOperator(), exports2);
    tslib_1.__exportStar(require_FindOperatorType(), exports2);
    tslib_1.__exportStar(require_FindOptionsOrder(), exports2);
    tslib_1.__exportStar(require_FindOptionsRelations(), exports2);
    tslib_1.__exportStar(require_FindOptionsSelect(), exports2);
    tslib_1.__exportStar(require_FindOptionsUtils(), exports2);
    tslib_1.__exportStar(require_FindOptionsWhere(), exports2);
    tslib_1.__exportStar(require_FindTreeOptions(), exports2);
    tslib_1.__exportStar(require_JoinOptions(), exports2);
    tslib_1.__exportStar(require_OrderByCondition(), exports2);
    tslib_1.__exportStar(require_AbstractLogger(), exports2);
    tslib_1.__exportStar(require_Logger(), exports2);
    tslib_1.__exportStar(require_LoggerOptions(), exports2);
    tslib_1.__exportStar(require_AdvancedConsoleLogger(), exports2);
    tslib_1.__exportStar(require_FormattedConsoleLogger(), exports2);
    tslib_1.__exportStar(require_SimpleConsoleLogger(), exports2);
    tslib_1.__exportStar(require_FileLogger(), exports2);
    tslib_1.__exportStar(require_EntityMetadata(), exports2);
    tslib_1.__exportStar(require_EntityManager(), exports2);
    tslib_1.__exportStar(require_AbstractRepository(), exports2);
    tslib_1.__exportStar(require_Repository(), exports2);
    tslib_1.__exportStar(require_BaseEntity(), exports2);
    tslib_1.__exportStar(require_TreeRepository(), exports2);
    tslib_1.__exportStar(require_MongoRepository(), exports2);
    tslib_1.__exportStar(require_RemoveOptions(), exports2);
    tslib_1.__exportStar(require_SaveOptions(), exports2);
    tslib_1.__exportStar(require_TableCheck(), exports2);
    tslib_1.__exportStar(require_TableColumn(), exports2);
    tslib_1.__exportStar(require_TableExclusion(), exports2);
    tslib_1.__exportStar(require_TableForeignKey(), exports2);
    tslib_1.__exportStar(require_TableIndex(), exports2);
    tslib_1.__exportStar(require_TableUnique(), exports2);
    tslib_1.__exportStar(require_Table(), exports2);
    tslib_1.__exportStar(require_View(), exports2);
    tslib_1.__exportStar(require_TableCheckOptions(), exports2);
    tslib_1.__exportStar(require_TableColumnOptions(), exports2);
    tslib_1.__exportStar(require_TableExclusionOptions(), exports2);
    tslib_1.__exportStar(require_TableForeignKeyOptions(), exports2);
    tslib_1.__exportStar(require_TableIndexOptions(), exports2);
    tslib_1.__exportStar(require_TableOptions(), exports2);
    tslib_1.__exportStar(require_TableUniqueOptions(), exports2);
    tslib_1.__exportStar(require_ViewOptions(), exports2);
    tslib_1.__exportStar(require_typings(), exports2);
    tslib_1.__exportStar(require_DatabaseType(), exports2);
    tslib_1.__exportStar(require_GeoJsonTypes(), exports2);
    tslib_1.__exportStar(require_ReplicationMode(), exports2);
    tslib_1.__exportStar(require_MssqlParameter(), exports2);
    tslib_1.__exportStar(require_QueryEvent(), exports2);
    var ConnectionOptionsReader_1 = require_ConnectionOptionsReader();
    Object.defineProperty(exports2, "ConnectionOptionsReader", { enumerable: true, get: function() {
      return ConnectionOptionsReader_1.ConnectionOptionsReader;
    } });
    var DataSource_1 = require_DataSource();
    Object.defineProperty(exports2, "DataSource", { enumerable: true, get: function() {
      return DataSource_1.DataSource;
    } });
    var Connection_1 = require_Connection();
    Object.defineProperty(exports2, "Connection", { enumerable: true, get: function() {
      return Connection_1.Connection;
    } });
    var ConnectionManager_1 = require_ConnectionManager();
    Object.defineProperty(exports2, "ConnectionManager", { enumerable: true, get: function() {
      return ConnectionManager_1.ConnectionManager;
    } });
    var QueryBuilder_1 = require_QueryBuilder();
    Object.defineProperty(exports2, "QueryBuilder", { enumerable: true, get: function() {
      return QueryBuilder_1.QueryBuilder;
    } });
    var SelectQueryBuilder_1 = require_SelectQueryBuilder();
    Object.defineProperty(exports2, "SelectQueryBuilder", { enumerable: true, get: function() {
      return SelectQueryBuilder_1.SelectQueryBuilder;
    } });
    var DeleteQueryBuilder_1 = require_DeleteQueryBuilder();
    Object.defineProperty(exports2, "DeleteQueryBuilder", { enumerable: true, get: function() {
      return DeleteQueryBuilder_1.DeleteQueryBuilder;
    } });
    var InsertQueryBuilder_1 = require_InsertQueryBuilder();
    Object.defineProperty(exports2, "InsertQueryBuilder", { enumerable: true, get: function() {
      return InsertQueryBuilder_1.InsertQueryBuilder;
    } });
    var UpdateQueryBuilder_1 = require_UpdateQueryBuilder();
    Object.defineProperty(exports2, "UpdateQueryBuilder", { enumerable: true, get: function() {
      return UpdateQueryBuilder_1.UpdateQueryBuilder;
    } });
    var RelationQueryBuilder_1 = require_RelationQueryBuilder();
    Object.defineProperty(exports2, "RelationQueryBuilder", { enumerable: true, get: function() {
      return RelationQueryBuilder_1.RelationQueryBuilder;
    } });
    var Brackets_1 = require_Brackets();
    Object.defineProperty(exports2, "Brackets", { enumerable: true, get: function() {
      return Brackets_1.Brackets;
    } });
    var NotBrackets_1 = require_NotBrackets();
    Object.defineProperty(exports2, "NotBrackets", { enumerable: true, get: function() {
      return NotBrackets_1.NotBrackets;
    } });
    var InsertResult_1 = require_InsertResult();
    Object.defineProperty(exports2, "InsertResult", { enumerable: true, get: function() {
      return InsertResult_1.InsertResult;
    } });
    var UpdateResult_1 = require_UpdateResult();
    Object.defineProperty(exports2, "UpdateResult", { enumerable: true, get: function() {
      return UpdateResult_1.UpdateResult;
    } });
    var DeleteResult_1 = require_DeleteResult();
    Object.defineProperty(exports2, "DeleteResult", { enumerable: true, get: function() {
      return DeleteResult_1.DeleteResult;
    } });
    var QueryResult_1 = require_QueryResult();
    Object.defineProperty(exports2, "QueryResult", { enumerable: true, get: function() {
      return QueryResult_1.QueryResult;
    } });
    var MongoEntityManager_1 = require_MongoEntityManager();
    Object.defineProperty(exports2, "MongoEntityManager", { enumerable: true, get: function() {
      return MongoEntityManager_1.MongoEntityManager;
    } });
    var Migration_1 = require_Migration();
    Object.defineProperty(exports2, "Migration", { enumerable: true, get: function() {
      return Migration_1.Migration;
    } });
    var MigrationExecutor_1 = require_MigrationExecutor();
    Object.defineProperty(exports2, "MigrationExecutor", { enumerable: true, get: function() {
      return MigrationExecutor_1.MigrationExecutor;
    } });
    var DefaultNamingStrategy_1 = require_DefaultNamingStrategy();
    Object.defineProperty(exports2, "DefaultNamingStrategy", { enumerable: true, get: function() {
      return DefaultNamingStrategy_1.DefaultNamingStrategy;
    } });
    var LegacyOracleNamingStrategy_1 = require_LegacyOracleNamingStrategy();
    Object.defineProperty(exports2, "LegacyOracleNamingStrategy", { enumerable: true, get: function() {
      return LegacyOracleNamingStrategy_1.LegacyOracleNamingStrategy;
    } });
    var EntitySchema_1 = require_EntitySchema();
    Object.defineProperty(exports2, "EntitySchema", { enumerable: true, get: function() {
      return EntitySchema_1.EntitySchema;
    } });
    var EntitySchemaEmbeddedColumnOptions_1 = require_EntitySchemaEmbeddedColumnOptions();
    Object.defineProperty(exports2, "EntitySchemaEmbeddedColumnOptions", { enumerable: true, get: function() {
      return EntitySchemaEmbeddedColumnOptions_1.EntitySchemaEmbeddedColumnOptions;
    } });
    var EntitySchemaOptions_1 = require_EntitySchemaOptions();
    Object.defineProperty(exports2, "EntitySchemaOptions", { enumerable: true, get: function() {
      return EntitySchemaOptions_1.EntitySchemaOptions;
    } });
    var InstanceChecker_1 = require_InstanceChecker();
    Object.defineProperty(exports2, "InstanceChecker", { enumerable: true, get: function() {
      return InstanceChecker_1.InstanceChecker;
    } });
    var TreeRepositoryUtils_1 = require_TreeRepositoryUtils();
    Object.defineProperty(exports2, "TreeRepositoryUtils", { enumerable: true, get: function() {
      return TreeRepositoryUtils_1.TreeRepositoryUtils;
    } });
  }
});

// src/services/typeorm/entities/ProspectEntity.ts
var require_ProspectEntity = __commonJS({
  "src/services/typeorm/entities/ProspectEntity.ts"(exports2) {
    "use strict";
    var __decorate2 = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata2 = exports2 && exports2.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var _a;
    var _b;
    var _c;
    var _d;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProspectEntity = void 0;
    var typeorm_1 = require_typeorm();
    var UserEntity_1 = require_UserEntity();
    var OrganizationEntity_1 = require_OrganizationEntity();
    var ProspectEntity3 = class ProspectEntity {
      constructor() {
        __publicField(this, "id");
        __publicField(this, "firstName");
        __publicField(this, "lastName");
        __publicField(this, "email");
        __publicField(this, "companyName");
        __publicField(this, "domain");
        __publicField(this, "phone");
        __publicField(this, "salary");
        __publicField(this, "department");
        __publicField(this, "linkedinUrl");
        __publicField(this, "title");
        __publicField(this, "user");
        __publicField(this, "userId");
        __publicField(this, "organization");
        __publicField(this, "organizationId");
        __publicField(this, "createdAt");
        __publicField(this, "updatedAt");
      }
    };
    exports2.ProspectEntity = ProspectEntity3;
    __decorate2([
      (0, typeorm_1.PrimaryGeneratedColumn)("uuid"),
      __metadata2("design:type", String)
    ], ProspectEntity3.prototype, "id", void 0);
    __decorate2([
      (0, typeorm_1.Column)(),
      __metadata2("design:type", String)
    ], ProspectEntity3.prototype, "firstName", void 0);
    __decorate2([
      (0, typeorm_1.Column)(),
      __metadata2("design:type", String)
    ], ProspectEntity3.prototype, "lastName", void 0);
    __decorate2([
      (0, typeorm_1.Column)(),
      __metadata2("design:type", String)
    ], ProspectEntity3.prototype, "email", void 0);
    __decorate2([
      (0, typeorm_1.Column)({ nullable: true }),
      __metadata2("design:type", String)
    ], ProspectEntity3.prototype, "companyName", void 0);
    __decorate2([
      (0, typeorm_1.Column)({ nullable: true }),
      __metadata2("design:type", String)
    ], ProspectEntity3.prototype, "domain", void 0);
    __decorate2([
      (0, typeorm_1.Column)({ nullable: true }),
      __metadata2("design:type", String)
    ], ProspectEntity3.prototype, "phone", void 0);
    __decorate2([
      (0, typeorm_1.Column)({ nullable: true }),
      __metadata2("design:type", Number)
    ], ProspectEntity3.prototype, "salary", void 0);
    __decorate2([
      (0, typeorm_1.Column)({ nullable: true }),
      __metadata2("design:type", String)
    ], ProspectEntity3.prototype, "department", void 0);
    __decorate2([
      (0, typeorm_1.Column)({ nullable: true }),
      __metadata2("design:type", String)
    ], ProspectEntity3.prototype, "linkedinUrl", void 0);
    __decorate2([
      (0, typeorm_1.Column)({ nullable: true }),
      __metadata2("design:type", String)
    ], ProspectEntity3.prototype, "title", void 0);
    __decorate2([
      (0, typeorm_1.ManyToOne)(() => UserEntity_1.UserEntity, (user) => user.prospects, {
        onDelete: "CASCADE"
      }),
      (0, typeorm_1.JoinColumn)({ name: "userId" }),
      __metadata2("design:type", typeof (_a = typeof UserEntity_1.UserEntity !== "undefined" && UserEntity_1.UserEntity) === "function" ? _a : Object)
    ], ProspectEntity3.prototype, "user", void 0);
    __decorate2([
      (0, typeorm_1.Column)(),
      __metadata2("design:type", String)
    ], ProspectEntity3.prototype, "userId", void 0);
    __decorate2([
      (0, typeorm_1.ManyToOne)(() => OrganizationEntity_1.OrganizationEntity, (organization) => organization.prospects, {
        onDelete: "CASCADE"
      }),
      (0, typeorm_1.JoinColumn)({ name: "organizationId" }),
      __metadata2("design:type", typeof (_b = typeof OrganizationEntity_1.OrganizationEntity !== "undefined" && OrganizationEntity_1.OrganizationEntity) === "function" ? _b : Object)
    ], ProspectEntity3.prototype, "organization", void 0);
    __decorate2([
      (0, typeorm_1.Column)(),
      __metadata2("design:type", String)
    ], ProspectEntity3.prototype, "organizationId", void 0);
    __decorate2([
      (0, typeorm_1.CreateDateColumn)(),
      __metadata2("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
    ], ProspectEntity3.prototype, "createdAt", void 0);
    __decorate2([
      (0, typeorm_1.UpdateDateColumn)(),
      __metadata2("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
    ], ProspectEntity3.prototype, "updatedAt", void 0);
    exports2.ProspectEntity = ProspectEntity3 = __decorate2([
      (0, typeorm_1.Index)(["email", "organizationId"], { unique: true }),
      (0, typeorm_1.Entity)("Prospect")
    ], ProspectEntity3);
  }
});

// src/types/enums/CsvImportStatusEnum.ts
var CsvImportStatusEnum_exports = {};
__export(CsvImportStatusEnum_exports, {
  CsvImportStatusEnum: () => CsvImportStatusEnum
});
var CsvImportStatusEnum;
var init_CsvImportStatusEnum = __esm({
  "src/types/enums/CsvImportStatusEnum.ts"() {
    "use strict";
    CsvImportStatusEnum = /* @__PURE__ */ ((CsvImportStatusEnum2) => {
      CsvImportStatusEnum2["NEW"] = "new";
      CsvImportStatusEnum2["BUSY"] = "busy";
      CsvImportStatusEnum2["DONE"] = "done";
      CsvImportStatusEnum2["ERROR"] = "error";
      return CsvImportStatusEnum2;
    })(CsvImportStatusEnum || {});
  }
});

// src/services/typeorm/entities/CsvImportRecordEntity.ts
var require_CsvImportRecordEntity = __commonJS({
  "src/services/typeorm/entities/CsvImportRecordEntity.ts"(exports2) {
    "use strict";
    var __decorate2 = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata2 = exports2 && exports2.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var _a;
    var _b;
    var _c;
    var _d;
    var _e;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CsvImportRecordEntity = void 0;
    var typeorm_1 = require_typeorm();
    var UserEntity_1 = require_UserEntity();
    var OrganizationEntity_1 = require_OrganizationEntity();
    var CsvImportStatusEnum_1 = (init_CsvImportStatusEnum(), __toCommonJS(CsvImportStatusEnum_exports));
    var CsvImportRecordEntity3 = class CsvImportRecordEntity {
      constructor() {
        __publicField(this, "id");
        __publicField(this, "key");
        __publicField(this, "organization");
        __publicField(this, "organizationId");
        __publicField(this, "user");
        __publicField(this, "userId");
        __publicField(this, "status");
        __publicField(this, "totalRows");
        __publicField(this, "processedRows");
        __publicField(this, "failedRows");
        __publicField(this, "lastError");
        __publicField(this, "createdAt");
        __publicField(this, "updatedAt");
      }
    };
    exports2.CsvImportRecordEntity = CsvImportRecordEntity3;
    __decorate2([
      (0, typeorm_1.PrimaryGeneratedColumn)("uuid"),
      __metadata2("design:type", String)
    ], CsvImportRecordEntity3.prototype, "id", void 0);
    __decorate2([
      (0, typeorm_1.Column)(),
      __metadata2("design:type", String)
    ], CsvImportRecordEntity3.prototype, "key", void 0);
    __decorate2([
      (0, typeorm_1.ManyToOne)(() => OrganizationEntity_1.OrganizationEntity, (org) => org.csvImports, {
        onDelete: "CASCADE"
      }),
      (0, typeorm_1.JoinColumn)({ name: "organizationId" }),
      __metadata2("design:type", typeof (_a = typeof OrganizationEntity_1.OrganizationEntity !== "undefined" && OrganizationEntity_1.OrganizationEntity) === "function" ? _a : Object)
    ], CsvImportRecordEntity3.prototype, "organization", void 0);
    __decorate2([
      (0, typeorm_1.Column)(),
      __metadata2("design:type", String)
    ], CsvImportRecordEntity3.prototype, "organizationId", void 0);
    __decorate2([
      (0, typeorm_1.ManyToOne)(() => UserEntity_1.UserEntity, (user) => user.csvImports, {
        onDelete: "CASCADE"
      }),
      (0, typeorm_1.JoinColumn)({ name: "userId" }),
      __metadata2("design:type", typeof (_b = typeof UserEntity_1.UserEntity !== "undefined" && UserEntity_1.UserEntity) === "function" ? _b : Object)
    ], CsvImportRecordEntity3.prototype, "user", void 0);
    __decorate2([
      (0, typeorm_1.Column)(),
      __metadata2("design:type", String)
    ], CsvImportRecordEntity3.prototype, "userId", void 0);
    __decorate2([
      (0, typeorm_1.Column)({
        type: "enum",
        enum: CsvImportStatusEnum_1.CsvImportStatusEnum,
        default: CsvImportStatusEnum_1.CsvImportStatusEnum.NEW
      }),
      __metadata2("design:type", typeof (_c = typeof CsvImportStatusEnum_1.CsvImportStatusEnum !== "undefined" && CsvImportStatusEnum_1.CsvImportStatusEnum) === "function" ? _c : Object)
    ], CsvImportRecordEntity3.prototype, "status", void 0);
    __decorate2([
      (0, typeorm_1.Column)({ nullable: true }),
      __metadata2("design:type", Number)
    ], CsvImportRecordEntity3.prototype, "totalRows", void 0);
    __decorate2([
      (0, typeorm_1.Column)({ nullable: true }),
      __metadata2("design:type", Number)
    ], CsvImportRecordEntity3.prototype, "processedRows", void 0);
    __decorate2([
      (0, typeorm_1.Column)({ nullable: true }),
      __metadata2("design:type", Number)
    ], CsvImportRecordEntity3.prototype, "failedRows", void 0);
    __decorate2([
      (0, typeorm_1.Column)({ nullable: true }),
      __metadata2("design:type", String)
    ], CsvImportRecordEntity3.prototype, "lastError", void 0);
    __decorate2([
      (0, typeorm_1.CreateDateColumn)(),
      __metadata2("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
    ], CsvImportRecordEntity3.prototype, "createdAt", void 0);
    __decorate2([
      (0, typeorm_1.UpdateDateColumn)(),
      __metadata2("design:type", typeof (_e = typeof Date !== "undefined" && Date) === "function" ? _e : Object)
    ], CsvImportRecordEntity3.prototype, "updatedAt", void 0);
    exports2.CsvImportRecordEntity = CsvImportRecordEntity3 = __decorate2([
      (0, typeorm_1.Entity)("CsvImportRecord")
    ], CsvImportRecordEntity3);
  }
});

// src/services/typeorm/entities/OrganizationEntity.ts
var require_OrganizationEntity = __commonJS({
  "src/services/typeorm/entities/OrganizationEntity.ts"(exports2) {
    "use strict";
    var __decorate2 = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata2 = exports2 && exports2.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var _a;
    var _b;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OrganizationEntity = void 0;
    var typeorm_1 = require_typeorm();
    var UserOrganizationEntity_1 = require_UserOrganizationEntity();
    var ProspectEntity_1 = require_ProspectEntity();
    var CsvImportRecordEntity_1 = require_CsvImportRecordEntity();
    var OrganizationEntity2 = class OrganizationEntity {
      constructor() {
        __publicField(this, "id");
        __publicField(this, "name");
        __publicField(this, "userOrganizations");
        __publicField(this, "prospects");
        __publicField(this, "csvImports");
        __publicField(this, "createdAt");
        __publicField(this, "updatedAt");
      }
    };
    exports2.OrganizationEntity = OrganizationEntity2;
    __decorate2([
      (0, typeorm_1.PrimaryGeneratedColumn)("uuid"),
      __metadata2("design:type", String)
    ], OrganizationEntity2.prototype, "id", void 0);
    __decorate2([
      (0, typeorm_1.Column)({ unique: true }),
      __metadata2("design:type", String)
    ], OrganizationEntity2.prototype, "name", void 0);
    __decorate2([
      (0, typeorm_1.OneToMany)(() => UserOrganizationEntity_1.UserOrganizationEntity, (user) => user.organization),
      __metadata2("design:type", Array)
    ], OrganizationEntity2.prototype, "userOrganizations", void 0);
    __decorate2([
      (0, typeorm_1.OneToMany)(() => ProspectEntity_1.ProspectEntity, (prospect) => prospect.organization),
      __metadata2("design:type", Array)
    ], OrganizationEntity2.prototype, "prospects", void 0);
    __decorate2([
      (0, typeorm_1.OneToMany)(() => CsvImportRecordEntity_1.CsvImportRecordEntity, (csv) => csv.organization),
      __metadata2("design:type", Array)
    ], OrganizationEntity2.prototype, "csvImports", void 0);
    __decorate2([
      (0, typeorm_1.CreateDateColumn)(),
      __metadata2("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
    ], OrganizationEntity2.prototype, "createdAt", void 0);
    __decorate2([
      (0, typeorm_1.UpdateDateColumn)(),
      __metadata2("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
    ], OrganizationEntity2.prototype, "updatedAt", void 0);
    exports2.OrganizationEntity = OrganizationEntity2 = __decorate2([
      (0, typeorm_1.Entity)("Organization")
    ], OrganizationEntity2);
  }
});

// src/types/enums/UserRoleEnum.ts
var UserRoleEnum_exports = {};
__export(UserRoleEnum_exports, {
  UserRoleEnum: () => UserRoleEnum
});
var UserRoleEnum;
var init_UserRoleEnum = __esm({
  "src/types/enums/UserRoleEnum.ts"() {
    "use strict";
    UserRoleEnum = /* @__PURE__ */ ((UserRoleEnum2) => {
      UserRoleEnum2["USER"] = "user";
      UserRoleEnum2["ADMIN"] = "admin";
      return UserRoleEnum2;
    })(UserRoleEnum || {});
  }
});

// src/services/typeorm/entities/UserOrganizationEntity.ts
var require_UserOrganizationEntity = __commonJS({
  "src/services/typeorm/entities/UserOrganizationEntity.ts"(exports2) {
    "use strict";
    var __decorate2 = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata2 = exports2 && exports2.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var _a;
    var _b;
    var _c;
    var _d;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UserOrganizationEntity = void 0;
    var typeorm_1 = require_typeorm();
    var UserEntity_1 = require_UserEntity();
    var OrganizationEntity_1 = require_OrganizationEntity();
    var UserRoleEnum_1 = (init_UserRoleEnum(), __toCommonJS(UserRoleEnum_exports));
    var UserOrganizationEntity2 = class UserOrganizationEntity {
      constructor() {
        __publicField(this, "id");
        __publicField(this, "userId");
        __publicField(this, "organizationId");
        __publicField(this, "user");
        __publicField(this, "organization");
        __publicField(this, "role");
        __publicField(this, "createdAt");
      }
    };
    exports2.UserOrganizationEntity = UserOrganizationEntity2;
    __decorate2([
      (0, typeorm_1.PrimaryGeneratedColumn)("uuid"),
      __metadata2("design:type", String)
    ], UserOrganizationEntity2.prototype, "id", void 0);
    __decorate2([
      (0, typeorm_1.Column)(),
      __metadata2("design:type", String)
    ], UserOrganizationEntity2.prototype, "userId", void 0);
    __decorate2([
      (0, typeorm_1.Column)(),
      __metadata2("design:type", String)
    ], UserOrganizationEntity2.prototype, "organizationId", void 0);
    __decorate2([
      (0, typeorm_1.ManyToOne)(() => UserEntity_1.UserEntity, { onDelete: "CASCADE" }),
      (0, typeorm_1.JoinColumn)({ name: "userId" }),
      __metadata2("design:type", typeof (_a = typeof UserEntity_1.UserEntity !== "undefined" && UserEntity_1.UserEntity) === "function" ? _a : Object)
    ], UserOrganizationEntity2.prototype, "user", void 0);
    __decorate2([
      (0, typeorm_1.ManyToOne)(() => OrganizationEntity_1.OrganizationEntity, { onDelete: "CASCADE" }),
      (0, typeorm_1.JoinColumn)({ name: "organizationId" }),
      __metadata2("design:type", typeof (_b = typeof OrganizationEntity_1.OrganizationEntity !== "undefined" && OrganizationEntity_1.OrganizationEntity) === "function" ? _b : Object)
    ], UserOrganizationEntity2.prototype, "organization", void 0);
    __decorate2([
      (0, typeorm_1.Column)({ type: "enum", enum: UserRoleEnum_1.UserRoleEnum, default: UserRoleEnum_1.UserRoleEnum.USER }),
      __metadata2("design:type", typeof (_c = typeof UserRoleEnum_1.UserRoleEnum !== "undefined" && UserRoleEnum_1.UserRoleEnum) === "function" ? _c : Object)
    ], UserOrganizationEntity2.prototype, "role", void 0);
    __decorate2([
      (0, typeorm_1.CreateDateColumn)(),
      __metadata2("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
    ], UserOrganizationEntity2.prototype, "createdAt", void 0);
    exports2.UserOrganizationEntity = UserOrganizationEntity2 = __decorate2([
      (0, typeorm_1.Index)("userOrganizationUserIdPerOrganizationId", ["userId", "organizationId"], {
        unique: true
      }),
      (0, typeorm_1.Entity)("UserOrganization")
    ], UserOrganizationEntity2);
  }
});

// src/services/typeorm/entities/AttachmentEntity.ts
var require_AttachmentEntity = __commonJS({
  "src/services/typeorm/entities/AttachmentEntity.ts"(exports2) {
    "use strict";
    var __decorate2 = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata2 = exports2 && exports2.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AttachmentEntity = void 0;
    var typeorm_1 = require_typeorm();
    var AttachmentEntity2 = class AttachmentEntity {
      constructor() {
        __publicField(this, "id");
        __publicField(this, "originalName");
        __publicField(this, "key");
        __publicField(this, "publicKey");
        __publicField(this, "userId");
        __publicField(this, "fileSizeInBytes");
      }
    };
    exports2.AttachmentEntity = AttachmentEntity2;
    __decorate2([
      (0, typeorm_1.PrimaryGeneratedColumn)("uuid"),
      __metadata2("design:type", String)
    ], AttachmentEntity2.prototype, "id", void 0);
    __decorate2([
      (0, typeorm_1.Column)(),
      __metadata2("design:type", String)
    ], AttachmentEntity2.prototype, "originalName", void 0);
    __decorate2([
      (0, typeorm_1.Column)(),
      __metadata2("design:type", String)
    ], AttachmentEntity2.prototype, "key", void 0);
    __decorate2([
      (0, typeorm_1.Column)(),
      __metadata2("design:type", String)
    ], AttachmentEntity2.prototype, "publicKey", void 0);
    __decorate2([
      (0, typeorm_1.Column)(),
      __metadata2("design:type", String)
    ], AttachmentEntity2.prototype, "userId", void 0);
    __decorate2([
      (0, typeorm_1.Column)(),
      __metadata2("design:type", Number)
    ], AttachmentEntity2.prototype, "fileSizeInBytes", void 0);
    exports2.AttachmentEntity = AttachmentEntity2 = __decorate2([
      (0, typeorm_1.Entity)("Attachment")
    ], AttachmentEntity2);
  }
});

// src/services/typeorm/entities/UserEntity.ts
var require_UserEntity = __commonJS({
  "src/services/typeorm/entities/UserEntity.ts"(exports2) {
    "use strict";
    var __decorate2 = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata2 = exports2 && exports2.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var _a;
    var _b;
    var _c;
    var _d;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UserEntity = void 0;
    var typeorm_1 = require_typeorm();
    var UserOrganizationEntity_1 = require_UserOrganizationEntity();
    var AttachmentEntity_1 = require_AttachmentEntity();
    var ProspectEntity_1 = require_ProspectEntity();
    var CsvImportRecordEntity_1 = require_CsvImportRecordEntity();
    var UserEntity2 = class UserEntity {
      constructor() {
        __publicField(this, "id");
        __publicField(this, "cognitoUserId");
        __publicField(this, "name");
        __publicField(this, "email");
        __publicField(this, "companyName");
        __publicField(this, "companyUrl");
        __publicField(this, "birthday");
        __publicField(this, "avatar");
        __publicField(this, "avatarId");
        __publicField(this, "userOrganizations");
        __publicField(this, "prospects");
        __publicField(this, "csvImports");
        __publicField(this, "createdAt");
        __publicField(this, "updatedAt");
      }
    };
    exports2.UserEntity = UserEntity2;
    __decorate2([
      (0, typeorm_1.PrimaryGeneratedColumn)("uuid"),
      __metadata2("design:type", String)
    ], UserEntity2.prototype, "id", void 0);
    __decorate2([
      (0, typeorm_1.Column)({ unique: true }),
      __metadata2("design:type", String)
    ], UserEntity2.prototype, "cognitoUserId", void 0);
    __decorate2([
      (0, typeorm_1.Column)({ nullable: true }),
      __metadata2("design:type", String)
    ], UserEntity2.prototype, "name", void 0);
    __decorate2([
      (0, typeorm_1.Column)({ unique: true }),
      __metadata2("design:type", String)
    ], UserEntity2.prototype, "email", void 0);
    __decorate2([
      (0, typeorm_1.Column)({ nullable: true }),
      __metadata2("design:type", String)
    ], UserEntity2.prototype, "companyName", void 0);
    __decorate2([
      (0, typeorm_1.Column)({ nullable: true }),
      __metadata2("design:type", String)
    ], UserEntity2.prototype, "companyUrl", void 0);
    __decorate2([
      (0, typeorm_1.Column)({ nullable: true }),
      __metadata2("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
    ], UserEntity2.prototype, "birthday", void 0);
    __decorate2([
      (0, typeorm_1.OneToOne)(() => AttachmentEntity_1.AttachmentEntity, { nullable: true, onDelete: "SET NULL" }),
      (0, typeorm_1.JoinColumn)({ name: "avatarId" }),
      __metadata2("design:type", typeof (_b = typeof AttachmentEntity_1.AttachmentEntity !== "undefined" && AttachmentEntity_1.AttachmentEntity) === "function" ? _b : Object)
    ], UserEntity2.prototype, "avatar", void 0);
    __decorate2([
      (0, typeorm_1.Column)({ nullable: true }),
      __metadata2("design:type", String)
    ], UserEntity2.prototype, "avatarId", void 0);
    __decorate2([
      (0, typeorm_1.OneToMany)(() => UserOrganizationEntity_1.UserOrganizationEntity, (user) => user.user),
      __metadata2("design:type", Array)
    ], UserEntity2.prototype, "userOrganizations", void 0);
    __decorate2([
      (0, typeorm_1.OneToMany)(() => ProspectEntity_1.ProspectEntity, (prospect) => prospect.user),
      __metadata2("design:type", Array)
    ], UserEntity2.prototype, "prospects", void 0);
    __decorate2([
      (0, typeorm_1.OneToMany)(() => CsvImportRecordEntity_1.CsvImportRecordEntity, (csv) => csv.user),
      __metadata2("design:type", Array)
    ], UserEntity2.prototype, "csvImports", void 0);
    __decorate2([
      (0, typeorm_1.CreateDateColumn)(),
      __metadata2("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
    ], UserEntity2.prototype, "createdAt", void 0);
    __decorate2([
      (0, typeorm_1.UpdateDateColumn)(),
      __metadata2("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
    ], UserEntity2.prototype, "updatedAt", void 0);
    exports2.UserEntity = UserEntity2 = __decorate2([
      (0, typeorm_1.Entity)("User")
    ], UserEntity2);
  }
});

// src/types/enums/InviteStatusEnum.ts
var InviteStatusEnum_exports = {};
__export(InviteStatusEnum_exports, {
  InviteStatus: () => InviteStatus
});
var InviteStatus;
var init_InviteStatusEnum = __esm({
  "src/types/enums/InviteStatusEnum.ts"() {
    "use strict";
    InviteStatus = /* @__PURE__ */ ((InviteStatus2) => {
      InviteStatus2["PENDING"] = "pending";
      InviteStatus2["ACCEPTED"] = "accepted";
      InviteStatus2["DECLINED_BY_USER"] = "declinedByUser";
      InviteStatus2["DECLINED_BY_ADMIN"] = "declinedByAdmin";
      return InviteStatus2;
    })(InviteStatus || {});
  }
});

// src/services/typeorm/entities/OrganizationInviteEntity.ts
var require_OrganizationInviteEntity = __commonJS({
  "src/services/typeorm/entities/OrganizationInviteEntity.ts"(exports2) {
    "use strict";
    var __decorate2 = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata2 = exports2 && exports2.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var _a;
    var _b;
    var _c;
    var _d;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OrganizationInviteEntity = void 0;
    var typeorm_1 = require_typeorm();
    var OrganizationEntity_1 = require_OrganizationEntity();
    var InviteStatusEnum_1 = (init_InviteStatusEnum(), __toCommonJS(InviteStatusEnum_exports));
    var OrganizationInviteEntity2 = class OrganizationInviteEntity {
      constructor() {
        __publicField(this, "id");
        __publicField(this, "email");
        __publicField(this, "organization");
        __publicField(this, "organizationId");
        __publicField(this, "expiresAt");
        //unique token for accepting the invite
        __publicField(this, "token");
        __publicField(this, "status");
        __publicField(this, "createdAt");
      }
    };
    exports2.OrganizationInviteEntity = OrganizationInviteEntity2;
    __decorate2([
      (0, typeorm_1.PrimaryGeneratedColumn)("uuid"),
      __metadata2("design:type", String)
    ], OrganizationInviteEntity2.prototype, "id", void 0);
    __decorate2([
      (0, typeorm_1.Column)(),
      __metadata2("design:type", String)
    ], OrganizationInviteEntity2.prototype, "email", void 0);
    __decorate2([
      (0, typeorm_1.ManyToOne)(() => OrganizationEntity_1.OrganizationEntity, { onDelete: "CASCADE" }),
      (0, typeorm_1.JoinColumn)({ name: "organizationId" }),
      __metadata2("design:type", typeof (_a = typeof OrganizationEntity_1.OrganizationEntity !== "undefined" && OrganizationEntity_1.OrganizationEntity) === "function" ? _a : Object)
    ], OrganizationInviteEntity2.prototype, "organization", void 0);
    __decorate2([
      (0, typeorm_1.Column)(),
      __metadata2("design:type", String)
    ], OrganizationInviteEntity2.prototype, "organizationId", void 0);
    __decorate2([
      (0, typeorm_1.Column)(),
      __metadata2("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
    ], OrganizationInviteEntity2.prototype, "expiresAt", void 0);
    __decorate2([
      (0, typeorm_1.Column)(),
      __metadata2("design:type", String)
    ], OrganizationInviteEntity2.prototype, "token", void 0);
    __decorate2([
      (0, typeorm_1.Column)({ type: "enum", enum: InviteStatusEnum_1.InviteStatus, default: InviteStatusEnum_1.InviteStatus.PENDING }),
      __metadata2("design:type", typeof (_c = typeof InviteStatusEnum_1.InviteStatus !== "undefined" && InviteStatusEnum_1.InviteStatus) === "function" ? _c : Object)
    ], OrganizationInviteEntity2.prototype, "status", void 0);
    __decorate2([
      (0, typeorm_1.CreateDateColumn)(),
      __metadata2("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
    ], OrganizationInviteEntity2.prototype, "createdAt", void 0);
    exports2.OrganizationInviteEntity = OrganizationInviteEntity2 = __decorate2([
      (0, typeorm_1.Entity)("OrganizationInvite")
    ], OrganizationInviteEntity2);
  }
});

// src/lambdas/split-process-csv.ts
var split_process_csv_exports = {};
__export(split_process_csv_exports, {
  handler: () => handler
});
module.exports = __toCommonJS(split_process_csv_exports);

// node_modules/typeorm/index.mjs
var import_index = __toESM(require_typeorm(), 1);
var {
  ConnectionOptionsReader,
  DataSource,
  Connection,
  ConnectionManager,
  QueryBuilder,
  SelectQueryBuilder,
  DeleteQueryBuilder,
  InsertQueryBuilder,
  UpdateQueryBuilder,
  RelationQueryBuilder,
  Brackets,
  NotBrackets,
  InsertResult,
  UpdateResult,
  DeleteResult,
  QueryResult,
  MongoEntityManager,
  Migration,
  MigrationExecutor,
  DefaultNamingStrategy,
  LegacyOracleNamingStrategy,
  EntitySchema,
  EntitySchemaEmbeddedColumnOptions,
  EntitySchemaOptions,
  InstanceChecker,
  TreeRepositoryUtils,
  getMetadataArgsStorage,
  getConnectionOptions,
  getConnectionManager,
  createConnection,
  createConnections,
  getConnection,
  getManager,
  getMongoManager,
  getSqljsManager,
  getRepository,
  getTreeRepository,
  getCustomRepository,
  getMongoRepository,
  createQueryBuilder,
  useContainer,
  getFromContainer,
  CannotReflectMethodParameterTypeError,
  AlreadyHasActiveConnectionError,
  SubjectWithoutIdentifierError,
  CannotConnectAlreadyConnectedError,
  LockNotSupportedOnGivenDriverError,
  ConnectionIsNotSetError,
  CannotCreateEntityIdMapError,
  MetadataAlreadyExistsError,
  CannotDetermineEntityError,
  UpdateValuesMissingError,
  TreeRepositoryNotSupportedError,
  CustomRepositoryNotFoundError,
  TransactionNotStartedError,
  TransactionAlreadyStartedError,
  EntityNotFoundError,
  EntityMetadataNotFoundError,
  MustBeEntityError,
  OptimisticLockVersionMismatchError,
  LimitOnUpdateNotSupportedError,
  PrimaryColumnCannotBeNullableError,
  CustomRepositoryCannotInheritRepositoryError,
  QueryRunnerProviderAlreadyReleasedError,
  CannotAttachTreeChildrenEntityError,
  CustomRepositoryDoesNotHaveEntityError,
  MissingDeleteDateColumnError,
  NoConnectionForRepositoryError,
  CircularRelationsError,
  ReturningStatementNotSupportedError,
  UsingJoinTableIsNotAllowedError,
  MissingJoinColumnError,
  MissingPrimaryColumnError,
  EntityPropertyNotFoundError,
  MissingDriverError,
  DriverPackageNotInstalledError,
  CannotGetEntityManagerNotConnectedError,
  ConnectionNotFoundError,
  NoVersionOrUpdateDateColumnError,
  InsertValuesMissingError,
  OptimisticLockCanNotBeUsedError,
  MetadataWithSuchNameAlreadyExistsError,
  DriverOptionNotSetError,
  FindRelationsNotFoundError,
  PessimisticLockTransactionRequiredError,
  RepositoryNotTreeError,
  DataTypeNotSupportedError,
  InitializedRelationError,
  MissingJoinTableError,
  QueryFailedError,
  NoNeedToReleaseEntityManagerError,
  UsingJoinColumnOnlyOnOneSideAllowedError,
  UsingJoinTableOnlyOnOneSideAllowedError,
  SubjectRemovedAndUpdatedError,
  PersistedEntityNotFoundError,
  UsingJoinColumnIsNotAllowedError,
  ColumnTypeUndefinedError,
  QueryRunnerAlreadyReleasedError,
  OffsetWithoutLimitNotSupportedError,
  CannotExecuteNotConnectedError,
  NoConnectionOptionError,
  TypeORMError,
  ForbiddenTransactionModeOverrideError,
  Column,
  CreateDateColumn,
  DeleteDateColumn,
  PrimaryGeneratedColumn,
  PrimaryColumn,
  UpdateDateColumn,
  VersionColumn,
  VirtualColumn,
  ViewColumn,
  ObjectIdColumn,
  AfterInsert,
  AfterLoad,
  AfterRemove,
  AfterSoftRemove,
  AfterRecover,
  AfterUpdate,
  BeforeInsert,
  BeforeRemove,
  BeforeSoftRemove,
  BeforeRecover,
  BeforeUpdate,
  EventSubscriber,
  JoinColumn,
  JoinTable,
  ManyToMany,
  ManyToOne,
  OneToMany,
  OneToOne,
  RelationCount,
  RelationId,
  Entity,
  ChildEntity,
  TableInheritance,
  ViewEntity,
  TreeLevelColumn,
  TreeParent,
  TreeChildren,
  Tree,
  Index,
  ForeignKey,
  Unique,
  Check,
  Exclusion,
  Generated,
  EntityRepository,
  And,
  Or,
  Any,
  ArrayContainedBy,
  ArrayContains,
  ArrayOverlap,
  Between,
  Equal,
  In,
  IsNull,
  LessThan,
  LessThanOrEqual,
  ILike,
  Like,
  MoreThan,
  MoreThanOrEqual,
  Not,
  Raw,
  JsonContains,
  EqualOperator,
  FindOperator,
  FindOptionsUtils,
  AbstractLogger,
  AdvancedConsoleLogger,
  FormattedConsoleLogger,
  SimpleConsoleLogger,
  FileLogger,
  EntityMetadata,
  EntityManager,
  AbstractRepository,
  Repository,
  BaseEntity,
  TreeRepository,
  MongoRepository,
  TableCheck,
  TableColumn,
  TableExclusion,
  TableForeignKey,
  TableIndex,
  TableUnique,
  Table,
  View,
  BSON,
  Binary,
  BSONRegExp,
  BSONSymbol,
  BSONType,
  Code,
  DBRef,
  Decimal128,
  deserialize,
  Double,
  Int32,
  Long,
  MaxKey,
  MinKey,
  ObjectId,
  serialize,
  Timestamp,
  MssqlParameter
} = import_index.default;

// src/services/typeorm/typeorm.service.ts
var import_UserEntity = __toESM(require_UserEntity());
var import_OrganizationEntity = __toESM(require_OrganizationEntity());
var import_UserOrganizationEntity = __toESM(require_UserOrganizationEntity());
var import_OrganizationInviteEntity = __toESM(require_OrganizationInviteEntity());
var import_AttachmentEntity = __toESM(require_AttachmentEntity());
var import_ProspectEntity = __toESM(require_ProspectEntity());
var import_CsvImportRecordEntity = __toESM(require_CsvImportRecordEntity());
function getDataSource(opts) {
  return new DataSource({
    type: "postgres",
    host: opts.host,
    port: opts.port,
    username: opts.user,
    password: opts.password,
    database: opts.dbName,
    synchronize: false,
    logging: process.env.NODE_ENV === "local",
    migrations: opts.migrations,
    ssl: { rejectUnauthorized: false },
    entities: [
      import_UserEntity.UserEntity,
      import_OrganizationEntity.OrganizationEntity,
      import_UserOrganizationEntity.UserOrganizationEntity,
      import_OrganizationInviteEntity.OrganizationInviteEntity,
      import_AttachmentEntity.AttachmentEntity,
      import_ProspectEntity.ProspectEntity,
      import_CsvImportRecordEntity.CsvImportRecordEntity
    ]
  });
}
function getDb(opts) {
  return getDataSource(opts).initialize();
}

// src/repos/prospect.repo.ts
var import_ProspectEntity2 = __toESM(require_ProspectEntity());

// src/types/errors/ApplicationError.ts
var ApplicationError = class extends Error {
  constructor(message, cause, errorCode) {
    super(message);
    this.message = message;
    this.cause = cause;
    this.errorCode = errorCode;
  }
};

// src/types/errors/DBError.ts
var DBError = class extends ApplicationError {
  constructor(message, cause) {
    super(message, cause);
  }
};

// src/repos/prospect.repo.ts
function getProspectRepo(db) {
  const prospectRepo = db.getRepository(import_ProspectEntity2.ProspectEntity);
  return {
    reconnect(connection) {
      return getProspectRepo(connection.entityManager);
    },
    async create(prospect) {
      const result = await prospectRepo.createQueryBuilder().insert().values(prospect).returning("*").execute();
      return result.raw[0];
    },
    async getByOrganizationId(organizationId) {
      try {
        return await prospectRepo.find({
          where: { organizationId }
        });
      } catch (error) {
        throw new DBError(
          `Prospects for organization id ${organizationId} not found`,
          error
        );
      }
    },
    async getByIdAndOrganizationId(prospectId, organizationId) {
      try {
        return await prospectRepo.findOneOrFail({
          where: { id: prospectId, organizationId }
        });
      } catch (error) {
        throw new DBError(`Prospect with id ${prospectId} not found`, error);
      }
    }
  };
}

// src/repos/csv-import-record.repo.ts
var import_CsvImportRecordEntity2 = __toESM(require_CsvImportRecordEntity());
function getCsvImportRecordRepo(db) {
  const csvImportRecord = db.getRepository(
    import_CsvImportRecordEntity2.CsvImportRecordEntity
  );
  return {
    reconnect(connection) {
      return getCsvImportRecordRepo(connection.entityManager);
    },
    async getById(id) {
      try {
        return await csvImportRecord.findOneByOrFail({ id });
      } catch (error) {
        throw new DBError(
          `Failed to get csv import record with id ${id}`,
          error
        );
      }
    },
    async create(data) {
      try {
        const result = await csvImportRecord.createQueryBuilder("csvImportRecord").insert().values(data).returning("*").execute();
        return result.raw[0];
      } catch (error) {
        throw new DBError("Failed to create csv import record", error);
      }
    },
    async update(id, data) {
      try {
        const result = await csvImportRecord.createQueryBuilder("csvImportRecord").update(import_CsvImportRecordEntity2.CsvImportRecordEntity).set(data).where("id = :id", { id }).returning("*").execute();
        return result.raw[0];
      } catch (error) {
        throw new DBError(
          `Failed to update csv import record with id ${id}`,
          error
        );
      }
    },
    incrementProcessedRows(id) {
      try {
        return csvImportRecord.createQueryBuilder().update(import_CsvImportRecordEntity2.CsvImportRecordEntity).set({ processedRows: () => 'COALESCE("processedRows",0)+1' }).where("id = :id", { id }).execute().then(() => {
        });
      } catch (error) {
        throw new DBError(
          `Failed to increase processedRows for csv import record with id ${id}`,
          error
        );
      }
    },
    incrementFailedRows(id) {
      try {
        return csvImportRecord.createQueryBuilder().update(import_CsvImportRecordEntity2.CsvImportRecordEntity).set({ failedRows: () => 'COALESCE("failedRows",0)+1' }).where("id = :id", { id }).execute().then(() => {
        });
      } catch (error) {
        throw new DBError(
          `Failed to increase failedRows for csv import record with id ${id}`,
          error
        );
      }
    },
    checkIfDone(id) {
      try {
        return csvImportRecord.createQueryBuilder("csvImportRecord").where("id = :id", { id }).andWhere('"totalRows" IS NOT NULL').andWhere('"totalRows" > 0').andWhere(
          'COALESCE("processedRows", 0) + COALESCE("failedRows", 0) >= "totalRows"'
        ).getCount().then((count) => count > 0);
      } catch (error) {
        throw new DBError(
          `Failed to check if csv import record with id ${id} is done`,
          error
        );
      }
    }
  };
}

// src/lambdas/split-process-csv.ts
init_CsvImportStatusEnum();

// src/services/typeorm/typeorm-transaction.service.ts
function getTypeOrmTransactionService(db) {
  return {
    async run(cb) {
      return await db.transaction((entityManager) => {
        const connection = {
          entityManager
        };
        return cb(connection);
      });
    }
  };
}

// src/lambdas/split-process-csv.ts
var handler = async (event) => {
  if (!event.Records.length) {
    return;
  }
  const db = await getDb({
    host: process.env.PGHOST,
    port: parseInt(process.env.PGPORT),
    dbName: process.env.PGDATABASE,
    user: process.env.PGUSERNAME,
    password: process.env.PGPASSWORD
  });
  const transactionService = getTypeOrmTransactionService(db);
  const prospectRepo = getProspectRepo(db);
  const importRepo = getCsvImportRecordRepo(db);
  for (const record of event.Records) {
    const { importRecordId, row } = JSON.parse(
      record.body
    );
    try {
      if (!importRecordId || !row) {
        throw new Error("Missing required fields in the message");
      }
      await transactionService.run(async (connection) => {
        const prospectRepoTx = prospectRepo.reconnect(connection);
        const importRepoTx = importRepo.reconnect(connection);
        await prospectRepoTx.create({ ...row });
        await importRepoTx.incrementProcessedRows(importRecordId);
        const isDone = await importRepoTx.checkIfDone(importRecordId);
        if (isDone) {
          await importRepoTx.update(importRecordId, {
            status: "done" /* DONE */
          });
        }
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      await transactionService.run(async (connection) => {
        const importRepoTx = importRepo.reconnect(connection);
        await importRepoTx.incrementFailedRows(importRecordId);
        await importRepoTx.update(importRecordId, { lastError: errorMessage });
        const isDone = await importRepoTx.checkIfDone(importRecordId);
        if (isDone) {
          await importRepoTx.update(importRecordId, {
            status: "done" /* DONE */
          });
        }
      });
      console.log("Error processing row for importRecordId");
    }
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  handler
});
/*! Bundled license information:

reflect-metadata/Reflect.js:
  (*! *****************************************************************************
  Copyright (C) Microsoft. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

typeorm/index.js:
  (*!
   *)
*/
//# sourceMappingURL=split-process-csv.js.map
